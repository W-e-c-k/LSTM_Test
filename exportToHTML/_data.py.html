<html>
<head>
<title>_data.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_data.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Base class for sparse matrice with a .data attribute 
 
    subclasses must provide a _with_data() method that 
    creates a new matrix with the same sparsity pattern 
    as self but with a different data array 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_base </span><span class="s2">import </span><span class="s1">_spbase</span><span class="s3">, </span><span class="s1">sparray</span><span class="s3">, </span><span class="s1">_ufuncs_with_fixed_point_at_zero</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_sputils </span><span class="s2">import </span><span class="s1">isscalarlike</span><span class="s3">, </span><span class="s1">validateaxis</span>

<span class="s1">__all__ </span><span class="s3">= []</span>


<span class="s4"># TODO implement all relevant operations</span>
<span class="s4"># use .data.__methods__() instead of /=, *=, etc.</span>
<span class="s2">class </span><span class="s1">_data_matrix</span><span class="s3">(</span><span class="s1">_spbase</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">):</span>
        <span class="s1">_spbase</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s3">@</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">newtype</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">newtype</span>

    <span class="s2">def </span><span class="s1">_deduped_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">'sum_duplicates'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_duplicates</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">__abs__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">()))</span>

    <span class="s2">def </span><span class="s1">__round__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ndigits</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">around</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">(), </span><span class="s1">decimals</span><span class="s3">=</span><span class="s1">ndigits</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_real</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_imag</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__neg__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s5">'b'</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">'negating a boolean sparse array is not '</span>
                                      <span class="s5">'supported'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__imul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):  </span><span class="s4"># self *= other</span>
        <span class="s2">if </span><span class="s1">isscalarlike</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">*= </span><span class="s1">other</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__itruediv__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):  </span><span class="s4"># self /= other</span>
        <span class="s2">if </span><span class="s1">isscalarlike</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s1">recip </span><span class="s3">= </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">other</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">*= </span><span class="s1">recip</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">astype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s5">'unsafe'</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">dtype</span><span class="s3">:</span>
            <span class="s1">matrix </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s1">casting</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">),</span>
                <span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">matrix</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">matrix</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">(), </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">copy</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">astype</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">_spbase</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s2">def </span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">(), </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">copy</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">conjugate</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">_spbase</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s2">def </span><span class="s1">copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">copy</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">_spbase</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s2">def </span><span class="s1">count_nonzero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">count_nonzero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">())</span>

    <span class="s1">count_nonzero</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">_spbase</span><span class="s3">.</span><span class="s1">count_nonzero</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s2">def </span><span class="s1">power</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This function performs element-wise power. 
 
        Parameters 
        ---------- 
        n : scalar 
            n is a non-zero scalar (nonzero avoids dense ones creation) 
            If zero power is desired, special case it to use `np.ones` 
 
        dtype : If dtype is not specified, the current dtype will be preserved. 
 
        Raises 
        ------ 
        NotImplementedError : if n is a zero scalar 
            If zero power is desired, special case it to use 
            `np.ones(A.shape, dtype=A.dtype)` 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isscalarlike</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">&quot;input is not scalar&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                <span class="s5">&quot;zero power is not supported as it would densify the matrix.</span><span class="s2">\n</span><span class="s5">&quot;</span>
                <span class="s5">&quot;Use `np.ones(A.shape, dtype=A.dtype)` for this case.&quot;</span>
            <span class="s3">)</span>

        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">data </span><span class="s3">** </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s4">###########################</span>
    <span class="s4"># Multiplication handlers #</span>
    <span class="s4">###########################</span>

    <span class="s2">def </span><span class="s1">_mul_scalar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">* </span><span class="s1">other</span><span class="s3">)</span>


<span class="s4"># Add the numpy unary ufuncs for which func(0) = 0 to _data_matrix.</span>
<span class="s2">for </span><span class="s1">npfunc </span><span class="s2">in </span><span class="s1">_ufuncs_with_fixed_point_at_zero</span><span class="s3">:</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">npfunc</span><span class="s3">.</span><span class="s1">__name__</span>

    <span class="s2">def </span><span class="s1">_create_method</span><span class="s3">(</span><span class="s1">op</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">op</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">())</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_with_data</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">method</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= (</span><span class="s5">f&quot;Element-wise </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
                          <span class="s5">f&quot;See `numpy.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">` for more information.&quot;</span><span class="s3">)</span>
        <span class="s1">method</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s1">name</span>

        <span class="s2">return </span><span class="s1">method</span>

    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">_data_matrix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">_create_method</span><span class="s3">(</span><span class="s1">npfunc</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_find_missing_index</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">!= </span><span class="s1">a</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">k</span>

    <span class="s1">k </span><span class="s3">+= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">k</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s6">1</span>


<span class="s2">class </span><span class="s1">_minmax_mixin</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Mixin for min and max methods. 
 
    These are not implemented for dia_matrix, hence the separate class. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_min_or_max_axis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">min_or_max</span><span class="s3">):</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;zero-size array to reduction operation&quot;</span><span class="s3">)</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1 </span><span class="s3">- </span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s1">idx_dtype </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_index_dtype</span><span class="s3">(</span><span class="s1">maxval</span><span class="s3">=</span><span class="s1">M</span><span class="s3">)</span>

        <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tocsc</span><span class="s3">() </span><span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">()</span>
        <span class="s1">mat</span><span class="s3">.</span><span class="s1">sum_duplicates</span><span class="s3">()</span>

        <span class="s1">major_index</span><span class="s3">, </span><span class="s1">value </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">_minor_reduce</span><span class="s3">(</span><span class="s1">min_or_max</span><span class="s3">)</span>
        <span class="s1">not_full </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">)[</span><span class="s1">major_index</span><span class="s3">] &lt; </span><span class="s1">N</span>
        <span class="s1">value</span><span class="s3">[</span><span class="s1">not_full</span><span class="s3">] = </span><span class="s1">min_or_max</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[</span><span class="s1">not_full</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">mask </span><span class="s3">= </span><span class="s1">value </span><span class="s3">!= </span><span class="s6">0</span>
        <span class="s1">major_index </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">major_index</span><span class="s3">)</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sparray</span><span class="s3">):</span>
            <span class="s1">coords </span><span class="s3">= (</span><span class="s1">major_index</span><span class="s3">,)</span>
            <span class="s1">shape </span><span class="s3">= (</span><span class="s1">M</span><span class="s3">,)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_coo_container</span><span class="s3">((</span><span class="s1">value</span><span class="s3">, </span><span class="s1">coords</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_coo_container</span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">value</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">idx_dtype</span><span class="s3">), </span><span class="s1">major_index</span><span class="s3">)),</span>
                <span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_coo_container</span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">major_index</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">value</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">idx_dtype</span><span class="s3">))),</span>
                <span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=(</span><span class="s1">M</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_min_or_max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">min_or_max</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Sparse arrays do not support an 'out' parameter.&quot;</span><span class="s3">)</span>

        <span class="s1">validateaxis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">not in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;axis out of range&quot;</span><span class="s3">)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s2">None  </span><span class="s4"># avoid calling special axis case. no impact on 1d</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s6">0 </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;zero-size array to reduction operation&quot;</span><span class="s3">)</span>

            <span class="s1">zero </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nnz </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">zero</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">min_or_max</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">().</span><span class="s1">ravel</span><span class="s3">())</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nnz </span><span class="s3">!= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">min_or_max</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">m</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">+= </span><span class="s6">2</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s3">== </span><span class="s6">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">axis </span><span class="s3">== </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_min_or_max_axis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">min_or_max</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;axis out of range&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arg_min_or_max_axis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">argmin_or_argmax</span><span class="s3">, </span><span class="s1">compare</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] == </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Cannot apply the operation along a zero-sized dimension.&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">+= </span><span class="s6">2</span>

        <span class="s1">zero </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tocsc</span><span class="s3">() </span><span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">()</span>
        <span class="s1">mat</span><span class="s3">.</span><span class="s1">sum_duplicates</span><span class="s3">()</span>

        <span class="s1">ret_size</span><span class="s3">, </span><span class="s1">line_size </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">_swap</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">ret_size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>

        <span class="s1">nz_lines</span><span class="s3">, = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">nz_lines</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">, </span><span class="s1">q </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">]</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">p</span><span class="s3">:</span><span class="s1">q</span><span class="s3">]</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">:</span><span class="s1">q</span><span class="s3">]</span>
            <span class="s1">extreme_index </span><span class="s3">= </span><span class="s1">argmin_or_argmax</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s1">extreme_value </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">extreme_value</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">) </span><span class="s2">or </span><span class="s1">q </span><span class="s3">- </span><span class="s1">p </span><span class="s3">== </span><span class="s1">line_size</span><span class="s3">:</span>
                <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">indices</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">zero_ind </span><span class="s3">= </span><span class="s1">_find_missing_index</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">line_size</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">extreme_value </span><span class="s3">== </span><span class="s1">zero</span><span class="s3">:</span>
                    <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">extreme_index</span><span class="s3">, </span><span class="s1">zero_ind</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">zero_ind</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sparray</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">ret</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ascontainer</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arg_min_or_max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">argmin_or_argmax</span><span class="s3">, </span><span class="s1">compare</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Sparse types do not support an 'out' parameter.&quot;</span><span class="s3">)</span>

        <span class="s1">validateaxis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">not in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;axis out of range&quot;</span><span class="s3">)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s2">None  </span><span class="s4"># avoid calling special axis case. no impact on 1d</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arg_min_or_max_axis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">argmin_or_argmax</span><span class="s3">, </span><span class="s1">compare</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s6">0 </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Cannot apply the operation to an empty matrix.&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nnz </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">0</span>

        <span class="s1">zero </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">mat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tocoo</span><span class="s3">()</span>
        <span class="s4"># Convert to canonical form: no duplicates, sorted indices.</span>
        <span class="s1">mat</span><span class="s3">.</span><span class="s1">sum_duplicates</span><span class="s3">()</span>
        <span class="s1">extreme_index </span><span class="s3">= </span><span class="s1">argmin_or_argmax</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">extreme_value </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">]</span>
        <span class="s1">num_col </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s4"># If the min value is less than zero, or max is greater than zero,</span>
        <span class="s4"># then we do not need to worry about implicit zeros.</span>
        <span class="s2">if </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">extreme_value</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">):</span>
            <span class="s4"># cast to Python int to avoid overflow and RuntimeError</span>
            <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">row</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">]) * </span><span class="s1">num_col </span><span class="s3">+ </span><span class="s1">int</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">col</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">])</span>

        <span class="s4"># Cheap test for the rare case where we have no implicit zeros.</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s3">== </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">nnz</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">row</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">]) * </span><span class="s1">num_col </span><span class="s3">+ </span><span class="s1">int</span><span class="s3">(</span><span class="s1">mat</span><span class="s3">.</span><span class="s1">col</span><span class="s3">[</span><span class="s1">extreme_index</span><span class="s3">])</span>

        <span class="s4"># At this stage, any implicit zero could be the min or max value.</span>
        <span class="s4"># After sum_duplicates(), the `row` and `col` arrays are guaranteed to</span>
        <span class="s4"># be sorted in C-order, which means the linearized indices are sorted.</span>
        <span class="s1">linear_indices </span><span class="s3">= </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">row </span><span class="s3">* </span><span class="s1">num_col </span><span class="s3">+ </span><span class="s1">mat</span><span class="s3">.</span><span class="s1">col</span>
        <span class="s1">first_implicit_zero_index </span><span class="s3">= </span><span class="s1">_find_missing_index</span><span class="s3">(</span><span class="s1">linear_indices</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">extreme_value </span><span class="s3">== </span><span class="s1">zero</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">min</span><span class="s3">(</span><span class="s1">first_implicit_zero_index</span><span class="s3">, </span><span class="s1">extreme_index</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">first_implicit_zero_index</span>

    <span class="s2">def </span><span class="s1">max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the maximum of the array/matrix or maximum along an axis. 
        This takes all elements into account, not just the non-zero ones. 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None} optional 
            Axis along which the sum is computed. The default is to 
            compute the maximum over all elements, returning 
            a scalar (i.e., `axis` = `None`). 
 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except 
            for the default value, as this argument is not used. 
 
        Returns 
        ------- 
        amax : coo_matrix or scalar 
            Maximum of `a`. If `axis` is None, the result is a scalar value. 
            If `axis` is given, the result is a sparse.coo_matrix of dimension 
            ``a.ndim - 1``. 
 
        See Also 
        -------- 
        min : The minimum value of a sparse array/matrix along a given axis. 
        numpy.matrix.max : NumPy's implementation of 'max' for matrices 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">min</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the minimum of the array/matrix or maximum along an axis. 
        This takes all elements into account, not just the non-zero ones. 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None} optional 
            Axis along which the sum is computed. The default is to 
            compute the minimum over all elements, returning 
            a scalar (i.e., `axis` = `None`). 
 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except for 
            the default value, as this argument is not used. 
 
        Returns 
        ------- 
        amin : coo_matrix or scalar 
            Minimum of `a`. If `axis` is None, the result is a scalar value. 
            If `axis` is given, the result is a sparse.coo_matrix of dimension 
            ``a.ndim - 1``. 
 
        See Also 
        -------- 
        max : The maximum value of a sparse array/matrix along a given axis. 
        numpy.matrix.min : NumPy's implementation of 'min' for matrices 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanmax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the maximum of the array/matrix or maximum along an axis, ignoring any 
        NaNs. This takes all elements into account, not just the non-zero 
        ones. 
 
        .. versionadded:: 1.11.0 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None} optional 
            Axis along which the maximum is computed. The default is to 
            compute the maximum over all elements, returning 
            a scalar (i.e., `axis` = `None`). 
 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except 
            for the default value, as this argument is not used. 
 
        Returns 
        ------- 
        amax : coo_matrix or scalar 
            Maximum of `a`. If `axis` is None, the result is a scalar value. 
            If `axis` is given, the result is a sparse.coo_matrix of dimension 
            ``a.ndim - 1``. 
 
        See Also 
        -------- 
        nanmin : The minimum value of a sparse array/matrix along a given axis, 
                 ignoring NaNs. 
        max : The maximum value of a sparse array/matrix along a given axis, 
              propagating NaNs. 
        numpy.nanmax : NumPy's implementation of 'nanmax'. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fmax</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanmin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the minimum of the array/matrix or minimum along an axis, ignoring any 
        NaNs. This takes all elements into account, not just the non-zero 
        ones. 
 
        .. versionadded:: 1.11.0 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None} optional 
            Axis along which the minimum is computed. The default is to 
            compute the minimum over all elements, returning 
            a scalar (i.e., `axis` = `None`). 
 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except for 
            the default value, as this argument is not used. 
 
        Returns 
        ------- 
        amin : coo_matrix or scalar 
            Minimum of `a`. If `axis` is None, the result is a scalar value. 
            If `axis` is given, the result is a sparse.coo_matrix of dimension 
            ``a.ndim - 1``. 
 
        See Also 
        -------- 
        nanmax : The maximum value of a sparse array/matrix along a given axis, 
                 ignoring NaNs. 
        min : The minimum value of a sparse array/matrix along a given axis, 
              propagating NaNs. 
        numpy.nanmin : NumPy's implementation of 'nanmin'. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fmin</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return indices of maximum elements along an axis. 
 
        Implicit zero elements are also taken into account. If there are 
        several maximum values, the index of the first occurrence is returned. 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None}, optional 
            Axis along which the argmax is computed. If None (default), index 
            of the maximum element in the flatten data is returned. 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except for 
            the default value, as this argument is not used. 
 
        Returns 
        ------- 
        ind : numpy.matrix or int 
            Indices of maximum elements. If matrix, its size along `axis` is 1. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arg_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">greater</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return indices of minimum elements along an axis. 
 
        Implicit zero elements are also taken into account. If there are 
        several minimum values, the index of the first occurrence is returned. 
 
        Parameters 
        ---------- 
        axis : {-2, -1, 0, 1, None}, optional 
            Axis along which the argmin is computed. If None (default), index 
            of the minimum element in the flatten data is returned. 
        out : None, optional 
            This argument is in the signature *solely* for NumPy 
            compatibility reasons. Do not pass in anything except for 
            the default value, as this argument is not used. 
 
        Returns 
        ------- 
         ind : numpy.matrix or int 
            Indices of minimum elements. If matrix, its size along `axis` is 1. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arg_min_or_max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">less</span><span class="s3">)</span>
</pre>
</body>
</html>