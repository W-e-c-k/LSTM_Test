<html>
<head>
<title>distribution_lib.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
distribution_lib.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Unified high level distribution APIs across backends. 
 
!!!DO NOT USE!!! Currently under development and APIs are not final. 
 
Currently only the JAX backend has been implemented. The TensorFlow backend 
will be implemented in the future (via tf.dtensor API). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">api_export </span><span class="s2">import </span><span class="s1">keras_export</span>
<span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">backend </span><span class="s2">import </span><span class="s1">KerasTensor</span>
<span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">backend </span><span class="s2">import </span><span class="s1">distribution_lib</span>
<span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">common </span><span class="s2">import </span><span class="s1">global_state</span>

<span class="s1">DEFAULT_BATCH_DIM_NAME </span><span class="s3">= </span><span class="s4">&quot;batch&quot;</span>
<span class="s1">GLOBAL_ATTRIBUTE_NAME </span><span class="s3">= </span><span class="s4">&quot;distribution&quot;</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.list_devices&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">list_devices</span><span class="s3">(</span><span class="s1">device_type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return all the available devices based on the device type. 
 
    Note: in a distributed setting, global devices are returned. 
 
    Args: 
        device_type: string, one of `&quot;cpu&quot;`, `&quot;gpu&quot;` or `&quot;tpu&quot;`. 
            Defaults to `&quot;gpu&quot;` or `&quot;tpu&quot;` if available when 
            `device_type` is not provided. Otherwise 
            will return the `&quot;cpu&quot;` devices. 
 
    Return: 
        List of devices that are available for distribute computation. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">list_devices</span><span class="s3">(</span><span class="s1">device_type</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.initialize&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">initialize</span><span class="s3">(</span><span class="s1">job_addresses</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">num_processes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">process_id</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Initialize the distribution system for multi-host/process setting. 
 
    Calling `initialize` will prepare the backend for execution on multi-host 
    GPU or TPUs. It should be called before any computations. 
 
    Note that the parameters can also be injected via environment variables, 
    which can be better controlled by the launch script at startup time. 
    For certain backend that also rely on the environment variables to 
    configure, Keras will properly forward them. 
 
    Args: 
        job_addresses: string. Comma separated IP addresses for all the jobs 
            that will form the whole computation cluster. Note that for JAX 
            backend, only the address for job 0 (coodinator) is needed. For 
            certain runtime like cloud TPU, this value can be `None`, and the 
            backend will figure it out with the TPU environment variables. You 
            can also config this value via environment variable 
            `KERAS_DISTRIBUTION_JOB_ADDRESSES`. 
        num_processes: int. The number of worker/processes that will form the 
            whole computation cluster. For certain runtime like cloud TPU, this 
            value can be `None`, and the backend will figure it out with the TPU 
            environment variables. You can also configure this value via 
            environment variable `KERAS_DISTRIBUTION_NUM_PROCESSES`. 
        process_id: int. The ID number of the current worker/process. The value 
            should be ranged from `0` to `num_processes - 1`. `0` will indicate 
            the current worker/process is the master/coordinate job. You can 
            also configure this value via environment variable 
            `KERAS_DISTRIBUTION_PROCESS_ID`. 
 
        Example: 
            Suppose there are two GPU processes, and process 0 is running at 
            address `10.0.0.1:1234`, and process 1 is running at address 
            `10.0.0.2:2345`. To configure such cluster, you can run 
 
        On process 0: 
        ```python 
        keras.distribute.initialize( 
            job_addresses=&quot;10.0.0.1:1234,10.0.0.2:2345&quot;, 
            num_processes=2, 
            process_id=0) 
        ``` 
 
        On process 1: 
        ```python 
        keras.distribute.initialize( 
            job_addresses=&quot;10.0.0.1:1234,10.0.0.2:2345&quot;, 
            num_processes=2, 
            process_id=1) 
        ``` 
 
        or via the environment variables: 
        On process 0: 
        ```python 
        os.environ[ 
            &quot;KERAS_DISTRIBUTION_JOB_ADDRESSES&quot;] = &quot;10.0.0.1:1234,10.0.0.2:2345&quot; 
        os.environ[&quot;KERAS_DISTRIBUTION_NUM_PROCESSES&quot;] = &quot;2&quot; 
        os.environ[&quot;KERAS_DISTRIBUTION_PROCESS_ID&quot;] = &quot;0&quot; 
        keras.distribute.initialize() 
        ``` 
 
        On process 1: 
        ```python 
        os.environ[ 
            &quot;KERAS_DISTRIBUTION_JOB_ADDRESSES&quot;] = &quot;10.0.0.1:1234,10.0.0.2:2345&quot; 
        os.environ[&quot;KERAS_DISTRIBUTION_NUM_PROCESSES&quot;] = &quot;2&quot; 
        os.environ[&quot;KERAS_DISTRIBUTION_PROCESS_ID&quot;] = &quot;1&quot; 
        keras.distribute.initialize() 
        ``` 
 
        Also note that for JAX backend, the `job_addresses` can be further 
        reduced to just the master/coordinator address, which is 
        `10.0.0.1:1234`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">job_addresses </span><span class="s2">is None</span>
        <span class="s2">and </span><span class="s4">&quot;KERAS_DISTRIBUTION_JOB_ADDRESSES&quot; </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span>
    <span class="s3">):</span>
        <span class="s1">job_addresses </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s4">&quot;KERAS_DISTRIBUTION_JOB_ADDRESSES&quot;</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">num_processes </span><span class="s2">is None</span>
        <span class="s2">and </span><span class="s4">&quot;KERAS_DISTRIBUTION_NUM_PROCESSES&quot; </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span>
    <span class="s3">):</span>
        <span class="s1">num_processes </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s4">&quot;KERAS_DISTRIBUTION_NUM_PROCESSES&quot;</span><span class="s3">])</span>
    <span class="s2">if </span><span class="s1">process_id </span><span class="s2">is None and </span><span class="s4">&quot;KERAS_DISTRIBUTION_PROCESS_ID&quot; </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">:</span>
        <span class="s1">process_id </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s4">&quot;KERAS_DISTRIBUTION_PROCESS_ID&quot;</span><span class="s3">])</span>
    <span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">initialize</span><span class="s3">(</span><span class="s1">job_addresses</span><span class="s3">, </span><span class="s1">num_processes</span><span class="s3">, </span><span class="s1">process_id</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.DeviceMesh&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">DeviceMesh</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;A cluster of computation devices for distributed computation. 
 
    This API is aligned with `jax.sharding.Mesh` and `tf.dtensor.Mesh`, which 
    represents the computation devices in the global context. 
 
    See more details in [jax.sharding.Mesh]( 
        https://jax.readthedocs.io/en/latest/jax.sharding.html#jax.sharding.Mesh) 
    and [tf.dtensor.Mesh]( 
        https://www.tensorflow.org/api_docs/python/tf/experimental/dtensor/Mesh). 
 
    Args: 
        shape: tuple of list of integers. The shape of the overall 
            `DeviceMesh`, e.g. `(8,)` for a data parallel only distribution, 
            or `(4, 2)` for a model+data parallel distribution. 
        axis_names: List of string. The logical name of the each axis for 
            the `DeviceMesh`. The length of the `axis_names` should match to 
            the rank of the `shape`. The `axis_names` will be used to 
            match/create the `TensorLayout` when distribute the data and 
            variables. 
        devices: Optional list of devices. Defaults to all the available 
            devices locally from `keras.distribution.list_devices()`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">shape</span><span class="s3">,</span>
        <span class="s1">axis_names</span><span class="s3">,</span>
        <span class="s1">devices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">shape </span><span class="s2">or not </span><span class="s1">axis_names</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Shape and axis_names cannot be empty. Received: &quot;</span>
                <span class="s4">f&quot;shape=</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">, axis_names=</span><span class="s2">{</span><span class="s1">axis_names</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axis_names</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Shape and axis_names should have same size. &quot;</span>
                <span class="s4">f&quot;Received: shape=</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">, axis_names=</span><span class="s2">{</span><span class="s1">axis_names</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">devices </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">devices </span><span class="s3">= </span><span class="s1">list_devices</span><span class="s3">()</span>
        <span class="s1">devices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">devices</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) != </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Shape does not match the number of devices. &quot;</span>
                <span class="s4">f&quot;Received: shape=</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">; devices.shape=&quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_shape </span><span class="s3">= </span><span class="s1">shape</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_axis_names </span><span class="s3">= </span><span class="s1">axis_names</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_devices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">devices</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_shape</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">axis_names</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_axis_names</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">devices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_devices</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;shape=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">, axis_names=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">axis_names</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__repr__</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.TensorLayout&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">TensorLayout</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;A layout to apply to a tensor. 
 
    This API is aligned with `jax.sharding.NamedSharding` 
    and `tf.dtensor.Layout`. 
 
    See more details in [jax.sharding.NamedSharding]( 
        https://jax.readthedocs.io/en/latest/jax.sharding.html#jax.sharding.NamedSharding) 
    and [tf.dtensor.Layout]( 
        https://www.tensorflow.org/api_docs/python/tf/experimental/dtensor/Layout). 
 
    Args: 
        axes: tuple of strings that should map to the `axis_names` in 
            a `DeviceMesh`. For any dimensions that doesn't need any sharding, 
            A `None` can be used a placeholder. 
        device_mesh: Optional `DeviceMesh` that will be used to create 
            the layout. The actual mapping of tensor to physical device 
            is not known until the mesh is specified. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_axes </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh </span><span class="s3">= </span><span class="s1">device_mesh</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_axes</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">axes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_axes</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span>

    <span class="s3">@</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Cannot override device mesh value. Existing &quot;</span>
                <span class="s4">f&quot;value is </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh </span><span class="s3">= </span><span class="s1">device_mesh</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_axes</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_validate_axes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span><span class="s3">:</span>
            <span class="s1">valid_axis_names </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span><span class="s3">.</span><span class="s1">axis_names</span><span class="s3">)</span>
            <span class="s1">axis_names </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_axes</span><span class="s3">) - </span><span class="s1">set</span><span class="s3">([</span><span class="s2">None</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">axis_names </span><span class="s3">- </span><span class="s1">valid_axis_names</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;Invalid axis names for Layout. Valid axis &quot;</span>
                    <span class="s4">f&quot;names: </span><span class="s2">{</span><span class="s1">valid_axis_names</span><span class="s2">}</span><span class="s4">, Got </span><span class="s2">{</span><span class="s1">axis_names</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;axes=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">axes</span><span class="s2">}</span><span class="s4">, device_mesh=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__repr__</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">Distribution</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Base class for variable distribution strategies. 
 
    A `Distribution` has following key functionalities: 
 
    1. Distribute the model variables to a `DeviceMesh`. 
    2. Distribute the input data to a `DeviceMesh`. 
    3. Distribute an intermediate state tensor in the model. 
 
    It can create a context scope so that the framework to properly detect the 
    `Distribution` and distribute the variable/data accordingly. 
 
    Args: 
        device_mesh: A `DeviceMesh` instance. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh </span><span class="s3">= </span><span class="s1">device_mesh</span>

    <span class="s2">def </span><span class="s1">get_data_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_shape</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Retrieve the `TensorLayout` for the input data. 
 
        Args: 
            data_shape: shape for the input data in list or tuple format. 
 
        Returns: 
            The `TensorLayout` for the data, which can be used by 
            `backend.distribute_value()` to redistribute a input data. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_variable_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">variable</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Retrieve the `TensorLayout` for the variable. 
 
        Args: 
            variable: A `KerasVariable` instance. 
 
        return: 
            The `TensorLayout` for the variable, which can be used by 
            `backend.distribute_value()` to redistribute a variable. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_tensor_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Retrieve the `TensorLayout` for the intermediate tensor. 
 
        Args: 
            path: a string path for the corresponding tensor. 
 
        return: 
            The `TensorLayout` for the intermediate tensor, which can be used 
            by `backend.relayout()` to reshard the tensor. Could also return 
            None. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">scope</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Context manager to make the `Distribution` current.&quot;&quot;&quot;</span>
        <span class="s1">original_scope </span><span class="s3">= </span><span class="s1">distribution</span><span class="s3">()</span>
        <span class="s1">set_distribution</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">set_distribution</span><span class="s3">(</span><span class="s1">original_scope</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span>

    <span class="s2">def </span><span class="s1">distribute_dataset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Create a distributed dataset instance from the original user dataset. 
 
        Args: 
            dataset: the original global dataset instance. Only 
            `tf.data.Dataset` is supported at the moment. 
 
        Returns: 
            a sharded `tf.data.Dataset` instance, which will produce data for 
            the current local worker/process. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">device_mesh=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__repr__</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.DataParallel&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">DataParallel</span><span class="s3">(</span><span class="s1">Distribution</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Distribution for data parallelism. 
 
    You can choose to create this instance by either specifying 
    the `device_mesh` or `devices` arguments (but not both). 
 
    The `device_mesh` argument is expected to be a `DeviceMesh` instance, 
    and is expected to be 1D only. In case that the mesh has multiple axes, 
    then the first axis will be treated as the data parallel dimension 
    (and a warning will be raised). 
 
    When a list of `devices` are provided, they will be used to construct a 
    1D mesh. 
 
    When both `mesh` and `devices` are absent, then `list_devices()` 
    will be used to detect any available devices and create a 1D mesh from 
    them. 
 
    Args: 
        device_mesh: Optional `DeviceMesh` instance. 
        devices: Optional list of devices. 
        auto_shard_dataset: Automatically shard the dataset amongst processes. 
            Defaults to true. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">devices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">auto_shard_dataset</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">device_mesh</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_initialize_with_device_mesh</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">devices</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_initialize_mesh_from_devices</span><span class="s3">(</span><span class="s1">devices</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_initialize_mesh_from_list_devices</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_batch_dim_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">axis_names</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s6"># Those following attributes might get convert to public methods.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">= </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">num_processes</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id </span><span class="s3">= </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">process_id</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_multi_process </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">&gt; </span><span class="s5">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_auto_shard_dataset </span><span class="s3">= </span><span class="s1">auto_shard_dataset</span>

    <span class="s2">def </span><span class="s1">_initialize_with_device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">, </span><span class="s1">DeviceMesh</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Expect `mesh` to be an instance of `DeviceMesh`. &quot;</span>
                <span class="s4">f&quot;Received: mesh=</span><span class="s2">{</span><span class="s1">device_mesh</span><span class="s2">} </span><span class="s4">(of type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span><span class="s2">}</span><span class="s4">)&quot;</span>
            <span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">&quot;Expect the input mesh to be 1D, but received &quot;</span>
                <span class="s4">&quot;mesh.devices.ndim=%d. &quot;</span>
                <span class="s4">&quot;The first axis will be used for data-parallel sharding.&quot;</span><span class="s3">,</span>
                <span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_initialize_mesh_from_devices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">devices</span><span class="s3">):</span>
        <span class="s1">devices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">devices</span><span class="s3">)</span>
        <span class="s1">device_mesh </span><span class="s3">= </span><span class="s1">DeviceMesh</span><span class="s3">(</span>
            <span class="s1">shape</span><span class="s3">=</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
            <span class="s1">axis_names</span><span class="s3">=[</span><span class="s1">DEFAULT_BATCH_DIM_NAME</span><span class="s3">],</span>
            <span class="s1">devices</span><span class="s3">=</span><span class="s1">devices</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_initialize_mesh_from_list_devices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">devices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">list_devices</span><span class="s3">())</span>
        <span class="s1">device_mesh </span><span class="s3">= </span><span class="s1">DeviceMesh</span><span class="s3">(</span>
            <span class="s1">shape</span><span class="s3">=</span><span class="s1">devices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
            <span class="s1">axis_names</span><span class="s3">=[</span><span class="s1">DEFAULT_BATCH_DIM_NAME</span><span class="s3">],</span>
            <span class="s1">devices</span><span class="s3">=</span><span class="s1">devices</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_data_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_shape</span><span class="s3">):</span>
        <span class="s1">data_shard_spec </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data_shape</span><span class="s3">)</span>
        <span class="s1">data_shard_spec</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_batch_dim_name  </span><span class="s6"># Shard on the first dim</span>
        <span class="s2">return </span><span class="s1">TensorLayout</span><span class="s3">(</span><span class="s1">data_shard_spec</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_variable_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">variable</span><span class="s3">):</span>
        <span class="s1">variable_shard_spec </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">TensorLayout</span><span class="s3">(</span><span class="s1">variable_shard_spec</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_tensor_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s6"># For data parallel training, the intermediate state is not changed.</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">distribute_dataset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">tensorflow</span><span class="s3">.</span><span class="s1">python</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">experimental</span><span class="s3">.</span><span class="s1">ops </span><span class="s2">import </span><span class="s3">(</span>
            <span class="s1">distribute </span><span class="s2">as </span><span class="s1">tf_data_distribute</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">module_utils </span><span class="s2">import </span><span class="s1">tensorflow </span><span class="s2">as </span><span class="s1">tf</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">Dataset</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Only `tf.data.Dataset` is supported for &quot;</span>
                <span class="s4">f&quot;sharding, got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_multi_process </span><span class="s2">or not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_auto_shard_dataset</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dataset</span>

        <span class="s1">batch_size </span><span class="s3">= </span><span class="s1">tf_data_distribute</span><span class="s3">.</span><span class="s1">compute_batch_size</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">batch_size</span><span class="s3">.</span><span class="s1">numpy</span><span class="s3">() &lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;The batch size of the input dataset is &quot;</span>
                <span class="s4">&quot;unknown. Please config the batch size for &quot;</span>
                <span class="s4">&quot;the input dataset, e.g via `dataset.batch(batch_size)`&quot;</span>
            <span class="s3">)</span>
        <span class="s1">per_worker_batch_size </span><span class="s3">= </span><span class="s1">tf_data_distribute</span><span class="s3">.</span><span class="s1">batch_sizes_for_worker</span><span class="s3">(</span>
            <span class="s1">global_batch_size</span><span class="s3">=</span><span class="s1">batch_size</span><span class="s3">,</span>
            <span class="s1">num_workers</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span><span class="s3">,</span>
            <span class="s1">num_replicas_per_worker</span><span class="s3">=</span><span class="s5">1</span><span class="s3">,  </span><span class="s6"># We hard code this for now.</span>
            <span class="s1">worker_index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">rebatch</span><span class="s3">(</span><span class="s1">per_worker_batch_size</span><span class="s3">)</span>
        <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">tf_data_distribute</span><span class="s3">.</span><span class="s1">_AutoShardDataset</span><span class="s3">(</span>
            <span class="s1">distributed_dataset</span><span class="s3">,</span>
            <span class="s1">num_workers</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id</span><span class="s3">,</span>
            <span class="s1">num_replicas</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">distributed_dataset</span><span class="s3">.</span><span class="s1">prefetch</span><span class="s3">(</span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">AUTOTUNE</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.ModelParallel&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">ModelParallel</span><span class="s3">(</span><span class="s1">Distribution</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Distribution that shards model variables. 
 
    Compare to `DataParallel` which replicates the variables across all devices, 
    `ModelParallel` allows you to shard variables in addition to the input data. 
 
    To construct a `ModelParallel` distribution, you need to provide a 
    `DeviceMesh` and a `LayoutMap`. 
 
    1. `DeviceMesh` contains physical device information. The axis names in 
        the mesh will be used to map the variable and data layout. 
    2. `LayoutMap` contains the mapping between variable paths to their 
        corresponding `TensorLayout`. 
 
    Example: 
 
    ```python 
    devices = list_devices()    # Assume there are 8 devices. 
 
    # Create a mesh with 2 devices for data parallelism and 4 devices for 
    # model parallelism. 
    device_mesh = DeviceMesh(shape=(2, 4), axis_names=('batch', 'model'), 
                             devices=devices) 
    # Create a layout map that shard the `Dense` layer and `Conv2D` 
    # layer variables on the last dimension. 
    # Based on the `device_mesh`, this means the variables 
    # will be split across 4 devices. Any other variable that doesn't 
    # match any key in the layout map will be fully replicated. 
    layout_map = LayoutMap(device_mesh) 
    layout_map['dense.*kernel'] = (None, 'model') 
    layout_map['dense.*bias'] = ('model',) 
    layout_map['conv2d.*kernel'] = (None, None, None, 'model') 
    layout_map['conv2d.*bias'] = ('model',) 
 
    distribution = ModelParallel( 
        layout_map=layout_map, 
        batch_dim_name='batch', 
    ) 
 
    # Set the global distribution, or via `with distribution.scope():` 
    set_distribution(distribution) 
 
    model = model_creation() 
    model.compile() 
    model.fit(data) 
    ``` 
 
    You can quickly update the device mesh shape to change the sharding factor 
    of the variables. E.g. 
 
    ```python 
    # With only the shape change for the device mesh, the variables will be 
    # sharded across 8 devices instead of 4, which further reduces the memory 
    # footprint of variables on each of the device. 
    device_mesh = DeviceMesh( 
        shape=(1, 8), 
        axis_names=('batch', 'model'), 
        devices=devices, 
    ) 
    ``` 
 
    To figure out a proper layout mapping rule for all the model variables, you 
    can first list out all the model variable paths, which will be used as the 
    key to map the variables to `TensorLayout`. 
 
    e.g. 
 
    ```python 
    model = create_model() 
    for v in model.variables: 
        print(v.path) 
    ``` 
 
    Args: 
        layout_map: `LayoutMap` instance which map the variable path to the 
            corresponding tensor layout. 
        batch_dim_name: Optional string, the axis name in the device mesh 
            (of the `layout_map` object) 
            that will be used to distribute data. If unspecified, the 
            first axis from the device mesh will be used. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">layout_map</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">batch_dim_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;device_mesh&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">layout_map </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;You must specify a layout_map argument.&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">layout_map</span><span class="s3">, </span><span class="s1">LayoutMap</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Argument `layout_map` must be a `LayoutMap` instance. &quot;</span>
                <span class="s4">f&quot;Received: layout_map=</span><span class="s2">{</span><span class="s1">layout_map</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s1">device_mesh </span><span class="s3">= </span><span class="s1">layout_map</span><span class="s3">.</span><span class="s1">device_mesh</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">device_mesh</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map </span><span class="s3">= </span><span class="s1">layout_map</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_batch_dim_name </span><span class="s3">= </span><span class="s1">batch_dim_name </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">axis_names</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s6"># Those following attributes might get convert to public methods.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">= </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">num_processes</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id </span><span class="s3">= </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">process_id</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_multi_process </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">&gt; </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">get_data_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_shape</span><span class="s3">):</span>
        <span class="s1">data_shard_spec </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data_shape</span><span class="s3">)</span>
        <span class="s1">data_shard_spec</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_batch_dim_name  </span><span class="s6"># Shard on the first dim</span>
        <span class="s2">return </span><span class="s1">TensorLayout</span><span class="s3">(</span><span class="s1">data_shard_spec</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_variable_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">variable</span><span class="s3">):</span>
        <span class="s1">variable_layout </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">variable</span><span class="s3">.</span><span class="s1">path</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">variable_layout </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">variable_layout</span>
        <span class="s1">variable_shard_spec </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">TensorLayout</span><span class="s3">(</span><span class="s1">variable_shard_spec</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_tensor_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">path</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">distribute_dataset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">tensorflow</span><span class="s3">.</span><span class="s1">python</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">experimental</span><span class="s3">.</span><span class="s1">ops </span><span class="s2">import </span><span class="s3">(</span>
            <span class="s1">distribute </span><span class="s2">as </span><span class="s1">tf_data_distribute</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">from </span><span class="s1">keras</span><span class="s3">.</span><span class="s1">src</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">module_utils </span><span class="s2">import </span><span class="s1">tensorflow </span><span class="s2">as </span><span class="s1">tf</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">Dataset</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Only `tf.data.Dataset` is supported for &quot;</span>
                <span class="s4">f&quot;sharding, got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_multi_process</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dataset</span>

        <span class="s1">global_batch_size </span><span class="s3">= </span><span class="s1">tf_data_distribute</span><span class="s3">.</span><span class="s1">compute_batch_size</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">global_batch_size</span><span class="s3">.</span><span class="s1">numpy</span><span class="s3">() &lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;The batch size of the input dataset is &quot;</span>
                <span class="s4">&quot;unknown. Please config the batch size for &quot;</span>
                <span class="s4">&quot;the input dataset, e.g via `dataset.batch(batch_size)`&quot;</span>
            <span class="s3">)</span>

        <span class="s6"># We need to compute the per-process/worker/host batch size.</span>
        <span class="s6"># This will depend on how many model replicas we have on each process.</span>
        <span class="s6"># Note that this might be smaller than one if model replicas are sharded</span>
        <span class="s6"># across multiple processes.</span>
        <span class="s1">mesh_batch_dim_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">axis_names</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_batch_dim_name</span>
        <span class="s3">)</span>
        <span class="s1">num_model_replicas </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">mesh_batch_dim_index</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">num_model_replicas </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># No sharding is needed in this case. Each process will have the</span>
            <span class="s6"># global batch size, and data from the iterator will need to be</span>
            <span class="s6"># replicated across all processes.</span>
            <span class="s2">return </span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">prefetch</span><span class="s3">(</span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">AUTOTUNE</span><span class="s3">)</span>
        <span class="s1">num_model_replicas_per_process </span><span class="s3">= </span><span class="s1">num_model_replicas </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span>
        <span class="s2">if </span><span class="s1">num_model_replicas_per_process </span><span class="s3">&gt;= </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># Each process will have one or more full model replicas. Data will</span>
            <span class="s6"># be sharded across all processes without replication.</span>
            <span class="s2">if </span><span class="s1">global_batch_size </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;Global batch size must be divisible by the number of &quot;</span>
                    <span class="s4">f&quot;processes. `global_batch_size`=</span><span class="s2">{</span><span class="s1">global_batch_size</span><span class="s2">} </span><span class="s4">and &quot;</span>
                    <span class="s4">f&quot;`num_process`=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">per_process_batch_size </span><span class="s3">= </span><span class="s1">global_batch_size </span><span class="s3">// </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span>
            <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">rebatch</span><span class="s3">(</span><span class="s1">per_process_batch_size</span><span class="s3">)</span>
            <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">distributed_dataset</span><span class="s3">.</span><span class="s1">shard</span><span class="s3">(</span>
                <span class="s1">num_shards</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process</span><span class="s3">,</span>
                <span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">distributed_dataset</span><span class="s3">.</span><span class="s1">prefetch</span><span class="s3">(</span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">AUTOTUNE</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Model replicas are sharded across multiple processes. Data will be</span>
            <span class="s6"># sharded across model replicas, and replicated across processes</span>
            <span class="s6"># within the same model replica.</span>
            <span class="s2">if </span><span class="s1">global_batch_size </span><span class="s3">% </span><span class="s1">num_model_replicas </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;Global batch size must be divisible by the number of &quot;</span>
                    <span class="s4">f&quot;replicas. `global_batch_size`=</span><span class="s2">{</span><span class="s1">global_batch_size</span><span class="s2">} </span><span class="s4">and &quot;</span>
                    <span class="s4">f&quot;`num_model_replicas`=</span><span class="s2">{</span><span class="s1">num_model_replicas</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">per_process_batch_size </span><span class="s3">= </span><span class="s1">global_batch_size </span><span class="s3">// </span><span class="s1">num_model_replicas</span>
            <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">rebatch</span><span class="s3">(</span><span class="s1">per_process_batch_size</span><span class="s3">)</span>
            <span class="s1">processes_per_replica </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_num_process </span><span class="s3">// </span><span class="s1">num_model_replicas</span>
            <span class="s6"># TODO: Figure out what the convention is for data sharding id.</span>
            <span class="s1">data_shard_id </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_process_id </span><span class="s3">% </span><span class="s1">processes_per_replica</span>
            <span class="s1">distributed_dataset </span><span class="s3">= </span><span class="s1">distributed_dataset</span><span class="s3">.</span><span class="s1">shard</span><span class="s3">(</span>
                <span class="s1">num_shards</span><span class="s3">=</span><span class="s1">num_model_replicas</span><span class="s3">,</span>
                <span class="s1">index</span><span class="s3">=</span><span class="s1">data_shard_id</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">distributed_dataset</span><span class="s3">.</span><span class="s1">prefetch</span><span class="s3">(</span><span class="s1">tf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">AUTOTUNE</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.LayoutMap&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">LayoutMap</span><span class="s3">(</span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableMapping</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A dict-like object that maps string to `TensorLayout` instances. 
 
    `LayoutMap` uses a string as key and a `TensorLayout` as value. There is a 
    behavior difference between a normal Python dict and this class. The string 
    key will be treated as a regex when retrieving the value. See the docstring 
    of `get` for more details. 
 
    See below for a usage example. You can define the naming schema 
    of the `TensorLayout`, and then retrieve the corresponding 
    `TensorLayout` instance. 
 
    In the normal case, the key to query is usually the `variable.path`, which 
    is the idenifier of the variable. 
 
    As shortcut, tuple or list of axis names are also allowed when inserting 
    as value, and will be converted to `TensorLayout`. 
 
    ```python 
    layout_map = LayoutMap(device_mesh) 
    layout_map['dense.*kernel'] = (None, 'model') 
    layout_map['dense.*bias'] = ('model',) 
    layout_map['conv2d.*kernel'] = (None, None, None, 'model') 
    layout_map['conv2d.*bias'] = ('model',) 
 
    layout_1 = layout_map['dense_1.kernel']             # layout_1 == layout_2d 
    layout_2 = layout_map['dense_1.bias']               # layout_2 == layout_1d 
    layout_3 = layout_map['dense_2.kernel']             # layout_3 == layout_2d 
    layout_4 = layout_map['dense_2.bias']               # layout_4 == layout_1d 
    layout_5 = layout_map['my_model/conv2d_123/kernel'] # layout_5 == layout_4d 
    layout_6 = layout_map['my_model/conv2d_123/bias']   # layout_6 == layout_1d 
    layout_7 = layout_map['my_model/conv3d_1/kernel']   # layout_7 == None 
    layout_8 = layout_map['my_model/conv3d_1/bias']     # layout_8 == None 
    ``` 
 
    Args: 
        device_mesh: `keras.distribution.DeviceMesh` instance. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map </span><span class="s3">= </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">OrderedDict</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh </span><span class="s3">= </span><span class="s1">device_mesh</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Retrieves the corresponding layout by the string key. 
 
        When there isn't an exact match, all the existing keys in the layout map 
        will be treated as a regex and map against the input key again. When 
        there are multiple matches for the regex, an `ValueError` will be 
        raised. Returns `None` if there isn't any match found. 
 
        Args: 
            key: String key to query a layout. 
 
        Returns: 
            Corresponding layout based on the query. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

        <span class="s1">matching_keys </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">re</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
                <span class="s1">matching_keys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">matching_keys</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;Path '</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">' matches multiple layout &quot;</span>
                <span class="s4">f&quot;specification keys: </span><span class="s2">{</span><span class="s1">matching_keys</span><span class="s2">}</span><span class="s4">. Please make &quot;</span>
                <span class="s4">&quot;sure each tensor/variable path only matches at most &quot;</span>
                <span class="s4">&quot;one layout specification key in the LayoutMap.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">matching_keys</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">matching_keys</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Insert TensorLayout to the LayoutMap. 
 
        Args: 
            key: String key for the `TensorLayout`. 
            layout: The `TensorLayout`. As a shortcut, tuple of string and None 
                are also acceptable, and will be converted to `TensorLayout`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s4">already exist in the LayoutMap with &quot;</span>
                <span class="s4">f&quot;value </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span><span class="s2">}</span><span class="s4">. Please make sure to &quot;</span>
                <span class="s4">&quot;not use duplicated keys.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">layout </span><span class="s3">= </span><span class="s1">TensorLayout</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">=</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">device_mesh</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">TensorLayout</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">layout</span><span class="s2">} </span><span class="s4">should be a TensorLayout type, got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_maybe_populate_device_mesh</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">layout</span>

    <span class="s2">def </span><span class="s1">__delitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
        <span class="s6"># let the dict to handle the key missing error</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__iter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_layout_map</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_device_mesh</span>

    <span class="s2">def </span><span class="s1">_maybe_populate_device_mesh</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">layout</span><span class="s3">.</span><span class="s1">device_mesh </span><span class="s2">is None and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">layout</span><span class="s3">.</span><span class="s1">device_mesh </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">device_mesh</span>


<span class="s1">LayoutMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">LayoutMap</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">.</span><span class="s1">__doc__</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.distribute_tensor&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">distribute_tensor</span><span class="s3">(</span><span class="s1">tensor</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Change the layout of a Tensor value in the jit function execution. 
 
    Args: 
        tensor: a Tensor to change the layout. 
        layout: `TensorLayout` to be applied on the value. 
 
    Returns: 
        a new value with the specified tensor layout. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tensor</span><span class="s3">, </span><span class="s1">KerasTensor</span><span class="s3">):</span>
        <span class="s6"># keras tensor is only used for building functional model, and can't be</span>
        <span class="s6"># used to alter layout/sharding.</span>
        <span class="s2">return </span><span class="s1">tensor</span>
    <span class="s2">return </span><span class="s1">distribution_lib</span><span class="s3">.</span><span class="s1">distribute_tensor</span><span class="s3">(</span><span class="s1">tensor</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.distribution&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">distribution</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Retrieve the current distribution from global context.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">global_state</span><span class="s3">.</span><span class="s1">get_global_attribute</span><span class="s3">(</span><span class="s1">GLOBAL_ATTRIBUTE_NAME</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">keras_export</span><span class="s3">(</span><span class="s4">&quot;keras.distribution.set_distribution&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">set_distribution</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Set the distribution as the global distribution setting. 
 
    Args: 
        value: a `Distribution` instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">global_state</span><span class="s3">.</span><span class="s1">set_global_attribute</span><span class="s3">(</span><span class="s1">GLOBAL_ATTRIBUTE_NAME</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
</pre>
</body>
</html>