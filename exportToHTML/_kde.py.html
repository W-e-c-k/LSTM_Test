<html>
<head>
<title>_kde.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_kde.py</font>
</center></td></tr></table>
<pre><span class="s0">#-------------------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0">#  Define classes for (uni/multi)-variate kernel density estimation.</span>
<span class="s0">#</span>
<span class="s0">#  Currently, only Gaussian kernels are implemented.</span>
<span class="s0">#</span>
<span class="s0">#  Written by: Robert Kern</span>
<span class="s0">#</span>
<span class="s0">#  Date: 2004-08-09</span>
<span class="s0">#</span>
<span class="s0">#  Modified: 2005-02-10 by Robert Kern.</span>
<span class="s0">#              Contributed to SciPy</span>
<span class="s0">#            2005-10-07 by Robert Kern.</span>
<span class="s0">#              Some fixes to match the new scipy_core</span>
<span class="s0">#</span>
<span class="s0">#  Copyright 2004-2005 by Enthought, Inc.</span>
<span class="s0">#</span>
<span class="s0">#-------------------------------------------------------------------------------</span>

<span class="s0"># Standard library imports.</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s0"># SciPy imports.</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">linalg</span><span class="s3">, </span><span class="s1">special</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">check_random_state</span>

<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s3">(</span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">atleast_2d</span><span class="s3">, </span><span class="s1">reshape</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">newaxis</span><span class="s3">, </span><span class="s1">exp</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">,</span>
                   <span class="s1">sqrt</span><span class="s3">, </span><span class="s1">ravel</span><span class="s3">, </span><span class="s1">power</span><span class="s3">, </span><span class="s1">atleast_1d</span><span class="s3">, </span><span class="s1">squeeze</span><span class="s3">, </span><span class="s1">sum</span><span class="s3">, </span><span class="s1">transpose</span><span class="s3">,</span>
                   <span class="s1">ones</span><span class="s3">, </span><span class="s1">cov</span><span class="s3">)</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s0"># Local imports.</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_mvn</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_stats </span><span class="s2">import </span><span class="s1">gaussian_kernel_estimate</span><span class="s3">, </span><span class="s1">gaussian_kernel_estimate_log</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'gaussian_kde'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">gaussian_kde</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Representation of a kernel-density estimate using Gaussian kernels. 
 
    Kernel density estimation is a way to estimate the probability density 
    function (PDF) of a random variable in a non-parametric way. 
    `gaussian_kde` works for both uni-variate and multi-variate data.   It 
    includes automatic bandwidth determination.  The estimation works best for 
    a unimodal distribution; bimodal or multi-modal distributions tend to be 
    oversmoothed. 
 
    Parameters 
    ---------- 
    dataset : array_like 
        Datapoints to estimate from. In case of univariate data this is a 1-D 
        array, otherwise a 2-D array with shape (# of dims, # of data). 
    bw_method : str, scalar or callable, optional 
        The method used to calculate the estimator bandwidth.  This can be 
        'scott', 'silverman', a scalar constant or a callable.  If a scalar, 
        this will be used directly as `kde.factor`.  If a callable, it should 
        take a `gaussian_kde` instance as only parameter and return a scalar. 
        If None (default), 'scott' is used.  See Notes for more details. 
    weights : array_like, optional 
        weights of datapoints. This must be the same shape as dataset. 
        If None (default), the samples are assumed to be equally weighted 
 
    Attributes 
    ---------- 
    dataset : ndarray 
        The dataset with which `gaussian_kde` was initialized. 
    d : int 
        Number of dimensions. 
    n : int 
        Number of datapoints. 
    neff : int 
        Effective number of datapoints. 
 
        .. versionadded:: 1.2.0 
    factor : float 
        The bandwidth factor, obtained from `kde.covariance_factor`. The square 
        of `kde.factor` multiplies the covariance matrix of the data in the kde 
        estimation. 
    covariance : ndarray 
        The covariance matrix of `dataset`, scaled by the calculated bandwidth 
        (`kde.factor`). 
    inv_cov : ndarray 
        The inverse of `covariance`. 
 
    Methods 
    ------- 
    evaluate 
    __call__ 
    integrate_gaussian 
    integrate_box_1d 
    integrate_box 
    integrate_kde 
    pdf 
    logpdf 
    resample 
    set_bandwidth 
    covariance_factor 
 
    Notes 
    ----- 
    Bandwidth selection strongly influences the estimate obtained from the KDE 
    (much more so than the actual shape of the kernel).  Bandwidth selection 
    can be done by a &quot;rule of thumb&quot;, by cross-validation, by &quot;plug-in 
    methods&quot; or by other means; see [3]_, [4]_ for reviews.  `gaussian_kde` 
    uses a rule of thumb, the default is Scott's Rule. 
 
    Scott's Rule [1]_, implemented as `scotts_factor`, is:: 
 
        n**(-1./(d+4)), 
 
    with ``n`` the number of data points and ``d`` the number of dimensions. 
    In the case of unequally weighted points, `scotts_factor` becomes:: 
 
        neff**(-1./(d+4)), 
 
    with ``neff`` the effective number of datapoints. 
    Silverman's Rule [2]_, implemented as `silverman_factor`, is:: 
 
        (n * (d + 2) / 4.)**(-1. / (d + 4)). 
 
    or in the case of unequally weighted points:: 
 
        (neff * (d + 2) / 4.)**(-1. / (d + 4)). 
 
    Good general descriptions of kernel density estimation can be found in [1]_ 
    and [2]_, the mathematics for this multi-dimensional implementation can be 
    found in [1]_. 
 
    With a set of weighted samples, the effective number of datapoints ``neff`` 
    is defined by:: 
 
        neff = sum(weights)^2 / sum(weights^2) 
 
    as detailed in [5]_. 
 
    `gaussian_kde` does not currently support data that lies in a 
    lower-dimensional subspace of the space in which it is expressed. For such 
    data, consider performing principle component analysis / dimensionality 
    reduction and using `gaussian_kde` with the transformed data. 
 
    References 
    ---------- 
    .. [1] D.W. Scott, &quot;Multivariate Density Estimation: Theory, Practice, and 
           Visualization&quot;, John Wiley &amp; Sons, New York, Chicester, 1992. 
    .. [2] B.W. Silverman, &quot;Density Estimation for Statistics and Data 
           Analysis&quot;, Vol. 26, Monographs on Statistics and Applied Probability, 
           Chapman and Hall, London, 1986. 
    .. [3] B.A. Turlach, &quot;Bandwidth Selection in Kernel Density Estimation: A 
           Review&quot;, CORE and Institut de Statistique, Vol. 19, pp. 1-33, 1993. 
    .. [4] D.M. Bashtannyk and R.J. Hyndman, &quot;Bandwidth selection for kernel 
           conditional density estimation&quot;, Computational Statistics &amp; Data 
           Analysis, Vol. 36, pp. 279-298, 2001. 
    .. [5] Gray P. G., 1969, Journal of the Royal Statistical Society. 
           Series A (General), 132, 272 
 
    Examples 
    -------- 
    Generate some random two-dimensional data: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; def measure(n): 
    ...     &quot;Measurement model, return two coupled measurements.&quot; 
    ...     m1 = np.random.normal(size=n) 
    ...     m2 = np.random.normal(scale=0.5, size=n) 
    ...     return m1+m2, m1-m2 
 
    &gt;&gt;&gt; m1, m2 = measure(2000) 
    &gt;&gt;&gt; xmin = m1.min() 
    &gt;&gt;&gt; xmax = m1.max() 
    &gt;&gt;&gt; ymin = m2.min() 
    &gt;&gt;&gt; ymax = m2.max() 
 
    Perform a kernel density estimate on the data: 
 
    &gt;&gt;&gt; X, Y = np.mgrid[xmin:xmax:100j, ymin:ymax:100j] 
    &gt;&gt;&gt; positions = np.vstack([X.ravel(), Y.ravel()]) 
    &gt;&gt;&gt; values = np.vstack([m1, m2]) 
    &gt;&gt;&gt; kernel = stats.gaussian_kde(values) 
    &gt;&gt;&gt; Z = np.reshape(kernel(positions).T, X.shape) 
 
    Plot the results: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.imshow(np.rot90(Z), cmap=plt.cm.gist_earth_r, 
    ...           extent=[xmin, xmax, ymin, ymax]) 
    &gt;&gt;&gt; ax.plot(m1, m2, 'k.', markersize=2) 
    &gt;&gt;&gt; ax.set_xlim([xmin, xmax]) 
    &gt;&gt;&gt; ax.set_ylim([ymin, ymax]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">bw_method</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dataset </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">))</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`dataset` input should have multiple elements.&quot;</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">shape</span>

        <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_weights </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_weights </span><span class="s3">/= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_weights</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`weights` input should be one-dimensional.&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_weights</span><span class="s3">) != </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`weights` input should be of length n&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_neff </span><span class="s3">= </span><span class="s6">1</span><span class="s3">/</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_weights</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>

        <span class="s0"># This can be converted to a warning once gh-10205 is resolved</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Number of dimensions is greater than number of samples. &quot;</span>
                   <span class="s4">&quot;This results in a singular data covariance matrix, which &quot;</span>
                   <span class="s4">&quot;cannot be treated using the algorithms implemented in &quot;</span>
                   <span class="s4">&quot;`gaussian_kde`. Note that `gaussian_kde` interprets each &quot;</span>
                   <span class="s4">&quot;*column* of `dataset` to be a point; consider transposing &quot;</span>
                   <span class="s4">&quot;the input to `dataset`.&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_bandwidth</span><span class="s3">(</span><span class="s1">bw_method</span><span class="s3">=</span><span class="s1">bw_method</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;The data appears to lie in a lower-dimensional subspace &quot;</span>
                   <span class="s4">&quot;of the space in which it is expressed. This has resulted &quot;</span>
                   <span class="s4">&quot;in a singular data covariance matrix, which cannot be &quot;</span>
                   <span class="s4">&quot;treated using the algorithms implemented in &quot;</span>
                   <span class="s4">&quot;`gaussian_kde`. Consider performing principle component &quot;</span>
                   <span class="s4">&quot;analysis / dimensionality reduction and using &quot;</span>
                   <span class="s4">&quot;`gaussian_kde` with the transformed data.&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">evaluate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">points</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the estimated pdf on a set of points. 
 
        Parameters 
        ---------- 
        points : (# of dimensions, # of points)-array 
            Alternatively, a (# of dimensions,) vector can be passed in and 
            treated as a single point. 
 
        Returns 
        ------- 
        values : (# of points,)-array 
            The values at each point. 
 
        Raises 
        ------ 
        ValueError : if the dimensionality of the input points is different than 
                     the dimensionality of the KDE. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">points </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">points</span><span class="s3">))</span>

        <span class="s1">d</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">points</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">d </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">m </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">:</span>
                <span class="s0"># points was passed in as a row vector</span>
                <span class="s1">points </span><span class="s3">= </span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">points</span><span class="s3">, (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s6">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s4">f&quot;points have dimension </span><span class="s2">{</span><span class="s1">d</span><span class="s2">}</span><span class="s4">, &quot;</span>
                       <span class="s4">f&quot;dataset has dimension </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">output_dtype</span><span class="s3">, </span><span class="s1">spec </span><span class="s3">= </span><span class="s1">_get_output_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance</span><span class="s3">, </span><span class="s1">points</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">gaussian_kernel_estimate</span><span class="s3">[</span><span class="s1">spec</span><span class="s3">](</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">],</span>
            <span class="s1">points</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cho_cov</span><span class="s3">, </span><span class="s1">output_dtype</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">result</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">]</span>

    <span class="s1">__call__ </span><span class="s3">= </span><span class="s1">evaluate</span>

    <span class="s2">def </span><span class="s1">integrate_gaussian</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">, </span><span class="s1">cov</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Multiply estimated density by a multivariate Gaussian and integrate 
        over the whole space. 
 
        Parameters 
        ---------- 
        mean : aray_like 
            A 1-D array, specifying the mean of the Gaussian. 
        cov : array_like 
            A 2-D array, specifying the covariance matrix of the Gaussian. 
 
        Returns 
        ------- 
        result : scalar 
            The value of the integral. 
 
        Raises 
        ------ 
        ValueError 
            If the mean or covariance of the input Gaussian differs from 
            the KDE's dimensionality. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">mean</span><span class="s3">))</span>
        <span class="s1">cov </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">cov</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">mean</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;mean does not have dimension %s&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cov</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;covariance does not have dimension %s&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">)</span>

        <span class="s0"># make mean a column vector</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">mean</span><span class="s3">[:, </span><span class="s1">newaxis</span><span class="s3">]</span>

        <span class="s1">sum_cov </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance </span><span class="s3">+ </span><span class="s1">cov</span>

        <span class="s0"># This will raise LinAlgError if the new cov matrix is not s.p.d</span>
        <span class="s0"># cho_factor returns (ndarray, bool) where bool is a flag for whether</span>
        <span class="s0"># or not ndarray is upper or lower triangular</span>
        <span class="s1">sum_cov_chol </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cho_factor</span><span class="s3">(</span><span class="s1">sum_cov</span><span class="s3">)</span>

        <span class="s1">diff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset </span><span class="s3">- </span><span class="s1">mean</span>
        <span class="s1">tdiff </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cho_solve</span><span class="s3">(</span><span class="s1">sum_cov_chol</span><span class="s3">, </span><span class="s1">diff</span><span class="s3">)</span>

        <span class="s1">sqrt_det </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diagonal</span><span class="s3">(</span><span class="s1">sum_cov_chol</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]))</span>
        <span class="s1">norm_const </span><span class="s3">= </span><span class="s1">power</span><span class="s3">(</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">sum_cov</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] / </span><span class="s6">2.0</span><span class="s3">) * </span><span class="s1">sqrt_det</span>

        <span class="s1">energies </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">diff </span><span class="s3">* </span><span class="s1">tdiff</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">) / </span><span class="s6">2.0</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">energies</span><span class="s3">)*</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">) / </span><span class="s1">norm_const</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">integrate_box_1d</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Computes the integral of a 1D pdf between two bounds. 
 
        Parameters 
        ---------- 
        low : scalar 
            Lower bound of integration. 
        high : scalar 
            Upper bound of integration. 
 
        Returns 
        ------- 
        value : scalar 
            The result of the integral. 
 
        Raises 
        ------ 
        ValueError 
            If the KDE is over more than one dimension. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;integrate_box_1d() only handles 1D pdfs&quot;</span><span class="s3">)</span>

        <span class="s1">stdev </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance</span><span class="s3">))[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s1">normalized_low </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">((</span><span class="s1">low </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">) / </span><span class="s1">stdev</span><span class="s3">)</span>
        <span class="s1">normalized_high </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">((</span><span class="s1">high </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">) / </span><span class="s1">stdev</span><span class="s3">)</span>

        <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">*(</span>
                        <span class="s1">special</span><span class="s3">.</span><span class="s1">ndtr</span><span class="s3">(</span><span class="s1">normalized_high</span><span class="s3">) -</span>
                        <span class="s1">special</span><span class="s3">.</span><span class="s1">ndtr</span><span class="s3">(</span><span class="s1">normalized_low</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">integrate_box</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low_bounds</span><span class="s3">, </span><span class="s1">high_bounds</span><span class="s3">, </span><span class="s1">maxpts</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Computes the integral of a pdf over a rectangular interval. 
 
        Parameters 
        ---------- 
        low_bounds : array_like 
            A 1-D array containing the lower bounds of integration. 
        high_bounds : array_like 
            A 1-D array containing the upper bounds of integration. 
        maxpts : int, optional 
            The maximum number of points to use for integration. 
 
        Returns 
        ------- 
        value : scalar 
            The result of the integral. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">maxpts </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">extra_kwds </span><span class="s3">= {</span><span class="s4">'maxpts'</span><span class="s3">: </span><span class="s1">maxpts</span><span class="s3">}</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">extra_kwds </span><span class="s3">= {}</span>

        <span class="s1">value</span><span class="s3">, </span><span class="s1">inform </span><span class="s3">= </span><span class="s1">_mvn</span><span class="s3">.</span><span class="s1">mvnun_weighted</span><span class="s3">(</span><span class="s1">low_bounds</span><span class="s3">, </span><span class="s1">high_bounds</span><span class="s3">,</span>
                                            <span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">,</span>
                                            <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance</span><span class="s3">, **</span><span class="s1">extra_kwds</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">inform</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'An integral in _mvn.mvnun requires more points than %s' </span><span class="s3">%</span>
                   <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d </span><span class="s3">* </span><span class="s6">1000</span><span class="s3">))</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">integrate_kde</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Computes the integral of the product of this  kernel density estimate 
        with another. 
 
        Parameters 
        ---------- 
        other : gaussian_kde instance 
            The other kde. 
 
        Returns 
        ------- 
        value : scalar 
            The result of the integral. 
 
        Raises 
        ------ 
        ValueError 
            If the KDEs have different dimensionality. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">d </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;KDEs are not the same dimensionality&quot;</span><span class="s3">)</span>

        <span class="s0"># we want to iterate over the smallest number of points</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">small </span><span class="s3">= </span><span class="s1">other</span>
            <span class="s1">large </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">small </span><span class="s3">= </span><span class="s1">self</span>
            <span class="s1">large </span><span class="s3">= </span><span class="s1">other</span>

        <span class="s1">sum_cov </span><span class="s3">= </span><span class="s1">small</span><span class="s3">.</span><span class="s1">covariance </span><span class="s3">+ </span><span class="s1">large</span><span class="s3">.</span><span class="s1">covariance</span>
        <span class="s1">sum_cov_chol </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cho_factor</span><span class="s3">(</span><span class="s1">sum_cov</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s6">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">small</span><span class="s3">.</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">mean </span><span class="s3">= </span><span class="s1">small</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">newaxis</span><span class="s3">]</span>
            <span class="s1">diff </span><span class="s3">= </span><span class="s1">large</span><span class="s3">.</span><span class="s1">dataset </span><span class="s3">- </span><span class="s1">mean</span>
            <span class="s1">tdiff </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cho_solve</span><span class="s3">(</span><span class="s1">sum_cov_chol</span><span class="s3">, </span><span class="s1">diff</span><span class="s3">)</span>

            <span class="s1">energies </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">diff </span><span class="s3">* </span><span class="s1">tdiff</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">) / </span><span class="s6">2.0</span>
            <span class="s1">result </span><span class="s3">+= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">energies</span><span class="s3">)*</span><span class="s1">large</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)*</span><span class="s1">small</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s1">sqrt_det </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diagonal</span><span class="s3">(</span><span class="s1">sum_cov_chol</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]))</span>
        <span class="s1">norm_const </span><span class="s3">= </span><span class="s1">power</span><span class="s3">(</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">sum_cov</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] / </span><span class="s6">2.0</span><span class="s3">) * </span><span class="s1">sqrt_det</span>

        <span class="s1">result </span><span class="s3">/= </span><span class="s1">norm_const</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">resample</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">seed</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot;Randomly sample a dataset from the estimated pdf. 
 
        Parameters 
        ---------- 
        size : int, optional 
            The number of samples to draw.  If not provided, then the size is 
            the same as the effective number of samples in the underlying 
            dataset. 
        seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
            If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
            singleton is used. 
            If `seed` is an int, a new ``RandomState`` instance is used, 
            seeded with `seed`. 
            If `seed` is already a ``Generator`` or ``RandomState`` instance then 
            that instance is used. 
 
        Returns 
        ------- 
        resample : (self.d, `size`) ndarray 
            The sampled dataset. 
 
        &quot;&quot;&quot; </span><span class="s0"># numpy/numpydoc#87  # noqa: E501</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">neff</span><span class="s3">)</span>

        <span class="s1">random_state </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s1">seed</span><span class="s3">)</span>
        <span class="s1">norm </span><span class="s3">= </span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">multivariate_normal</span><span class="s3">(</span>
            <span class="s1">zeros</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,), </span><span class="s1">float</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span>
        <span class="s3">))</span>
        <span class="s1">indices </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">)</span>
        <span class="s1">means </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">[:, </span><span class="s1">indices</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">means </span><span class="s3">+ </span><span class="s1">norm</span>

    <span class="s2">def </span><span class="s1">scotts_factor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Compute Scott's factor. 
 
        Returns 
        ------- 
        s : float 
            Scott's factor. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">power</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">neff</span><span class="s3">, -</span><span class="s6">1.</span><span class="s3">/(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">+</span><span class="s6">4</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">silverman_factor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Compute the Silverman factor. 
 
        Returns 
        ------- 
        s : float 
            The silverman factor. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">power</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">neff</span><span class="s3">*(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">+</span><span class="s6">2.0</span><span class="s3">)/</span><span class="s6">4.0</span><span class="s3">, -</span><span class="s6">1.</span><span class="s3">/(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">+</span><span class="s6">4</span><span class="s3">))</span>

    <span class="s0">#  Default method to calculate bandwidth, can be overwritten by subclass</span>
    <span class="s1">covariance_factor </span><span class="s3">= </span><span class="s1">scotts_factor</span>
    <span class="s1">covariance_factor</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s4">&quot;&quot;&quot;Computes the coefficient (`kde.factor`) that 
        multiplies the data covariance matrix to obtain the kernel covariance 
        matrix. The default is `scotts_factor`.  A subclass can overwrite this 
        method to provide a different method, or set it through a call to 
        `kde.set_bandwidth`.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_bandwidth</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">bw_method</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Compute the estimator bandwidth with given method. 
 
        The new bandwidth calculated after a call to `set_bandwidth` is used 
        for subsequent evaluations of the estimated density. 
 
        Parameters 
        ---------- 
        bw_method : str, scalar or callable, optional 
            The method used to calculate the estimator bandwidth.  This can be 
            'scott', 'silverman', a scalar constant or a callable.  If a 
            scalar, this will be used directly as `kde.factor`.  If a callable, 
            it should take a `gaussian_kde` instance as only parameter and 
            return a scalar.  If None (default), nothing happens; the current 
            `kde.covariance_factor` method is kept. 
 
        Notes 
        ----- 
        .. versionadded:: 0.11 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; import scipy.stats as stats 
        &gt;&gt;&gt; x1 = np.array([-7, -5, 1, 4, 5.]) 
        &gt;&gt;&gt; kde = stats.gaussian_kde(x1) 
        &gt;&gt;&gt; xs = np.linspace(-10, 10, num=50) 
        &gt;&gt;&gt; y1 = kde(xs) 
        &gt;&gt;&gt; kde.set_bandwidth(bw_method='silverman') 
        &gt;&gt;&gt; y2 = kde(xs) 
        &gt;&gt;&gt; kde.set_bandwidth(bw_method=kde.factor / 3.) 
        &gt;&gt;&gt; y3 = kde(xs) 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig, ax = plt.subplots() 
        &gt;&gt;&gt; ax.plot(x1, np.full(x1.shape, 1 / (4. * x1.size)), 'bo', 
        ...         label='Data points (rescaled)') 
        &gt;&gt;&gt; ax.plot(xs, y1, label='Scott (default)') 
        &gt;&gt;&gt; ax.plot(xs, y2, label='Silverman') 
        &gt;&gt;&gt; ax.plot(xs, y3, label='Const (1/3 * Silverman)') 
        &gt;&gt;&gt; ax.legend() 
        &gt;&gt;&gt; plt.show() 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bw_method </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">bw_method </span><span class="s3">== </span><span class="s4">'scott'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scotts_factor</span>
        <span class="s2">elif </span><span class="s1">bw_method </span><span class="s3">== </span><span class="s4">'silverman'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">silverman_factor</span>
        <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">bw_method</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bw_method</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_bw_method </span><span class="s3">= </span><span class="s4">'use constant'</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">bw_method</span>
        <span class="s2">elif </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">bw_method</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_bw_method </span><span class="s3">= </span><span class="s1">bw_method</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_bw_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;`bw_method` should be 'scott', 'silverman', a scalar &quot; </span><span class="s1">\</span>
                  <span class="s4">&quot;or a callable.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_covariance</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_compute_covariance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Computes the covariance matrix for each Gaussian kernel using 
        covariance_factor(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">factor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor</span><span class="s3">()</span>
        <span class="s0"># Cache covariance and Cholesky decomp of covariance</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">'_data_cho_cov'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_data_covariance </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">cov</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
                                               <span class="s1">bias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                               <span class="s1">aweights</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_data_cho_cov </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cholesky</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data_covariance</span><span class="s3">,</span>
                                                 <span class="s1">lower</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">covariance </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data_covariance </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">factor</span><span class="s3">**</span><span class="s6">2</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cho_cov </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data_cho_cov </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">factor</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">log_det </span><span class="s3">= </span><span class="s6">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cho_cov</span>
                                        <span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">))).</span><span class="s1">sum</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">inv_cov</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Re-compute from scratch each time because I'm not sure how this is</span>
        <span class="s0"># used in the wild. (Perhaps users change the `dataset`, since it's</span>
        <span class="s0"># not a private attribute?) `_compute_covariance` used to recalculate</span>
        <span class="s0"># all these, so we'll recalculate everything now that this is a</span>
        <span class="s0"># a property.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">factor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data_covariance </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">cov</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
                                           <span class="s1">bias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">aweights</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">inv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data_covariance</span><span class="s3">) / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">factor</span><span class="s3">**</span><span class="s6">2</span>

    <span class="s2">def </span><span class="s1">pdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Evaluate the estimated pdf on a provided set of points. 
 
        Notes 
        ----- 
        This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate`` 
        docstring for more details. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">evaluate</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">logpdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Evaluate the log of the estimated pdf on a provided set of points. 
        &quot;&quot;&quot;</span>
        <span class="s1">points </span><span class="s3">= </span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">d</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">points</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">d </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">m </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">:</span>
                <span class="s0"># points was passed in as a row vector</span>
                <span class="s1">points </span><span class="s3">= </span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">points</span><span class="s3">, (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s6">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s4">f&quot;points have dimension </span><span class="s2">{</span><span class="s1">d</span><span class="s2">}</span><span class="s4">, &quot;</span>
                       <span class="s4">f&quot;dataset has dimension </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">d</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">output_dtype</span><span class="s3">, </span><span class="s1">spec </span><span class="s3">= </span><span class="s1">_get_output_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance</span><span class="s3">, </span><span class="s1">points</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">gaussian_kernel_estimate_log</span><span class="s3">[</span><span class="s1">spec</span><span class="s3">](</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">],</span>
            <span class="s1">points</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cho_cov</span><span class="s3">, </span><span class="s1">output_dtype</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">result</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">marginal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dimensions</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Return a marginal KDE distribution 
 
        Parameters 
        ---------- 
        dimensions : int or 1-d array_like 
            The dimensions of the multivariate distribution corresponding 
            with the marginal variables, that is, the indices of the dimensions 
            that are being retained. The other dimensions are marginalized out. 
 
        Returns 
        ------- 
        marginal_kde : gaussian_kde 
            An object representing the marginal distribution. 
 
        Notes 
        ----- 
        .. versionadded:: 1.10.0 
 
        &quot;&quot;&quot;</span>

        <span class="s1">dims </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Elements of `dimensions` must be integers - the indices &quot;</span>
                   <span class="s4">&quot;of the marginal variables being retained.&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">)  </span><span class="s0"># number of dimensions</span>
        <span class="s1">original_dims </span><span class="s3">= </span><span class="s1">dims</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s1">dims</span><span class="s3">[</span><span class="s1">dims </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">n </span><span class="s3">+ </span><span class="s1">dims</span><span class="s3">[</span><span class="s1">dims </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">)) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;All elements of `dimensions` must be unique.&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">i_invalid </span><span class="s3">= (</span><span class="s1">dims </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">) | (</span><span class="s1">dims </span><span class="s3">&gt;= </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">i_invalid</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">f&quot;Dimensions </span><span class="s2">{</span><span class="s1">original_dims</span><span class="s3">[</span><span class="s1">i_invalid</span><span class="s3">]</span><span class="s2">} </span><span class="s4">are invalid &quot;</span>
                   <span class="s4">f&quot;for a distribution in </span><span class="s2">{</span><span class="s1">n</span><span class="s2">} </span><span class="s4">dimensions.&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">dataset </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dataset</span><span class="s3">[</span><span class="s1">dims</span><span class="s3">]</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span>

        <span class="s2">return </span><span class="s1">gaussian_kde</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">bw_method</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">covariance_factor</span><span class="s3">(),</span>
                            <span class="s1">weights</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">weights</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_weights</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_weights </span><span class="s3">= </span><span class="s1">ones</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span><span class="s3">)/</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_weights</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">neff</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_neff</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_neff </span><span class="s3">= </span><span class="s6">1</span><span class="s3">/</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weights</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_neff</span>


<span class="s2">def </span><span class="s1">_get_output_dtype</span><span class="s3">(</span><span class="s1">covariance</span><span class="s3">, </span><span class="s1">points</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculates the output dtype and the &quot;spec&quot; (=C type name). 
 
    This was necessary in order to deal with the fused types in the Cython 
    routine `gaussian_kernel_estimate`. See gh-10824 for details. 
    &quot;&quot;&quot;</span>
    <span class="s1">output_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">common_type</span><span class="s3">(</span><span class="s1">covariance</span><span class="s3">, </span><span class="s1">points</span><span class="s3">)</span>
    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">output_dtype</span><span class="s3">).</span><span class="s1">itemsize</span>
    <span class="s2">if </span><span class="s1">itemsize </span><span class="s3">== </span><span class="s6">4</span><span class="s3">:</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s4">'float'</span>
    <span class="s2">elif </span><span class="s1">itemsize </span><span class="s3">== </span><span class="s6">8</span><span class="s3">:</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s4">'double'</span>
    <span class="s2">elif </span><span class="s1">itemsize </span><span class="s2">in </span><span class="s3">(</span><span class="s6">12</span><span class="s3">, </span><span class="s6">16</span><span class="s3">):</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s4">'long double'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">output_dtype</span><span class="s2">} </span><span class="s4">has unexpected item size: </span><span class="s2">{</span><span class="s1">itemsize</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">output_dtype</span><span class="s3">, </span><span class="s1">spec</span>
</pre>
</body>
</html>