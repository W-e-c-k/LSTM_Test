<html>
<head>
<title>typing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typing.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2022-2024 MetaOPT Team. All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s0"># ==============================================================================</span>
<span class="s2">&quot;&quot;&quot;Typing utilities for OpTree.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">types</span>
<span class="s3">from </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">import </span><span class="s1">Hashable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">Callable</span><span class="s4">,</span>
    <span class="s1">DefaultDict</span><span class="s4">,</span>
    <span class="s1">Deque</span><span class="s4">,</span>
    <span class="s1">Dict</span><span class="s4">,</span>
    <span class="s1">ForwardRef</span><span class="s4">,</span>
    <span class="s1">Generic</span><span class="s4">,</span>
    <span class="s1">Iterable</span><span class="s4">,</span>
    <span class="s1">List</span><span class="s4">,</span>
    <span class="s1">NoReturn</span><span class="s4">,</span>
    <span class="s1">Optional</span><span class="s4">,</span>
    <span class="s1">Sequence</span><span class="s4">,</span>
    <span class="s1">Tuple</span><span class="s4">,</span>
    <span class="s1">TypeVar</span><span class="s4">,</span>
    <span class="s1">Union</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">NamedTuple  </span><span class="s0"># Generic NamedTuple: Python 3.11+</span>
<span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">OrderedDict  </span><span class="s0"># Generic OrderedDict: Python 3.7.2+</span>
<span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">Self  </span><span class="s0"># Python 3.11+</span>
<span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">TypeAlias  </span><span class="s0"># Python 3.10+</span>
<span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">Final</span><span class="s4">, </span><span class="s1">Protocol</span><span class="s4">, </span><span class="s1">runtime_checkable  </span><span class="s0"># Python 3.8+</span>

<span class="s3">from </span><span class="s1">optree </span><span class="s3">import </span><span class="s1">_C</span>
<span class="s3">from </span><span class="s1">optree</span><span class="s4">.</span><span class="s1">_C </span><span class="s3">import </span><span class="s1">PyTreeKind</span><span class="s4">, </span><span class="s1">PyTreeSpec</span>
<span class="s3">from </span><span class="s1">optree</span><span class="s4">.</span><span class="s1">accessor </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">AutoEntry</span><span class="s4">,</span>
    <span class="s1">DataclassEntry</span><span class="s4">,</span>
    <span class="s1">FlattenedEntry</span><span class="s4">,</span>
    <span class="s1">GetAttrEntry</span><span class="s4">,</span>
    <span class="s1">GetItemEntry</span><span class="s4">,</span>
    <span class="s1">MappingEntry</span><span class="s4">,</span>
    <span class="s1">NamedTupleEntry</span><span class="s4">,</span>
    <span class="s1">PyTreeAccessor</span><span class="s4">,</span>
    <span class="s1">PyTreeEntry</span><span class="s4">,</span>
    <span class="s1">SequenceEntry</span><span class="s4">,</span>
    <span class="s1">StructSequenceEntry</span><span class="s4">,</span>
<span class="s4">)</span>


<span class="s1">__all__ </span><span class="s4">= [</span>
    <span class="s5">'PyTreeSpec'</span><span class="s4">,</span>
    <span class="s5">'PyTreeDef'</span><span class="s4">,</span>
    <span class="s5">'PyTreeKind'</span><span class="s4">,</span>
    <span class="s5">'PyTree'</span><span class="s4">,</span>
    <span class="s5">'PyTreeTypeVar'</span><span class="s4">,</span>
    <span class="s5">'CustomTreeNode'</span><span class="s4">,</span>
    <span class="s5">'Children'</span><span class="s4">,</span>
    <span class="s5">'MetaData'</span><span class="s4">,</span>
    <span class="s5">'FlattenFunc'</span><span class="s4">,</span>
    <span class="s5">'UnflattenFunc'</span><span class="s4">,</span>
    <span class="s5">'PyTreeEntry'</span><span class="s4">,</span>
    <span class="s5">'GetItemEntry'</span><span class="s4">,</span>
    <span class="s5">'GetAttrEntry'</span><span class="s4">,</span>
    <span class="s5">'FlattenedEntry'</span><span class="s4">,</span>
    <span class="s5">'AutoEntry'</span><span class="s4">,</span>
    <span class="s5">'SequenceEntry'</span><span class="s4">,</span>
    <span class="s5">'MappingEntry'</span><span class="s4">,</span>
    <span class="s5">'NamedTupleEntry'</span><span class="s4">,</span>
    <span class="s5">'StructSequenceEntry'</span><span class="s4">,</span>
    <span class="s5">'DataclassEntry'</span><span class="s4">,</span>
    <span class="s5">'PyTreeAccessor'</span><span class="s4">,</span>
    <span class="s5">'is_namedtuple'</span><span class="s4">,</span>
    <span class="s5">'is_namedtuple_instance'</span><span class="s4">,</span>
    <span class="s5">'is_namedtuple_class'</span><span class="s4">,</span>
    <span class="s5">'namedtuple_fields'</span><span class="s4">,</span>
    <span class="s5">'is_structseq'</span><span class="s4">,</span>
    <span class="s5">'is_structseq_instance'</span><span class="s4">,</span>
    <span class="s5">'is_structseq_class'</span><span class="s4">,</span>
    <span class="s5">'structseq_fields'</span><span class="s4">,</span>
    <span class="s5">'T'</span><span class="s4">,</span>
    <span class="s5">'S'</span><span class="s4">,</span>
    <span class="s5">'U'</span><span class="s4">,</span>
    <span class="s5">'KT'</span><span class="s4">,</span>
    <span class="s5">'VT'</span><span class="s4">,</span>
    <span class="s5">'Iterable'</span><span class="s4">,</span>
    <span class="s5">'Sequence'</span><span class="s4">,</span>
    <span class="s5">'List'</span><span class="s4">,</span>
    <span class="s5">'Tuple'</span><span class="s4">,</span>
    <span class="s5">'NamedTuple'</span><span class="s4">,</span>
    <span class="s5">'Dict'</span><span class="s4">,</span>
    <span class="s5">'OrderedDict'</span><span class="s4">,</span>
    <span class="s5">'DefaultDict'</span><span class="s4">,</span>
    <span class="s5">'Deque'</span><span class="s4">,</span>
<span class="s4">]</span>


<span class="s1">PyTreeDef </span><span class="s4">= </span><span class="s1">PyTreeSpec  </span><span class="s0"># alias</span>

<span class="s1">T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'T'</span><span class="s4">)</span>
<span class="s1">S </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'S'</span><span class="s4">)</span>
<span class="s1">U </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'U'</span><span class="s4">)</span>
<span class="s1">KT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'KT'</span><span class="s4">)</span>
<span class="s1">VT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'VT'</span><span class="s4">)</span>


<span class="s1">Children</span><span class="s4">: </span><span class="s1">TypeAlias </span><span class="s4">= </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]</span>
<span class="s1">_MetaData </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'_MetaData'</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Hashable</span><span class="s4">)</span>
<span class="s1">MetaData</span><span class="s4">: </span><span class="s1">TypeAlias </span><span class="s4">= </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_MetaData</span><span class="s4">]</span>


<span class="s4">@</span><span class="s1">runtime_checkable</span>
<span class="s3">class </span><span class="s1">CustomTreeNode</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The abstract base class for custom pytree nodes.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">tree_flatten</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s4">(</span>
        <span class="s0"># Use `range(num_children)` as path entries</span>
        <span class="s1">tuple</span><span class="s4">[</span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">], </span><span class="s1">MetaData</span><span class="s4">]</span>
        <span class="s4">|</span>
        <span class="s0"># With optionally implemented path entries</span>
        <span class="s1">tuple</span><span class="s4">[</span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">], </span><span class="s1">MetaData</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] | </span><span class="s3">None</span><span class="s4">]</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Flatten the custom pytree node into children and auxiliary data.&quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">tree_unflatten</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">metadata</span><span class="s4">: </span><span class="s1">MetaData</span><span class="s4">, </span><span class="s1">children</span><span class="s4">: </span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]) </span><span class="s1">-&gt; CustomTreeNode</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Unflatten the children and auxiliary data into the custom pytree node.&quot;&quot;&quot;</span>


<span class="s1">_GenericAlias </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">str</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">_tp_cache</span><span class="s4">(</span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">functools  </span><span class="s0"># pylint: disable=import-outside-toplevel</span>

    <span class="s1">cached </span><span class="s4">= </span><span class="s1">functools</span><span class="s4">.</span><span class="s1">lru_cache</span><span class="s4">()(</span><span class="s1">func</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">functools</span><span class="s4">.</span><span class="s1">wraps</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">inner</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cached</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s0"># All real errors (not unhashable args) are raised below.</span>
            <span class="s3">return </span><span class="s1">func</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">inner</span>


<span class="s3">class </span><span class="s1">PyTree</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]):  </span><span class="s0"># pylint: disable=too-few-public-methods</span>
    <span class="s2">&quot;&quot;&quot;Generic PyTree type. 
 
    &gt;&gt;&gt; import torch 
    &gt;&gt;&gt; TensorTree = PyTree[torch.Tensor] 
    &gt;&gt;&gt; TensorTree  # doctest: +IGNORE_WHITESPACE 
    typing.Union[torch.Tensor, 
                 typing.Tuple[ForwardRef('PyTree[torch.Tensor]'), ...], 
                 typing.List[ForwardRef('PyTree[torch.Tensor]')], 
                 typing.Dict[typing.Any, ForwardRef('PyTree[torch.Tensor]')], 
                 typing.Deque[ForwardRef('PyTree[torch.Tensor]')], 
                 optree.typing.CustomTreeNode[ForwardRef('PyTree[torch.Tensor]')]] 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">_tp_cache</span>
    <span class="s3">def </span><span class="s1">__class_getitem__</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">item</span><span class="s4">: </span><span class="s1">T </span><span class="s4">| </span><span class="s1">tuple</span><span class="s4">[</span><span class="s1">T</span><span class="s4">] | </span><span class="s1">tuple</span><span class="s4">[</span><span class="s1">T</span><span class="s4">, </span><span class="s1">str </span><span class="s4">| </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; TypeAlias</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Instantiate a PyTree type with the given type.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">item</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">):</span>
            <span class="s1">item </span><span class="s4">= (</span><span class="s1">item</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">item</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">[...] only supports a tuple of 2 items, '</span>
                <span class="s5">f'a parameter and a string of type name, got </span><span class="s3">{</span><span class="s1">item</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s1">param</span><span class="s4">, </span><span class="s1">name </span><span class="s4">= </span><span class="s1">item</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">[...] only supports a tuple of 2 items, '</span>
                <span class="s5">f'a parameter and a string of type name, got </span><span class="s3">{</span><span class="s1">item</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">param</span><span class="s4">, </span><span class="s1">_GenericAlias</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">param</span><span class="s4">.</span><span class="s1">__origin__ </span><span class="s3">is </span><span class="s1">Union  </span><span class="s0"># type: ignore[attr-defined]</span>
            <span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">param</span><span class="s4">, </span><span class="s5">'__pytree_args__'</span><span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">param  </span><span class="s0"># PyTree[PyTree[T]] -&gt; PyTree[T]</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">recurse_ref </span><span class="s4">= </span><span class="s1">ForwardRef</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">param</span><span class="s4">, </span><span class="s1">TypeVar</span><span class="s4">):</span>
            <span class="s1">recurse_ref </span><span class="s4">= </span><span class="s1">ForwardRef</span><span class="s4">(</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">[</span><span class="s3">{</span><span class="s1">param</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">]'</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">param</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">param</span><span class="s4">.</span><span class="s1">__module__ </span><span class="s4">== </span><span class="s5">'builtins'</span><span class="s4">:</span>
                <span class="s1">typename </span><span class="s4">= </span><span class="s1">param</span><span class="s4">.</span><span class="s1">__qualname__</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">typename </span><span class="s4">= </span><span class="s5">f'</span><span class="s3">{</span><span class="s1">param</span><span class="s4">.</span><span class="s1">__module__</span><span class="s3">}</span><span class="s5">.</span><span class="s3">{</span><span class="s1">param</span><span class="s4">.</span><span class="s1">__qualname__</span><span class="s3">}</span><span class="s5">'</span>
                <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
                    <span class="s1">typename </span><span class="s4">= </span><span class="s5">f'</span><span class="s3">{</span><span class="s1">param</span><span class="s4">.</span><span class="s1">__module__</span><span class="s3">}</span><span class="s5">.</span><span class="s3">{</span><span class="s1">param</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">'</span>
            <span class="s1">recurse_ref </span><span class="s4">= </span><span class="s1">ForwardRef</span><span class="s4">(</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">[</span><span class="s3">{</span><span class="s1">typename</span><span class="s3">}</span><span class="s5">]'</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">recurse_ref </span><span class="s4">= </span><span class="s1">ForwardRef</span><span class="s4">(</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">[</span><span class="s3">{</span><span class="s1">param</span><span class="s3">!r}</span><span class="s5">]'</span><span class="s4">)</span>

        <span class="s1">pytree_alias </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">param</span><span class="s4">,  </span><span class="s0"># type: ignore[valid-type]</span>
            <span class="s1">Tuple</span><span class="s4">[</span><span class="s1">recurse_ref</span><span class="s4">, ...],  </span><span class="s0"># type: ignore[valid-type] # Tuple, NamedTuple, PyStructSequence</span>
            <span class="s1">List</span><span class="s4">[</span><span class="s1">recurse_ref</span><span class="s4">],  </span><span class="s0"># type: ignore[valid-type]</span>
            <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">recurse_ref</span><span class="s4">],  </span><span class="s0"># type: ignore[valid-type] # Dict, OrderedDict, DefaultDict</span>
            <span class="s1">Deque</span><span class="s4">[</span><span class="s1">recurse_ref</span><span class="s4">],  </span><span class="s0"># type: ignore[valid-type]</span>
            <span class="s1">CustomTreeNode</span><span class="s4">[</span><span class="s1">recurse_ref</span><span class="s4">],  </span><span class="s0"># type: ignore[valid-type]</span>
        <span class="s4">]</span>
        <span class="s1">pytree_alias</span><span class="s4">.</span><span class="s1">__pytree_args__ </span><span class="s4">= </span><span class="s1">item  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s3">return </span><span class="s1">pytree_alias</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:  </span><span class="s0"># pylint: disable=arguments-differ</span>
        <span class="s2">&quot;&quot;&quot;Prohibit instantiation.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Cannot instantiate special typing classes.'</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init_subclass__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Prohibit subclassing.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Cannot subclass special typing classes.'</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__copy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; PyTree</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Immutable copy.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__deepcopy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memo</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; PyTree</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Immutable copy.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">PyTreeTypeVar</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Type variable for PyTree. 
 
    &gt;&gt;&gt; import torch 
    &gt;&gt;&gt; TensorTree = PyTreeTypeVar('TensorTree', torch.Tensor) 
    &gt;&gt;&gt; TensorTree  # doctest: +IGNORE_WHITESPACE 
    typing.Union[torch.Tensor, 
                 typing.Tuple[ForwardRef('TensorTree'), ...], 
                 typing.List[ForwardRef('TensorTree')], 
                 typing.Dict[typing.Any, ForwardRef('TensorTree')], 
                 typing.Deque[ForwardRef('TensorTree')], 
                 optree.typing.CustomTreeNode[ForwardRef('TensorTree')]] 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">_tp_cache</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">param</span><span class="s4">: </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; TypeAlias</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Instantiate a PyTree type variable with the given name and parameter.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s5">only supports a string of type name, got </span><span class="s3">{</span><span class="s1">name</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">PyTree</span><span class="s4">[</span><span class="s1">param</span><span class="s4">, </span><span class="s1">name</span><span class="s4">]  </span><span class="s0"># type: ignore[misc,valid-type]</span>

    <span class="s3">def </span><span class="s1">__init_subclass__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Prohibit subclassing.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Cannot subclass special typing classes.'</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__copy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeAlias</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Immutable copy.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__deepcopy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memo</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; TypeAlias</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Immutable copy.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s1">FlattenFunc</span><span class="s4">: </span><span class="s1">TypeAlias </span><span class="s4">= </span><span class="s1">Callable</span><span class="s4">[</span>
    <span class="s4">[</span><span class="s1">CustomTreeNode</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]],</span>
    <span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">], </span><span class="s1">MetaData</span><span class="s4">],</span>
        <span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">], </span><span class="s1">MetaData</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]],</span>
    <span class="s4">],</span>
<span class="s4">]</span>
<span class="s1">UnflattenFunc</span><span class="s4">: </span><span class="s1">TypeAlias </span><span class="s4">= </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">MetaData</span><span class="s4">, </span><span class="s1">Children</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]], </span><span class="s1">CustomTreeNode</span><span class="s4">[</span><span class="s1">T</span><span class="s4">]]</span>


<span class="s3">def </span><span class="s1">is_namedtuple</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object </span><span class="s4">| </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the object is an instance of namedtuple or a subclass of namedtuple.&quot;&quot;&quot;</span>
    <span class="s1">cls </span><span class="s4">= </span><span class="s1">obj </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">else </span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">is_namedtuple_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_namedtuple_instance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the object is an instance of namedtuple.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">is_namedtuple_class</span><span class="s4">(</span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">is_namedtuple_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">: </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the class is a subclass of namedtuple.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s4">(</span>
        <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">type</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">issubclass</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'_fields'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">tuple</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">all</span><span class="s4">(</span>
            <span class="s1">type</span><span class="s4">(</span><span class="s1">field</span><span class="s4">) </span><span class="s3">is </span><span class="s1">str  </span><span class="s0"># pylint: disable=unidiomatic-typecheck</span>
            <span class="s3">for </span><span class="s1">field </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_fields  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s4">)</span>
        <span class="s3">and </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'_make'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">))</span>
        <span class="s3">and </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'_asdict'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">))</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">namedtuple_fields</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">tuple </span><span class="s4">| </span><span class="s1">type</span><span class="s4">[</span><span class="s1">tuple</span><span class="s4">]) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, ...]:</span>
    <span class="s2">&quot;&quot;&quot;Return the field names of a namedtuple.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
        <span class="s1">cls </span><span class="s4">= </span><span class="s1">obj</span>
        <span class="s3">if not </span><span class="s1">is_namedtuple_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'Expected a collections.namedtuple type, got </span><span class="s3">{</span><span class="s1">cls</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">cls </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">is_namedtuple_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'Expected an instance of collections.namedtuple type, got </span><span class="s3">{</span><span class="s1">obj</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_fields  </span><span class="s0"># type: ignore[attr-defined]</span>


<span class="s1">_T_co </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">'_T_co'</span><span class="s4">, </span><span class="s1">covariant</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">_StructSequenceMeta</span><span class="s4">(</span><span class="s1">type</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__subclasscheck__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">subclass</span><span class="s4">: </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether the class is a PyStructSequence type. 
 
        &gt;&gt;&gt; import time 
        &gt;&gt;&gt; issubclass(time.struct_time, structseq) 
        True 
        &gt;&gt;&gt; class MyTuple(tuple): 
        ...     n_fields = 2 
        ...     n_sequence_fields = 2 
        ...     n_unnamed_fields = 0 
        &gt;&gt;&gt; issubclass(MyTuple, structseq) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">subclass</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__instancecheck__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return whether the object is a PyStructSequence instance. 
 
        &gt;&gt;&gt; import sys 
        &gt;&gt;&gt; isinstance(sys.float_info, structseq) 
        True 
        &gt;&gt;&gt; isinstance((1, 2), structseq) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">is_structseq_instance</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>


<span class="s0"># Reference: https://github.com/python/typeshed/blob/main/stdlib/_typeshed/__init__.pyi</span>
<span class="s0"># This is an internal CPython type that is like, but subtly different from a NamedTuple.</span>
<span class="s0"># `structseq` classes are unsubclassable, so are all decorated with `@final`.</span>
<span class="s0"># pylint: disable-next=invalid-name,missing-class-docstring</span>
<span class="s3">class </span><span class="s1">structseq</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">_StructSequenceMeta</span><span class="s4">):  </span><span class="s0"># type: ignore[misc] # noqa: N801</span>
    <span class="s2">&quot;&quot;&quot;A generic type stub for CPython's ``PyStructSequence`` type.&quot;&quot;&quot;</span>

    <span class="s1">n_fields</span><span class="s4">: </span><span class="s1">Final</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]  </span><span class="s0"># type: ignore[misc] # pylint: disable=invalid-name</span>
    <span class="s1">n_sequence_fields</span><span class="s4">: </span><span class="s1">Final</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]  </span><span class="s0"># type: ignore[misc] # pylint: disable=invalid-name</span>
    <span class="s1">n_unnamed_fields</span><span class="s4">: </span><span class="s1">Final</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]  </span><span class="s0"># type: ignore[misc] # pylint: disable=invalid-name</span>

    <span class="s3">def </span><span class="s1">__init_subclass__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Prohibit subclassing.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;type 'structseq' is not an acceptable base type&quot;</span><span class="s4">)</span>

    <span class="s0"># pylint: disable-next=unused-argument,redefined-builtin</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">sequence</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">dict</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = ...) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">del </span><span class="s1">_StructSequenceMeta</span>


<span class="s3">def </span><span class="s1">is_structseq</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object </span><span class="s4">| </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the object is an instance of PyStructSequence or a class of PyStructSequence.&quot;&quot;&quot;</span>
    <span class="s1">cls </span><span class="s4">= </span><span class="s1">obj </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">else </span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_structseq_instance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the object is an instance of PyStructSequence.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">))</span>


<span class="s0"># Set if the type allows subclassing (see CPython's Include/object.h)</span>
<span class="s1">Py_TPFLAGS_BASETYPE</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s1">_C</span><span class="s4">.</span><span class="s1">Py_TPFLAGS_BASETYPE  </span><span class="s0"># (1UL &lt;&lt; 10)</span>


<span class="s3">def </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">: </span><span class="s1">type</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the class is a class of PyStructSequence.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">type</span><span class="s4">)</span>
        <span class="s0"># Check direct inheritance from `tuple` rather than `issubclass(cls, tuple)`</span>
        <span class="s3">and </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__bases__ </span><span class="s4">== (</span><span class="s1">tuple</span><span class="s4">,)</span>
        <span class="s0"># Check PyStructSequence members</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'n_fields'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">int</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'n_sequence_fields'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">int</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">'n_unnamed_fields'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">int</span><span class="s4">)</span>
    <span class="s4">):</span>
        <span class="s0"># Check the type does not allow subclassing</span>
        <span class="s3">if </span><span class="s1">platform</span><span class="s4">.</span><span class="s1">python_implementation</span><span class="s4">() == </span><span class="s5">'PyPy'</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s0"># pylint: disable-next=too-few-public-methods</span>
                <span class="s3">class </span><span class="s1">_</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):  </span><span class="s0"># noqa: N801</span>
                    <span class="s3">pass</span>

            <span class="s3">except </span><span class="s4">(</span><span class="s1">AssertionError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">):</span>
                <span class="s3">return True</span>
            <span class="s3">return False</span>
        <span class="s3">return not </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__flags__ </span><span class="s4">&amp; </span><span class="s1">Py_TPFLAGS_BASETYPE</span><span class="s4">)</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">structseq_fields</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">tuple </span><span class="s4">| </span><span class="s1">type</span><span class="s4">[</span><span class="s1">tuple</span><span class="s4">]) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, ...]:</span>
    <span class="s2">&quot;&quot;&quot;Return the field names of a PyStructSequence.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
        <span class="s1">cls </span><span class="s4">= </span><span class="s1">obj</span>
        <span class="s3">if not </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'Expected a PyStructSequence type, got </span><span class="s3">{</span><span class="s1">cls</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">cls </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">is_structseq_class</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'Expected an instance of PyStructSequence type, got </span><span class="s3">{</span><span class="s1">obj</span><span class="s3">!r}</span><span class="s5">.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">platform</span><span class="s4">.</span><span class="s1">python_implementation</span><span class="s4">() == </span><span class="s5">'PyPy'</span><span class="s4">:</span>
        <span class="s0"># pylint: disable-next=import-error,import-outside-toplevel</span>
        <span class="s3">from </span><span class="s1">_structseq </span><span class="s3">import </span><span class="s1">structseqfield</span>

        <span class="s1">indices_by_name </span><span class="s4">= {</span>
            <span class="s1">name</span><span class="s4">: </span><span class="s1">member</span><span class="s4">.</span><span class="s1">index</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">member </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">).</span><span class="s1">items</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">member</span><span class="s4">, </span><span class="s1">structseqfield</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s1">fields </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">indices_by_name</span><span class="s4">, </span><span class="s1">key</span><span class="s4">=</span><span class="s1">indices_by_name</span><span class="s4">.</span><span class="s1">get</span><span class="s4">)  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">fields </span><span class="s4">= [</span>
            <span class="s1">name</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">member </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">).</span><span class="s1">items</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">member</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">MemberDescriptorType</span><span class="s4">)</span>
        <span class="s4">]</span>
    <span class="s3">return </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">fields</span><span class="s4">[: </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">n_sequence_fields</span><span class="s4">])  </span><span class="s0"># type: ignore[attr-defined]</span>


<span class="s0"># Ensure that the behavior is consistent with C++ implementation</span>
<span class="s0"># pylint: disable-next=wrong-import-position,ungrouped-imports</span>
<span class="s3">from </span><span class="s1">optree</span><span class="s4">.</span><span class="s1">_C </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">is_namedtuple</span><span class="s4">,</span>
    <span class="s1">is_namedtuple_class</span><span class="s4">,</span>
    <span class="s1">is_namedtuple_instance</span><span class="s4">,</span>
    <span class="s1">is_structseq</span><span class="s4">,</span>
    <span class="s1">is_structseq_class</span><span class="s4">,</span>
    <span class="s1">is_structseq_instance</span><span class="s4">,</span>
    <span class="s1">namedtuple_fields</span><span class="s4">,</span>
    <span class="s1">structseq_fields</span><span class="s4">,</span>
<span class="s4">)</span>
</pre>
</body>
</html>