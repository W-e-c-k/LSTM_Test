<html>
<head>
<title>optree_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
optree_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">types</span>

<span class="s0">import </span><span class="s1">optree</span>
<span class="s0">import </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">utils</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">config </span><span class="s0">import </span><span class="s1">backend</span>


<span class="s0">def </span><span class="s1">register_tree_node_class</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">register_pytree_node_class</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">)</span>


<span class="s4"># Register backend-specific node classes</span>
<span class="s0">if </span><span class="s1">backend</span><span class="s2">() == </span><span class="s3">&quot;tensorflow&quot;</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">tensorflow</span><span class="s2">.</span><span class="s1">python</span><span class="s2">.</span><span class="s1">trackable</span><span class="s2">.</span><span class="s1">data_structures </span><span class="s0">import </span><span class="s1">ListWrapper</span>

    <span class="s1">optree</span><span class="s2">.</span><span class="s1">register_pytree_node</span><span class="s2">(</span>
        <span class="s1">ListWrapper</span><span class="s2">,</span>
        <span class="s0">lambda </span><span class="s1">x</span><span class="s2">: (</span><span class="s1">x</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
        <span class="s0">lambda </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">ListWrapper</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">children</span><span class="s2">)),</span>
        <span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">is_nested</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">):</span>
    <span class="s0">return not </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_is_leaf</span><span class="s2">(</span>
        <span class="s1">structure</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">traverse</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">structure</span><span class="s2">, </span><span class="s1">top_down</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s4"># From https://github.com/google/jax/pull/19695</span>
    <span class="s0">def </span><span class="s1">traverse_children</span><span class="s2">():</span>
        <span class="s1">children</span><span class="s2">, </span><span class="s1">treedef </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_flatten</span><span class="s2">(</span>
            <span class="s1">structure</span><span class="s2">,</span>
            <span class="s1">is_leaf</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">x </span><span class="s0">is not </span><span class="s1">structure</span><span class="s2">,</span>
            <span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">treedef</span><span class="s2">.</span><span class="s1">num_nodes </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">treedef</span><span class="s2">.</span><span class="s1">num_leaves </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">structure</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_unflatten</span><span class="s2">(</span>
                <span class="s1">treedef</span><span class="s2">,</span>
                <span class="s2">[</span><span class="s1">traverse</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">top_down</span><span class="s2">=</span><span class="s1">top_down</span><span class="s2">) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">children</span><span class="s2">],</span>
            <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">top_down</span><span class="s2">:</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">ret </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">traverse_children</span><span class="s2">()</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">traversed_structure </span><span class="s2">= </span><span class="s1">traverse_children</span><span class="s2">()</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">traversed_structure</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">ret </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">traversed_structure</span>
    <span class="s0">return None if </span><span class="s1">ret </span><span class="s0">is </span><span class="s1">_MAP_TO_NONE </span><span class="s0">else </span><span class="s1">ret</span>


<span class="s0">def </span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">):</span>
    <span class="s4"># optree.tree_flatten returns a pair (leaves, treespec) where the first</span>
    <span class="s4"># element is a list of leaf values and the second element is a treespec</span>
    <span class="s4"># representing the structure of the pytree.</span>
    <span class="s1">leaves</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_flatten</span><span class="s2">(</span>
        <span class="s1">structure</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">leaves</span>


<span class="s0">def </span><span class="s1">map_structure</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, *</span><span class="s1">structures</span><span class="s2">):</span>
    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">f&quot;`func` must be callable. Received: func=</span><span class="s0">{</span><span class="s1">func</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">structures</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Must provide at least one structure&quot;</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">other </span><span class="s0">in </span><span class="s1">structures</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]:</span>
        <span class="s1">assert_same_structure</span><span class="s2">(</span><span class="s1">structures</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">other</span><span class="s2">, </span><span class="s1">check_types</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_map</span><span class="s2">(</span>
        <span class="s1">func</span><span class="s2">, *</span><span class="s1">structures</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">map_structure_up_to</span><span class="s2">(</span><span class="s1">shallow_structure</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">structures</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">_map_structure_with_path_up_to</span><span class="s2">(</span>
        <span class="s1">shallow_structure</span><span class="s2">,</span>
        <span class="s0">lambda </span><span class="s1">_</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">: </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">),  </span><span class="s4"># Discards path.</span>
        <span class="s2">*</span><span class="s1">structures</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">assert_same_structure</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">check_types</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s1">a_structure </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_structure</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">)</span>
    <span class="s1">b_structure </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_structure</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">a_structure </span><span class="s2">!= </span><span class="s1">b_structure</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;`a` and `b` don't have the same structure. &quot;</span>
            <span class="s3">f&quot;Received: structure of a=</span><span class="s0">{</span><span class="s1">a_structure</span><span class="s0">}</span><span class="s3">, &quot;</span>
            <span class="s3">f&quot;structure of b=</span><span class="s0">{</span><span class="s1">b_structure</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">check_types</span><span class="s2">:</span>
        <span class="s1">type_structure </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_map</span><span class="s2">(</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">: </span><span class="s1">type</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">is </span><span class="s1">type</span><span class="s2">(</span><span class="s1">y</span><span class="s2">),</span>
            <span class="s1">a</span><span class="s2">,</span>
            <span class="s1">b</span><span class="s2">,</span>
            <span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_all</span><span class="s2">(</span>
            <span class="s1">type_structure</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span>
        <span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s3">&quot;The type of the leaves of `a` and `b` doesn't match.&quot;</span>
            <span class="s2">)</span>


<span class="s0">def </span><span class="s1">pack_sequence_as</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">, </span><span class="s1">flat_sequence</span><span class="s2">, </span><span class="s1">sequence_fn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">sequence_fn </span><span class="s2">= </span><span class="s1">sequence_fn </span><span class="s0">or </span><span class="s1">_sequence_like</span>

    <span class="s0">def </span><span class="s1">truncate</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">length</span><span class="s2">):</span>
        <span class="s1">value_str </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">value_str</span><span class="s2">[:</span><span class="s1">length</span><span class="s2">] + (</span><span class="s1">value_str</span><span class="s2">[</span><span class="s1">length</span><span class="s2">:] </span><span class="s0">and </span><span class="s3">&quot;...&quot;</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">is_nested</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
            <span class="s3">&quot;Attempted to pack value:</span><span class="s0">\n  </span><span class="s3">{}</span><span class="s0">\n</span><span class="s3">into a structure, but found &quot;</span>
            <span class="s3">&quot;incompatible type `{}` instead.&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                <span class="s1">truncate</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">, </span><span class="s5">100</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">is_nested</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">) != </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;The target structure is of type `{}`</span><span class="s0">\n  </span><span class="s3">{}</span><span class="s0">\n</span><span class="s3">However the input &quot;</span>
                <span class="s3">&quot;is a sequence ({}) of length {}.</span><span class="s0">\n  </span><span class="s3">{}</span><span class="s0">\n</span><span class="s3">nest cannot &quot;</span>
                <span class="s3">&quot;guarantee that it is safe to map one to the other.&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                    <span class="s1">type</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">),</span>
                    <span class="s1">truncate</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">, </span><span class="s5">100</span><span class="s2">),</span>
                    <span class="s1">type</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">),</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">),</span>
                    <span class="s1">truncate</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">, </span><span class="s5">100</span><span class="s2">),</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">flat_sequence</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">final_index</span><span class="s2">, </span><span class="s1">packed </span><span class="s2">= </span><span class="s1">_packed_nest_with_indices</span><span class="s2">(</span>
            <span class="s1">structure</span><span class="s2">, </span><span class="s1">flat_sequence</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">sequence_fn</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">final_index </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">IndexError</span>
    <span class="s0">except </span><span class="s1">IndexError</span><span class="s2">:</span>
        <span class="s1">flat_structure </span><span class="s2">= </span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_structure</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">):</span>
            <span class="s4"># pylint: disable=raise-missing-from</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Could not pack sequence. &quot;</span>
                <span class="s3">f&quot;Structure had </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_structure</span><span class="s2">)</span><span class="s0">} </span><span class="s3">atoms, but &quot;</span>
                <span class="s3">f&quot;flat_sequence had </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">flat_sequence</span><span class="s2">)</span><span class="s0">} </span><span class="s3">items. &quot;</span>
                <span class="s3">f&quot;Structure: </span><span class="s0">{</span><span class="s1">structure</span><span class="s0">}</span><span class="s3">, flat_sequence: </span><span class="s0">{</span><span class="s1">flat_sequence</span><span class="s0">}</span><span class="s3">.&quot;</span>
            <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">sequence_fn</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">, </span><span class="s1">packed</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">lists_to_tuples</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">sequence_fn</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">_sequence_like</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">pack_sequence_as</span><span class="s2">(</span>
        <span class="s1">structure</span><span class="s2">, </span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">), </span><span class="s1">sequence_fn</span><span class="s2">=</span><span class="s1">sequence_fn</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">map_shape_structure</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">structure</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">is_shape_tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">all</span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">e</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">))) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">x</span>
        <span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">f&quot;`func` must be callable. Received: func=</span><span class="s0">{</span><span class="s1">func</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_map</span><span class="s2">(</span>
        <span class="s1">func</span><span class="s2">,</span>
        <span class="s1">structure</span><span class="s2">,</span>
        <span class="s1">is_leaf</span><span class="s2">=</span><span class="s1">is_shape_tuple</span><span class="s2">,</span>
        <span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">_MapToNone</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot;A special object used as a sentinel within `traverse`.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s3">&quot;keras.utils.tree._MAP_TO_NONE&quot;</span>


<span class="s1">_MAP_TO_NONE </span><span class="s2">= </span><span class="s1">_MapToNone</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_yield_flat_up_to</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">, </span><span class="s1">input_tree</span><span class="s2">, </span><span class="s1">path</span><span class="s2">=()):</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">, (</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">)) </span><span class="s0">or not </span><span class="s2">(</span>
        <span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">shallow_tree</span><span class="s2">, (</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">or </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">is_namedtuple</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">)</span>
    <span class="s2">):</span>
        <span class="s0">yield </span><span class="s2">(</span><span class="s1">path</span><span class="s2">, </span><span class="s1">input_tree</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">input_tree </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">_yield_sorted_items</span><span class="s2">(</span><span class="s1">input_tree</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">shallow_key</span><span class="s2">, </span><span class="s1">shallow_subtree </span><span class="s0">in </span><span class="s1">_yield_sorted_items</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">):</span>
            <span class="s1">subpath </span><span class="s2">= </span><span class="s1">path </span><span class="s2">+ (</span><span class="s1">shallow_key</span><span class="s2">,)</span>
            <span class="s1">input_subtree </span><span class="s2">= </span><span class="s1">input_tree</span><span class="s2">[</span><span class="s1">shallow_key</span><span class="s2">]</span>
            <span class="s0">for </span><span class="s1">leaf_path</span><span class="s2">, </span><span class="s1">leaf_value </span><span class="s0">in </span><span class="s1">_yield_flat_up_to</span><span class="s2">(</span>
                <span class="s1">shallow_subtree</span><span class="s2">, </span><span class="s1">input_subtree</span><span class="s2">, </span><span class="s1">path</span><span class="s2">=</span><span class="s1">subpath</span>
            <span class="s2">):</span>
                <span class="s0">yield </span><span class="s2">(</span><span class="s1">leaf_path</span><span class="s2">, </span><span class="s1">leaf_value</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_multiyield_flat_up_to</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">, *</span><span class="s1">input_trees</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Same as `_yield_flat_up_to`, but takes multiple input trees.&quot;&quot;&quot;</span>
    <span class="s1">zipped_iterators </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span>
        <span class="s2">*[</span>
            <span class="s1">_yield_flat_up_to</span><span class="s2">(</span><span class="s1">shallow_tree</span><span class="s2">, </span><span class="s1">input_tree</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">input_tree </span><span class="s0">in </span><span class="s1">input_trees</span>
        <span class="s2">]</span>
    <span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">paths_and_values </span><span class="s0">in </span><span class="s1">zipped_iterators</span><span class="s2">:</span>
            <span class="s1">paths</span><span class="s2">, </span><span class="s1">values </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">paths_and_values</span><span class="s2">)</span>
            <span class="s0">yield </span><span class="s1">paths</span><span class="s2">[:</span><span class="s5">1</span><span class="s2">] + </span><span class="s1">values</span>
    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">paths </span><span class="s2">= </span><span class="s1">locals</span><span class="s2">().</span><span class="s1">get</span><span class="s2">(</span><span class="s3">&quot;paths&quot;</span><span class="s2">, ((),))</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">f&quot;Could not find key '</span><span class="s0">{</span><span class="s1">e</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s0">}</span><span class="s3">' in some `input_trees`. &quot;</span>
            <span class="s3">&quot;Please ensure the structure of all `input_trees` are &quot;</span>
            <span class="s3">&quot;compatible with `shallow_tree`. The last valid path &quot;</span>
            <span class="s3">f&quot;yielded was </span><span class="s0">{</span><span class="s1">paths</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s0">}</span><span class="s3">.&quot;</span>
        <span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>


<span class="s0">def </span><span class="s1">_map_structure_with_path_up_to</span><span class="s2">(</span><span class="s1">shallow_structure</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">structures</span><span class="s2">):</span>
    <span class="s1">results </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">path_and_values </span><span class="s0">in </span><span class="s1">_multiyield_flat_up_to</span><span class="s2">(</span>
        <span class="s1">shallow_structure</span><span class="s2">, *</span><span class="s1">structures</span>
    <span class="s2">):</span>
        <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(*</span><span class="s1">path_and_values</span><span class="s2">))</span>
    <span class="s1">shallow_structure_spec </span><span class="s2">= </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">tree_structure</span><span class="s2">(</span>
        <span class="s1">shallow_structure</span><span class="s2">, </span><span class="s1">none_is_leaf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">=</span><span class="s3">&quot;keras&quot;</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">shallow_structure_spec</span><span class="s2">.</span><span class="s1">unflatten</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_sequence_like</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s4"># TODO: Support attrs library</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, (</span><span class="s1">dict</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">)):</span>
        <span class="s4"># Pack dictionaries in a deterministic order by sorting the keys.</span>
        <span class="s4"># Notice this means that we ignore the original order of `OrderedDict`</span>
        <span class="s4"># instances. This is intentional, to avoid potential bugs caused by</span>
        <span class="s4"># mixing ordered and plain dicts (e.g., flattening a dict but using a</span>
        <span class="s4"># corresponding `OrderedDict` to pack it back).</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">), </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">keys_and_values </span><span class="s2">= ((</span><span class="s1">key</span><span class="s2">, </span><span class="s1">result</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]) </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">instance</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">defaultdict</span><span class="s2">):</span>
            <span class="s4"># `defaultdict` requires a default factory as the first argument.</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)(</span><span class="s1">instance</span><span class="s2">.</span><span class="s1">default_factory</span><span class="s2">, </span><span class="s1">keys_and_values</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">MappingProxyType</span><span class="s2">):</span>
            <span class="s4"># MappingProxyType requires a dict to proxy to.</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)(</span><span class="s1">dict</span><span class="s2">(</span><span class="s1">keys_and_values</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)(</span><span class="s1">keys_and_values</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">MappingView</span><span class="s2">):</span>
        <span class="s4"># We can't directly construct mapping views, so we create a list instead</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">is_namedtuple</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">):</span>
        <span class="s1">instance_type </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">instance_type</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s3">f&quot;Couldn't traverse </span><span class="s0">{</span><span class="s1">instance</span><span class="s0">!r} </span><span class="s3">with arguments </span><span class="s0">{</span><span class="s1">args</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s4"># Not a namedtuple</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)(</span><span class="s1">args</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_yield_sorted_items</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
    <span class="s4"># TODO: Support attrs library</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">):</span>
        <span class="s4"># Iterate through dictionaries in a deterministic order by sorting the</span>
        <span class="s4"># keys. Notice this means that we ignore the original order of</span>
        <span class="s4"># `OrderedDict` instances. This is intentional, to avoid potential bugs</span>
        <span class="s4"># caused by mixing ordered and plain dicts (e.g., flattening a dict but</span>
        <span class="s4"># using a corresponding `OrderedDict` to pack it back).</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
            <span class="s0">yield </span><span class="s1">key</span><span class="s2">, </span><span class="s1">iterable</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
    <span class="s0">elif </span><span class="s1">optree</span><span class="s2">.</span><span class="s1">is_namedtuple</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">iterable</span><span class="s2">.</span><span class="s1">_fields</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s2">(</span><span class="s1">field</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">field</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
            <span class="s0">yield </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">_yield_value</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
    <span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">_yield_sorted_items</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">):</span>
        <span class="s0">yield </span><span class="s1">v</span>


<span class="s0">def </span><span class="s1">_packed_nest_with_indices</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">, </span><span class="s1">flat</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">sequence_fn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">packed </span><span class="s2">= []</span>
    <span class="s1">sequence_fn </span><span class="s2">= </span><span class="s1">sequence_fn </span><span class="s0">or </span><span class="s1">_sequence_like</span>
    <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">_yield_value</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">is_nested</span><span class="s2">(</span><span class="s1">s</span><span class="s2">):</span>
            <span class="s1">new_index</span><span class="s2">, </span><span class="s1">child </span><span class="s2">= </span><span class="s1">_packed_nest_with_indices</span><span class="s2">(</span>
                <span class="s1">s</span><span class="s2">, </span><span class="s1">flat</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">sequence_fn</span>
            <span class="s2">)</span>
            <span class="s1">packed</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sequence_fn</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">child</span><span class="s2">))</span>
            <span class="s1">index </span><span class="s2">= </span><span class="s1">new_index</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">packed</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">flat</span><span class="s2">[</span><span class="s1">index</span><span class="s2">])</span>
            <span class="s1">index </span><span class="s2">+= </span><span class="s5">1</span>
    <span class="s0">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">packed</span>
</pre>
</body>
</html>