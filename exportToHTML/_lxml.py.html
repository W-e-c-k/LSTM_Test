<html>
<head>
<title>_lxml.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_lxml.py</font>
</center></td></tr></table>
<pre><span class="s0"># Use of this source code is governed by the MIT license.</span>
<span class="s1">__license__ </span><span class="s2">= </span><span class="s3">&quot;MIT&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3">'LXMLTreeBuilderForXML'</span><span class="s2">,</span>
    <span class="s3">'LXMLTreeBuilder'</span><span class="s2">,</span>
    <span class="s2">]</span>

<span class="s4">try</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s4">import </span><span class="s1">Callable </span><span class="s0"># Python 3.6</span>
<span class="s4">except </span><span class="s1">ImportError </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">collections </span><span class="s4">import </span><span class="s1">Callable</span>

<span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>
<span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">StringIO</span>
<span class="s4">from </span><span class="s1">lxml </span><span class="s4">import </span><span class="s1">etree</span>
<span class="s4">from </span><span class="s1">bs4</span><span class="s2">.</span><span class="s1">element </span><span class="s4">import </span><span class="s2">(</span>
    <span class="s1">Comment</span><span class="s2">,</span>
    <span class="s1">Doctype</span><span class="s2">,</span>
    <span class="s1">NamespacedAttribute</span><span class="s2">,</span>
    <span class="s1">ProcessingInstruction</span><span class="s2">,</span>
    <span class="s1">XMLProcessingInstruction</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s4">from </span><span class="s1">bs4</span><span class="s2">.</span><span class="s1">builder </span><span class="s4">import </span><span class="s2">(</span>
    <span class="s1">DetectsXMLParsedAsHTML</span><span class="s2">,</span>
    <span class="s1">FAST</span><span class="s2">,</span>
    <span class="s1">HTML</span><span class="s2">,</span>
    <span class="s1">HTMLTreeBuilder</span><span class="s2">,</span>
    <span class="s1">PERMISSIVE</span><span class="s2">,</span>
    <span class="s1">ParserRejectedMarkup</span><span class="s2">,</span>
    <span class="s1">TreeBuilder</span><span class="s2">,</span>
    <span class="s1">XML</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">bs4</span><span class="s2">.</span><span class="s1">dammit </span><span class="s4">import </span><span class="s1">EncodingDetector</span>

<span class="s1">LXML </span><span class="s2">= </span><span class="s3">'lxml'</span>

<span class="s4">def </span><span class="s1">_invert</span><span class="s2">(</span><span class="s1">d</span><span class="s2">):</span>
    <span class="s5">&quot;Invert a dictionary.&quot;</span>
    <span class="s4">return </span><span class="s1">dict</span><span class="s2">((</span><span class="s1">v</span><span class="s2">,</span><span class="s1">k</span><span class="s2">) </span><span class="s4">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">d</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>

<span class="s4">class </span><span class="s1">LXMLTreeBuilderForXML</span><span class="s2">(</span><span class="s1">TreeBuilder</span><span class="s2">):</span>
    <span class="s1">DEFAULT_PARSER_CLASS </span><span class="s2">= </span><span class="s1">etree</span><span class="s2">.</span><span class="s1">XMLParser</span>

    <span class="s1">is_xml </span><span class="s2">= </span><span class="s4">True</span>
    <span class="s1">processing_instruction_class </span><span class="s2">= </span><span class="s1">XMLProcessingInstruction</span>

    <span class="s1">NAME </span><span class="s2">= </span><span class="s3">&quot;lxml-xml&quot;</span>
    <span class="s1">ALTERNATE_NAMES </span><span class="s2">= [</span><span class="s3">&quot;xml&quot;</span><span class="s2">]</span>

    <span class="s0"># Well, it's permissive by XML parser standards.</span>
    <span class="s1">features </span><span class="s2">= [</span><span class="s1">NAME</span><span class="s2">, </span><span class="s1">LXML</span><span class="s2">, </span><span class="s1">XML</span><span class="s2">, </span><span class="s1">FAST</span><span class="s2">, </span><span class="s1">PERMISSIVE</span><span class="s2">]</span>

    <span class="s1">CHUNK_SIZE </span><span class="s2">= </span><span class="s6">512</span>

    <span class="s0"># This namespace mapping is specified in the XML Namespace</span>
    <span class="s0"># standard.</span>
    <span class="s1">DEFAULT_NSMAPS </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">xml</span><span class="s2">=</span><span class="s3">'http://www.w3.org/XML/1998/namespace'</span><span class="s2">)</span>

    <span class="s1">DEFAULT_NSMAPS_INVERTED </span><span class="s2">= </span><span class="s1">_invert</span><span class="s2">(</span><span class="s1">DEFAULT_NSMAPS</span><span class="s2">)</span>

    <span class="s0"># NOTE: If we parsed Element objects and looked at .sourceline,</span>
    <span class="s0"># we'd be able to see the line numbers from the original document.</span>
    <span class="s0"># But instead we build an XMLParser or HTMLParser object to serve</span>
    <span class="s0"># as the target of parse messages, and those messages don't include</span>
    <span class="s0"># line numbers.</span>
    <span class="s0"># See: https://bugs.launchpad.net/lxml/+bug/1846906</span>
    
    <span class="s4">def </span><span class="s1">initialize_soup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">soup</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Let the BeautifulSoup object know about the standard namespace 
        mapping. 
 
        :param soup: A `BeautifulSoup`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">LXMLTreeBuilderForXML</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">initialize_soup</span><span class="s2">(</span><span class="s1">soup</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_register_namespaces</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">DEFAULT_NSMAPS</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_register_namespaces</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Let the BeautifulSoup object know about namespaces encountered 
        while parsing the document. 
 
        This might be useful later on when creating CSS selectors. 
 
        This will track (almost) all namespaces, even ones that were 
        only in scope for part of the document. If two namespaces have 
        the same prefix, only the first one encountered will be 
        tracked. Un-prefixed namespaces are not tracked. 
 
        :param mapping: A dictionary mapping namespace prefixes to URIs. 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
            <span class="s0"># This is 'if key' and not 'if key is not None' because we</span>
            <span class="s0"># don't track un-prefixed namespaces. Soupselect will</span>
            <span class="s0"># treat an un-prefixed namespace as the default, which</span>
            <span class="s0"># causes confusion in some cases.</span>
            <span class="s4">if </span><span class="s1">key </span><span class="s4">and </span><span class="s1">key </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">_namespaces</span><span class="s2">:</span>
                <span class="s0"># Let the BeautifulSoup object know about a new namespace.</span>
                <span class="s0"># If there are multiple namespaces defined with the same</span>
                <span class="s0"># prefix, the first one in the document takes precedence.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">_namespaces</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">value</span>
                
    <span class="s4">def </span><span class="s1">default_parser</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Find the default parser for the given encoding. 
 
        :param encoding: A string. 
        :return: Either a parser object or a class, which 
          will be instantiated with default arguments. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_default_parser </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_default_parser</span>
        <span class="s4">return </span><span class="s1">etree</span><span class="s2">.</span><span class="s1">XMLParser</span><span class="s2">(</span>
            <span class="s1">target</span><span class="s2">=</span><span class="s1">self</span><span class="s2">, </span><span class="s1">strip_cdata</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">recover</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">=</span><span class="s1">encoding</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">parser_for</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Instantiate an appropriate parser for the given encoding. 
 
        :param encoding: A string. 
        :return: A parser object such as an `etree.XMLParser`. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Use the default parser.</span>
        <span class="s1">parser </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">default_parser</span><span class="s2">(</span><span class="s1">encoding</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parser</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">):</span>
            <span class="s0"># Instantiate the parser with default arguments</span>
            <span class="s1">parser </span><span class="s2">= </span><span class="s1">parser</span><span class="s2">(</span>
                <span class="s1">target</span><span class="s2">=</span><span class="s1">self</span><span class="s2">, </span><span class="s1">strip_cdata</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">recover</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">=</span><span class="s1">encoding</span>
            <span class="s2">)</span>
        <span class="s4">return </span><span class="s1">parser</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">empty_element_tags</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0"># TODO: Issue a warning if parser is present but not a</span>
        <span class="s0"># callable, since that means there's no way to create new</span>
        <span class="s0"># parsers for different encodings.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_default_parser </span><span class="s2">= </span><span class="s1">parser</span>
        <span class="s4">if </span><span class="s1">empty_element_tags </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">empty_element_tags </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">empty_element_tags</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">DEFAULT_NSMAPS_INVERTED</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">active_namespace_prefixes </span><span class="s2">= [</span><span class="s1">dict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">DEFAULT_NSMAPS</span><span class="s2">)]</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">LXMLTreeBuilderForXML</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        
    <span class="s4">def </span><span class="s1">_getNsTag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">):</span>
        <span class="s0"># Split the namespace URL out of a fully-qualified lxml tag</span>
        <span class="s0"># name. Copied from lxml's src/lxml/sax.py.</span>
        <span class="s4">if </span><span class="s1">tag</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s3">'{'</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">tag</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:].</span><span class="s1">split</span><span class="s2">(</span><span class="s3">'}'</span><span class="s2">, </span><span class="s6">1</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">prepare_markup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">markup</span><span class="s2">, </span><span class="s1">user_specified_encoding</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">exclude_encodings</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">document_declared_encoding</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Run any preliminary steps necessary to make incoming markup 
        acceptable to the parser. 
 
        lxml really wants to get a bytestring and convert it to 
        Unicode itself. So instead of using UnicodeDammit to convert 
        the bytestring to Unicode using different encodings, this 
        implementation uses EncodingDetector to iterate over the 
        encodings, and tell lxml to try to parse the document as each 
        one in turn. 
 
        :param markup: Some markup -- hopefully a bytestring. 
        :param user_specified_encoding: The user asked to try this encoding. 
        :param document_declared_encoding: The markup itself claims to be 
            in this encoding. 
        :param exclude_encodings: The user asked _not_ to try any of 
            these encodings. 
 
        :yield: A series of 4-tuples: 
         (markup, encoding, declared encoding, 
          has undergone character replacement) 
 
         Each 4-tuple represents a strategy for converting the 
         document to Unicode and parsing it. Each strategy will be tried  
         in turn. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_html </span><span class="s2">= </span><span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_xml</span>
        <span class="s4">if </span><span class="s1">is_html</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">processing_instruction_class </span><span class="s2">= </span><span class="s1">ProcessingInstruction</span>
            <span class="s0"># We're in HTML mode, so if we're given XML, that's worth</span>
            <span class="s0"># noting.</span>
            <span class="s1">DetectsXMLParsedAsHTML</span><span class="s2">.</span><span class="s1">warn_if_markup_looks_like_xml</span><span class="s2">(</span>
                <span class="s1">markup</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span>
            <span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">processing_instruction_class </span><span class="s2">= </span><span class="s1">XMLProcessingInstruction</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0"># We were given Unicode. Maybe lxml can parse Unicode on</span>
            <span class="s0"># this system?</span>

            <span class="s0"># TODO: This is a workaround for</span>
            <span class="s0"># https://bugs.launchpad.net/lxml/+bug/1948551.</span>
            <span class="s0"># We can remove it once the upstream issue is fixed.</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">) &gt; </span><span class="s6">0 </span><span class="s4">and </span><span class="s1">markup</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s3">u'</span><span class="s4">\N{BYTE ORDER MARK}</span><span class="s3">'</span><span class="s2">:</span>
                <span class="s1">markup </span><span class="s2">= </span><span class="s1">markup</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]</span>
            <span class="s4">yield </span><span class="s1">markup</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s1">document_declared_encoding</span><span class="s2">, </span><span class="s4">False</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0"># No, apparently not. Convert the Unicode to UTF-8 and</span>
            <span class="s0"># tell lxml to parse it as UTF-8.</span>
            <span class="s4">yield </span><span class="s2">(</span><span class="s1">markup</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s3">&quot;utf8&quot;</span><span class="s2">), </span><span class="s3">&quot;utf8&quot;</span><span class="s2">,</span>
                   <span class="s1">document_declared_encoding</span><span class="s2">, </span><span class="s4">False</span><span class="s2">)</span>

        <span class="s0"># This was provided by the end-user; treat it as a known</span>
        <span class="s0"># definite encoding per the algorithm laid out in the HTML5</span>
        <span class="s0"># spec.  (See the EncodingDetector class for details.)</span>
        <span class="s1">known_definite_encodings </span><span class="s2">= [</span><span class="s1">user_specified_encoding</span><span class="s2">]</span>

        <span class="s0"># This was found in the document; treat it as a slightly lower-priority</span>
        <span class="s0"># user encoding.</span>
        <span class="s1">user_encodings </span><span class="s2">= [</span><span class="s1">document_declared_encoding</span><span class="s2">]</span>
        <span class="s1">detector </span><span class="s2">= </span><span class="s1">EncodingDetector</span><span class="s2">(</span>
            <span class="s1">markup</span><span class="s2">, </span><span class="s1">known_definite_encodings</span><span class="s2">=</span><span class="s1">known_definite_encodings</span><span class="s2">,</span>
            <span class="s1">user_encodings</span><span class="s2">=</span><span class="s1">user_encodings</span><span class="s2">, </span><span class="s1">is_html</span><span class="s2">=</span><span class="s1">is_html</span><span class="s2">,</span>
            <span class="s1">exclude_encodings</span><span class="s2">=</span><span class="s1">exclude_encodings</span>
        <span class="s2">)</span>
        <span class="s4">for </span><span class="s1">encoding </span><span class="s4">in </span><span class="s1">detector</span><span class="s2">.</span><span class="s1">encodings</span><span class="s2">:</span>
            <span class="s4">yield </span><span class="s2">(</span><span class="s1">detector</span><span class="s2">.</span><span class="s1">markup</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">document_declared_encoding</span><span class="s2">, </span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">feed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">markup</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">):</span>
            <span class="s1">markup </span><span class="s2">= </span><span class="s1">BytesIO</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">markup </span><span class="s2">= </span><span class="s1">StringIO</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">)</span>

        <span class="s0"># Call feed() at least once, even if the markup is empty,</span>
        <span class="s0"># or the parser won't be initialized.</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">markup</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">CHUNK_SIZE</span><span class="s2">)</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parser_for</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">original_encoding</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser</span><span class="s2">.</span><span class="s1">feed</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s4">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) != </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0"># Now call feed() on the rest of the data, chunk by chunk.</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">markup</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">CHUNK_SIZE</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) != </span><span class="s6">0</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">parser</span><span class="s2">.</span><span class="s1">feed</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s4">except </span><span class="s2">(</span><span class="s1">UnicodeDecodeError</span><span class="s2">, </span><span class="s1">LookupError</span><span class="s2">, </span><span class="s1">etree</span><span class="s2">.</span><span class="s1">ParserError</span><span class="s2">) </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ParserRejectedMarkup</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">close</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">DEFAULT_NSMAPS_INVERTED</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">start</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">nsmap</span><span class="s2">={}):</span>
        <span class="s0"># Make sure attrs is a mutable dict--lxml may send an immutable dictproxy.</span>
        <span class="s1">attrs </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">)</span>
        <span class="s1">nsprefix </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s0"># Invert each namespace map as it comes in.</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">) == </span><span class="s6">0 </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0"># There are no new namespaces for this tag, but</span>
                <span class="s0"># non-default namespaces are in play, so we need a</span>
                <span class="s0"># separate tag stack to know when they end.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">None</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">) &gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0"># A new namespace mapping has come into play.</span>

            <span class="s0"># First, Let the BeautifulSoup object know about it.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_register_namespaces</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">)</span>

            <span class="s0"># Then, add it to our running list of inverted namespace</span>
            <span class="s0"># mappings.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_invert</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">))</span>

            <span class="s0"># The currently active namespace prefixes have</span>
            <span class="s0"># changed. Calculate the new mapping so it can be stored</span>
            <span class="s0"># with all Tag objects created while these prefixes are in</span>
            <span class="s0"># scope.</span>
            <span class="s1">current_mapping </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">active_namespace_prefixes</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">])</span>
            <span class="s1">current_mapping</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">)</span>

            <span class="s0"># We should not track un-prefixed namespaces as we can only hold one</span>
            <span class="s0"># and it will be recognized as the default namespace by soupsieve,</span>
            <span class="s0"># which may be confusing in some situations.</span>
            <span class="s4">if </span><span class="s3">'' </span><span class="s4">in </span><span class="s1">current_mapping</span><span class="s2">:</span>
                <span class="s4">del </span><span class="s1">current_mapping</span><span class="s2">[</span><span class="s3">''</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">active_namespace_prefixes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">current_mapping</span><span class="s2">)</span>
            
            <span class="s0"># Also treat the namespace mapping as a set of attributes on the</span>
            <span class="s0"># tag, so we can recreate it later.</span>
            <span class="s1">attrs </span><span class="s2">= </span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s4">for </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">namespace </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">nsmap</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
                <span class="s1">attribute </span><span class="s2">= </span><span class="s1">NamespacedAttribute</span><span class="s2">(</span>
                    <span class="s3">&quot;xmlns&quot;</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s3">&quot;http://www.w3.org/2000/xmlns/&quot;</span><span class="s2">)</span>
                <span class="s1">attrs</span><span class="s2">[</span><span class="s1">attribute</span><span class="s2">] = </span><span class="s1">namespace</span>

        <span class="s0"># Namespaces are in play. Find any attributes that came in</span>
        <span class="s0"># from lxml with namespaces attached to their names, and</span>
        <span class="s0"># turn then into NamespacedAttribute objects.</span>
        <span class="s1">new_attrs </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
            <span class="s1">namespace</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getNsTag</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">namespace </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">new_attrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">] = </span><span class="s1">value</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">nsprefix </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_prefix_for_namespace</span><span class="s2">(</span><span class="s1">namespace</span><span class="s2">)</span>
                <span class="s1">attr </span><span class="s2">= </span><span class="s1">NamespacedAttribute</span><span class="s2">(</span><span class="s1">nsprefix</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">)</span>
                <span class="s1">new_attrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s1">attrs </span><span class="s2">= </span><span class="s1">new_attrs</span>

        <span class="s1">namespace</span><span class="s2">, </span><span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getNsTag</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">nsprefix </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_prefix_for_namespace</span><span class="s2">(</span><span class="s1">namespace</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">handle_starttag</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">, </span><span class="s1">nsprefix</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">,</span>
            <span class="s1">namespaces</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">active_namespace_prefixes</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s2">)</span>
        
    <span class="s4">def </span><span class="s1">_prefix_for_namespace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Find the currently active prefix for the given namespace.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">namespace </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return None</span>
        <span class="s4">for </span><span class="s1">inverted_nsmap </span><span class="s4">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">inverted_nsmap </span><span class="s4">is not None and </span><span class="s1">namespace </span><span class="s4">in </span><span class="s1">inverted_nsmap</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">inverted_nsmap</span><span class="s2">[</span><span class="s1">namespace</span><span class="s2">]</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">end</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">()</span>
        <span class="s1">completed_tag </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">tagStack</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s1">namespace</span><span class="s2">, </span><span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getNsTag</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">nsprefix </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">namespace </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">inverted_nsmap </span><span class="s4">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">inverted_nsmap </span><span class="s4">is not None and </span><span class="s1">namespace </span><span class="s4">in </span><span class="s1">inverted_nsmap</span><span class="s2">:</span>
                    <span class="s1">nsprefix </span><span class="s2">= </span><span class="s1">inverted_nsmap</span><span class="s2">[</span><span class="s1">namespace</span><span class="s2">]</span>
                    <span class="s4">break</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">handle_endtag</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">nsprefix</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0"># This tag, or one of its parents, introduced a namespace</span>
            <span class="s0"># mapping, so pop it off the stack.</span>
            <span class="s1">out_of_scope_nsmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nsmaps</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>

            <span class="s4">if </span><span class="s1">out_of_scope_nsmap </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s0"># This tag introduced a namespace mapping which is no</span>
                <span class="s0"># longer in scope. Recalculate the currently active</span>
                <span class="s0"># namespace prefixes.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">active_namespace_prefixes</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
            
    <span class="s4">def </span><span class="s1">pi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">()</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">target </span><span class="s2">+ </span><span class="s3">' ' </span><span class="s2">+ </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">handle_data</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">processing_instruction_class</span><span class="s2">)</span>
        
    <span class="s4">def </span><span class="s1">data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">content</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">handle_data</span><span class="s2">(</span><span class="s1">content</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">doctype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">system</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">()</span>
        <span class="s1">doctype </span><span class="s2">= </span><span class="s1">Doctype</span><span class="s2">.</span><span class="s1">for_name_and_ids</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">system</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">object_was_parsed</span><span class="s2">(</span><span class="s1">doctype</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">comment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">content</span><span class="s2">):</span>
        <span class="s5">&quot;Handle comments as Comment objects.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">handle_data</span><span class="s2">(</span><span class="s1">content</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">endData</span><span class="s2">(</span><span class="s1">Comment</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">test_fragment_to_document</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;See `TreeBuilder`.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s3">'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="s4">\n</span><span class="s3">%s' </span><span class="s2">% </span><span class="s1">fragment</span>


<span class="s4">class </span><span class="s1">LXMLTreeBuilder</span><span class="s2">(</span><span class="s1">HTMLTreeBuilder</span><span class="s2">, </span><span class="s1">LXMLTreeBuilderForXML</span><span class="s2">):</span>

    <span class="s1">NAME </span><span class="s2">= </span><span class="s1">LXML</span>
    <span class="s1">ALTERNATE_NAMES </span><span class="s2">= [</span><span class="s3">&quot;lxml-html&quot;</span><span class="s2">]</span>

    <span class="s1">features </span><span class="s2">= </span><span class="s1">ALTERNATE_NAMES </span><span class="s2">+ [</span><span class="s1">NAME</span><span class="s2">, </span><span class="s1">HTML</span><span class="s2">, </span><span class="s1">FAST</span><span class="s2">, </span><span class="s1">PERMISSIVE</span><span class="s2">]</span>
    <span class="s1">is_xml </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s1">processing_instruction_class </span><span class="s2">= </span><span class="s1">ProcessingInstruction</span>

    <span class="s4">def </span><span class="s1">default_parser</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">etree</span><span class="s2">.</span><span class="s1">HTMLParser</span>

    <span class="s4">def </span><span class="s1">feed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">markup</span><span class="s2">):</span>
        <span class="s1">encoding </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">soup</span><span class="s2">.</span><span class="s1">original_encoding</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parser_for</span><span class="s2">(</span><span class="s1">encoding</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser</span><span class="s2">.</span><span class="s1">feed</span><span class="s2">(</span><span class="s1">markup</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">parser</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s4">except </span><span class="s2">(</span><span class="s1">UnicodeDecodeError</span><span class="s2">, </span><span class="s1">LookupError</span><span class="s2">, </span><span class="s1">etree</span><span class="s2">.</span><span class="s1">ParserError</span><span class="s2">) </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ParserRejectedMarkup</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">test_fragment_to_document</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;See `TreeBuilder`.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s3">'&lt;html&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;' </span><span class="s2">% </span><span class="s1">fragment</span>
</pre>
</body>
</html>