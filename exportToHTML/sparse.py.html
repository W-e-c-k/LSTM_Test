<html>
<head>
<title>sparse.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sparse.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>

<span class="s0">import </span><span class="s1">tensorflow </span><span class="s0">as </span><span class="s1">tf</span>

<span class="s1">ones_bool </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">bool</span><span class="s2">)</span>
<span class="s1">ones_int8 </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
<span class="s1">zeros_int8 </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
<span class="s1">ones_like_int8 </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
<span class="s1">zeros_like_int8 </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">default_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">x_shape </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if </span><span class="s1">x_shape</span><span class="s2">.</span><span class="s1">rank </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s4"># Workaround for bug on GPU when sparse tensor represents a scalar.</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">constant</span><span class="s2">(</span><span class="s1">default_value</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, ())</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">to_dense</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">default_value</span><span class="s2">=</span><span class="s1">default_value</span><span class="s2">)</span>
    <span class="s1">x</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">x_shape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
    <span class="s1">x_shape </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">)</span>
    <span class="s1">x</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">x_shape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">broadcast_scalar_to_sparse_shape</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">):</span>
    <span class="s1">output </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">)</span>
    <span class="s1">output</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">output</span>


<span class="s0">def </span><span class="s1">sparse_subtract</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Subtraction for `tf.SparseTensor`s. 
 
    Either `x1` or `x2` or both can be `tf.SparseTensor`s. 
 
    Args: 
        x1: fist tensor to add. 
        x2: second tensor to add. 
    Returns: 
        The sum of `x1` and `x2`, which is a `tf.SparseTensor` if and only if 
        both `x1` or `x2` are `tf.SparseTensor`s. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">negative</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">negative</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">sparse_union_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2_indices</span><span class="s2">, </span><span class="s1">x2_values</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Compute the indices for the union of the indices of the provided 
    `tf.SparseTensor`s and another set of indices and return the modified values 
    for these indices. 
 
    Args: 
        x: a `tf.SparseTensor`. 
        indices: another set of indices in the `tf.SparseTensor` format. 
    Returns: A tuple containing: 
        - the indices for the union 
        - `x1` values for the union indices (some zeros were added) 
        - `x2` values for the union indices (some zeros were added) or `None` if 
          `x2_values` was `None`. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Add zeros at the x2 indices to x1 to create the union.</span>
    <span class="s1">zeros2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">(</span>
        <span class="s1">x2_indices</span><span class="s2">,</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x2_indices</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">],), </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
        <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">x1_for_union </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">zeros2</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x2_values </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s4"># Add zeros at the x1 indices to x2 to create the union.</span>
        <span class="s1">x2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">(</span><span class="s1">x2_indices</span><span class="s2">, </span><span class="s1">x2_values</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">)</span>
        <span class="s1">zeros1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">)</span>
        <span class="s1">x2_for_union </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">zeros1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">x1_for_union</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x1_for_union</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2_for_union</span><span class="s2">.</span><span class="s1">values</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">x1_for_union</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x1_for_union</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">indexed_slices_union_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2_indices</span><span class="s2">, </span><span class="s1">x2_values</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Compute the indices for the union of two `tf.IndexedSlices` and modify 
    the values for these indices. 
 
    Args: 
        x1: the first `tf.IndexedSlices`. 
        x2_indices: the indices for the second `tf.IndexedSlices`. 
        x2_value: (optional) the values for the second `tf.IndexedSlices`. 
    Returns: A tuple containing: 
        - the indices for the union 
        - `x1` values for the union indices (some zeros were added) 
        - `x2` values for the union indices (some zeros were added) or `None` if 
          `x2_values` was `None`. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Compute the union of the indices by doing a logical or between the one-hot</span>
    <span class="s4"># encoded indices for x1 and x2.</span>
    <span class="s1">dim_0 </span><span class="s2">= </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x1_indices_expanded </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">x2_indices_expanded </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">x2_indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">x1_indices_count </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x1_indices_expanded</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x2_indices_count </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x2_indices_expanded</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x1_indices_one_hot </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
        <span class="s1">x1_indices_expanded</span><span class="s2">,</span>
        <span class="s1">ones_bool</span><span class="s2">((</span><span class="s1">x1_indices_count</span><span class="s2">,)),</span>
        <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
    <span class="s2">)</span>
    <span class="s1">x2_indices_one_hot </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
        <span class="s1">x2_indices_expanded</span><span class="s2">,</span>
        <span class="s1">ones_bool</span><span class="s2">((</span><span class="s1">x2_indices_count</span><span class="s2">,)),</span>
        <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
    <span class="s2">)</span>
    <span class="s1">union_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span><span class="s1">x1_indices_one_hot</span><span class="s2">, </span><span class="s1">x2_indices_one_hot</span><span class="s2">)),</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">union_indices_count </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">union_indices</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s4"># Re-gather the values with extra zeros added at indices that are part of</span>
    <span class="s4"># the union but were not in x1 or x2.</span>
    <span class="s0">def </span><span class="s1">values_for_union</span><span class="s2">(</span><span class="s1">indices_expanded</span><span class="s2">, </span><span class="s1">indices_count</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
        <span class="s1">indices_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
            <span class="s1">indices_expanded</span><span class="s2">,</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">indices_count </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
        <span class="s2">)</span>
        <span class="s1">to_union_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">indices_indices</span><span class="s2">, </span><span class="s1">union_indices</span><span class="s2">)</span>
        <span class="s1">values_with_leading_zeros </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">concat</span><span class="s2">(</span>
            <span class="s2">[</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">,) + </span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">values</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">values_with_leading_zeros</span><span class="s2">, </span><span class="s1">to_union_indices</span><span class="s2">)</span>

    <span class="s4"># Only recompute values if some indices were added.</span>
    <span class="s1">x1_values_for_union_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x1_indices_count</span><span class="s2">, </span><span class="s1">union_indices_count</span><span class="s2">),</span>
        <span class="s0">lambda</span><span class="s2">: </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
        <span class="s0">lambda</span><span class="s2">: </span><span class="s1">values_for_union</span><span class="s2">(</span>
            <span class="s1">x1_indices_expanded</span><span class="s2">, </span><span class="s1">x1_indices_count</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s2">),</span>
    <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x2_values </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">x2_values_for_union_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x2_indices_count</span><span class="s2">, </span><span class="s1">union_indices_count</span><span class="s2">),</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">x2_values</span><span class="s2">,</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">values_for_union</span><span class="s2">(</span>
                <span class="s1">x2_indices_expanded</span><span class="s2">, </span><span class="s1">x2_indices_count</span><span class="s2">, </span><span class="s1">x2_values</span>
            <span class="s2">),</span>
        <span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">x2_values_for_union_indices </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s2">(</span>
        <span class="s1">union_indices</span><span class="s2">,</span>
        <span class="s1">x1_values_for_union_indices</span><span class="s2">,</span>
        <span class="s1">x2_values_for_union_indices</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">sparse_intersection_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Compute the indices for the intersection of two `tf.SparseTensor`s and 
    modify the values for these indices. 
 
    Args: 
        x1: the first `tf.SparseTensor`. 
        x2: the second `tf.SparseTensor`. 
    Returns: A tuple containing: 
        - the indices for the intersection 
        - `x1` values for the intersection indices (some values were removed) 
        - `x2` values for the intersection indices (some values were removed) 
    &quot;&quot;&quot;</span>
    <span class="s4"># Compute the intersection of indices in the form of a sparse</span>
    <span class="s4"># tensor containing ones as values.</span>
    <span class="s1">ones1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">ones_like_int8</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">)</span>
    <span class="s1">ones2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">ones_like_int8</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
    <span class="s4"># tf.sets.intersection ignores the last dimension when, so we</span>
    <span class="s4"># need to add a dummy extra dimension and then remove it.</span>
    <span class="s1">intersection_extra_dim </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sets</span><span class="s2">.</span><span class="s1">intersection</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">ones1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">),</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">ones2</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">),</span>
    <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">empty_intersection</span><span class="s2">():</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">.</span><span class="s1">rank</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">),</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">non_empty_intersection</span><span class="s2">():</span>
        <span class="s1">intersection </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">intersection_extra_dim</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">)</span>

        <span class="s4"># Compute the masks to remove indices in x1 and x2 that are not</span>
        <span class="s4"># in the intersection, then trim x1 and x2.</span>
        <span class="s1">zeros1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">zeros_like_int8</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">)</span>
        <span class="s1">zeros2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">map_values</span><span class="s2">(</span><span class="s1">zeros_like_int8</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
        <span class="s1">mask1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">zeros1</span><span class="s2">, </span><span class="s1">intersection</span><span class="s2">)</span>
        <span class="s1">mask2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">zeros2</span><span class="s2">, </span><span class="s1">intersection</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">intersection</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">retain</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">mask1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">bool</span><span class="s2">)).</span><span class="s1">values</span><span class="s2">,</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">retain</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">mask2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">bool</span><span class="s2">)).</span><span class="s1">values</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">size</span><span class="s2">(</span><span class="s1">intersection_extra_dim</span><span class="s2">), </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s1">empty_intersection</span><span class="s2">,</span>
        <span class="s1">non_empty_intersection</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">indexed_slices_intersection_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Compute the indices for the intersection of two `tf.IndexedSlices` and 
    modify the values for these indices. 
 
    Args: 
        x1: the first `tf.IndexedSlices`. 
        x2: the second `tf.IndexedSlices`. 
    Returns: A tuple containing: 
        - the indices for the intersection 
        - `x1` values for the intersection indices (some values were removed) 
        - `x2` values for the intersection indices (some values were removed) 
    &quot;&quot;&quot;</span>
    <span class="s4"># Compute the intersection of the indices by doing a logical</span>
    <span class="s4"># and between the one hot encoded indices for x1 and x2.</span>
    <span class="s1">dim_0 </span><span class="s2">= </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x1_indices_expanded </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">x2_indices_expanded </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">x1_indices_count </span><span class="s2">= </span><span class="s1">x1_indices_expanded</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x2_indices_count </span><span class="s2">= </span><span class="s1">x2_indices_expanded</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s1">x1_indices_one_hot </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
        <span class="s1">x1_indices_expanded</span><span class="s2">,</span>
        <span class="s1">ones_bool</span><span class="s2">((</span><span class="s1">x1_indices_count</span><span class="s2">,)),</span>
        <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
    <span class="s2">)</span>
    <span class="s1">x2_indices_one_hot </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
        <span class="s1">x2_indices_expanded</span><span class="s2">,</span>
        <span class="s1">ones_bool</span><span class="s2">((</span><span class="s1">x2_indices_count</span><span class="s2">,)),</span>
        <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
    <span class="s2">)</span>
    <span class="s1">intersection_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">logical_and</span><span class="s2">(</span><span class="s1">x1_indices_one_hot</span><span class="s2">, </span><span class="s1">x2_indices_one_hot</span><span class="s2">)),</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">intersection_indices_count </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">intersection_indices</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">empty_intersection</span><span class="s2">():</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">intersection_indices</span><span class="s2">,</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">,) + </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">,) + </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">non_empty_intersection</span><span class="s2">():</span>
        <span class="s4"># Re-gather sub parts of the values that are part of the intersection.</span>
        <span class="s0">def </span><span class="s1">values_for_intersection</span><span class="s2">(</span><span class="s1">indices_expanded</span><span class="s2">, </span><span class="s1">indices_count</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s1">indices_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">scatter_nd</span><span class="s2">(</span>
                <span class="s1">indices_expanded</span><span class="s2">,</span>
                <span class="s1">tf</span><span class="s2">.</span><span class="s1">range</span><span class="s2">(</span><span class="s1">indices_count</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s1">dim_0</span><span class="s2">,),</span>
            <span class="s2">)</span>
            <span class="s1">to_intersection_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span>
                <span class="s1">indices_indices</span><span class="s2">, </span><span class="s1">intersection_indices</span>
            <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">to_intersection_indices</span><span class="s2">)</span>

        <span class="s4"># Only recompute values if some indices were removed.</span>
        <span class="s1">x1_values_for_intersection </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x1_indices_count</span><span class="s2">, </span><span class="s1">intersection_indices_count</span><span class="s2">),</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">values_for_intersection</span><span class="s2">(</span>
                <span class="s1">x1_indices_expanded</span><span class="s2">, </span><span class="s1">x1_indices_count</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span>
            <span class="s2">),</span>
        <span class="s2">)</span>
        <span class="s1">x2_values_for_intersection </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
            <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x2_indices_count</span><span class="s2">, </span><span class="s1">intersection_indices_count</span><span class="s2">),</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
            <span class="s0">lambda</span><span class="s2">: </span><span class="s1">values_for_intersection</span><span class="s2">(</span>
                <span class="s1">x2_indices_expanded</span><span class="s2">, </span><span class="s1">x2_indices_count</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span>
            <span class="s2">),</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">intersection_indices</span><span class="s2">,</span>
            <span class="s1">x1_values_for_intersection</span><span class="s2">,</span>
            <span class="s1">x2_values_for_intersection</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
        <span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">intersection_indices_count</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s1">empty_intersection</span><span class="s2">,</span>
        <span class="s1">non_empty_intersection</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">densifying_unary</span><span class="s2">(</span><span class="s1">default_value</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Decorator to add support for `tf.SparseTensor` and `tf.IndexedSlices` to 
    a non-zero-preserving element-wise unary operator. 
 
    There are requirements on the operator for this decorator to work correctly: 
 
    - The operator must be element-wise 
    - The operator must be unary (one input tensor and one output tensor) 
    - The operator must return a tensor of the same shape. 
 
    Additional arguments to the function (besides the input tensor) are 
    supported. The returned result is a dense tensor and contains 
    `default_value` outside of the indices of the input tensor. 
 
    Args: 
        default_value: The value to use outside of indices. It must be the value 
        that the operator returns for zero values. 
    Returns: 
        Wrapped function that supports `tf.SparseTensor` and `tf.IndexedSlices`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">wrap_densifying_unary</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">sparse_wrapper</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                <span class="s1">sparse_output </span><span class="s2">= </span><span class="s1">sparse_with_values</span><span class="s2">(</span>
                    <span class="s1">x</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s0">return </span><span class="s1">sparse_to_dense</span><span class="s2">(</span>
                    <span class="s1">sparse_output</span><span class="s2">,</span>
                    <span class="s1">tf</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">default_value</span><span class="s2">, </span><span class="s1">sparse_output</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
                <span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                <span class="s1">sparse_output_values </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">output </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span>
                    <span class="s1">x</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                    <span class="s1">tf</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">default_value</span><span class="s2">, </span><span class="s1">sparse_output_values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
                <span class="s2">)</span>
                <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">tensor_scatter_nd_update</span><span class="s2">(</span>
                    <span class="s1">output</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), </span><span class="s1">sparse_output_values</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">sparse_wrapper</span>

    <span class="s0">return </span><span class="s1">wrap_densifying_unary</span>


<span class="s0">def </span><span class="s1">elementwise_unary</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Decorator to add support for `tf.SparseTensor` and `tf.IndexedSlices` to 
    a zero-preserving element-wise unary operator. 
 
    There are requirements on the operator for this decorator to work correctly: 
 
    - The operator must be element-wise 
    - The operator must be unary (one input tensor and one output tensor) 
    - The operator must return a tensor of the same shape, and if it is a 
      `tf.SparseTensor` or `tf.IndexedSlices`, the indices of the result must be 
      the same. Therefore: 
        - Reduction operations are not supported (e.g. `mean`). 
        - Operations for which the result may be dense (e.g. `reciprocal`), or 
          the sparse indices depend on the inputs are not supported (e.g. 
          `clip`). This implies that `func(0)` must be 0. 
 
    Additional arguments to the function (besides the input tensor) are 
    supported as long as they cannot change the indices of the result. For 
    instance,`round` is supported, but `clip` is not supported as 
    `clip(x, 1.0, 2.0)` would always return a dense tensor. 
 
    Note that if an input sparse tensor contains zero values, the indices and 
    the zero values are preserved. 
 
    Args: 
        func: The function to wrap. 
    Returns: 
        Wrapped function that supports `tf.SparseTensor` and `tf.IndexedSlices`. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">sparse_wrapper</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">))</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                <span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">), </span><span class="s1">x</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dense_shape</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">sparse_wrapper</span>


<span class="s0">def </span><span class="s1">elementwise_binary_union</span><span class="s2">(</span><span class="s1">sparse_op</span><span class="s2">, </span><span class="s1">densify_mixed</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Decorator to add support for `tf.SparseTensor` and `tf.IndexedSlices` to 
    an element-wise binary operator such that the indices present in the result 
    are the union of the indices in the two operand. 
 
    The primary use case for this is the `add` and `subtract` operators. 
 
    There are requirements on the operator for this decorator to work correctly: 
 
    - The operator must be element-wise. 
    - The operator must be binary (two input tensors and one output tensor). 
    - Both inputs must be of the same shape or one input must be a scalar. 
    - The output must be of the same shape as the (non scalar) inputs. 
    - The indices of the output must be the union of the indices of the inputs. 
      This implies that func(0, 0) must be 0. As a result, if one operand is 
      dense or a scalar, then the result will be dense. 
 
    Additional arguments to the function (besides the input tensors) are not 
    supported. 
 
    Note that if the result of the operation is zero at some indices, including 
    because the operands were zero at these indices, the zeros and indices are 
    preserved. 
 
    Args: 
        sparse_op: implementation of the operation for `tf.SparseTensor`. Must 
            work if both of the operands are `tf.SparseTensor`s and can 
            optionally work if one of the operand is a `tf.SparseTensor` and 
            the other one is dense tensor, see `densify_mixed`. 
        densify_mixed: if `True`, `sparse_op` does not support a mix of 
            `tf.SparseTensor` and dense tensor or dense tensor with 
            `tf.SparseTensor` and the `tf.SparseTensor` tensor is densified. 
    Returns: 
        Wrapped function that supports `tf.SparseTensor` and `tf.IndexedSlices`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">wrap_elementwise_binary_union</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">sparse_wrapper</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                    <span class="s4"># x1 is a SparseTensor and x2 is a SparseTensor.</span>
                    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices </span><span class="s0">is </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span>
                            <span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
                        <span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">output </span><span class="s2">= </span><span class="s1">sparse_op</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
                        <span class="s1">output</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">output</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x1 is a SparseTensor.</span>
                    <span class="s0">if </span><span class="s1">densify_mixed</span><span class="s2">:</span>
                        <span class="s1">x1 </span><span class="s2">= </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                            <span class="s4"># x2 is a scalar, broadcast.</span>
                            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">broadcast_scalar_to_sparse_shape</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">sparse_op</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                <span class="s4"># x2 is a SparseTensor.</span>
                <span class="s0">if </span><span class="s1">densify_mixed</span><span class="s2">:</span>
                    <span class="s1">x2 </span><span class="s2">= </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                        <span class="s4"># x1 is a scalar, broadcast.</span>
                        <span class="s1">x1 </span><span class="s2">= </span><span class="s1">broadcast_scalar_to_sparse_shape</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">sparse_op</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                    <span class="s4"># x1 is an IndexedSlices and x2 is an IndexedSlices.</span>
                    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices </span><span class="s0">is </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                            <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">),</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                        <span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s4"># Compute the union of indices.</span>
                        <span class="s2">(</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                            <span class="s1">x2_values_for_union</span><span class="s2">,</span>
                        <span class="s2">) = </span><span class="s1">indexed_slices_union_indices_and_values</span><span class="s2">(</span>
                            <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span>
                        <span class="s2">)</span>
                        <span class="s4"># Now, it is an element-wise operation on the union.</span>
                        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                            <span class="s1">func</span><span class="s2">(</span>
                                <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                                <span class="s1">x2_values_for_union</span><span class="s2">,</span>
                            <span class="s2">),</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                        <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x1 is an IndexedSlices, densify.</span>
                    <span class="s1">x1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                <span class="s4"># x2 is an IndexedSlices, densify.</span>
                <span class="s1">x2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">sparse_wrapper</span>

    <span class="s0">return </span><span class="s1">wrap_elementwise_binary_union</span>


<span class="s0">def </span><span class="s1">elementwise_binary_intersection</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Decorator to add support for `tf.SparseTensor` and `tf.IndexedSlices` to 
    an element-wise binary operator such that the indices present in the result 
    are the intersection of the indices in the two operand. 
 
    The primary use case for this is the `multiply` operator. 
 
    There are requirements on the operator for this decorator to work correctly: 
 
    - The operator must be element-wise. 
    - The operator must be binary (two input tensors and one output tensor). 
    - Both inputs must be of the same shape or one input must be a scalar. 
    - The output must be of the same shape as the (non scalar) inputs. 
    - The indices of the output must be the intersection of the indices of the 
      inputs. This implies that func(0, x) and func(x, 0) must be 0 for any x. 
      As a result, if one operand is dense or a scalar, then the indices are the 
      ones from the other operand. 
 
    Additional arguments to the function (besides the input tensors) are not 
    supported. 
 
    Note that if the operands contains zero values at some common indices, the 
    indices and the zero values are preserved. 
 
    Args: 
        func: The function to wrap. 
    Returns: 
        Wrapped function that supports `tf.SparseTensor` and `tf.IndexedSlices`. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">sparse_wrapper</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                <span class="s4"># x1 is a SparseTensor and x2 is a SparseTensor.</span>
                <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices </span><span class="s0">is </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># Compute the intersection of indices.</span>
                    <span class="s2">(</span>
                        <span class="s1">intersection_indices</span><span class="s2">,</span>
                        <span class="s1">x1_values_for_intersection</span><span class="s2">,</span>
                        <span class="s1">x2_values_for_intersection</span><span class="s2">,</span>
                    <span class="s2">) = </span><span class="s1">sparse_intersection_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
                    <span class="s4"># Now, it is an element-wise operation on the intersection.</span>
                    <span class="s1">output </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">(</span>
                        <span class="s1">intersection_indices</span><span class="s2">,</span>
                        <span class="s1">func</span><span class="s2">(</span>
                            <span class="s1">x1_values_for_intersection</span><span class="s2">,</span>
                            <span class="s1">x2_values_for_intersection</span><span class="s2">,</span>
                        <span class="s2">),</span>
                        <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">output</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is a SparseTensor.</span>
                <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s4"># x2 is a scalar, apply func element-wise.</span>
                    <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x2 is dense, gather values from x1 indices.</span>
                    <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span>
                        <span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather_nd</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">))</span>
                    <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
            <span class="s4"># x2 is a SparseTensor.</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s4"># x1 is a scalar, apply func element-wise.</span>
                <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is dense, gather values from x2 indices.</span>
                <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span>
                    <span class="s1">x2</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather_nd</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">), </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
                <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                <span class="s4"># x1 is an IndexedSlices and x2 is an IndexedSlices.</span>
                <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices </span><span class="s0">is </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">), </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># Compute the intersection of indices.</span>
                    <span class="s2">(</span>
                        <span class="s1">intersection_indices</span><span class="s2">,</span>
                        <span class="s1">x1_values_for_intersection</span><span class="s2">,</span>
                        <span class="s1">x2_values_for_intersection</span><span class="s2">,</span>
                    <span class="s2">) = </span><span class="s1">indexed_slices_intersection_indices_and_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>
                    <span class="s4"># Now, it is an element-wise operation on the intersection.</span>
                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">(</span>
                            <span class="s1">x1_values_for_intersection</span><span class="s2">,</span>
                            <span class="s1">x2_values_for_intersection</span><span class="s2">,</span>
                        <span class="s2">),</span>
                        <span class="s1">intersection_indices</span><span class="s2">,</span>
                        <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                    <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is an IndexedSlices.</span>
                <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s4"># x2 is a scalar, apply func element-wise.</span>
                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">), </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x2 is dense, gather values from x1 indices.</span>
                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)),</span>
                        <span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                        <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                    <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
            <span class="s4"># x2 is an IndexedSlices.</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s4"># x1 is a scalar, apply func element-wise.</span>
                <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                    <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">), </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dense_shape</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is dense, gather values from x2 indices.</span>
                <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                    <span class="s1">func</span><span class="s2">(</span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">), </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">values</span><span class="s2">),</span>
                    <span class="s1">x2</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                    <span class="s1">x2</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                <span class="s2">)</span>
        <span class="s4"># Default case, no SparseTensor and no IndexedSlices.</span>
        <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">sparse_wrapper</span>


<span class="s0">def </span><span class="s1">elementwise_division</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Decorator to add support for `tf.SparseTensor` and `tf.IndexedSlices` to 
    element-wise binary division and related operators. 
 
    This decorator is designed for operations related to the division of two 
    operands (e.g. `divide`). It accepts `tf.SparseTensor` and 
    `tf.IndexedSlices` for both the dividend and the divisor, but handles them 
    differently based on whether they are the dividend or the divisor. 
 
    - If the divisor is a `tf.SparseTensor` or `tf.IndexedSlices`, it is 
      densified and the result is dense because the result contains Inf or Nan 
      outside of the indices of the dividend. 
    - If the dividend is a `tf.SparseTensor` or `tf.IndexedSlices` and the 
      divisor is dense, it finds occurrences of zeros and NaNs in the divisor. 
      The result may therefore have more indices than there were in the dividend 
      to return correct values where the divisor was zero or NaN. 
    - If the dividend is a `tf.SparseTensor` or `tf.IndexedSlices` and the 
      divisor is a scalar, it does the division element-wise. Note that the 
      result is incorrectly sparse if the scalar divisor is zero. 
 
    Args: 
        func: The function to wrap. 
    Returns: 
        Wrapped function that supports `tf.SparseTensor` and `tf.IndexedSlices`. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">sparse_wrapper</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
                <span class="s4"># x1 is a SparseTensor and x2 is a SparseTensor.</span>
                <span class="s4"># Divisor is sparse, meaning we're doing divisions by zero</span>
                <span class="s4"># outside of x2.indices, so the result is dense. Densify both.</span>
                <span class="s1">x1 </span><span class="s2">= </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
                <span class="s1">x2 </span><span class="s2">= </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is a SparseTensor.</span>
                <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s4"># x2 is a scalar, apply func element-wise.</span>
                    <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x2 is dense.</span>
                    <span class="s1">x2_zeros_and_nans </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)</span>
                    <span class="s0">if not </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">is_integer</span><span class="s2">:</span>
                        <span class="s1">x2_zeros_and_nans </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span>
                            <span class="s1">x2_zeros_and_nans</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">is_nan</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
                        <span class="s2">)</span>

                    <span class="s0">def </span><span class="s1">func_for_x1_indices</span><span class="s2">():</span>
                        <span class="s4"># Gather values from x1 indices.</span>
                        <span class="s0">return </span><span class="s1">sparse_with_values</span><span class="s2">(</span>
                            <span class="s1">x1</span><span class="s2">, </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather_nd</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">))</span>
                        <span class="s2">)</span>

                    <span class="s0">def </span><span class="s1">func_for_union_indices</span><span class="s2">():</span>
                        <span class="s4"># Compute the union of indices to keep zeros and NaNs.</span>
                        <span class="s1">x2_zeros_and_nan_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">x2_zeros_and_nans</span><span class="s2">)</span>
                        <span class="s2">(</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                            <span class="s1">_</span><span class="s2">,</span>
                        <span class="s2">) = </span><span class="s1">sparse_union_indices_and_values</span><span class="s2">(</span>
                            <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2_zeros_and_nan_indices</span>
                        <span class="s2">)</span>
                        <span class="s1">output </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">(</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">func</span><span class="s2">(</span>
                                <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                                <span class="s1">tf</span><span class="s2">.</span><span class="s1">gather_nd</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">union_indices</span><span class="s2">),</span>
                            <span class="s2">),</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                        <span class="s2">)</span>
                        <span class="s1">output</span><span class="s2">.</span><span class="s1">set_shape</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">output</span>

                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
                        <span class="s1">tf</span><span class="s2">.</span><span class="s1">reduce_any</span><span class="s2">(</span><span class="s1">x2_zeros_and_nans</span><span class="s2">),</span>
                        <span class="s1">func_for_union_indices</span><span class="s2">,</span>
                        <span class="s1">func_for_x1_indices</span><span class="s2">,</span>
                    <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">):</span>
            <span class="s4"># x2 is a SparseTensor.</span>
            <span class="s4"># Divisor is sparse, densify to do the divisions by zero correctly.</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">sparse_to_dense</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
                <span class="s4"># x1 is an IndexedSlices and x2 is an IndexedSlices.</span>
                <span class="s4"># Divisor is slices, meaning we're doing divisions by zero</span>
                <span class="s4"># outside of x2.indices, so the result is dense. Densify both.</span>
                <span class="s1">x1 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
                <span class="s1">x2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># x1 is a IndexedSlices.</span>
                <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s6">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s4"># x2 is a scalar, apply func element-wise.</span>
                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">), </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># x2 is dense.</span>
                    <span class="s1">x2_zeros_and_nans </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)</span>
                    <span class="s0">if not </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">is_integer</span><span class="s2">:</span>
                        <span class="s1">x2_zeros_and_nans </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span>
                            <span class="s1">x2_zeros_and_nans</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">is_nan</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
                        <span class="s2">)</span>
                    <span class="s1">x2_zeros_and_nans </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">reduce_any</span><span class="s2">(</span>
                        <span class="s1">x2_zeros_and_nans</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">.</span><span class="s1">rank</span><span class="s2">))</span>
                    <span class="s2">)</span>

                    <span class="s0">def </span><span class="s1">func_for_x1_indices</span><span class="s2">():</span>
                        <span class="s4"># Gather values from x1 indices.</span>
                        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                            <span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)),</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                        <span class="s2">)</span>

                    <span class="s0">def </span><span class="s1">func_for_union_indices</span><span class="s2">():</span>
                        <span class="s1">x2_zeros_and_nan_indices </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span>
                            <span class="s1">tf</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">x2_zeros_and_nans</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s3">1</span>
                        <span class="s2">)</span>
                        <span class="s4"># Compute the union of indices to keep zeros and NaNs.</span>
                        <span class="s2">(</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                            <span class="s1">_</span><span class="s2">,</span>
                        <span class="s2">) = </span><span class="s1">indexed_slices_union_indices_and_values</span><span class="s2">(</span>
                            <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2_zeros_and_nan_indices</span>
                        <span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">(</span>
                            <span class="s1">func</span><span class="s2">(</span>
                                <span class="s1">x1_values_for_union</span><span class="s2">,</span>
                                <span class="s1">tf</span><span class="s2">.</span><span class="s1">gather</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">union_indices</span><span class="s2">),</span>
                            <span class="s2">),</span>
                            <span class="s1">union_indices</span><span class="s2">,</span>
                            <span class="s1">x1</span><span class="s2">.</span><span class="s1">dense_shape</span><span class="s2">,</span>
                        <span class="s2">)</span>

                    <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
                        <span class="s1">tf</span><span class="s2">.</span><span class="s1">reduce_any</span><span class="s2">(</span><span class="s1">x2_zeros_and_nans</span><span class="s2">),</span>
                        <span class="s1">func_for_union_indices</span><span class="s2">,</span>
                        <span class="s1">func_for_x1_indices</span><span class="s2">,</span>
                    <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">IndexedSlices</span><span class="s2">):</span>
            <span class="s4"># x2 is a IndexedSlices.</span>
            <span class="s4"># Divisor is slices, densify to do the divisions by zero correctly.</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
        <span class="s4"># Default case, no SparseTensor and no IndexedSlices.</span>
        <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">sparse_wrapper</span>
</pre>
</body>
</html>