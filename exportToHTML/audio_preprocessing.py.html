<html>
<head>
<title>audio_preprocessing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
audio_preprocessing.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">preprocessing</span><span class="s2">.</span><span class="s1">tf_data_layer </span><span class="s0">import </span><span class="s1">TFDataLayer</span>

<span class="s3"># mel spectrum constants.</span>
<span class="s1">_MEL_BREAK_FREQUENCY_HERTZ </span><span class="s2">= </span><span class="s4">700.0</span>
<span class="s1">_MEL_HIGH_FREQUENCY_Q </span><span class="s2">= </span><span class="s4">1127.0</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s5">&quot;keras.layers.MelSpectrogram&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MelSpectrogram</span><span class="s2">(</span><span class="s1">TFDataLayer</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;A preprocessing layer to convert raw audio signals to Mel spectrograms. 
 
    This layer takes `float32`/`float64` single or batched audio signal as 
    inputs and computes the Mel spectrogram using Short-Time Fourier Transform 
    and Mel scaling. The input should be a 1D (unbatched) or 2D (batched) tensor 
    representing audio signals. The output will be a 2D or 3D tensor 
    representing Mel spectrograms. 
 
    A spectrogram is an image-like representation that shows the frequency 
    spectrum of a signal over time. It uses x-axis to represent time, y-axis to 
    represent frequency, and each pixel to represent intensity. 
    Mel spectrograms are a special type of spectrogram that use the mel scale, 
    which approximates how humans perceive sound. They are commonly used in 
    speech and music processing tasks like speech recognition, speaker 
    identification, and music genre classification. 
 
    References: 
    - [Spectrogram](https://en.wikipedia.org/wiki/Spectrogram), 
    - [Mel scale](https://en.wikipedia.org/wiki/Mel_scale). 
 
    Examples: 
 
    **Unbatched audio signal** 
 
    &gt;&gt;&gt; layer = keras.layers.MelSpectrogram(num_mel_bins=64, 
    ...                                     sampling_rate=8000, 
    ...                                     sequence_stride=256, 
    ...                                     fft_length=2048) 
    &gt;&gt;&gt; layer(keras.random.uniform(shape=(16000,))).shape 
    (64, 63) 
 
    **Batched audio signal** 
 
    &gt;&gt;&gt; layer = keras.layers.MelSpectrogram(num_mel_bins=80, 
    ...                                     sampling_rate=8000, 
    ...                                     sequence_stride=128, 
    ...                                     fft_length=2048) 
    &gt;&gt;&gt; layer(keras.random.uniform(shape=(2, 16000))).shape 
    (2, 80, 125) 
 
    Input shape: 
        1D (unbatched) or 2D (batched) tensor with shape:`(..., samples)`. 
 
    Output shape: 
        2D (unbatched) or 3D (batched) tensor with 
        shape:`(..., num_mel_bins, time)`. 
 
    Args: 
        fft_length: Integer, size of the FFT window. 
        sequence_stride: Integer, number of samples between successive STFT 
            columns. 
        sequence_length: Integer, size of the window used for applying 
            `window` to each audio frame. If `None`, defaults to `fft_length`. 
        window: String, name of the window function to use. Available values 
            are `&quot;hann&quot;` and `&quot;hamming&quot;`. If `window` is a tensor, it will be 
            used directly as the window and its length must be 
            `sequence_length`. If `window` is `None`, no windowing is 
            used. Defaults to `&quot;hann&quot;`. 
        sampling_rate: Integer, sample rate of the input signal. 
        num_mel_bins: Integer, number of mel bins to generate. 
        min_freq: Float, minimum frequency of the mel bins. 
        max_freq: Float, maximum frequency of the mel bins. 
            If `None`, defaults to `sampling_rate / 2`. 
        power_to_db: If True, convert the power spectrogram to decibels. 
        top_db: Float, minimum negative cut-off `max(10 * log10(S)) - top_db`. 
        mag_exp: Float, exponent for the magnitude spectrogram. 
            1 for magnitude, 2 for power, etc. Default is 2. 
        ref_power: Float, the power is scaled relative to it 
            `10 * log10(S / ref_power)`. 
        min_power: Float, minimum value for power and `ref_power`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fft_length</span><span class="s2">=</span><span class="s4">2048</span><span class="s2">,</span>
        <span class="s1">sequence_stride</span><span class="s2">=</span><span class="s4">512</span><span class="s2">,</span>
        <span class="s1">sequence_length</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">window</span><span class="s2">=</span><span class="s5">&quot;hann&quot;</span><span class="s2">,</span>
        <span class="s1">sampling_rate</span><span class="s2">=</span><span class="s4">16000</span><span class="s2">,</span>
        <span class="s1">num_mel_bins</span><span class="s2">=</span><span class="s4">128</span><span class="s2">,</span>
        <span class="s1">min_freq</span><span class="s2">=</span><span class="s4">20.0</span><span class="s2">,</span>
        <span class="s1">max_freq</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">power_to_db</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">top_db</span><span class="s2">=</span><span class="s4">80.0</span><span class="s2">,</span>
        <span class="s1">mag_exp</span><span class="s2">=</span><span class="s4">2.0</span><span class="s2">,</span>
        <span class="s1">min_power</span><span class="s2">=</span><span class="s4">1e-10</span><span class="s2">,</span>
        <span class="s1">ref_power</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fft_length </span><span class="s2">= </span><span class="s1">fft_length</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride </span><span class="s2">= </span><span class="s1">sequence_stride</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_length </span><span class="s2">= </span><span class="s1">sequence_length </span><span class="s0">or </span><span class="s1">fft_length</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">window </span><span class="s2">= </span><span class="s1">window</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sampling_rate </span><span class="s2">= </span><span class="s1">sampling_rate</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">num_mel_bins </span><span class="s2">= </span><span class="s1">num_mel_bins</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">min_freq </span><span class="s2">= </span><span class="s1">min_freq</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">max_freq </span><span class="s2">= </span><span class="s1">max_freq </span><span class="s0">or </span><span class="s1">int</span><span class="s2">(</span><span class="s1">sampling_rate </span><span class="s2">/ </span><span class="s4">2</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">power_to_db </span><span class="s2">= </span><span class="s1">power_to_db</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">top_db </span><span class="s2">= </span><span class="s1">top_db</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">mag_exp </span><span class="s2">= </span><span class="s1">mag_exp</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">min_power </span><span class="s2">= </span><span class="s1">min_power</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ref_power </span><span class="s2">= </span><span class="s1">ref_power</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">):</span>
        <span class="s1">dtype </span><span class="s2">= (</span>
            <span class="s5">&quot;float32&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dtype </span><span class="s0">not in </span><span class="s2">[</span><span class="s5">&quot;float32&quot;</span><span class="s2">, </span><span class="s5">&quot;float64&quot;</span><span class="s2">]</span>
            <span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dtype</span>
        <span class="s2">)  </span><span class="s3"># jax, tf supports only &quot;float32&quot; and &quot;float64&quot; in stft</span>
        <span class="s1">inputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">outputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_spectrogram</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">)</span>
        <span class="s1">outputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_melscale</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">power_to_db</span><span class="s2">:</span>
            <span class="s1">outputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dbscale</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">)</span>
        <span class="s3"># swap time &amp; freq axis to have shape of (..., num_mel_bins, time)</span>
        <span class="s1">outputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, -</span><span class="s4">2</span><span class="s2">)</span>
        <span class="s1">outputs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dtype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">outputs</span>

    <span class="s0">def </span><span class="s1">_spectrogram</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">):</span>
        <span class="s1">real</span><span class="s2">, </span><span class="s1">imag </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">stft</span><span class="s2">(</span>
            <span class="s1">inputs</span><span class="s2">,</span>
            <span class="s1">sequence_length</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_length</span><span class="s2">,</span>
            <span class="s1">sequence_stride</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride</span><span class="s2">,</span>
            <span class="s1">fft_length</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fft_length</span><span class="s2">,</span>
            <span class="s1">window</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">window</span><span class="s2">,</span>
            <span class="s1">center</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s3"># abs of complex  = sqrt(real^2 + imag^2)</span>
        <span class="s1">spec </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">real</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">imag</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">spec </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">power</span><span class="s2">(</span><span class="s1">spec</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mag_exp</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">spec</span>

    <span class="s0">def </span><span class="s1">_melscale</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">):</span>
        <span class="s1">matrix </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">linear_to_mel_weight_matrix</span><span class="s2">(</span>
            <span class="s1">num_mel_bins</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_mel_bins</span><span class="s2">,</span>
            <span class="s1">num_spectrogram_bins</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">)[-</span><span class="s4">1</span><span class="s2">],</span>
            <span class="s1">sampling_rate</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sampling_rate</span><span class="s2">,</span>
            <span class="s1">lower_edge_hertz</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">min_freq</span><span class="s2">,</span>
            <span class="s1">upper_edge_hertz</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_freq</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">tensordot</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_dbscale</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">):</span>
        <span class="s1">log_spec </span><span class="s2">= </span><span class="s4">10.0 </span><span class="s2">* (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">log10</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">min_power</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">ref_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ref_power</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">log_spec </span><span class="s2">-= </span><span class="s4">10.0 </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">log10</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">ref_value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">min_power</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">log_spec </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s1">log_spec</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">log_spec</span><span class="s2">) - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">top_db</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">log_spec</span>

    <span class="s0">def </span><span class="s1">_hertz_to_mel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frequencies_hertz</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Converts frequencies in `frequencies_hertz` in Hertz to the 
            mel scale. 
 
        Args: 
            frequencies_hertz: A tensor of frequencies in Hertz. 
            name: An optional name for the operation. 
 
        Returns: 
            A tensor of the same shape and type of `frequencies_hertz` 
            containing frequencies in the mel scale. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_MEL_HIGH_FREQUENCY_Q </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span>
            <span class="s4">1.0 </span><span class="s2">+ (</span><span class="s1">frequencies_hertz </span><span class="s2">/ </span><span class="s1">_MEL_BREAK_FREQUENCY_HERTZ</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">linear_to_mel_weight_matrix</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_mel_bins</span><span class="s2">=</span><span class="s4">20</span><span class="s2">,</span>
        <span class="s1">num_spectrogram_bins</span><span class="s2">=</span><span class="s4">129</span><span class="s2">,</span>
        <span class="s1">sampling_rate</span><span class="s2">=</span><span class="s4">8000</span><span class="s2">,</span>
        <span class="s1">lower_edge_hertz</span><span class="s2">=</span><span class="s4">125.0</span><span class="s2">,</span>
        <span class="s1">upper_edge_hertz</span><span class="s2">=</span><span class="s4">3800.0</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;float32&quot;</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Returns a matrix to warp linear scale spectrograms to the mel scale. 
 
        Returns a weight matrix that can be used to re-weight a tensor 
        containing `num_spectrogram_bins` linearly sampled frequency information 
        from `[0, sampling_rate / 2]` into `num_mel_bins` frequency information 
        from `[lower_edge_hertz, upper_edge_hertz]` on the mel scale. 
 
        This function follows the [Hidden Markov Model Toolkit (HTK)]( 
        http://htk.eng.cam.ac.uk/) convention, defining the mel scale in 
        terms of a frequency in hertz according to the following formula: 
 
        ```mel(f) = 2595 * log10( 1 + f/700)``` 
 
        In the returned matrix, all the triangles (filterbanks) have a peak 
        value of 1.0. 
 
        For example, the returned matrix `A` can be used to right-multiply a 
        spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear 
        scale spectrum values (e.g. STFT magnitudes) to generate a 
        &quot;mel spectrogram&quot; `M` of shape `[frames, num_mel_bins]`. 
 
        ``` 
        # `S` has shape [frames, num_spectrogram_bins] 
        # `M` has shape [frames, num_mel_bins] 
        M = keras.ops.matmul(S, A) 
        ``` 
 
        The matrix can be used with `keras.ops.tensordot` to convert an 
        arbitrary rank `Tensor` of linear-scale spectral bins into the 
        mel scale. 
 
        ``` 
        # S has shape [..., num_spectrogram_bins]. 
        # M has shape [..., num_mel_bins]. 
        M = keras.ops.tensordot(S, A, 1) 
        ``` 
 
        References: 
        - [Mel scale (Wikipedia)](https://en.wikipedia.org/wiki/Mel_scale) 
 
        Args: 
            num_mel_bins: Python int. How many bands in the resulting 
                mel spectrum. 
            num_spectrogram_bins: An integer `Tensor`. How many bins there are 
                in the source spectrogram data, which is understood to be 
                `fft_size // 2 + 1`, i.e. the spectrogram only contains the 
                nonredundant FFT bins. 
            sampling_rate: An integer or float `Tensor`. Samples per second of 
                the input signal used to create the spectrogram. Used to figure 
                out the frequencies corresponding to each spectrogram bin, 
                which dictates how they are mapped into the mel scale. 
            lower_edge_hertz: Python float. Lower bound on the frequencies to be 
                included in the mel spectrum. This corresponds to the lower 
                edge of the lowest triangular band. 
            upper_edge_hertz: Python float. The desired top edge of the highest 
                frequency band. 
            dtype: The `DType` of the result matrix. Must be a floating point 
                type. 
 
        Returns: 
            A tensor of shape `[num_spectrogram_bins, num_mel_bins]`. 
        &quot;&quot;&quot;</span>

        <span class="s3"># This function can be constant folded by graph optimization since</span>
        <span class="s3"># there are no Tensor inputs.</span>
        <span class="s1">sampling_rate </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">sampling_rate</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">lower_edge_hertz </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span>
            <span class="s1">lower_edge_hertz</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">upper_edge_hertz </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span>
            <span class="s1">upper_edge_hertz</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">zero </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s3"># HTK excludes the spectrogram DC bin.</span>
        <span class="s1">bands_to_zero </span><span class="s2">= </span><span class="s4">1</span>
        <span class="s1">nyquist_hertz </span><span class="s2">= </span><span class="s1">sampling_rate </span><span class="s2">/ </span><span class="s4">2.0</span>
        <span class="s1">linear_frequencies </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span>
            <span class="s1">zero</span><span class="s2">, </span><span class="s1">nyquist_hertz</span><span class="s2">, </span><span class="s1">num_spectrogram_bins</span>
        <span class="s2">)[</span><span class="s1">bands_to_zero</span><span class="s2">:]</span>
        <span class="s1">spectrogram_bins_mel </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_hertz_to_mel</span><span class="s2">(</span><span class="s1">linear_frequencies</span><span class="s2">), </span><span class="s4">1</span>
        <span class="s2">)</span>

        <span class="s3"># Compute num_mel_bins triples of (lower_edge, center, upper_edge). The</span>
        <span class="s3"># center of each band is the lower and upper edge of the adjacent bands.</span>
        <span class="s3"># Accordingly, we divide [lower_edge_hertz, upper_edge_hertz] into</span>
        <span class="s3"># num_mel_bins + 2 pieces.</span>
        <span class="s1">band_edges_mel </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">math</span><span class="s2">.</span><span class="s1">extract_sequences</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_hertz_to_mel</span><span class="s2">(</span><span class="s1">lower_edge_hertz</span><span class="s2">),</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_hertz_to_mel</span><span class="s2">(</span><span class="s1">upper_edge_hertz</span><span class="s2">),</span>
                <span class="s1">num_mel_bins </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">,</span>
            <span class="s2">),</span>
            <span class="s1">sequence_length</span><span class="s2">=</span><span class="s4">3</span><span class="s2">,</span>
            <span class="s1">sequence_stride</span><span class="s2">=</span><span class="s4">1</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s3"># Split the triples up and reshape them into [1, num_mel_bins] tensors.</span>
        <span class="s1">lower_edge_mel</span><span class="s2">, </span><span class="s1">center_mel</span><span class="s2">, </span><span class="s1">upper_edge_mel </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">num_mel_bins</span><span class="s2">])</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s1">band_edges_mel</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s3"># Calculate lower and upper slopes for every spectrogram bin.</span>
        <span class="s3"># Line segments are linear in the mel domain, not Hertz.</span>
        <span class="s1">lower_slopes </span><span class="s2">= (</span><span class="s1">spectrogram_bins_mel </span><span class="s2">- </span><span class="s1">lower_edge_mel</span><span class="s2">) / (</span>
            <span class="s1">center_mel </span><span class="s2">- </span><span class="s1">lower_edge_mel</span>
        <span class="s2">)</span>
        <span class="s1">upper_slopes </span><span class="s2">= (</span><span class="s1">upper_edge_mel </span><span class="s2">- </span><span class="s1">spectrogram_bins_mel</span><span class="s2">) / (</span>
            <span class="s1">upper_edge_mel </span><span class="s2">- </span><span class="s1">center_mel</span>
        <span class="s2">)</span>

        <span class="s3"># Intersect the line segments with each other and zero.</span>
        <span class="s1">mel_weights_matrix </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s1">zero</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">lower_slopes</span><span class="s2">, </span><span class="s1">upper_slopes</span><span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s3"># Re-add the zeroed lower bins we sliced out above.</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">pad</span><span class="s2">(</span>
            <span class="s1">mel_weights_matrix</span><span class="s2">,</span>
            <span class="s2">[[</span><span class="s1">bands_to_zero</span><span class="s2">, </span><span class="s4">0</span><span class="s2">], [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">]],</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compute_output_shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">input_shape</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">) == </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">output_shape </span><span class="s2">= [</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">num_mel_bins</span><span class="s2">,</span>
                <span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">input_shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">)</span>
                    <span class="s2">// </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride</span>
                    <span class="s0">if </span><span class="s1">input_shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] </span><span class="s0">is not None</span>
                    <span class="s0">else None</span>
                <span class="s2">),</span>
            <span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">output_shape </span><span class="s2">= [</span>
                <span class="s1">input_shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">],</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">num_mel_bins</span><span class="s2">,</span>
                <span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">input_shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">)</span>
                    <span class="s2">// </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride</span>
                    <span class="s0">if </span><span class="s1">input_shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] </span><span class="s0">is not None</span>
                    <span class="s0">else None</span>
                <span class="s2">),</span>
            <span class="s2">]</span>
        <span class="s0">return </span><span class="s1">output_shape</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">config </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">config</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span>
            <span class="s2">{</span>
                <span class="s5">&quot;fft_length&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fft_length</span><span class="s2">,</span>
                <span class="s5">&quot;sequence_stride&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_stride</span><span class="s2">,</span>
                <span class="s5">&quot;sequence_length&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sequence_length</span><span class="s2">,</span>
                <span class="s5">&quot;window&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">window</span><span class="s2">,</span>
                <span class="s5">&quot;sampling_rate&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sampling_rate</span><span class="s2">,</span>
                <span class="s5">&quot;num_mel_bins&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_mel_bins</span><span class="s2">,</span>
                <span class="s5">&quot;min_freq&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">min_freq</span><span class="s2">,</span>
                <span class="s5">&quot;max_freq&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_freq</span><span class="s2">,</span>
                <span class="s5">&quot;power_to_db&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">power_to_db</span><span class="s2">,</span>
                <span class="s5">&quot;top_db&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">top_db</span><span class="s2">,</span>
                <span class="s5">&quot;mag_exp&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mag_exp</span><span class="s2">,</span>
                <span class="s5">&quot;min_power&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">min_power</span><span class="s2">,</span>
                <span class="s5">&quot;ref_power&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ref_power</span><span class="s2">,</span>
            <span class="s2">}</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">config</span>
</pre>
</body>
</html>