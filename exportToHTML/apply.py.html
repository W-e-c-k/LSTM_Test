<html>
<head>
<title>apply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
apply.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_config </span><span class="s0">import </span><span class="s1">option_context</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">internals </span><span class="s0">import </span><span class="s1">BlockValuesRefs</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">AggFuncType</span><span class="s2">,</span>
    <span class="s1">AggFuncTypeBase</span><span class="s2">,</span>
    <span class="s1">AggFuncTypeDict</span><span class="s2">,</span>
    <span class="s1">AggObjType</span><span class="s2">,</span>
    <span class="s1">Axis</span><span class="s2">,</span>
    <span class="s1">AxisInt</span><span class="s2">,</span>
    <span class="s1">NDFrameT</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">compat</span><span class="s2">.</span><span class="s1">_optional </span><span class="s0">import </span><span class="s1">import_optional_dependency</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">SpecificationError</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">cast </span><span class="s0">import </span><span class="s1">is_nested_object</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">is_dict_like</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_sequence</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">CategoricalDtype</span><span class="s2">,</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCNDFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">_numba</span><span class="s2">.</span><span class="s1">executor </span><span class="s0">import </span><span class="s1">generate_apply_looper</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">construction </span><span class="s0">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Generator</span><span class="s2">,</span>
        <span class="s1">Hashable</span><span class="s2">,</span>
        <span class="s1">Iterable</span><span class="s2">,</span>
        <span class="s1">MutableMapping</span><span class="s2">,</span>
        <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">Index</span><span class="s2">,</span>
        <span class="s1">Series</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby </span><span class="s0">import </span><span class="s1">GroupBy</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">resample </span><span class="s0">import </span><span class="s1">Resampler</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">window</span><span class="s2">.</span><span class="s1">rolling </span><span class="s0">import </span><span class="s1">BaseWindow</span>


<span class="s1">ResType </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">frame_apply</span><span class="s2">(</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">Axis </span><span class="s2">= </span><span class="s3">0</span><span class="s2">,</span>
    <span class="s1">raw</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">result_type</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">by_row</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s0">False</span><span class="s2">, </span><span class="s4">&quot;compat&quot;</span><span class="s2">] = </span><span class="s4">&quot;compat&quot;</span><span class="s2">,</span>
    <span class="s1">engine</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s4">&quot;python&quot;</span><span class="s2">,</span>
    <span class="s1">engine_kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">args</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; FrameApply</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;construct and return a row or column based frame apply object&quot;&quot;&quot;</span>
    <span class="s1">axis </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_get_axis_number</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">klass</span><span class="s2">: </span><span class="s1">type</span><span class="s2">[</span><span class="s1">FrameApply</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s1">klass </span><span class="s2">= </span><span class="s1">FrameRowApply</span>
    <span class="s0">elif </span><span class="s1">axis </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s1">klass </span><span class="s2">= </span><span class="s1">FrameColumnApply</span>

    <span class="s1">_</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">reconstruct_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">func </span><span class="s0">is not None</span>

    <span class="s0">return </span><span class="s1">klass</span><span class="s2">(</span>
        <span class="s1">obj</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">,</span>
        <span class="s1">raw</span><span class="s2">=</span><span class="s1">raw</span><span class="s2">,</span>
        <span class="s1">result_type</span><span class="s2">=</span><span class="s1">result_type</span><span class="s2">,</span>
        <span class="s1">by_row</span><span class="s2">=</span><span class="s1">by_row</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">=</span><span class="s1">engine</span><span class="s2">,</span>
        <span class="s1">engine_kwargs</span><span class="s2">=</span><span class="s1">engine_kwargs</span><span class="s2">,</span>
        <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">Apply</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">):</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">AggObjType</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
        <span class="s1">raw</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">result_type</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">by_row</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s0">False</span><span class="s2">, </span><span class="s4">&quot;compat&quot;</span><span class="s2">, </span><span class="s4">&quot;_compat&quot;</span><span class="s2">] = </span><span class="s4">&quot;compat&quot;</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s4">&quot;python&quot;</span><span class="s2">,</span>
        <span class="s1">engine_kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">raw </span><span class="s2">= </span><span class="s1">raw</span>

        <span class="s0">assert </span><span class="s1">by_row </span><span class="s0">is False or </span><span class="s1">by_row </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;compat&quot;</span><span class="s2">, </span><span class="s4">&quot;_compat&quot;</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">by_row </span><span class="s2">= </span><span class="s1">by_row</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s2">= </span><span class="s1">args </span><span class="s0">or </span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs </span><span class="s2">= </span><span class="s1">kwargs </span><span class="s0">or </span><span class="s2">{}</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">= </span><span class="s1">engine</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">engine_kwargs </span><span class="s2">= {} </span><span class="s0">if </span><span class="s1">engine_kwargs </span><span class="s0">is None else </span><span class="s1">engine_kwargs</span>

        <span class="s0">if </span><span class="s1">result_type </span><span class="s0">not in </span><span class="s2">[</span><span class="s0">None</span><span class="s2">, </span><span class="s4">&quot;reduce&quot;</span><span class="s2">, </span><span class="s4">&quot;broadcast&quot;</span><span class="s2">, </span><span class="s4">&quot;expand&quot;</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;invalid value for result_type, must be one &quot;</span>
                <span class="s4">&quot;of {None, 'reduce', 'broadcast', 'expand'}&quot;</span>
            <span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s2">= </span><span class="s1">result_type</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">func </span><span class="s2">= </span><span class="s1">func</span>

    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">agg_or_apply_list_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">agg_or_apply_dict_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">agg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series </span><span class="s2">| </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Provide an implementation for the aggregators. 
 
        Returns 
        ------- 
        Result of aggregation, or None if agg cannot be performed by 
        this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_str</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_dict_like</span><span class="s2">()</span>
        <span class="s0">elif </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s6"># we require a list, but not a 'str'</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_list_like</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_cython_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">f </span><span class="s0">and not </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s1">warn_alias_replacement</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)()</span>

        <span class="s6"># caller can react</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Transform a DataFrame or Series. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Result of applying ``func`` along the given axis of the 
            Series or DataFrame. 
 
        Raises 
        ------ 
        ValueError 
            If the transform function fails or does not transform. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s1">is_series </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1</span>

        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_get_axis_number</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">assert not </span><span class="s1">is_series</span>
            <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">).</span><span class="s1">T</span>

        <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">list</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">], </span><span class="s1">func</span><span class="s2">)</span>
            <span class="s6"># Convert func equivalent dict</span>
            <span class="s0">if </span><span class="s1">is_series</span><span class="s2">:</span>
                <span class="s1">func </span><span class="s2">= {</span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">or </span><span class="s1">v</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func</span><span class="s2">}</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">func </span><span class="s2">= {</span><span class="s1">col</span><span class="s2">: </span><span class="s1">func </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">obj</span><span class="s2">}</span>

        <span class="s0">if </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">AggFuncTypeDict</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transform_dict_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s6"># func is either str or callable</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">AggFuncTypeBase</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">transform_str_or_callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Transform function failed&quot;</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s6"># Functions that transform may return empty Series/DataFrame</span>
        <span class="s6"># when the dtype is not appropriate</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, (</span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s1">result</span><span class="s2">.</span><span class="s1">empty</span>
            <span class="s0">and not </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">empty</span>
        <span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Transform function failed&quot;</span><span class="s2">)</span>
        <span class="s6"># error: Argument 1 to &quot;__get__&quot; of &quot;AxisProperty&quot; has incompatible type</span>
        <span class="s6"># &quot;Union[Series, DataFrame, GroupBy[Any], SeriesGroupBy,</span>
        <span class="s6"># DataFrameGroupBy, BaseWindow, Resampler]&quot;; expected &quot;Union[DataFrame,</span>
        <span class="s6"># Series]&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, (</span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">)) </span><span class="s0">or not </span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">equals</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">index  </span><span class="s6"># type: ignore[arg-type]</span>
        <span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Function did not transform&quot;</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">transform_dict_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute transform in the case of a dict-like func 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">.</span><span class="s1">concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s6"># transform is currently only for Series/DataFrame</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCNDFrame</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">func</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;No transform functions were provided&quot;</span><span class="s2">)</span>

        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">normalize_dictlike_arg</span><span class="s2">(</span><span class="s4">&quot;transform&quot;</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>

        <span class="s1">results</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">] = {}</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">colg </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">results</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">colg</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">concat</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">transform_str_or_callable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute transform in the case of a string or callable func 
        &quot;&quot;&quot;</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_str</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_cython_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">f</span><span class="s2">:</span>
                <span class="s1">warn_alias_replacement</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)()</span>

        <span class="s6"># Two possible ways to use a UDF - apply or call directly</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">agg_list_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute aggregation in the case of a list-like argument. 
 
        Returns 
        ------- 
        Result of aggregation. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_or_apply_list_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">=</span><span class="s4">&quot;agg&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compute_list_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">],</span>
        <span class="s1">selected_obj</span><span class="s2">: </span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">] | </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute agg/apply results for like-like input. 
 
        Parameters 
        ---------- 
        op_name : {&quot;agg&quot;, &quot;apply&quot;} 
            Operation being performed. 
        selected_obj : Series or DataFrame 
            Data to perform operation on. 
        kwargs : dict 
            Keyword arguments to pass to the functions. 
 
        Returns 
        ------- 
        keys : list[Hashable] or Index 
            Index labels for result. 
        results : list 
            Data for result. When aggregating with a Series, this can contain any 
            Python objects. 
        &quot;&quot;&quot;</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">list</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s1">results </span><span class="s2">= []</span>
        <span class="s1">keys </span><span class="s2">= []</span>

        <span class="s6"># degenerate case</span>
        <span class="s0">if </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">func</span><span class="s2">:</span>
                <span class="s1">colg </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">=</span><span class="s1">selected_obj</span><span class="s2">)</span>
                <span class="s1">args </span><span class="s2">= (</span>
                    <span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">]</span>
                    <span class="s0">if </span><span class="s1">include_axis</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">colg</span><span class="s2">)</span>
                    <span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
                <span class="s2">)</span>
                <span class="s1">new_res </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">colg</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)(</span><span class="s1">a</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">new_res</span><span class="s2">)</span>

                <span class="s6"># make sure we find a good name</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">or </span><span class="s1">a</span>
                <span class="s1">keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">):</span>
                <span class="s1">colg </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">col</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">=</span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">iloc</span><span class="s2">[:, </span><span class="s1">index</span><span class="s2">])</span>
                <span class="s1">args </span><span class="s2">= (</span>
                    <span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">]</span>
                    <span class="s0">if </span><span class="s1">include_axis</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">colg</span><span class="s2">)</span>
                    <span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
                <span class="s2">)</span>
                <span class="s1">new_res </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">colg</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)(</span><span class="s1">func</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">new_res</span><span class="s2">)</span>
                <span class="s1">indices</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">index</span><span class="s2">)</span>
            <span class="s6"># error: Incompatible types in assignment (expression has type &quot;Any |</span>
            <span class="s6"># Index&quot;, variable has type &quot;list[Any | Callable[..., Any] | str]&quot;)</span>
            <span class="s1">keys </span><span class="s2">= </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)  </span><span class="s6"># type: ignore[assignment]</span>

        <span class="s0">return </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">results</span>

    <span class="s0">def </span><span class="s1">wrap_results_list_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">], </span><span class="s1">results</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">]</span>
    <span class="s2">):</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">.</span><span class="s1">concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">concat</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">=</span><span class="s1">keys</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s6"># we are concatting non-NDFrame objects,</span>
            <span class="s6"># e.g. a list of scalars</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

            <span class="s1">result </span><span class="s2">= </span><span class="s1">Series</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">keys</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">is_nested_object</span><span class="s2">(</span><span class="s1">result</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">&quot;cannot combine transform and aggregation operations&quot;</span>
                <span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">agg_dict_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute aggregation in the case of a dict-like argument. 
 
        Returns 
        ------- 
        Result of aggregation. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_or_apply_dict_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">=</span><span class="s4">&quot;agg&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compute_dict_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">],</span>
        <span class="s1">selected_obj</span><span class="s2">: </span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">selection</span><span class="s2">: </span><span class="s1">Hashable </span><span class="s2">| </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">],</span>
        <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">], </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute agg/apply results for dict-like input. 
 
        Parameters 
        ---------- 
        op_name : {&quot;agg&quot;, &quot;apply&quot;} 
            Operation being performed. 
        selected_obj : Series or DataFrame 
            Data to perform operation on. 
        selection : hashable or sequence of hashables 
            Used by GroupBy, Window, and Resample if selection is applied to the object. 
        kwargs : dict 
            Keyword arguments to pass to the functions. 
 
        Returns 
        ------- 
        keys : list[hashable] 
            Index labels for result. 
        results : list 
            Data for result. When aggregating with a Series, this can contain any 
            Python object. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
            <span class="s1">DataFrameGroupBy</span><span class="s2">,</span>
            <span class="s1">SeriesGroupBy</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">is_groupby </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span><span class="s1">DataFrameGroupBy</span><span class="s2">, </span><span class="s1">SeriesGroupBy</span><span class="s2">))</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">AggFuncTypeDict</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">normalize_dictlike_arg</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">selected_obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>

        <span class="s1">is_non_unique_col </span><span class="s2">= (</span>
            <span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">2</span>
            <span class="s0">and </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">nunique</span><span class="s2">() &lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s6"># key only used for output</span>
            <span class="s1">colg </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">selection</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">results </span><span class="s2">= [</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">colg</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()]</span>
            <span class="s1">keys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">func</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s0">elif not </span><span class="s1">is_groupby </span><span class="s0">and </span><span class="s1">is_non_unique_col</span><span class="s2">:</span>
            <span class="s6"># key used for column selection and output</span>
            <span class="s6"># GH#51099</span>
            <span class="s1">results </span><span class="s2">= []</span>
            <span class="s1">keys </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s1">indices </span><span class="s2">= </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">get_indexer_for</span><span class="s2">([</span><span class="s1">key</span><span class="s2">])</span>
                <span class="s1">labels </span><span class="s2">= </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
                <span class="s1">label_to_indices </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">):</span>
                    <span class="s1">label_to_indices</span><span class="s2">[</span><span class="s1">label</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">index</span><span class="s2">)</span>

                <span class="s1">key_data </span><span class="s2">= [</span>
                    <span class="s1">getattr</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">_ixs</span><span class="s2">(</span><span class="s1">indice</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">), </span><span class="s1">op_name</span><span class="s2">)(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">indices </span><span class="s0">in </span><span class="s1">label_to_indices</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                    <span class="s0">for </span><span class="s1">indice </span><span class="s0">in </span><span class="s1">indices</span>
                <span class="s2">]</span>

                <span class="s1">keys </span><span class="s2">+= [</span><span class="s1">key</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">key_data</span><span class="s2">)</span>
                <span class="s1">results </span><span class="s2">+= </span><span class="s1">key_data</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s6"># key used for column selection and output</span>
            <span class="s1">results </span><span class="s2">= [</span>
                <span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">1</span><span class="s2">), </span><span class="s1">op_name</span><span class="s2">)(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">how </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
            <span class="s2">]</span>
            <span class="s1">keys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">func</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>

        <span class="s0">return </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">results</span>

    <span class="s0">def </span><span class="s1">wrap_results_dict_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">selected_obj</span><span class="s2">: </span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">result_index</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">],</span>
        <span class="s1">result_data</span><span class="s2">: </span><span class="s1">list</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Index</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">.</span><span class="s1">concat </span><span class="s0">import </span><span class="s1">concat</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s6"># Avoid making two isinstance calls in all and any below</span>
        <span class="s1">is_ndframe </span><span class="s2">= [</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">ABCNDFrame</span><span class="s2">) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">result_data</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">is_ndframe</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">result_index</span><span class="s2">, </span><span class="s1">result_data</span><span class="s2">))</span>
            <span class="s1">keys_to_use</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">]</span>
            <span class="s1">keys_to_use </span><span class="s2">= [</span><span class="s1">k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">result_index </span><span class="s0">if not </span><span class="s1">results</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">empty</span><span class="s2">]</span>
            <span class="s6"># Have to check, if at least one DataFrame is not empty.</span>
            <span class="s1">keys_to_use </span><span class="s2">= </span><span class="s1">keys_to_use </span><span class="s0">if </span><span class="s1">keys_to_use </span><span class="s2">!= [] </span><span class="s0">else </span><span class="s1">result_index</span>
            <span class="s0">if </span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">2</span><span class="s2">:</span>
                <span class="s6"># keys are columns, so we can preserve names</span>
                <span class="s1">ktu </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">keys_to_use</span><span class="s2">)</span>
                <span class="s1">ktu</span><span class="s2">.</span><span class="s1">_set_names</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">names</span><span class="s2">)</span>
                <span class="s1">keys_to_use </span><span class="s2">= </span><span class="s1">ktu</span>

            <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s3">0 </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">) </span><span class="s0">else </span><span class="s3">1</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">concat</span><span class="s2">(</span>
                <span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">results</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">keys_to_use</span><span class="s2">},</span>
                <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
                <span class="s1">keys</span><span class="s2">=</span><span class="s1">keys_to_use</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">any</span><span class="s2">(</span><span class="s1">is_ndframe</span><span class="s2">):</span>
            <span class="s6"># There is a mix of NDFrames and scalars</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;cannot perform both aggregation &quot;</span>
                <span class="s4">&quot;and transformation operations &quot;</span>
                <span class="s4">&quot;simultaneously&quot;</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

            <span class="s6"># we have a list of scalars</span>
            <span class="s6"># GH 36212 use name only if obj is a series</span>
            <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s4">&quot;Series&quot;</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">)</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">name</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s0">None</span>

            <span class="s1">result </span><span class="s2">= </span><span class="s1">Series</span><span class="s2">(</span><span class="s1">result_data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">result_index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute apply in case of a string. 
 
        Returns 
        ------- 
        result: Series or DataFrame 
        &quot;&quot;&quot;</span>
        <span class="s6"># Caller is responsible for checking isinstance(self.f, str)</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">str</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
            <span class="s1">DataFrameGroupBy</span><span class="s2">,</span>
            <span class="s1">SeriesGroupBy</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s6"># Support for `frame.transform('method')`</span>
        <span class="s6"># Some methods (shift, etc.) require the axis argument, others</span>
        <span class="s6"># don't, so inspect and insert if necessary.</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">method</span><span class="s2">):</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getfullargspec</span><span class="s2">(</span><span class="s1">method</span><span class="s2">)</span>
            <span class="s1">arg_names </span><span class="s2">= (*</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, *</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">kwonlyargs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">!= </span><span class="s3">0 </span><span class="s0">and </span><span class="s2">(</span>
                <span class="s4">&quot;axis&quot; </span><span class="s0">not in </span><span class="s1">arg_names </span><span class="s0">or </span><span class="s1">func </span><span class="s0">in </span><span class="s2">(</span><span class="s4">&quot;corrwith&quot;</span><span class="s2">, </span><span class="s4">&quot;skew&quot;</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Operation </span><span class="s0">{</span><span class="s1">func</span><span class="s0">} </span><span class="s4">does not support axis=1&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s4">&quot;axis&quot; </span><span class="s0">in </span><span class="s1">arg_names</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span><span class="s1">SeriesGroupBy</span><span class="s2">, </span><span class="s1">DataFrameGroupBy</span><span class="s2">)):</span>
                    <span class="s6"># Try to avoid FutureWarning for deprecated axis keyword;</span>
                    <span class="s6"># If self.axis matches the axis we would get by not passing</span>
                    <span class="s6">#  axis, we safely exclude the keyword.</span>

                    <span class="s1">default_axis </span><span class="s2">= </span><span class="s3">0</span>
                    <span class="s0">if </span><span class="s1">func </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;idxmax&quot;</span><span class="s2">, </span><span class="s4">&quot;idxmin&quot;</span><span class="s2">]:</span>
                        <span class="s6"># DataFrameGroupBy.idxmax, idxmin axis defaults to self.axis,</span>
                        <span class="s6"># whereas other axis keywords default to 0</span>
                        <span class="s1">default_axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">axis</span>

                    <span class="s0">if </span><span class="s1">default_axis </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">[</span><span class="s4">&quot;axis&quot;</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">[</span><span class="s4">&quot;axis&quot;</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_str</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply_list_or_dict_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute apply in case of a list-like or dict-like. 
 
        Returns 
        ------- 
        result: Series, DataFrame, or None 
            Result when self.func is a list-like or dict-like, None otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s4">&quot;The 'numba' engine doesn't support list-like/&quot;</span>
                <span class="s4">&quot;dict likes of callables yet.&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">== </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">).</span><span class="s1">T</span>

        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s0">if </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_or_apply_dict_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">=</span><span class="s4">&quot;apply&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_or_apply_list_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">=</span><span class="s4">&quot;apply&quot;</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">reconstruct_and_relabel_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">normalize_dictlike_arg</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">how</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">, </span><span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncTypeDict</span>
    <span class="s2">) </span><span class="s1">-&gt; AggFuncTypeDict</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Handler for dict-like argument. 
 
        Ensures that necessary columns exist if obj is a DataFrame, and 
        that a nested renamer is not passed. Also normalizes to all lists 
        when values consists of a mix of list and non-lists. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">how </span><span class="s0">in </span><span class="s2">(</span><span class="s4">&quot;apply&quot;</span><span class="s2">, </span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;transform&quot;</span><span class="s2">)</span>

        <span class="s6"># Can't use func.values(); wouldn't work for a Series</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">how </span><span class="s2">== </span><span class="s4">&quot;agg&quot;</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">any</span><span class="s2">(</span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s2">) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">any</span><span class="s2">(</span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())):</span>
            <span class="s6"># GH 15931 - deprecation of renaming keys</span>
            <span class="s0">raise </span><span class="s1">SpecificationError</span><span class="s2">(</span><span class="s4">&quot;nested renamer is not supported&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s6"># Check for missing columns on a frame</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Index</span>

            <span class="s1">cols </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">func</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())).</span><span class="s1">difference</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">cols</span><span class="s2">) &gt; </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s4">f&quot;Column(s) </span><span class="s0">{</span><span class="s1">list</span><span class="s2">(</span><span class="s1">cols</span><span class="s2">)</span><span class="s0">} </span><span class="s4">do not exist&quot;</span><span class="s2">)</span>

        <span class="s1">aggregator_types </span><span class="s2">= (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">)</span>

        <span class="s6"># if we have a dict of any non-scalars</span>
        <span class="s6"># eg. {'A' : ['mean']}, normalize all to</span>
        <span class="s6"># be list-likes</span>
        <span class="s6"># Cannot use func.values() because arg may be a Series</span>
        <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">aggregator_types</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
            <span class="s1">new_func</span><span class="s2">: </span><span class="s1">AggFuncTypeDict </span><span class="s2">= {}</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">aggregator_types</span><span class="s2">):</span>
                    <span class="s1">new_func</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = [</span><span class="s1">v</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_func</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">v</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">new_func</span>
        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">def </span><span class="s1">_apply_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        if arg is a string, then try to operate on it: 
        - try to find a function (or attribute) on obj 
        - try to find a numpy function 
        - raise 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">f</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">f</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s6"># people may aggregate on a non-callable attribute</span>
            <span class="s6"># but don't let them think they can pass args to it</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s3">0</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">([</span><span class="s1">kwarg </span><span class="s0">for </span><span class="s1">kwarg </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">if </span><span class="s1">kwarg </span><span class="s0">not in </span><span class="s2">[</span><span class="s4">&quot;axis&quot;</span><span class="s2">]]) == </span><span class="s3">0</span>
            <span class="s0">return </span><span class="s1">f</span>
        <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">func</span><span class="s2">) </span><span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;__array__&quot;</span><span class="s2">):</span>
            <span class="s6"># in particular exclude Window</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">f</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">f&quot;'</span><span class="s0">{</span><span class="s1">func</span><span class="s0">}</span><span class="s4">' is not a valid function for '</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">' object&quot;</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NDFrameApply</span><span class="s2">(</span><span class="s1">Apply</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Methods shared by FrameApply and SeriesApply but 
    not GroupByApply or ResamplerWindowApply 
    &quot;&quot;&quot;</span>

    <span class="s1">obj</span><span class="s2">: </span><span class="s1">DataFrame </span><span class="s2">| </span><span class="s1">Series</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">agg_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_get_agg_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">agg_or_apply_list_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>

        <span class="s0">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s4">&quot;apply&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">FrameApply</span><span class="s2">):</span>
                <span class="s1">by_row </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row</span>

            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">SeriesApply</span><span class="s2">):</span>
                <span class="s1">by_row </span><span class="s2">= </span><span class="s4">&quot;_compat&quot; </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row </span><span class="s0">else False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">by_row </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">kwargs </span><span class="s2">= {**</span><span class="s1">kwargs</span><span class="s2">, </span><span class="s4">&quot;by_row&quot;</span><span class="s2">: </span><span class="s1">by_row</span><span class="s2">}</span>

        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;axis other than 0 is not supported&quot;</span><span class="s2">)</span>

        <span class="s1">keys</span><span class="s2">, </span><span class="s1">results </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_list_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results_list_like</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">, </span><span class="s1">results</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">agg_or_apply_dict_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s1">kwargs </span><span class="s2">= {}</span>
        <span class="s0">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s4">&quot;apply&quot;</span><span class="s2">:</span>
            <span class="s1">by_row </span><span class="s2">= </span><span class="s4">&quot;_compat&quot; </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row </span><span class="s0">else False</span>
            <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s4">&quot;by_row&quot;</span><span class="s2">: </span><span class="s1">by_row</span><span class="s2">})</span>

        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;axis other than 0 is not supported&quot;</span><span class="s2">)</span>

        <span class="s1">selection </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">result_index</span><span class="s2">, </span><span class="s1">result_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dict_like</span><span class="s2">(</span>
            <span class="s1">op_name</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">selection</span><span class="s2">, </span><span class="s1">kwargs</span>
        <span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results_dict_like</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">result_index</span><span class="s2">, </span><span class="s1">result_data</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">FrameApply</span><span class="s2">(</span><span class="s1">NDFrameApply</span><span class="s2">):</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">DataFrame</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">AggObjType</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
        <span class="s1">raw</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">result_type</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">by_row</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s0">False</span><span class="s2">, </span><span class="s4">&quot;compat&quot;</span><span class="s2">] = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s4">&quot;python&quot;</span><span class="s2">,</span>
        <span class="s1">engine_kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">by_row </span><span class="s0">is not False and </span><span class="s1">by_row </span><span class="s2">!= </span><span class="s4">&quot;compat&quot;</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;by_row=</span><span class="s0">{</span><span class="s1">by_row</span><span class="s0">} </span><span class="s4">not allowed&quot;</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">raw</span><span class="s2">,</span>
            <span class="s1">result_type</span><span class="s2">,</span>
            <span class="s1">by_row</span><span class="s2">=</span><span class="s1">by_row</span><span class="s2">,</span>
            <span class="s1">engine</span><span class="s2">=</span><span class="s1">engine</span><span class="s2">,</span>
            <span class="s1">engine_kwargs</span><span class="s2">=</span><span class="s1">engine_kwargs</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s6"># ---------------------------------------------------------------</span>
    <span class="s6"># Abstract Methods</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">result_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">result_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">series_generator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Generator</span><span class="s2">[</span><span class="s1">Series</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">cache</span>
    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">generate_numba_apply_func</span><span class="s2">(</span>
        <span class="s1">func</span><span class="s2">, </span><span class="s1">nogil</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">parallel</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">apply_with_numba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">validate_values_for_numba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Validate column dtyps all OK</span>
        <span class="s0">for </span><span class="s1">colname</span><span class="s2">, </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if not </span><span class="s1">is_numeric_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">f&quot;Column </span><span class="s0">{</span><span class="s1">colname</span><span class="s0">} </span><span class="s4">must have a numeric dtype. &quot;</span>
                    <span class="s4">f&quot;Found '</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">' instead&quot;</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">is_extension_array_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">f&quot;Column </span><span class="s0">{</span><span class="s1">colname</span><span class="s0">} </span><span class="s4">is backed by an extension array, &quot;</span>
                    <span class="s4">f&quot;which is not supported by the numba engine.&quot;</span>
                <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">wrap_results_for_axis</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">: </span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">: </span><span class="s1">Index</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s6"># ---------------------------------------------------------------</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">res_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_columns</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">columns</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;compute the results&quot;&quot;&quot;</span>

        <span class="s6"># dispatch to handle list-like or dict-like</span>
        <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s4">&quot;the 'numba' engine doesn't support lists of callables yet&quot;</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_list_or_dict_like</span><span class="s2">()</span>

        <span class="s6"># all empty</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">) == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_empty_result</span><span class="s2">()</span>

        <span class="s6"># string dispatch</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s4">&quot;the 'numba' engine doesn't support using &quot;</span>
                    <span class="s4">&quot;a string as the callable function&quot;</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_str</span><span class="s2">()</span>

        <span class="s6"># ufunc</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s4">&quot;the 'numba' engine doesn't support &quot;</span>
                    <span class="s4">&quot;using a numpy ufunc as the callable function&quot;</span>
                <span class="s2">)</span>
            <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">all</span><span class="s2">=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">):</span>
                <span class="s1">results </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_mgr</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s4">&quot;apply&quot;</span><span class="s2">, </span><span class="s1">func</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s6"># _constructor will retain self.index and self.columns</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_from_mgr</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s1">results</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>

        <span class="s6"># broadcasting</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s2">== </span><span class="s4">&quot;broadcast&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s4">&quot;the 'numba' engine doesn't support result_type='broadcast'&quot;</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_broadcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">)</span>

        <span class="s6"># one axis empty</span>
        <span class="s0">elif not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_empty_result</span><span class="s2">()</span>

        <span class="s6"># raw</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">raw</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_raw</span><span class="s2">(</span><span class="s1">engine</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine_kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_standard</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">agg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span>

        <span class="s6"># TODO: Avoid having to change state</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">== </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s3">0</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">agg</span><span class="s2">()</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>

        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T </span><span class="s0">if </span><span class="s1">result </span><span class="s0">is not None else </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_empty_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        we have an empty result; at least 1 axis is 0 
 
        we will try to apply the function to an empty 
        series in order to see if this is a reduction function 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s6"># we are not asked to reduce or infer reduction</span>
        <span class="s6"># so just return a copy of the existing object</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s0">not in </span><span class="s2">[</span><span class="s4">&quot;reduce&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s6"># we may need to infer</span>
        <span class="s1">should_reduce </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s2">== </span><span class="s4">&quot;reduce&quot;</span>

        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s0">if not </span><span class="s1">should_reduce</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span>
                        <span class="s1">Series</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span>
                        <span class="s1">Series</span><span class="s2">(</span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),</span>
                        <span class="s2">*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">,</span>
                        <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">,</span>
                    <span class="s2">)</span>
            <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">should_reduce </span><span class="s2">= </span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">Series</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">should_reduce</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_axis</span><span class="s2">):</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span><span class="s1">Series</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>

            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_axis</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">apply_raw</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">=</span><span class="s4">&quot;python&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;apply to the values as a numpy array&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">wrap_function</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Wrap user supplied function to work around numpy issue. 
 
            see https://github.com/numpy/numpy/issues/8352 
            &quot;&quot;&quot;</span>

            <span class="s0">def </span><span class="s1">wrapper</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">result</span>

            <span class="s0">return </span><span class="s1">wrapper</span>

        <span class="s0">if </span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;numba&quot;</span><span class="s2">:</span>
            <span class="s1">engine_kwargs </span><span class="s2">= {} </span><span class="s0">if </span><span class="s1">engine_kwargs </span><span class="s0">is None else </span><span class="s1">engine_kwargs</span>

            <span class="s6"># error: Argument 1 to &quot;__call__&quot; of &quot;_lru_cache_wrapper&quot; has</span>
            <span class="s6"># incompatible type &quot;Callable[..., Any] | str | list[Callable</span>
            <span class="s6"># [..., Any] | str] | dict[Hashable,Callable[..., Any] | str |</span>
            <span class="s6"># list[Callable[..., Any] | str]]&quot;; expected &quot;Hashable&quot;</span>
            <span class="s1">nb_looper </span><span class="s2">= </span><span class="s1">generate_apply_looper</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, **</span><span class="s1">engine_kwargs  </span><span class="s6"># type: ignore[arg-type]</span>
            <span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">nb_looper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s6"># If we made the result 2-D, squeeze it back to 1-D</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">apply_along_axis</span><span class="s2">(</span>
                <span class="s1">wrap_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">),</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
                <span class="s2">*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">,</span>
                <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s6"># TODO: mixed type case</span>
        <span class="s0">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">2</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply_broadcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">: </span><span class="s1">DataFrame</span><span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s1">result_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

        <span class="s6"># axis which we want to compare compliance</span>
        <span class="s1">result_compare </span><span class="s2">= </span><span class="s1">target</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">):</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span><span class="s1">target</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">ares </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">res</span><span class="s2">).</span><span class="s1">ndim</span>

            <span class="s6"># must be a scalar or 1d</span>
            <span class="s0">if </span><span class="s1">ares </span><span class="s2">&gt; </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;too many dims to broadcast&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">ares </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s6"># must match return dim</span>
                <span class="s0">if </span><span class="s1">result_compare </span><span class="s2">!= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">res</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;cannot broadcast result&quot;</span><span class="s2">)</span>

            <span class="s1">result_values</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] = </span><span class="s1">res</span>

        <span class="s6"># we *always* preserve the original index / columns</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span>
            <span class="s1">result_values</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">target</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">=</span><span class="s1">target</span><span class="s2">.</span><span class="s1">columns</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_standard</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine </span><span class="s2">== </span><span class="s4">&quot;python&quot;</span><span class="s2">:</span>
            <span class="s1">results</span><span class="s2">, </span><span class="s1">res_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_series_generator</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">results</span><span class="s2">, </span><span class="s1">res_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_series_numba</span><span class="s2">()</span>

        <span class="s6"># wrap results</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply_series_generator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">]:</span>
        <span class="s0">assert </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s1">series_gen </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">series_generator</span>
        <span class="s1">res_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_index</span>

        <span class="s1">results </span><span class="s2">= {}</span>

        <span class="s0">with </span><span class="s1">option_context</span><span class="s2">(</span><span class="s4">&quot;mode.chained_assignment&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">series_gen</span><span class="s2">):</span>
                <span class="s6"># ignore SettingWithCopy here in case the user mutates</span>
                <span class="s1">results</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">results</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">ABCSeries</span><span class="s2">):</span>
                    <span class="s6"># If we have a view on v, we need to make a copy because</span>
                    <span class="s6">#  series_generator will swap out the underlying data</span>
                    <span class="s1">results</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">results</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">results</span><span class="s2">, </span><span class="s1">res_index</span>

    <span class="s0">def </span><span class="s1">apply_series_numba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine_kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;parallel&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s4">&quot;Parallel apply is not supported when raw=False and engine='numba'&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">is_unique </span><span class="s0">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">.</span><span class="s1">is_unique</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s4">&quot;The index/columns must be unique when raw=False and engine='numba'&quot;</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">validate_values_for_numba</span><span class="s2">()</span>
        <span class="s1">results </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_with_numba</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">results</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_index</span>

    <span class="s0">def </span><span class="s1">wrap_results</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">: </span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s6"># see if we can infer the results</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">results</span><span class="s2">) &gt; </span><span class="s3">0 </span><span class="s0">and </span><span class="s3">0 </span><span class="s0">in </span><span class="s1">results </span><span class="s0">and </span><span class="s1">is_sequence</span><span class="s2">(</span><span class="s1">results</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results_for_axis</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">)</span>

        <span class="s6"># dict of scalars</span>

        <span class="s6"># the default dtype of an empty Series is `object`, but this</span>
        <span class="s6"># code can be hit by df.mean() where the result should have dtype</span>
        <span class="s6"># float64 even if it's an empty Series.</span>
        <span class="s1">constructor_sliced </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">results</span><span class="s2">) == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">constructor_sliced </span><span class="s0">is </span><span class="s1">Series</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s6"># Caller is responsible for checking isinstance(self.func, str)</span>
        <span class="s6"># TODO: GH#39993 - Avoid special-casing by replacing with lambda</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func </span><span class="s2">== </span><span class="s4">&quot;size&quot;</span><span class="s2">:</span>
            <span class="s6"># Special-cased because DataFrame.size returns a single scalar</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">agg_axis</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">apply_str</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">FrameRowApply</span><span class="s2">(</span><span class="s1">FrameApply</span><span class="s2">):</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s3">0</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">series_generator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Generator</span><span class="s2">[</span><span class="s1">Series</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_ixs</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">)))</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">cache</span>
    <span class="s0">def </span><span class="s1">generate_numba_apply_func</span><span class="s2">(</span>
        <span class="s1">func</span><span class="s2">, </span><span class="s1">nogil</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">parallel</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s1">numba </span><span class="s2">= </span><span class="s1">import_optional_dependency</span><span class="s2">(</span><span class="s4">&quot;numba&quot;</span><span class="s2">)</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s6"># Import helper from extensions to cast string object -&gt; np strings</span>
        <span class="s6"># Note: This also has the side effect of loading our numba extensions</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">_numba</span><span class="s2">.</span><span class="s1">extensions </span><span class="s0">import </span><span class="s1">maybe_cast_str</span>

        <span class="s1">jitted_udf </span><span class="s2">= </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">extending</span><span class="s2">.</span><span class="s1">register_jitable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s6"># Currently the parallel argument doesn't get passed through here</span>
        <span class="s6"># (it's disabled) since the dicts in numba aren't thread-safe.</span>
        <span class="s2">@</span><span class="s1">numba</span><span class="s2">.</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nogil</span><span class="s2">=</span><span class="s1">nogil</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s1">nopython</span><span class="s2">, </span><span class="s1">parallel</span><span class="s2">=</span><span class="s1">parallel</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">numba_func</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">col_names</span><span class="s2">, </span><span class="s1">df_index</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= {}</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]):</span>
                <span class="s6"># Create the series</span>
                <span class="s1">ser </span><span class="s2">= </span><span class="s1">Series</span><span class="s2">(</span>
                    <span class="s1">values</span><span class="s2">[:, </span><span class="s1">j</span><span class="s2">], </span><span class="s1">index</span><span class="s2">=</span><span class="s1">df_index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">maybe_cast_str</span><span class="s2">(</span><span class="s1">col_names</span><span class="s2">[</span><span class="s1">j</span><span class="s2">])</span>
                <span class="s2">)</span>
                <span class="s1">results</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">jitted_udf</span><span class="s2">(</span><span class="s1">ser</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">results</span>

        <span class="s0">return </span><span class="s1">numba_func</span>

    <span class="s0">def </span><span class="s1">apply_with_numba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
        <span class="s1">nb_func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">generate_numba_apply_func</span><span class="s2">(</span>
            <span class="s1">cast</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">), **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine_kwargs</span>
        <span class="s2">)</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">_numba</span><span class="s2">.</span><span class="s1">extensions </span><span class="s0">import </span><span class="s1">set_numba_data</span>

        <span class="s1">index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span>
        <span class="s0">if </span><span class="s1">index</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s4">&quot;string&quot;</span><span class="s2">:</span>
            <span class="s1">index </span><span class="s2">= </span><span class="s1">index</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>

        <span class="s1">columns </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">columns</span>
        <span class="s0">if </span><span class="s1">columns</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s4">&quot;string&quot;</span><span class="s2">:</span>
            <span class="s1">columns </span><span class="s2">= </span><span class="s1">columns</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>

        <span class="s6"># Convert from numba dict to regular dict</span>
        <span class="s6"># Our isinstance checks in the df constructor don't pass for numbas typed dict</span>
        <span class="s0">with </span><span class="s1">set_numba_data</span><span class="s2">(</span><span class="s1">index</span><span class="s2">) </span><span class="s0">as </span><span class="s1">index</span><span class="s2">, </span><span class="s1">set_numba_data</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">) </span><span class="s0">as </span><span class="s1">columns</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">nb_func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">result_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">result_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span>

    <span class="s0">def </span><span class="s1">wrap_results_for_axis</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">: </span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">: </span><span class="s1">Index</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return the results for the rows&quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s2">== </span><span class="s4">&quot;reduce&quot;</span><span class="s2">:</span>
            <span class="s6"># e.g. test_apply_dict GH#8735</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s0">is None and </span><span class="s1">all</span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">results</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s2">):</span>
            <span class="s6"># Our operation was a to_dict op e.g.</span>
            <span class="s6">#  test_apply_dict GH#8735, test_apply_reduce_to_dict GH#25196 #37544</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=</span><span class="s1">results</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s4">&quot;All arrays must be of the same length&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">err</span><span class="s2">):</span>
                <span class="s6"># e.g. result = [[2, 3], [1.5], ['foo', 'bar']]</span>
                <span class="s6">#  see test_agg_listlike_result GH#29587</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>
                <span class="s1">res</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>
                <span class="s0">return </span><span class="s1">res</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise</span>

        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">results</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">ABCSeries</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">res_columns</span><span class="s2">):</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">res_columns</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">res_index</span><span class="s2">):</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">columns </span><span class="s2">= </span><span class="s1">res_index</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">FrameColumnApply</span><span class="s2">(</span><span class="s1">FrameApply</span><span class="s2">):</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">apply_broadcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">: </span><span class="s1">DataFrame</span><span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">apply_broadcast</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">series_generator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Generator</span><span class="s2">[</span><span class="s1">Series</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">) &gt; </span><span class="s3">0</span>

        <span class="s6"># We create one Series object, and will swap out the data inside</span>
        <span class="s6">#  of it.  Kids: don't do this at home.</span>
        <span class="s1">ser </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_ixs</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>
        <span class="s1">mgr </span><span class="s2">= </span><span class="s1">ser</span><span class="s2">.</span><span class="s1">_mgr</span>

        <span class="s1">is_view </span><span class="s2">= </span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">].</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">()  </span><span class="s6"># type: ignore[union-attr]</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ser</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
            <span class="s6"># values will be incorrect for this block</span>
            <span class="s6"># TODO(EA2D): special case would be unnecessary with 2D EAs</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)):</span>
                <span class="s0">yield </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_ixs</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">):</span>
                <span class="s6"># GH#35462 re-pin mgr in case setitem changed it</span>
                <span class="s1">ser</span><span class="s2">.</span><span class="s1">_mgr </span><span class="s2">= </span><span class="s1">mgr</span>
                <span class="s1">mgr</span><span class="s2">.</span><span class="s1">set_values</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
                <span class="s1">object</span><span class="s2">.</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">ser</span><span class="s2">, </span><span class="s4">&quot;_name&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
                <span class="s0">if not </span><span class="s1">is_view</span><span class="s2">:</span>
                    <span class="s6"># In apply_series_generator we store the a shallow copy of the</span>
                    <span class="s6"># result, which potentially increases the ref count of this reused</span>
                    <span class="s6"># `ser` object (depending on the result of the applied function)</span>
                    <span class="s6"># -&gt; if that happened and `ser` is already a copy, then we reset</span>
                    <span class="s6"># the refs here to avoid triggering a unnecessary CoW inside the</span>
                    <span class="s6"># applied function (https://github.com/pandas-dev/pandas/pull/56212)</span>
                    <span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">].</span><span class="s1">refs </span><span class="s2">= </span><span class="s1">BlockValuesRefs</span><span class="s2">(</span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])  </span><span class="s6"># type: ignore[union-attr]</span>
                <span class="s0">yield </span><span class="s1">ser</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">cache</span>
    <span class="s0">def </span><span class="s1">generate_numba_apply_func</span><span class="s2">(</span>
        <span class="s1">func</span><span class="s2">, </span><span class="s1">nogil</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">parallel</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s1">numba </span><span class="s2">= </span><span class="s1">import_optional_dependency</span><span class="s2">(</span><span class="s4">&quot;numba&quot;</span><span class="s2">)</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">_numba</span><span class="s2">.</span><span class="s1">extensions </span><span class="s0">import </span><span class="s1">maybe_cast_str</span>

        <span class="s1">jitted_udf </span><span class="s2">= </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">extending</span><span class="s2">.</span><span class="s1">register_jitable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">numba</span><span class="s2">.</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nogil</span><span class="s2">=</span><span class="s1">nogil</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s1">nopython</span><span class="s2">, </span><span class="s1">parallel</span><span class="s2">=</span><span class="s1">parallel</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">numba_func</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">col_names_index</span><span class="s2">, </span><span class="s1">index</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= {}</span>
            <span class="s6"># Currently the parallel argument doesn't get passed through here</span>
            <span class="s6"># (it's disabled) since the dicts in numba aren't thread-safe.</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]):</span>
                <span class="s6"># Create the series</span>
                <span class="s6"># TODO: values corrupted without the copy</span>
                <span class="s1">ser </span><span class="s2">= </span><span class="s1">Series</span><span class="s2">(</span>
                    <span class="s1">values</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">(),</span>
                    <span class="s1">index</span><span class="s2">=</span><span class="s1">col_names_index</span><span class="s2">,</span>
                    <span class="s1">name</span><span class="s2">=</span><span class="s1">maybe_cast_str</span><span class="s2">(</span><span class="s1">index</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]),</span>
                <span class="s2">)</span>
                <span class="s1">results</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">jitted_udf</span><span class="s2">(</span><span class="s1">ser</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">results</span>

        <span class="s0">return </span><span class="s1">numba_func</span>

    <span class="s0">def </span><span class="s1">apply_with_numba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]:</span>
        <span class="s1">nb_func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">generate_numba_apply_func</span><span class="s2">(</span>
            <span class="s1">cast</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">), **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">engine_kwargs</span>
        <span class="s2">)</span>

        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">_numba</span><span class="s2">.</span><span class="s1">extensions </span><span class="s0">import </span><span class="s1">set_numba_data</span>

        <span class="s6"># Convert from numba dict to regular dict</span>
        <span class="s6"># Our isinstance checks in the df constructor don't pass for numbas typed dict</span>
        <span class="s0">with </span><span class="s1">set_numba_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">) </span><span class="s0">as </span><span class="s1">index</span><span class="s2">, </span><span class="s1">set_numba_data</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span>
        <span class="s2">) </span><span class="s0">as </span><span class="s1">columns</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">nb_func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">res</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">result_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">result_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span>

    <span class="s0">def </span><span class="s1">wrap_results_for_axis</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">: </span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">: </span><span class="s1">Index</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return the results for the columns&quot;&quot;&quot;</span>
        <span class="s1">result</span><span class="s2">: </span><span class="s1">DataFrame </span><span class="s2">| </span><span class="s1">Series</span>

        <span class="s6"># we have requested to expand</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_type </span><span class="s2">== </span><span class="s4">&quot;expand&quot;</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">infer_to_same_shape</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">)</span>

        <span class="s6"># we have a non-series and don't want inference</span>
        <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">results</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">ABCSeries</span><span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_sliced</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>

        <span class="s6"># we may want to infer results</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">infer_to_same_shape</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">infer_to_same_shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">: </span><span class="s1">ResType</span><span class="s2">, </span><span class="s1">res_index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;infer the results to the same shape as the input object&quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=</span><span class="s1">results</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s6"># set the index</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>

        <span class="s6"># infer dtypes</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">infer_objects</span><span class="s2">(</span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">SeriesApply</span><span class="s2">(</span><span class="s1">NDFrameApply</span><span class="s2">):</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">Series</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s1">by_row</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s0">False</span><span class="s2">, </span><span class="s4">&quot;compat&quot;</span><span class="s2">, </span><span class="s4">&quot;_compat&quot;</span><span class="s2">]  </span><span class="s6"># only relevant for apply()</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">Series</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">convert_dtype</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">NoDefault </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">by_row</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s0">False</span><span class="s2">, </span><span class="s4">&quot;compat&quot;</span><span class="s2">, </span><span class="s4">&quot;_compat&quot;</span><span class="s2">] = </span><span class="s4">&quot;compat&quot;</span><span class="s2">,</span>
        <span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">convert_dtype </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">convert_dtype </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">&quot;the convert_dtype parameter is deprecated and will be removed in a &quot;</span>
                <span class="s4">&quot;future version.  Do ``ser.astype(object).apply()`` &quot;</span>
                <span class="s4">&quot;instead if you want ``convert_dtype=False``.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">convert_dtype </span><span class="s2">= </span><span class="s1">convert_dtype</span>

        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">raw</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">result_type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
            <span class="s1">by_row</span><span class="s2">=</span><span class="s1">by_row</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">) == </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_empty_result</span><span class="s2">()</span>

        <span class="s6"># dispatch to handle list-like or dict-like</span>
        <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_list_or_dict_like</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s6"># if we are a string, try to dispatch</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_str</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row </span><span class="s2">== </span><span class="s4">&quot;_compat&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_compat</span><span class="s2">()</span>

        <span class="s6"># self.func is Callable</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_standard</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">agg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">agg</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
            <span class="s6"># string, list-like, and dict-like are entirely handled in super</span>
            <span class="s0">assert </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>

            <span class="s6"># GH53325: The setup below is just to keep current behavior while emitting a</span>
            <span class="s6"># deprecation message. In the future this will all be replaced with a simple</span>
            <span class="s6"># `result = f(self.obj, *self.args, **self.kwargs)`.</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= (</span>
                    <span class="s4">f&quot;using </span><span class="s0">{</span><span class="s1">func</span><span class="s0">} </span><span class="s4">in </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.agg cannot aggregate and &quot;</span>
                    <span class="s4">f&quot;has been deprecated. Use </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.transform to &quot;</span>
                    <span class="s4">f&quot;keep behavior unchanged.&quot;</span>
                <span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">())</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_empty_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Series</span><span class="s2">:</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">).</span><span class="s1">__finalize__</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;apply&quot;</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply_compat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;compat apply method for funcs in listlikes and dictlikes. 
 
         Used for each callable when giving listlikes and dictlikes of callables to 
         apply. Needed for compatibility with Pandas &lt; v2.1. 
 
        .. versionadded:: 2.1.0 
        &quot;&quot;&quot;</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>

        <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_cython_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">f </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">by_row</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">by_row</span><span class="s2">=</span><span class="s4">&quot;compat&quot;</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">by_row</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">apply_standard</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s6"># caller is responsible for ensuring that f is Callable</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">all</span><span class="s2">=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">elif not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s6"># _map_values does not support args/kwargs</span>
            <span class="s0">def </span><span class="s1">curried</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">curried </span><span class="s2">= </span><span class="s1">func</span>

        <span class="s6"># row-wise access</span>
        <span class="s6"># apply doesn't have a `na_action` keyword and for backward compat reasons</span>
        <span class="s6"># we need to give `na_action=&quot;ignore&quot;` for categorical data.</span>
        <span class="s6"># TODO: remove the `na_action=&quot;ignore&quot;` when that default has been changed in</span>
        <span class="s6">#  Categorical (GH51645).</span>
        <span class="s1">action </span><span class="s2">= </span><span class="s4">&quot;ignore&quot; </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype</span><span class="s2">) </span><span class="s0">else None</span>
        <span class="s1">mapped </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_map_values</span><span class="s2">(</span>
            <span class="s1">mapper</span><span class="s2">=</span><span class="s1">curried</span><span class="s2">, </span><span class="s1">na_action</span><span class="s2">=</span><span class="s1">action</span><span class="s2">, </span><span class="s1">convert</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">convert_dtype</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mapped</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mapped</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">ABCSeries</span><span class="s2">):</span>
            <span class="s6"># GH#43986 Need to do list(mapped) in order to get treated as nested</span>
            <span class="s6">#  See also GH#25959 regarding EA support</span>
            <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_expanddim</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">mapped</span><span class="s2">), </span><span class="s1">index</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(</span><span class="s1">mapped</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">).</span><span class="s1">__finalize__</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;apply&quot;</span>
            <span class="s2">)</span>


<span class="s0">class </span><span class="s1">GroupByApply</span><span class="s2">(</span><span class="s1">Apply</span><span class="s2">):</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">GroupBy </span><span class="s2">| </span><span class="s1">Resampler </span><span class="s2">| </span><span class="s1">BaseWindow</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">GroupBy</span><span class="s2">[</span><span class="s1">NDFrameT</span><span class="s2">],</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_get_axis_number</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">))</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">raw</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">result_type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">agg_or_apply_list_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span>
        <span class="s0">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s4">&quot;apply&quot;</span><span class="s2">:</span>
            <span class="s1">kwargs </span><span class="s2">= {**</span><span class="s1">kwargs</span><span class="s2">, </span><span class="s4">&quot;by_row&quot;</span><span class="s2">: </span><span class="s0">False</span><span class="s2">}</span>

        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;axis other than 0 is not supported&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s6"># For SeriesGroupBy this matches _obj_with_exclusions</span>
            <span class="s1">selected_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_selected_obj</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">selected_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_obj_with_exclusions</span>

        <span class="s6"># Only set as_index=True on groupby objects, not Window or Resample</span>
        <span class="s6"># that inherit from this class.</span>
        <span class="s0">with </span><span class="s1">com</span><span class="s2">.</span><span class="s1">temp_setattr</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;as_index&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">=</span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;as_index&quot;</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">keys</span><span class="s2">, </span><span class="s1">results </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_list_like</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">selected_obj</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results_list_like</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">, </span><span class="s1">results</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">agg_or_apply_dict_like</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
            <span class="s1">DataFrameGroupBy</span><span class="s2">,</span>
            <span class="s1">SeriesGroupBy</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">assert </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">]</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">kwargs </span><span class="s2">= {}</span>
        <span class="s0">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s4">&quot;apply&quot;</span><span class="s2">:</span>
            <span class="s1">by_row </span><span class="s2">= </span><span class="s4">&quot;_compat&quot; </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">by_row </span><span class="s0">else False</span>
            <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s4">&quot;by_row&quot;</span><span class="s2">: </span><span class="s1">by_row</span><span class="s2">})</span>

        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;axis other than 0 is not supported&quot;</span><span class="s2">)</span>

        <span class="s1">selected_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_selected_obj</span>
        <span class="s1">selection </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_selection</span>

        <span class="s1">is_groupby </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span><span class="s1">DataFrameGroupBy</span><span class="s2">, </span><span class="s1">SeriesGroupBy</span><span class="s2">))</span>

        <span class="s6"># Numba Groupby engine/engine-kwargs passthrough</span>
        <span class="s0">if </span><span class="s1">is_groupby</span><span class="s2">:</span>
            <span class="s1">engine </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;engine&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">engine_kwargs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;engine_kwargs&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s4">&quot;engine&quot;</span><span class="s2">: </span><span class="s1">engine</span><span class="s2">, </span><span class="s4">&quot;engine_kwargs&quot;</span><span class="s2">: </span><span class="s1">engine_kwargs</span><span class="s2">})</span>

        <span class="s0">with </span><span class="s1">com</span><span class="s2">.</span><span class="s1">temp_setattr</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;as_index&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">=</span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;as_index&quot;</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">result_index</span><span class="s2">, </span><span class="s1">result_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dict_like</span><span class="s2">(</span>
                <span class="s1">op_name</span><span class="s2">, </span><span class="s1">selected_obj</span><span class="s2">, </span><span class="s1">selection</span><span class="s2">, </span><span class="s1">kwargs</span>
            <span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">wrap_results_dict_like</span><span class="s2">(</span><span class="s1">selected_obj</span><span class="s2">, </span><span class="s1">result_index</span><span class="s2">, </span><span class="s1">result_data</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">ResamplerWindowApply</span><span class="s2">(</span><span class="s1">GroupByApply</span><span class="s2">):</span>
    <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">Resampler </span><span class="s2">| </span><span class="s1">BaseWindow</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">Resampler </span><span class="s2">| </span><span class="s1">BaseWindow</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">args</span><span class="s2">,</span>
        <span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">GroupByApply</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">raw</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">result_type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


<span class="s0">def </span><span class="s1">reconstruct_func</span><span class="s2">(</span>
    <span class="s1">func</span><span class="s2">: </span><span class="s1">AggFuncType </span><span class="s2">| </span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">, </span><span class="s1">AggFuncType</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...] | </span><span class="s0">None</span><span class="s2">, </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    This is the internal function to reconstruct func given if there is relabeling 
    or not and also normalize the keyword to get new order of columns. 
 
    If named aggregation is applied, `func` will be None, and kwargs contains the 
    column and aggregation function information to be parsed; 
    If named aggregation is not applied, `func` is either string (e.g. 'min') or 
    Callable, or list of them (e.g. ['min', np.max]), or the dictionary of column name 
    and str/Callable/list of them (e.g. {'A': 'min'}, or {'A': [np.min, lambda x: x]}) 
 
    If relabeling is True, will return relabeling, reconstructed func, column 
    names, and the reconstructed order of columns. 
    If relabeling is False, the columns and order will be None. 
 
    Parameters 
    ---------- 
    func: agg function (e.g. 'min' or Callable) or list of agg functions 
        (e.g. ['min', np.max]) or dictionary (e.g. {'A': ['min', np.max]}). 
    **kwargs: dict, kwargs used in is_multi_agg_with_relabel and 
        normalize_keyword_aggregation function for relabelling 
 
    Returns 
    ------- 
    relabelling: bool, if there is relabelling or not 
    func: normalized and mangled func 
    columns: tuple of column names 
    order: array of columns indices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; reconstruct_func(None, **{&quot;foo&quot;: (&quot;col&quot;, &quot;min&quot;)}) 
    (True, defaultdict(&lt;class 'list'&gt;, {'col': ['min']}), ('foo',), array([0])) 
 
    &gt;&gt;&gt; reconstruct_func(&quot;min&quot;) 
    (False, 'min', None, None) 
    &quot;&quot;&quot;</span>
    <span class="s1">relabeling </span><span class="s2">= </span><span class="s1">func </span><span class="s0">is None and </span><span class="s1">is_multi_agg_with_relabel</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s1">columns</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">order</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">if not </span><span class="s1">relabeling</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">func</span><span class="s2">) &gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)):</span>
            <span class="s6"># GH 28426 will raise error if duplicated function names are used and</span>
            <span class="s6"># there is no reassigned name</span>
            <span class="s0">raise </span><span class="s1">SpecificationError</span><span class="s2">(</span>
                <span class="s4">&quot;Function names must be unique if there is no new column names &quot;</span>
                <span class="s4">&quot;assigned&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">func </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s6"># nicer error message</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Must provide 'func' or tuples of '(column, aggfunc).&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">relabeling</span><span class="s2">:</span>
        <span class="s6"># error: Incompatible types in assignment (expression has type</span>
        <span class="s6"># &quot;MutableMapping[Hashable, list[Callable[..., Any] | str]]&quot;, variable has type</span>
        <span class="s6"># &quot;Callable[..., Any] | str | list[Callable[..., Any] | str] |</span>
        <span class="s6"># MutableMapping[Hashable, Callable[..., Any] | str | list[Callable[..., Any] |</span>
        <span class="s6"># str]] | None&quot;)</span>
        <span class="s1">func</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">order </span><span class="s2">= </span><span class="s1">normalize_keyword_aggregation</span><span class="s2">(  </span><span class="s6"># type: ignore[assignment]</span>
            <span class="s1">kwargs</span>
        <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">func </span><span class="s0">is not None</span>

    <span class="s0">return </span><span class="s1">relabeling</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">order</span>


<span class="s0">def </span><span class="s1">is_multi_agg_with_relabel</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether kwargs passed to .agg look like multi-agg with relabeling. 
 
    Parameters 
    ---------- 
    **kwargs : dict 
 
    Returns 
    ------- 
    bool 
 
    Examples 
    -------- 
    &gt;&gt;&gt; is_multi_agg_with_relabel(a=&quot;max&quot;) 
    False 
    &gt;&gt;&gt; is_multi_agg_with_relabel(a_max=(&quot;a&quot;, &quot;max&quot;), a_min=(&quot;a&quot;, &quot;min&quot;)) 
    True 
    &gt;&gt;&gt; is_multi_agg_with_relabel() 
    False 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) == </span><span class="s3">2 </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()) </span><span class="s0">and </span><span class="s2">(</span>
        <span class="s1">len</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">) &gt; </span><span class="s3">0</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">normalize_keyword_aggregation</span><span class="s2">(</span>
    <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span>
    <span class="s1">MutableMapping</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">]],</span>
    <span class="s1">tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, ...],</span>
    <span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
<span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Normalize user-provided &quot;named aggregation&quot; kwargs. 
    Transforms from the new ``Mapping[str, NamedAgg]`` style kwargs 
    to the old Dict[str, List[scalar]]]. 
 
    Parameters 
    ---------- 
    kwargs : dict 
 
    Returns 
    ------- 
    aggspec : dict 
        The transformed kwargs. 
    columns : tuple[str, ...] 
        The user-provided keys. 
    col_idx_order : List[int] 
        List of columns indices. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; normalize_keyword_aggregation({&quot;output&quot;: (&quot;input&quot;, &quot;sum&quot;)}) 
    (defaultdict(&lt;class 'list'&gt;, {'input': ['sum']}), ('output',), array([0])) 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">Index</span>

    <span class="s6"># Normalize the aggregation functions as Mapping[column, List[func]],</span>
    <span class="s6"># process normally, then fixup the names.</span>
    <span class="s6"># TODO: aggspec type: typing.Dict[str, List[AggScalar]]</span>
    <span class="s1">aggspec </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)</span>
    <span class="s1">order </span><span class="s2">= []</span>
    <span class="s1">columns</span><span class="s2">, </span><span class="s1">pairs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>

    <span class="s0">for </span><span class="s1">column</span><span class="s2">, </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">pairs</span><span class="s2">:</span>
        <span class="s1">aggspec</span><span class="s2">[</span><span class="s1">column</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">)</span>
        <span class="s1">order</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">column</span><span class="s2">, </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">) </span><span class="s0">or </span><span class="s1">aggfunc</span><span class="s2">))</span>

    <span class="s6"># uniquify aggfunc name if duplicated in order list</span>
    <span class="s1">uniquified_order </span><span class="s2">= </span><span class="s1">_make_unique_kwarg_list</span><span class="s2">(</span><span class="s1">order</span><span class="s2">)</span>

    <span class="s6"># GH 25719, due to aggspec will change the order of assigned columns in aggregation</span>
    <span class="s6"># uniquified_aggspec will store uniquified order list and will compare it with order</span>
    <span class="s6"># based on index</span>
    <span class="s1">aggspec_order </span><span class="s2">= [</span>
        <span class="s2">(</span><span class="s1">column</span><span class="s2">, </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">) </span><span class="s0">or </span><span class="s1">aggfunc</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">column</span><span class="s2">, </span><span class="s1">aggfuncs </span><span class="s0">in </span><span class="s1">aggspec</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">aggfuncs</span>
    <span class="s2">]</span>
    <span class="s1">uniquified_aggspec </span><span class="s2">= </span><span class="s1">_make_unique_kwarg_list</span><span class="s2">(</span><span class="s1">aggspec_order</span><span class="s2">)</span>

    <span class="s6"># get the new index of columns by comparison</span>
    <span class="s1">col_idx_order </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">uniquified_aggspec</span><span class="s2">).</span><span class="s1">get_indexer</span><span class="s2">(</span><span class="s1">uniquified_order</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">aggspec</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">col_idx_order</span>


<span class="s0">def </span><span class="s1">_make_unique_kwarg_list</span><span class="s2">(</span>
    <span class="s1">seq</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]</span>
<span class="s2">) </span><span class="s1">-&gt; Sequence</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Uniquify aggfunc name of the pairs in the order list 
 
    Examples: 
    -------- 
    &gt;&gt;&gt; kwarg_list = [('a', '&lt;lambda&gt;'), ('a', '&lt;lambda&gt;'), ('b', '&lt;lambda&gt;')] 
    &gt;&gt;&gt; _make_unique_kwarg_list(kwarg_list) 
    [('a', '&lt;lambda&gt;_0'), ('a', '&lt;lambda&gt;_1'), ('b', '&lt;lambda&gt;')] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s2">[</span>
        <span class="s2">(</span><span class="s1">pair</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">pair</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]</span><span class="s0">}</span><span class="s4">_</span><span class="s0">{</span><span class="s1">seq</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">].</span><span class="s1">count</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">) </span><span class="s0">if </span><span class="s1">seq</span><span class="s2">.</span><span class="s1">count</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">) &gt; </span><span class="s3">1 </span><span class="s0">else </span><span class="s1">pair</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">seq</span><span class="s2">)</span>
    <span class="s2">]</span>


<span class="s0">def </span><span class="s1">relabel_result</span><span class="s2">(</span>
    <span class="s1">result</span><span class="s2">: </span><span class="s1">DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">func</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Callable </span><span class="s2">| </span><span class="s1">str</span><span class="s2">]],</span>
    <span class="s1">columns</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">],</span>
    <span class="s1">order</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">int</span><span class="s2">],</span>
<span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Series</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Internal function to reorder result if relabelling is True for 
    dataframe.agg, and return the reordered result in dict. 
 
    Parameters: 
    ---------- 
    result: Result from aggregation 
    func: Dict of (column name, funcs) 
    columns: New columns name for relabelling 
    order: New order for relabelling 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas.core.apply import relabel_result 
    &gt;&gt;&gt; result = pd.DataFrame( 
    ...     {&quot;A&quot;: [np.nan, 2, np.nan], &quot;C&quot;: [6, np.nan, np.nan], &quot;B&quot;: [np.nan, 4, 2.5]}, 
    ...     index=[&quot;max&quot;, &quot;mean&quot;, &quot;min&quot;] 
    ... ) 
    &gt;&gt;&gt; funcs = {&quot;A&quot;: [&quot;max&quot;], &quot;C&quot;: [&quot;max&quot;], &quot;B&quot;: [&quot;mean&quot;, &quot;min&quot;]} 
    &gt;&gt;&gt; columns = (&quot;foo&quot;, &quot;aab&quot;, &quot;bar&quot;, &quot;dat&quot;) 
    &gt;&gt;&gt; order = [0, 1, 2, 3] 
    &gt;&gt;&gt; result_in_dict = relabel_result(result, funcs, columns, order) 
    &gt;&gt;&gt; pd.DataFrame(result_in_dict, index=columns) 
           A    C    B 
    foo  2.0  NaN  NaN 
    aab  NaN  6.0  NaN 
    bar  NaN  NaN  4.0 
    dat  NaN  NaN  2.5 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">Index</span>

    <span class="s1">reordered_indexes </span><span class="s2">= [</span>
        <span class="s1">pair</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">order</span><span class="s2">), </span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">t</span><span class="s2">: </span><span class="s1">t</span><span class="s2">[</span><span class="s3">1</span><span class="s2">])</span>
    <span class="s2">]</span>
    <span class="s1">reordered_result_in_dict</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Series</span><span class="s2">] = {}</span>
    <span class="s1">idx </span><span class="s2">= </span><span class="s3">0</span>

    <span class="s1">reorder_mask </span><span class="s2">= </span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">) &gt; </span><span class="s3">1</span>
    <span class="s0">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">fun </span><span class="s0">in </span><span class="s1">func</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">result</span><span class="s2">[</span><span class="s1">col</span><span class="s2">].</span><span class="s1">dropna</span><span class="s2">()</span>

        <span class="s6"># In the `_aggregate`, the callable names are obtained and used in `result`, and</span>
        <span class="s6"># these names are ordered alphabetically. e.g.</span>
        <span class="s6">#           C2   C1</span>
        <span class="s6"># &lt;lambda&gt;   1  NaN</span>
        <span class="s6"># amax     NaN  4.0</span>
        <span class="s6"># max      NaN  4.0</span>
        <span class="s6"># sum     18.0  6.0</span>
        <span class="s6"># Therefore, the order of functions for each column could be shuffled</span>
        <span class="s6"># accordingly so need to get the callable name if it is not parsed names, and</span>
        <span class="s6"># reorder the aggregated result for each column.</span>
        <span class="s6"># e.g. if df.agg(c1=(&quot;C2&quot;, sum), c2=(&quot;C2&quot;, lambda x: min(x))), correct order is</span>
        <span class="s6"># [sum, &lt;lambda&gt;], but in `result`, it will be [&lt;lambda&gt;, sum], and we need to</span>
        <span class="s6"># reorder so that aggregated values map to their functions regarding the order.</span>

        <span class="s6"># However there is only one column being used for aggregation, not need to</span>
        <span class="s6"># reorder since the index is not sorted, and keep as is in `funcs`, e.g.</span>
        <span class="s6">#         A</span>
        <span class="s6"># min   1.0</span>
        <span class="s6"># mean  1.5</span>
        <span class="s6"># mean  1.5</span>
        <span class="s0">if </span><span class="s1">reorder_mask</span><span class="s2">:</span>
            <span class="s1">fun </span><span class="s2">= [</span>
                <span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">f</span><span class="s2">) </span><span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">else </span><span class="s1">f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fun</span>
            <span class="s2">]</span>
            <span class="s1">col_idx_order </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">s</span><span class="s2">.</span><span class="s1">index</span><span class="s2">).</span><span class="s1">get_indexer</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">)</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s1">s</span><span class="s2">.</span><span class="s1">iloc</span><span class="s2">[</span><span class="s1">col_idx_order</span><span class="s2">]</span>

        <span class="s6"># assign the new user-provided &quot;named aggregation&quot; as index names, and reindex</span>
        <span class="s6"># it based on the whole user-provided names.</span>
        <span class="s1">s</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">reordered_indexes</span><span class="s2">[</span><span class="s1">idx </span><span class="s2">: </span><span class="s1">idx </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">)]</span>
        <span class="s1">reordered_result_in_dict</span><span class="s2">[</span><span class="s1">col</span><span class="s2">] = </span><span class="s1">s</span><span class="s2">.</span><span class="s1">reindex</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">idx </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">reordered_result_in_dict</span>


<span class="s0">def </span><span class="s1">reconstruct_and_relabel_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; DataFrame </span><span class="s2">| </span><span class="s1">Series</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>

    <span class="s1">relabeling</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">order </span><span class="s2">= </span><span class="s1">reconstruct_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">relabeling</span><span class="s2">:</span>
        <span class="s6"># This is to keep the order to columns occurrence unchanged, and also</span>
        <span class="s6"># keep the order of new columns occurrence unchanged</span>

        <span class="s6"># For the return values of reconstruct_func, if relabeling is</span>
        <span class="s6"># False, columns and order will be None.</span>
        <span class="s0">assert </span><span class="s1">columns </span><span class="s0">is not None</span>
        <span class="s0">assert </span><span class="s1">order </span><span class="s0">is not None</span>

        <span class="s1">result_in_dict </span><span class="s2">= </span><span class="s1">relabel_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">DataFrame</span><span class="s2">(</span><span class="s1">result_in_dict</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">columns</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s6"># TODO: Can't use, because mypy doesn't like us setting __name__</span>
<span class="s6">#   error: &quot;partial[Any]&quot; has no attribute &quot;__name__&quot;</span>
<span class="s6"># the type is:</span>
<span class="s6">#   typing.Sequence[Callable[..., ScalarResult]]</span>
<span class="s6">#     -&gt; typing.Sequence[Callable[..., ScalarResult]]:</span>


<span class="s0">def </span><span class="s1">_managle_lambda_list</span><span class="s2">(</span><span class="s1">aggfuncs</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; Sequence</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Possibly mangle a list of aggfuncs. 
 
    Parameters 
    ---------- 
    aggfuncs : Sequence 
 
    Returns 
    ------- 
    mangled: list-like 
        A new AggSpec sequence, where lambdas have been converted 
        to have unique names. 
 
    Notes 
    ----- 
    If just one aggfunc is passed, the name will not be mangled. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">aggfuncs</span><span class="s2">) &lt;= </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s6"># don't mangle for .agg([lambda x: .])</span>
        <span class="s0">return </span><span class="s1">aggfuncs</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s1">mangled_aggfuncs </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">aggfunc </span><span class="s0">in </span><span class="s1">aggfuncs</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_callable_name</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">) == </span><span class="s4">&quot;&lt;lambda&gt;&quot;</span><span class="s2">:</span>
            <span class="s1">aggfunc </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">)</span>
            <span class="s1">aggfunc</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s4">f&quot;&lt;lambda_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s4">&gt;&quot;</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s1">mangled_aggfuncs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">aggfunc</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">mangled_aggfuncs</span>


<span class="s0">def </span><span class="s1">maybe_mangle_lambdas</span><span class="s2">(</span><span class="s1">agg_spec</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Make new lambdas with unique names. 
 
    Parameters 
    ---------- 
    agg_spec : Any 
        An argument to GroupBy.agg. 
        Non-dict-like `agg_spec` are pass through as is. 
        For dict-like `agg_spec` a new spec is returned 
        with name-mangled lambdas. 
 
    Returns 
    ------- 
    mangled : Any 
        Same type as the input. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; maybe_mangle_lambdas('sum') 
    'sum' 
    &gt;&gt;&gt; maybe_mangle_lambdas([lambda: 1, lambda: 2])  # doctest: +SKIP 
    [&lt;function __main__.&lt;lambda_0&gt;, 
     &lt;function pandas...._make_lambda.&lt;locals&gt;.f(*args, **kwargs)&gt;] 
    &quot;&quot;&quot;</span>
    <span class="s1">is_dict </span><span class="s2">= </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">agg_spec</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s2">(</span><span class="s1">is_dict </span><span class="s0">or </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">agg_spec</span><span class="s2">)):</span>
        <span class="s0">return </span><span class="s1">agg_spec</span>
    <span class="s1">mangled_aggspec </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">agg_spec</span><span class="s2">)()  </span><span class="s6"># dict or OrderedDict</span>

    <span class="s0">if </span><span class="s1">is_dict</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">aggfuncs </span><span class="s0">in </span><span class="s1">agg_spec</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">aggfuncs</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">is_dict_like</span><span class="s2">(</span><span class="s1">aggfuncs</span><span class="s2">):</span>
                <span class="s1">mangled_aggfuncs </span><span class="s2">= </span><span class="s1">_managle_lambda_list</span><span class="s2">(</span><span class="s1">aggfuncs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">mangled_aggfuncs </span><span class="s2">= </span><span class="s1">aggfuncs</span>

            <span class="s1">mangled_aggspec</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">mangled_aggfuncs</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">mangled_aggspec </span><span class="s2">= </span><span class="s1">_managle_lambda_list</span><span class="s2">(</span><span class="s1">agg_spec</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">mangled_aggspec</span>


<span class="s0">def </span><span class="s1">validate_func_kwargs</span><span class="s2">(</span>
    <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str </span><span class="s2">| </span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">Any</span><span class="s2">]]]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Validates types of user-provided &quot;named aggregation&quot; kwargs. 
    `TypeError` is raised if aggfunc is not `str` or callable. 
 
    Parameters 
    ---------- 
    kwargs : dict 
 
    Returns 
    ------- 
    columns : List[str] 
        List of user-provided keys. 
    func : List[Union[str, callable[...,Any]]] 
        List of user-provided aggfuncs 
 
    Examples 
    -------- 
    &gt;&gt;&gt; validate_func_kwargs({'one': 'min', 'two': 'max'}) 
    (['one', 'two'], ['min', 'max']) 
    &quot;&quot;&quot;</span>
    <span class="s1">tuple_given_message </span><span class="s2">= </span><span class="s4">&quot;func is expected but received {} in **kwargs.&quot;</span>
    <span class="s1">columns </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s1">func </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">col_func </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">col_func</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">or </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">col_func</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">tuple_given_message</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">col_func</span><span class="s2">).</span><span class="s1">__name__</span><span class="s2">))</span>
        <span class="s1">func</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">col_func</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">columns</span><span class="s2">:</span>
        <span class="s1">no_arg_message </span><span class="s2">= </span><span class="s4">&quot;Must provide 'func' or named aggregation **kwargs.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">no_arg_message</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">func</span>


<span class="s0">def </span><span class="s1">include_axis</span><span class="s2">(</span><span class="s1">op_name</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;agg&quot;</span><span class="s2">, </span><span class="s4">&quot;apply&quot;</span><span class="s2">], </span><span class="s1">colg</span><span class="s2">: </span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">colg</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span>
        <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">colg</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">) </span><span class="s0">and </span><span class="s1">op_name </span><span class="s2">== </span><span class="s4">&quot;agg&quot;</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">warn_alias_replacement</span><span class="s2">(</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">AggObjType</span><span class="s2">,</span>
    <span class="s1">func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">alias</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">alias</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s4">&quot;np.&quot;</span><span class="s2">):</span>
        <span class="s1">full_alias </span><span class="s2">= </span><span class="s1">alias</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">full_alias </span><span class="s2">= </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">alias</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">alias </span><span class="s2">= </span><span class="s4">f'&quot;</span><span class="s0">{</span><span class="s1">alias</span><span class="s0">}</span><span class="s4">&quot;'</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">f&quot;The provided callable </span><span class="s0">{</span><span class="s1">func</span><span class="s0">} </span><span class="s4">is currently using &quot;</span>
        <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">full_alias</span><span class="s0">}</span><span class="s4">. In a future version of pandas, &quot;</span>
        <span class="s4">f&quot;the provided callable will be used directly. To keep current &quot;</span>
        <span class="s4">f&quot;behavior pass the string </span><span class="s0">{</span><span class="s1">alias</span><span class="s0">} </span><span class="s4">instead.&quot;</span><span class="s2">,</span>
        <span class="s1">category</span><span class="s2">=</span><span class="s1">FutureWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
    <span class="s2">)</span>
</pre>
</body>
</html>