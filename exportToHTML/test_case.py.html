<html>
<head>
<title>test_case.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_case.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">shutil</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">import </span><span class="s1">unittest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">distribution</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">tree</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s1">is_float_dtype</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s1">standardize_dtype</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">common</span><span class="s2">.</span><span class="s1">global_state </span><span class="s0">import </span><span class="s1">clear_session</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">common</span><span class="s2">.</span><span class="s1">keras_tensor </span><span class="s0">import </span><span class="s1">KerasTensor</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models </span><span class="s0">import </span><span class="s1">Model</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">traceback_utils</span>


<span class="s0">class </span><span class="s1">TestCase</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s1">maxDiff </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># clear global state so that test cases are independent</span>
        <span class="s3"># required for the jit enabled torch tests since dynamo has</span>
        <span class="s3"># a global cache for guards, compiled fn, etc</span>
        <span class="s1">clear_session</span><span class="s2">(</span><span class="s1">free_memory</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">is_traceback_filtering_enabled</span><span class="s2">():</span>
            <span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">disable_traceback_filtering</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">get_temp_dir</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">temp_dir </span><span class="s2">= </span><span class="s1">tempfile</span><span class="s2">.</span><span class="s1">mkdtemp</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">addCleanup</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">shutil</span><span class="s2">.</span><span class="s1">rmtree</span><span class="s2">(</span><span class="s1">temp_dir</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">temp_dir</span>

    <span class="s0">def </span><span class="s1">assertAllClose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertNotAllClose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertAllClose</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">msg </span><span class="s0">or </span><span class="s5">&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
            <span class="s5">f&quot;The two values are close at all elements. </span><span class="s0">\n</span><span class="s5">&quot;</span>
            <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">msg</span><span class="s0">}</span><span class="s5">.</span><span class="s0">\n</span><span class="s5">&quot;</span>
            <span class="s5">f&quot;Values: </span><span class="s0">{</span><span class="s1">x1</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertAlmostEqual</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_almost_equal</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">=</span><span class="s1">decimal</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertAllEqual</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">e1</span><span class="s2">, </span><span class="s1">e2 </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">e1</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">e2</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertAllEqual</span><span class="s2">(</span><span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">e1 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">e1</span><span class="s2">)</span>
                <span class="s1">e2 </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">(</span><span class="s1">e2</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertLen</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">expected_len</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">iterable</span><span class="s2">), </span><span class="s1">expected_len</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertSparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">KerasTensor</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;tensorflow&quot;</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">tensorflow </span><span class="s0">as </span><span class="s1">tf</span>

            <span class="s0">if </span><span class="s1">sparse</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIsInstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">SparseTensor</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;jax&quot;</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">jax</span><span class="s2">.</span><span class="s1">experimental</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">as </span><span class="s1">jax_sparse</span>

            <span class="s0">if </span><span class="s1">sparse</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">jax_sparse</span><span class="s2">.</span><span class="s1">JAXSparse</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIsInstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">jax_sparse</span><span class="s2">.</span><span class="s1">JAXSparse</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span>
                <span class="s1">sparse</span><span class="s2">,</span>
                <span class="s5">f&quot;Backend </span><span class="s0">{</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">()</span><span class="s0">} </span><span class="s5">does not support sparse tensors&quot;</span><span class="s2">,</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assertDType</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s2">):</span>
            <span class="s1">x_dtype </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># If x is a python number</span>
            <span class="s1">x_dtype </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>
        <span class="s1">standardized_dtype </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">default_msg </span><span class="s2">= (</span>
            <span class="s5">&quot;The dtype of x does not match the expected one. &quot;</span>
            <span class="s5">f&quot;Received: x.dtype=</span><span class="s0">{</span><span class="s1">x_dtype</span><span class="s0">} </span><span class="s5">and dtype=</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">msg </span><span class="s0">or </span><span class="s1">default_msg</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">x_dtype</span><span class="s2">, </span><span class="s1">standardized_dtype</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_class_serialization_test</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">custom_object_scope</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">deserialize_keras_object</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">serialize_keras_object</span>

        <span class="s3"># get_config roundtrip</span>
        <span class="s1">cls </span><span class="s2">= </span><span class="s1">instance</span><span class="s2">.</span><span class="s1">__class__</span>
        <span class="s1">config </span><span class="s2">= </span><span class="s1">instance</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">config_json </span><span class="s2">= </span><span class="s1">json</span><span class="s2">.</span><span class="s1">dumps</span><span class="s2">(</span><span class="s1">config</span><span class="s2">, </span><span class="s1">sort_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">=</span><span class="s4">4</span><span class="s2">)</span>
        <span class="s1">ref_dir </span><span class="s2">= </span><span class="s1">dir</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)[:]</span>
        <span class="s0">with </span><span class="s1">custom_object_scope</span><span class="s2">(</span><span class="s1">custom_objects</span><span class="s2">):</span>
            <span class="s1">revived_instance </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">from_config</span><span class="s2">(</span><span class="s1">config</span><span class="s2">)</span>
        <span class="s1">revived_config </span><span class="s2">= </span><span class="s1">revived_instance</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">revived_config_json </span><span class="s2">= </span><span class="s1">json</span><span class="s2">.</span><span class="s1">dumps</span><span class="s2">(</span>
            <span class="s1">revived_config</span><span class="s2">, </span><span class="s1">sort_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">=</span><span class="s4">4</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">config_json</span><span class="s2">, </span><span class="s1">revived_config_json</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">ref_dir</span><span class="s2">), </span><span class="s1">set</span><span class="s2">(</span><span class="s1">dir</span><span class="s2">(</span><span class="s1">revived_instance</span><span class="s2">)))</span>

        <span class="s3"># serialization roundtrip</span>
        <span class="s1">serialized </span><span class="s2">= </span><span class="s1">serialize_keras_object</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">)</span>
        <span class="s1">serialized_json </span><span class="s2">= </span><span class="s1">json</span><span class="s2">.</span><span class="s1">dumps</span><span class="s2">(</span><span class="s1">serialized</span><span class="s2">, </span><span class="s1">sort_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">=</span><span class="s4">4</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">custom_object_scope</span><span class="s2">(</span><span class="s1">custom_objects</span><span class="s2">):</span>
            <span class="s1">revived_instance </span><span class="s2">= </span><span class="s1">deserialize_keras_object</span><span class="s2">(</span>
                <span class="s1">json</span><span class="s2">.</span><span class="s1">loads</span><span class="s2">(</span><span class="s1">serialized_json</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s1">revived_config </span><span class="s2">= </span><span class="s1">revived_instance</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">revived_config_json </span><span class="s2">= </span><span class="s1">json</span><span class="s2">.</span><span class="s1">dumps</span><span class="s2">(</span>
            <span class="s1">revived_config</span><span class="s2">, </span><span class="s1">sort_keys</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">=</span><span class="s4">4</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">config_json</span><span class="s2">, </span><span class="s1">revived_config_json</span><span class="s2">)</span>
        <span class="s1">new_dir </span><span class="s2">= </span><span class="s1">dir</span><span class="s2">(</span><span class="s1">revived_instance</span><span class="s2">)[:]</span>
        <span class="s0">for </span><span class="s1">lst </span><span class="s0">in </span><span class="s2">[</span><span class="s1">ref_dir</span><span class="s2">, </span><span class="s1">new_dir</span><span class="s2">]:</span>
            <span class="s0">if </span><span class="s5">&quot;__annotations__&quot; </span><span class="s0">in </span><span class="s1">lst</span><span class="s2">:</span>
                <span class="s1">lst</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s5">&quot;__annotations__&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">ref_dir</span><span class="s2">), </span><span class="s1">set</span><span class="s2">(</span><span class="s1">new_dir</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">revived_instance</span>

    <span class="s0">def </span><span class="s1">run_layer_test</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">layer_cls</span><span class="s2">,</span>
        <span class="s1">init_kwargs</span><span class="s2">,</span>
        <span class="s1">input_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">input_dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">input_sparse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">input_data</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">call_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_output_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_output_dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_output_sparse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">expected_output</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_num_trainable_weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_num_non_trainable_weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_num_non_trainable_variables</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_num_seed_generators</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_num_losses</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">supports_masking</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expected_mask_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">custom_objects</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">run_training_check</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">run_mixed_precision_check</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Run basic checks on a layer. 
 
        Args: 
            layer_cls: The class of the layer to test. 
            init_kwargs: Dict of arguments to be used to 
                instantiate the layer. 
            input_shape: Shape tuple (or list/dict of shape tuples) 
                to call the layer on. 
            input_dtype: Corresponding input dtype. 
            input_sparse: Whether the input is a sparse tensor (this requires 
                the backend to support sparse tensors). 
            input_data: Tensor (or list/dict of tensors) 
                to call the layer on. 
            call_kwargs: Dict of arguments to use when calling the 
                layer (does not include the first input tensor argument) 
            expected_output_shape: Shape tuple 
                (or list/dict of shape tuples) 
                expected as output. 
            expected_output_dtype: dtype expected as output. 
            expected_output_sparse: Whether the output is expected to be sparse 
                (this requires the backend to support sparse tensors). 
            expected_output: Expected output tensor -- only 
                to be specified if input_data is provided. 
            expected_num_trainable_weights: Expected number 
                of trainable weights of the layer once built. 
            expected_num_non_trainable_weights: Expected number 
                of non-trainable weights of the layer once built. 
            expected_num_seed_generators: Expected number of 
                SeedGenerators objects of the layer once built. 
            expected_num_losses: Expected number of loss tensors 
                produced when calling the layer. 
            supports_masking: If True, will check that the layer 
                supports masking. 
            expected_mask_shape: Expected mask shape tuple 
                returned by compute_mask() (only supports 1 shape). 
            custom_objects: Dict of any custom objects to be 
                considered during deserialization. 
            run_training_check: Whether to attempt to train the layer 
                (if an input shape or input data was provided). 
            run_mixed_precision_check: Whether to test the layer with a mixed 
                precision dtype policy. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">input_shape </span><span class="s0">is not None and </span><span class="s1">input_data </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;input_shape and input_data cannot be passed &quot;</span>
                <span class="s5">&quot;at the same time.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">expected_output_shape </span><span class="s0">is not None and </span><span class="s1">expected_output </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;expected_output_shape and expected_output cannot be passed &quot;</span>
                <span class="s5">&quot;at the same time.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">expected_output </span><span class="s0">is not None and </span><span class="s1">input_data </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;In order to use expected_output, input_data must be provided.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">expected_mask_shape </span><span class="s0">is not None and </span><span class="s1">supports_masking </span><span class="s0">is not True</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;In order to use expected_mask_shape, supports_masking &quot;</span>
                <span class="s5">&quot;must be True.&quot;</span>
            <span class="s2">)</span>

        <span class="s1">init_kwargs </span><span class="s2">= </span><span class="s1">init_kwargs </span><span class="s0">or </span><span class="s2">{}</span>
        <span class="s1">call_kwargs </span><span class="s2">= </span><span class="s1">call_kwargs </span><span class="s0">or </span><span class="s2">{}</span>

        <span class="s0">if </span><span class="s1">input_shape </span><span class="s0">is not None and </span><span class="s1">input_dtype </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">is_shape_tuple</span><span class="s2">(</span>
                <span class="s1">input_shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">),</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">),</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;The number of input shapes and dtypes does not match&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                    <span class="s1">set</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                    <span class="s1">set</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;The number of input shapes and dtypes does not match&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">, </span><span class="s1">list</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">),</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">input_dtype</span><span class="s2">),</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;The number of input shapes and dtypes does not match&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;The type of input_shape is not supported&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">input_shape </span><span class="s0">is not None and </span><span class="s1">input_dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">input_dtype </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">map_shape_structure</span><span class="s2">(</span>
                <span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s5">&quot;float32&quot;</span><span class="s2">, </span><span class="s1">input_shape</span>
            <span class="s2">)</span>

        <span class="s3"># Serialization test.</span>
        <span class="s1">layer </span><span class="s2">= </span><span class="s1">layer_cls</span><span class="s2">(**</span><span class="s1">init_kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">run_class_serialization_test</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">)</span>

        <span class="s3"># Basic masking test.</span>
        <span class="s0">if </span><span class="s1">supports_masking </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                <span class="s1">layer</span><span class="s2">.</span><span class="s1">supports_masking</span><span class="s2">,</span>
                <span class="s1">supports_masking</span><span class="s2">,</span>
                <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected supports_masking value&quot;</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">run_build_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">.</span><span class="s1">built</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_num_trainable_weights </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span>
                    <span class="s1">layer</span><span class="s2">.</span><span class="s1">trainable_weights</span><span class="s2">,</span>
                    <span class="s1">expected_num_trainable_weights</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of trainable_weights&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_num_non_trainable_weights </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span>
                    <span class="s1">layer</span><span class="s2">.</span><span class="s1">non_trainable_weights</span><span class="s2">,</span>
                    <span class="s1">expected_num_non_trainable_weights</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of non_trainable_weights&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_num_non_trainable_variables </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span>
                    <span class="s1">layer</span><span class="s2">.</span><span class="s1">non_trainable_variables</span><span class="s2">,</span>
                    <span class="s1">expected_num_non_trainable_variables</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of non_trainable_variables&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_num_seed_generators </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span>
                    <span class="s1">get_seed_generators</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">),</span>
                    <span class="s1">expected_num_seed_generators</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of seed_generators&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;torch&quot;</span>
                <span class="s0">and </span><span class="s1">expected_num_trainable_weights </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">expected_num_non_trainable_weights </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">expected_num_seed_generators </span><span class="s0">is not None</span>
            <span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span>
                    <span class="s1">layer</span><span class="s2">.</span><span class="s1">torch_params</span><span class="s2">,</span>
                    <span class="s1">expected_num_trainable_weights</span>
                    <span class="s2">+ </span><span class="s1">expected_num_non_trainable_weights</span>
                    <span class="s2">+ </span><span class="s1">expected_num_seed_generators</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of torch_params&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">run_output_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">eager</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">expected_output_shape </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">is_shape_tuple</span><span class="s2">(</span>
                    <span class="s1">expected_output_shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
                <span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">output</span><span class="s2">),</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of outputs&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_shape </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_shape</span><span class="s2">,</span>
                        <span class="s1">output_shape</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output shape&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_shape</span><span class="s2">,</span>
                        <span class="s1">output</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output shape&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">set</span><span class="s2">(</span><span class="s1">output</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                        <span class="s1">set</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dict keys&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_shape </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_shape</span><span class="s2">,</span>
                        <span class="s1">output_shape</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output shape&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">list</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">output</span><span class="s2">),</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">expected_output_shape</span><span class="s2">),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of outputs&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_shape </span><span class="s2">= [</span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span><span class="s2">]</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_shape</span><span class="s2">,</span>
                        <span class="s1">output_shape</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output shape&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                        <span class="s5">&quot;The type of expected_output_shape is not supported&quot;</span>
                    <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_output_dtype </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">output</span><span class="s2">),</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of outputs&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_dtype </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
                        <span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span>
                    <span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_dtype</span><span class="s2">,</span>
                        <span class="s1">output_dtype</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dtype&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">set</span><span class="s2">(</span><span class="s1">output</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                        <span class="s1">set</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dict keys&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_dtype </span><span class="s2">= {</span>
                        <span class="s1">k</span><span class="s2">: </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                    <span class="s2">}</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_dtype</span><span class="s2">,</span>
                        <span class="s1">output_dtype</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dtype&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIsInstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">list</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">output</span><span class="s2">),</span>
                        <span class="s1">len</span><span class="s2">(</span><span class="s1">expected_output_dtype</span><span class="s2">),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected number of outputs&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s1">output_dtype </span><span class="s2">= [</span>
                        <span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">output</span>
                    <span class="s2">]</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_dtype</span><span class="s2">,</span>
                        <span class="s1">output_dtype</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dtype&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">output_dtype </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">output</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">dtype</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                        <span class="s1">expected_output_dtype</span><span class="s2">,</span>
                        <span class="s1">backend</span><span class="s2">.</span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">output_dtype</span><span class="s2">),</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output dtype&quot;</span><span class="s2">,</span>
                    <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">expected_output_sparse</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">output</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertSparse</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">eager</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">expected_output </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">expected_output</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">output</span><span class="s2">))</span>
                    <span class="s0">for </span><span class="s1">ref_v</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span>
                        <span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">expected_output</span><span class="s2">), </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">output</span><span class="s2">)</span>
                    <span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertAllClose</span><span class="s2">(</span>
                            <span class="s1">ref_v</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Unexpected output value&quot;</span>
                        <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">expected_num_losses </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLen</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">.</span><span class="s1">losses</span><span class="s2">, </span><span class="s1">expected_num_losses</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">run_training_step</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">input_data</span><span class="s2">, </span><span class="s1">output_data</span><span class="s2">):</span>
            <span class="s0">class </span><span class="s1">TestModel</span><span class="s2">(</span><span class="s1">Model</span><span class="s2">):</span>
                <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">layer</span><span class="s2">):</span>
                    <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">layer </span><span class="s2">= </span><span class="s1">layer</span>

                <span class="s0">def </span><span class="s1">call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">training</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layer</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">training</span><span class="s2">=</span><span class="s1">training</span><span class="s2">)</span>

            <span class="s1">model </span><span class="s2">= </span><span class="s1">TestModel</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">)</span>

            <span class="s1">data </span><span class="s2">= (</span><span class="s1">input_data</span><span class="s2">, </span><span class="s1">output_data</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;torch&quot;</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">map_structure</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">convert_to_numpy</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">data_generator</span><span class="s2">():</span>
                <span class="s0">while True</span><span class="s2">:</span>
                    <span class="s0">yield </span><span class="s1">data</span>

            <span class="s3"># test the &quot;default&quot; path for each backend by setting</span>
            <span class="s3"># jit_compile=&quot;auto&quot;.</span>
            <span class="s3"># for tensorflow and jax backends auto is jitted</span>
            <span class="s3"># Note that tensorflow cannot be jitted with sparse tensors</span>
            <span class="s3"># for torch backend auto is eager</span>
            <span class="s3">#</span>
            <span class="s3"># NB: for torch, jit_compile=True turns on torchdynamo</span>
            <span class="s3">#  which may not always succeed in tracing depending</span>
            <span class="s3">#  on the model. Run your program with these env vars</span>
            <span class="s3">#  to get debug traces of dynamo:</span>
            <span class="s3">#    TORCH_LOGS=&quot;+dynamo&quot;</span>
            <span class="s3">#    TORCHDYNAMO_VERBOSE=1</span>
            <span class="s3">#    TORCHDYNAMO_REPORT_GUARD_FAILURES=1</span>
            <span class="s1">jit_compile </span><span class="s2">= </span><span class="s5">&quot;auto&quot;</span>
            <span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;tensorflow&quot; </span><span class="s0">and </span><span class="s1">input_sparse</span><span class="s2">:</span>
                <span class="s1">jit_compile </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">model</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">optimizer</span><span class="s2">=</span><span class="s5">&quot;sgd&quot;</span><span class="s2">, </span><span class="s1">loss</span><span class="s2">=</span><span class="s5">&quot;mse&quot;</span><span class="s2">, </span><span class="s1">jit_compile</span><span class="s2">=</span><span class="s1">jit_compile</span><span class="s2">)</span>
            <span class="s1">model</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">(</span><span class="s1">data_generator</span><span class="s2">(), </span><span class="s1">steps_per_epoch</span><span class="s2">=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>

        <span class="s3"># Build test.</span>
        <span class="s0">if </span><span class="s1">input_data </span><span class="s0">is not None or </span><span class="s1">input_shape </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">input_shape </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">build_shape </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">map_structure</span><span class="s2">(</span>
                    <span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">input_data</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">build_shape </span><span class="s2">= </span><span class="s1">input_shape</span>
            <span class="s1">layer </span><span class="s2">= </span><span class="s1">layer_cls</span><span class="s2">(**</span><span class="s1">init_kwargs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">build_shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                <span class="s1">layer</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(**</span><span class="s1">build_shape</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">layer</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">build_shape</span><span class="s2">)</span>
            <span class="s1">run_build_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">)</span>

            <span class="s3"># Symbolic call test.</span>
            <span class="s0">if </span><span class="s1">input_shape </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">keras_tensor_inputs </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">map_structure</span><span class="s2">(</span>
                    <span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">create_keras_tensors</span><span class="s2">(</span>
                        <span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">input_sparse</span>
                    <span class="s2">),</span>
                    <span class="s1">input_data</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">keras_tensor_inputs </span><span class="s2">= </span><span class="s1">create_keras_tensors</span><span class="s2">(</span>
                    <span class="s1">input_shape</span><span class="s2">, </span><span class="s1">input_dtype</span><span class="s2">, </span><span class="s1">input_sparse</span>
                <span class="s2">)</span>
            <span class="s1">layer </span><span class="s2">= </span><span class="s1">layer_cls</span><span class="s2">(**</span><span class="s1">init_kwargs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">keras_tensor_inputs</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                <span class="s1">keras_tensor_outputs </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(</span>
                    <span class="s2">**</span><span class="s1">keras_tensor_inputs</span><span class="s2">, **</span><span class="s1">call_kwargs</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">keras_tensor_outputs </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(</span><span class="s1">keras_tensor_inputs</span><span class="s2">, **</span><span class="s1">call_kwargs</span><span class="s2">)</span>
            <span class="s1">run_build_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">)</span>
            <span class="s1">run_output_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">keras_tensor_outputs</span><span class="s2">, </span><span class="s1">eager</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">expected_mask_shape </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">output_mask </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">compute_mask</span><span class="s2">(</span><span class="s1">keras_tensor_inputs</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">expected_mask_shape</span><span class="s2">, </span><span class="s1">output_mask</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

        <span class="s3"># Eager call test and compiled training test.</span>
        <span class="s0">if </span><span class="s1">input_data </span><span class="s0">is not None or </span><span class="s1">input_shape </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">input_data </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">input_data </span><span class="s2">= </span><span class="s1">create_eager_tensors</span><span class="s2">(</span>
                    <span class="s1">input_shape</span><span class="s2">, </span><span class="s1">input_dtype</span><span class="s2">, </span><span class="s1">input_sparse</span>
                <span class="s2">)</span>
            <span class="s1">layer </span><span class="s2">= </span><span class="s1">layer_cls</span><span class="s2">(**</span><span class="s1">init_kwargs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_data</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                <span class="s1">output_data </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(**</span><span class="s1">input_data</span><span class="s2">, **</span><span class="s1">call_kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">output_data </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(</span><span class="s1">input_data</span><span class="s2">, **</span><span class="s1">call_kwargs</span><span class="s2">)</span>
            <span class="s1">run_output_asserts</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">output_data</span><span class="s2">, </span><span class="s1">eager</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">run_training_check</span><span class="s2">:</span>
                <span class="s1">run_training_step</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">, </span><span class="s1">input_data</span><span class="s2">, </span><span class="s1">output_data</span><span class="s2">)</span>

            <span class="s3"># Never test mixed precision on torch CPU. Torch lacks support.</span>
            <span class="s0">if </span><span class="s1">run_mixed_precision_check </span><span class="s0">and </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;torch&quot;</span><span class="s2">:</span>
                <span class="s0">import </span><span class="s1">torch</span>

                <span class="s1">run_mixed_precision_check </span><span class="s2">= </span><span class="s1">torch</span><span class="s2">.</span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">is_available</span><span class="s2">()</span>

            <span class="s0">if </span><span class="s1">run_mixed_precision_check</span><span class="s2">:</span>
                <span class="s1">layer </span><span class="s2">= </span><span class="s1">layer_cls</span><span class="s2">(**{**</span><span class="s1">init_kwargs</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s2">: </span><span class="s5">&quot;mixed_float16&quot;</span><span class="s2">})</span>
                <span class="s1">input_spec </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">map_structure</span><span class="s2">(</span>
                    <span class="s0">lambda </span><span class="s1">spec</span><span class="s2">: </span><span class="s1">KerasTensor</span><span class="s2">(</span>
                        <span class="s1">spec</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                        <span class="s1">dtype</span><span class="s2">=(</span>
                            <span class="s1">layer</span><span class="s2">.</span><span class="s1">compute_dtype</span>
                            <span class="s0">if </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">autocast</span>
                            <span class="s0">and </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">is_float_dtype</span><span class="s2">(</span><span class="s1">spec</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                            <span class="s0">else </span><span class="s1">spec</span><span class="s2">.</span><span class="s1">dtype</span>
                        <span class="s2">),</span>
                    <span class="s2">),</span>
                    <span class="s1">keras_tensor_inputs</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_data</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
                    <span class="s1">output_data </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(**</span><span class="s1">input_data</span><span class="s2">, **</span><span class="s1">call_kwargs</span><span class="s2">)</span>
                    <span class="s1">output_spec </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">compute_output_spec</span><span class="s2">(**</span><span class="s1">input_spec</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">output_data </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">(</span><span class="s1">input_data</span><span class="s2">, **</span><span class="s1">call_kwargs</span><span class="s2">)</span>
                    <span class="s1">output_spec </span><span class="s2">= </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">compute_output_spec</span><span class="s2">(</span><span class="s1">input_spec</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">tensor</span><span class="s2">, </span><span class="s1">spec </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span>
                    <span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">output_data</span><span class="s2">), </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">output_spec</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">tensor</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">weight </span><span class="s0">in </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">weights</span><span class="s2">:</span>
                    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">standardize_dtype</span><span class="s2">(</span><span class="s1">weight</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">is_float_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s5">&quot;float32&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">tensorflow_uses_gpu</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;tensorflow&quot; </span><span class="s0">and </span><span class="s1">uses_gpu</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">jax_uses_gpu</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;jax&quot; </span><span class="s0">and </span><span class="s1">uses_gpu</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">torch_uses_gpu</span><span class="s2">():</span>
    <span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() != </span><span class="s5">&quot;torch&quot;</span><span class="s2">:</span>
        <span class="s0">return False</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">torch</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">get_device</span>

    <span class="s0">return </span><span class="s1">get_device</span><span class="s2">() == </span><span class="s5">&quot;cuda&quot;</span>


<span class="s0">def </span><span class="s1">uses_gpu</span><span class="s2">():</span>
    <span class="s3"># Condition used to skip tests when using the GPU</span>
    <span class="s1">devices </span><span class="s2">= </span><span class="s1">distribution</span><span class="s2">.</span><span class="s1">list_devices</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">d</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">&quot;gpu&quot;</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">devices</span><span class="s2">):</span>
        <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">create_keras_tensors</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s1">utils</span><span class="s2">.</span><span class="s1">removesuffix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">&quot;_shape&quot;</span><span class="s2">): </span><span class="s1">KerasTensor</span><span class="s2">(</span>
                <span class="s1">v</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">sparse</span><span class="s2">=</span><span class="s1">sparse</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">input_shape</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s2">}</span>
    <span class="s0">return </span><span class="s1">map_shape_dtype_structure</span><span class="s2">(</span>
        <span class="s0">lambda </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">: </span><span class="s1">KerasTensor</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">=</span><span class="s1">sparse</span><span class="s2">),</span>
        <span class="s1">input_shape</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">create_eager_tensors</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend </span><span class="s0">import </span><span class="s1">random</span>

    <span class="s0">if </span><span class="s1">set</span><span class="s2">(</span><span class="s1">tree</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)).</span><span class="s1">difference</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s5">&quot;float16&quot;</span><span class="s2">, </span><span class="s5">&quot;float32&quot;</span><span class="s2">, </span><span class="s5">&quot;float64&quot;</span><span class="s2">, </span><span class="s5">&quot;int16&quot;</span><span class="s2">, </span><span class="s5">&quot;int32&quot;</span><span class="s2">, </span><span class="s5">&quot;int64&quot;</span><span class="s2">]</span>
    <span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s5">&quot;dtype must be a standard float or int dtype. &quot;</span>
            <span class="s5">f&quot;Received: dtype=</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">sparse</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;tensorflow&quot;</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">tensorflow </span><span class="s0">as </span><span class="s1">tf</span>

            <span class="s0">def </span><span class="s1">create_fn</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
                <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">(</span><span class="s4">0</span><span class="s2">)</span>
                <span class="s1">x </span><span class="s2">= (</span><span class="s4">4 </span><span class="s2">* </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">standard_normal</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">)</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">random</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) &lt; </span><span class="s4">0.7</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">tf</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">from_dense</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s5">&quot;jax&quot;</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">jax</span><span class="s2">.</span><span class="s1">experimental</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">as </span><span class="s1">jax_sparse</span>

            <span class="s0">def </span><span class="s1">create_fn</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
                <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">(</span><span class="s4">0</span><span class="s2">)</span>
                <span class="s1">x </span><span class="s2">= (</span><span class="s4">4 </span><span class="s2">* </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">standard_normal</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">)</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">random</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) &lt; </span><span class="s4">0.7</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">jax_sparse</span><span class="s2">.</span><span class="s1">BCOO</span><span class="s2">.</span><span class="s1">fromdense</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">n_batch</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">f&quot;Sparse is unsupported with backend </span><span class="s0">{</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">()</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:</span>

        <span class="s0">def </span><span class="s1">create_fn</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
                <span class="s1">random</span><span class="s2">.</span><span class="s1">uniform</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;float32&quot;</span><span class="s2">) * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span>
            <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s1">utils</span><span class="s2">.</span><span class="s1">removesuffix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">&quot;_shape&quot;</span><span class="s2">): </span><span class="s1">create_fn</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">input_shape</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s2">}</span>
    <span class="s0">return </span><span class="s1">map_shape_dtype_structure</span><span class="s2">(</span><span class="s1">create_fn</span><span class="s2">, </span><span class="s1">input_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">is_shape_tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">all</span><span class="s2">(</span>
        <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">e</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">))) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">x</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">map_shape_dtype_structure</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Variant of tree.map_structure that operates on shape tuples.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">is_shape_tuple</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">fn</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">[</span>
            <span class="s1">map_shape_dtype_structure</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s2">]</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span>
            <span class="s1">map_shape_dtype_structure</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s1">k</span><span class="s2">: </span><span class="s1">map_shape_dtype_structure</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">shape</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s2">}</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s5">f&quot;Cannot map function to unknown objects </span><span class="s0">{</span><span class="s1">shape</span><span class="s0">} </span><span class="s5">and </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s2">)</span>


<span class="s0">def </span><span class="s1">get_seed_generators</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Get a List of all seed generators in the layer recursively.&quot;&quot;&quot;</span>
    <span class="s1">seed_generators </span><span class="s2">= []</span>
    <span class="s1">seen_ids </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">sublayer </span><span class="s0">in </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">_flatten_layers</span><span class="s2">(</span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">sg </span><span class="s0">in </span><span class="s1">sublayer</span><span class="s2">.</span><span class="s1">_seed_generators</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">id</span><span class="s2">(</span><span class="s1">sg</span><span class="s2">) </span><span class="s0">not in </span><span class="s1">seen_ids</span><span class="s2">:</span>
                <span class="s1">seed_generators</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sg</span><span class="s2">)</span>
                <span class="s1">seen_ids</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">id</span><span class="s2">(</span><span class="s1">sg</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">seed_generators</span>
</pre>
</body>
</html>