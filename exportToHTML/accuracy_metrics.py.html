<html>
<head>
<title>accuracy_metrics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
accuracy_metrics.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">losses</span><span class="s2">.</span><span class="s1">loss </span><span class="s0">import </span><span class="s1">squeeze_or_expand_to_same_rank</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">metrics </span><span class="s0">import </span><span class="s1">reduction_metrics</span>


<span class="s0">def </span><span class="s1">accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">())</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.Accuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Accuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Calculates how often predictions equal labels. 
 
    This metric creates two local variables, `total` and `count` that are used 
    to compute the frequency with which `y_pred` matches `y_true`. This 
    frequency is ultimately returned as `binary accuracy`: an idempotent 
    operation that simply divides `total` by `count`. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Args: 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Examples: 
 
    &gt;&gt;&gt; m = keras.metrics.Accuracy() 
    &gt;&gt;&gt; m.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]]) 
    &gt;&gt;&gt; m.result() 
    0.75 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]], 
    ...                sample_weight=[1, 1, 0, 0]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='binary_crossentropy', 
                  metrics=[keras.metrics.Accuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">=</span><span class="s1">accuracy</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.binary_accuracy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">binary_accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">=</span><span class="s6">0.5</span><span class="s2">):</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">threshold </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">&gt; </span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">())</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.BinaryAccuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinaryAccuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Calculates how often predictions match binary labels. 
 
    This metric creates two local variables, `total` and `count` that are used 
    to compute the frequency with which `y_pred` matches `y_true`. This 
    frequency is ultimately returned as `binary accuracy`: an idempotent 
    operation that simply divides `total` by `count`. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Args: 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        threshold: (Optional) Float representing the threshold for deciding 
        whether prediction values are 1 or 0. 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.BinaryAccuracy() 
    &gt;&gt;&gt; m.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]]) 
    &gt;&gt;&gt; m.result() 
    0.75 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]], 
    ...                sample_weight=[1, 0, 0, 1]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='binary_crossentropy', 
                  metrics=[keras.metrics.BinaryAccuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;binary_accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">=</span><span class="s6">0.5</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">fn</span><span class="s2">=</span><span class="s1">binary_accuracy</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">=</span><span class="s1">threshold</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">threshold </span><span class="s2">= </span><span class="s1">threshold</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s3">&quot;threshold&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">threshold</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.categorical_accuracy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">categorical_accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">y_true_org_shape </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s1">y_pred_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_true_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s5"># If the shape of y_true is (num_samples, 1), squeeze to (num_samples,)</span>
    <span class="s0">if </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">y_true_rank </span><span class="s0">is not None</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s2">(</span><span class="s1">y_pred_rank </span><span class="s0">is not None</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
    <span class="s2">):</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s5"># If the predicted output and actual output types don't match, force cast</span>
    <span class="s5"># them to match.</span>
    <span class="s0">if </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">())</span>
    <span class="s0">if </span><span class="s1">reshape_matches</span><span class="s2">:</span>
        <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">, </span><span class="s1">y_true_org_shape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">matches</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.CategoricalAccuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CategoricalAccuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Calculates how often predictions match one-hot labels. 
 
    You can provide logits of classes as `y_pred`, since argmax of 
    logits and probabilities are same. 
 
    This metric creates two local variables, `total` and `count` that are used 
    to compute the frequency with which `y_pred` matches `y_true`. This 
    frequency is ultimately returned as `categorical accuracy`: an idempotent 
    operation that simply divides `total` by `count`. 
 
    `y_pred` and `y_true` should be passed in as vectors of probabilities, 
    rather than as labels. If necessary, use `ops.one_hot` to expand `y_true` as 
    a vector. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Args: 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.CategoricalAccuracy() 
    &gt;&gt;&gt; m.update_state([[0, 0, 1], [0, 1, 0]], [[0.1, 0.9, 0.8], 
    ...                 [0.05, 0.95, 0]]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([[0, 0, 1], [0, 1, 0]], [[0.1, 0.9, 0.8], 
    ...                 [0.05, 0.95, 0]], 
    ...                sample_weight=[0.7, 0.3]) 
    &gt;&gt;&gt; m.result() 
    0.3 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='categorical_crossentropy', 
                  metrics=[keras.metrics.CategoricalAccuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;categorical_accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">=</span><span class="s1">categorical_accuracy</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.sparse_categorical_accuracy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">sparse_categorical_accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true_org_shape </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s1">y_pred_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_true_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s5"># If the shape of y_true is (num_samples, 1), squeeze to (num_samples,)</span>
    <span class="s0">if </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">y_true_rank </span><span class="s0">is not None</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s2">(</span><span class="s1">y_pred_rank </span><span class="s0">is not None</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s0">and </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)[-</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">1</span>
    <span class="s2">):</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s5"># If the predicted output and actual output types don't match, force cast</span>
    <span class="s5"># them to match.</span>
    <span class="s0">if </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">())</span>
    <span class="s0">if </span><span class="s1">reshape_matches</span><span class="s2">:</span>
        <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">, </span><span class="s1">y_true_org_shape</span><span class="s2">)</span>
    <span class="s5"># if shape is (num_samples, 1) squeeze</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">matches</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">matches</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.SparseCategoricalAccuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SparseCategoricalAccuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Calculates how often predictions match integer labels. 
 
    ```python 
    acc = np.dot(sample_weight, np.equal(y_true, np.argmax(y_pred, axis=1)) 
    ``` 
 
    You can provide logits of classes as `y_pred`, since argmax of 
    logits and probabilities are same. 
 
    This metric creates two local variables, `total` and `count` that are used 
    to compute the frequency with which `y_pred` matches `y_true`. This 
    frequency is ultimately returned as `sparse categorical accuracy`: an 
    idempotent operation that simply divides `total` by `count`. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Args: 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.SparseCategoricalAccuracy() 
    &gt;&gt;&gt; m.update_state([[2], [1]], [[0.1, 0.6, 0.3], [0.05, 0.95, 0]]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([[2], [1]], [[0.1, 0.6, 0.3], [0.05, 0.95, 0]], 
    ...                sample_weight=[0.7, 0.3]) 
    &gt;&gt;&gt; m.result() 
    0.3 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='sparse_categorical_crossentropy', 
                  metrics=[keras.metrics.SparseCategoricalAccuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;sparse_categorical_accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">=</span><span class="s1">sparse_categorical_accuracy</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.top_k_categorical_accuracy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">top_k_categorical_accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">5</span><span class="s2">):</span>
    <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">y_true_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_pred_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_true_org_shape </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>

    <span class="s5"># Flatten y_pred to (batch_size, num_samples) and y_true to (num_samples,)</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">y_true_rank </span><span class="s0">is not None</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">y_pred_rank </span><span class="s0">is not None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">y_pred_rank </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, [-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]])</span>
        <span class="s0">if </span><span class="s1">y_true_rank </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, [-</span><span class="s6">1</span><span class="s2">])</span>

    <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">in_top_k</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s3">&quot;int32&quot;</span><span class="s2">), </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">),</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">(),</span>
    <span class="s2">)</span>

    <span class="s5"># returned matches is expected to have same shape as y_true input</span>
    <span class="s0">if </span><span class="s1">reshape_matches</span><span class="s2">:</span>
        <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">, </span><span class="s1">y_true_org_shape</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">matches</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.TopKCategoricalAccuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TopKCategoricalAccuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes how often targets are in the top `K` predictions. 
 
    Args: 
        k: (Optional) Number of top elements to look at for computing accuracy. 
            Defaults to `5`. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.TopKCategoricalAccuracy(k=1) 
    &gt;&gt;&gt; m.update_state([[0, 0, 1], [0, 1, 0]], 
    ...                [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([[0, 0, 1], [0, 1, 0]], 
    ...                [[0.1, 0.9, 0.8], [0.05, 0.95, 0]], 
    ...                sample_weight=[0.7, 0.3]) 
    &gt;&gt;&gt; m.result() 
    0.3 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='categorical_crossentropy', 
                  metrics=[keras.metrics.TopKCategoricalAccuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">5</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;top_k_categorical_accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">fn</span><span class="s2">=</span><span class="s1">top_k_categorical_accuracy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">k</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">&quot;k&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.sparse_top_k_categorical_accuracy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">sparse_top_k_categorical_accuracy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">5</span><span class="s2">):</span>
    <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_pred_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">y_true_org_shape </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>

    <span class="s5"># Flatten y_pred to (batch_size, num_samples) and y_true to (num_samples,)</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">y_true_rank </span><span class="s0">is not None</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">y_pred_rank </span><span class="s0">is not None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">y_pred_rank </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, [-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]])</span>
        <span class="s0">if </span><span class="s1">y_true_rank </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">reshape_matches </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, [-</span><span class="s6">1</span><span class="s2">])</span>

    <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">in_top_k</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s3">&quot;int32&quot;</span><span class="s2">), </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">),</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">floatx</span><span class="s2">(),</span>
    <span class="s2">)</span>

    <span class="s5"># returned matches is expected to have same shape as y_true input</span>
    <span class="s0">if </span><span class="s1">reshape_matches</span><span class="s2">:</span>
        <span class="s1">matches </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">matches</span><span class="s2">, </span><span class="s1">y_true_org_shape</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">matches</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.metrics.SparseTopKCategoricalAccuracy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SparseTopKCategoricalAccuracy</span><span class="s2">(</span><span class="s1">reduction_metrics</span><span class="s2">.</span><span class="s1">MeanMetricWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes how often integer targets are in the top `K` predictions. 
 
    Args: 
        k: (Optional) Number of top elements to look at for computing accuracy. 
            Defaults to `5`. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.SparseTopKCategoricalAccuracy(k=1) 
    &gt;&gt;&gt; m.update_state([2, 1], [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]) 
    &gt;&gt;&gt; m.result() 
    0.5 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([2, 1], [[0.1, 0.9, 0.8], [0.05, 0.95, 0]], 
    ...                sample_weight=[0.7, 0.3]) 
    &gt;&gt;&gt; m.result() 
    0.3 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss='sparse_categorical_crossentropy', 
                  metrics=[keras.metrics.SparseTopKCategoricalAccuracy()]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">5</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;sparse_top_k_categorical_accuracy&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">fn</span><span class="s2">=</span><span class="s1">sparse_top_k_categorical_accuracy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">k</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s3">&quot;up&quot;</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s3">&quot;k&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">}</span>
</pre>
</body>
</html>