<html>
<head>
<title>blocks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
blocks.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">wraps</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">final</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">weakref</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_config </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">get_option</span><span class="s2">,</span>
    <span class="s1">using_copy_on_write</span><span class="s2">,</span>
    <span class="s1">warn_copy_on_write</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">internals </span><span class="s0">as </span><span class="s1">libinternals</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">internals </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BlockPlacement</span><span class="s2">,</span>
    <span class="s1">BlockValuesRefs</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">missing </span><span class="s0">import </span><span class="s1">NA</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">AxisInt</span><span class="s2">,</span>
    <span class="s1">DtypeBackend</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">F</span><span class="s2">,</span>
    <span class="s1">FillnaOptions</span><span class="s2">,</span>
    <span class="s1">IgnoreRaise</span><span class="s2">,</span>
    <span class="s1">InterpolateOptions</span><span class="s2">,</span>
    <span class="s1">QuantileInterpolation</span><span class="s2">,</span>
    <span class="s1">Self</span><span class="s2">,</span>
    <span class="s1">Shape</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_validators </span><span class="s0">import </span><span class="s1">validate_bool_kwarg</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">astype </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">astype_array_safe</span><span class="s2">,</span>
    <span class="s1">astype_is_view</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">cast </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">LossySetitemError</span><span class="s2">,</span>
    <span class="s1">can_hold_element</span><span class="s2">,</span>
    <span class="s1">convert_dtypes</span><span class="s2">,</span>
    <span class="s1">find_result_type</span><span class="s2">,</span>
    <span class="s1">maybe_downcast_to_dtype</span><span class="s2">,</span>
    <span class="s1">np_can_hold_element</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">DatetimeTZDtype</span><span class="s2">,</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">IntervalDtype</span><span class="s2">,</span>
    <span class="s1">NumpyEADtype</span><span class="s2">,</span>
    <span class="s1">PeriodDtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCIndex</span><span class="s2">,</span>
    <span class="s1">ABCNumpyExtensionArray</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">missing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">missing</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos</span><span class="s2">.</span><span class="s1">putmask </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">extract_bool_array</span><span class="s2">,</span>
    <span class="s1">putmask_inplace</span><span class="s2">,</span>
    <span class="s1">putmask_without_repeat</span><span class="s2">,</span>
    <span class="s1">setitem_datetimelike_compat</span><span class="s2">,</span>
    <span class="s1">validate_putmask</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos</span><span class="s2">.</span><span class="s1">quantile </span><span class="s0">import </span><span class="s1">quantile_compat</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos</span><span class="s2">.</span><span class="s1">replace </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">compare_or_regex_search</span><span class="s2">,</span>
    <span class="s1">replace_regex</span><span class="s2">,</span>
    <span class="s1">should_use_regex</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos</span><span class="s2">.</span><span class="s1">transforms </span><span class="s0">import </span><span class="s1">shift</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">ExtensionArray</span><span class="s2">,</span>
    <span class="s1">IntervalArray</span><span class="s2">,</span>
    <span class="s1">NumpyExtensionArray</span><span class="s2">,</span>
    <span class="s1">PeriodArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">PandasObject</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">computation </span><span class="s0">import </span><span class="s1">expressions</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">construction </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexers </span><span class="s0">import </span><span class="s1">check_setitem_lengths</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">get_values_for_csv</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Iterable</span><span class="s2">,</span>
        <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">api </span><span class="s0">import </span><span class="s1">Index</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">_mixins </span><span class="s0">import </span><span class="s1">NDArrayBackedExtensionArray</span>

<span class="s3"># comparison is faster than is_object_dtype</span>
<span class="s1">_dtype_obj </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">&quot;object&quot;</span><span class="s2">)</span>


<span class="s1">COW_WARNING_GENERAL_MSG </span><span class="s2">= </span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">Setting a value on a view: behaviour will change in pandas 3.0. 
You are mutating a Series or DataFrame object, and currently this mutation will 
also have effect on other Series or DataFrame objects that share data with this 
object. In pandas 3.0 (with Copy-on-Write), updating one Series or DataFrame object 
will never modify another. 
&quot;&quot;&quot;</span>


<span class="s1">COW_WARNING_SETITEM_MSG </span><span class="s2">= </span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">Setting a value on a view: behaviour will change in pandas 3.0. 
Currently, the mutation will also have effect on the object that shares data 
with this object. For example, when setting a value in a Series that was 
extracted from a column of a DataFrame, that DataFrame will also be updated: 
 
    ser = df[&quot;col&quot;] 
    ser[0] = 0     &lt;--- in pandas 2, this also updates `df` 
 
In pandas 3.0 (with Copy-on-Write), updating one Series/DataFrame will never 
modify another, and thus in the example above, `df` will not be changed. 
&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">maybe_split</span><span class="s2">(</span><span class="s1">meth</span><span class="s2">: </span><span class="s1">F</span><span class="s2">) </span><span class="s1">-&gt; F</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    If we have a multi-column block, split and operate block-wise.  Otherwise 
    use the original method. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">meth</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">newfunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">meth</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># Split and operate column-by-column</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">split_and_operate</span><span class="s2">(</span><span class="s1">meth</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">F</span><span class="s2">, </span><span class="s1">newfunc</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Block</span><span class="s2">(</span><span class="s1">PandasObject</span><span class="s2">, </span><span class="s1">libinternals</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Canonical n-dimensional unit of homogeneous dtype contained in a pandas 
    data structure 
 
    Index-ignorant; let the container take care of that 
    &quot;&quot;&quot;</span>

    <span class="s1">values</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">| </span><span class="s1">ExtensionArray</span>
    <span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span>
    <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs</span>
    <span class="s1">__init__</span><span class="s2">: </span><span class="s1">Callable</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>
    <span class="s1">is_numeric </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_validate_ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        We validate dimension for blocks that can hold 2D values, which for now 
        means numpy dtypes or DatetimeTZDtype. 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">return not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_object</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_extension</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_np_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_can_consolidate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3"># We _could_ consolidate for DatetimeTZDtype but don't for now.</span>
        <span class="s0">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_extension</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_consolidate_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_consolidate</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_can_hold_na</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Can we store NA values in this Block? 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">not in </span><span class="s4">&quot;iub&quot;</span>
        <span class="s0">return </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">_can_hold_na</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_bool</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        We can be bool if a) we are bool dtype or b) object dtype with bool objects. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">external_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">external_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">fill_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># Used in reindex_indexer</span>
        <span class="s0">return </span><span class="s1">na_value_for_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">compat</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_standardize_fill_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s3"># if we are passed a scalar None, convert it here</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">_dtype_obj </span><span class="s0">and </span><span class="s1">is_valid_na_for_dtype</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">mgr_locs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; BlockPlacement</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span>

    <span class="s2">@</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s0">def </span><span class="s1">mgr_locs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs </span><span class="s2">= </span><span class="s1">new_mgr_locs</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">make_block</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">values</span><span class="s2">,</span>
        <span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Create a new block, with type inference propagate any values that are 
        not specified 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">placement </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">placement </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_extension</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">new_block</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">placement</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">make_block_same_class</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">values</span><span class="s2">,</span>
        <span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Wrap given values in a block of same type as self.&quot;&quot;&quot;</span>
        <span class="s3"># Pre-2.0 we called ensure_wrapped_if_datetimelike because fastparquet</span>
        <span class="s3">#  relied on it, as of 2.0 the caller is responsible for this.</span>
        <span class="s0">if </span><span class="s1">placement </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">placement </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span>

        <span class="s3"># We assume maybe_coerce_values has already been called</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">placement</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s3"># don't want to print out all of the items here</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">: </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span><span class="s0">} </span><span class="s4">dtype: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s4">&quot; x &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s1">str</span><span class="s2">(</span><span class="s1">s</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">])</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">, dtype: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">&quot;</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">slice_block_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">slc</span><span class="s2">: </span><span class="s1">slice</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Perform __getitem__-like, return result as block. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_mgr_locs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">[</span><span class="s1">slc</span><span class="s2">]</span>

        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_slice</span><span class="s2">(</span><span class="s1">slc</span><span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">take_block_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Perform __getitem__-like, return result as block. 
 
        Only supports slices that preserve dimensionality. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: only called from is from internals.concat, and we can verify</span>
        <span class="s3">#  that never happens with 1-column blocks, i.e. never for ExtensionBlock.</span>

        <span class="s1">new_mgr_locs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">]</span>

        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_slice</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">getitem_block_columns</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">slicer</span><span class="s2">: </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">, </span><span class="s1">ref_inplace_op</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Perform __getitem__-like, return result as block. 
 
        Only supports slices that preserve dimensionality. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_slice</span><span class="s2">(</span><span class="s1">slicer</span><span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs </span><span class="s0">if not </span><span class="s1">ref_inplace_op </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">() </span><span class="s0">else None</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_can_hold_element</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">element</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;require the same dtype as ourselves&quot;&quot;&quot;</span>
        <span class="s1">element </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">can_hold_element</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">element</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">should_store</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Should we set self.values[indexer] = value inplace or do we need to cast? 
 
        Parameters 
        ---------- 
        value : np.ndarray or ExtensionArray 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">value</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Apply/Reduce and Helpers</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        apply the function to my values; return a block if we are not 
        one 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split_op_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s3"># We will apply the function and reshape the result into a single-row</span>
        <span class="s3">#  Block with the same mgr_locs; squeezing will be done at a higher level</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">res_values </span><span class="s2">= </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">res_values </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">nb</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_split_op_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s3"># See also: split_and_operate</span>
        <span class="s0">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
            <span class="s3"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s3"># if we get a 2D ExtensionArray, we need to split it into 1D pieces</span>
            <span class="s1">nbs </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">):</span>
                <span class="s0">if not </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
                    <span class="s1">vals </span><span class="s2">= </span><span class="s1">result</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">vals </span><span class="s2">= </span><span class="s1">result</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

                <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
                <span class="s1">block </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">values</span><span class="s2">=</span><span class="s1">vals</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)</span>
                <span class="s1">nbs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">block</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">nbs</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s2">[</span><span class="s1">nb</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_split</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Split a block into a list of single-column blocks. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span>

        <span class="s1">new_blocks </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ref_loc </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">):</span>
            <span class="s1">vals </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)]</span>

            <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">ref_loc</span><span class="s2">)</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">vals</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s6">2</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">)</span>
            <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">new_blocks</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">split_and_operate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Split the block and apply func column-by-column. 
 
        Parameters 
        ---------- 
        func : Block method 
        *args 
        **kwargs 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s6">1</span>

        <span class="s1">res_blocks </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">():</span>
            <span class="s1">rbs </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rbs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">res_blocks</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Up/Down-casting</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        coerce the current block to a dtype compat for other 
        we will return a block, possibly object, and not raise 
 
        we can also safely try to coerce to the same dtype 
        and will receive the same block 
        &quot;&quot;&quot;</span>
        <span class="s1">new_dtype </span><span class="s2">= </span><span class="s1">find_result_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">new_dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s3"># GH#52927 avoid RecursionError</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                <span class="s4">&quot;Something has gone wrong, please report a bug at &quot;</span>
                <span class="s4">&quot;https://github.com/pandas-dev/pandas/issues&quot;</span>
            <span class="s2">)</span>

        <span class="s3"># In a future version of pandas, the default will be that</span>
        <span class="s3"># setting `nan` into an integer series won't raise.</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">is_scalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">is_integer_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">NaT</span>
            <span class="s0">and not </span><span class="s2">(</span>
                <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">timedelta64</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnat</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">warn_on_upcast </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">elif </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span>
            <span class="s0">and </span><span class="s1">is_integer_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">is_float_dtype</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">has_only_ints_or_nan</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">warn_on_upcast </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">warn_on_upcast</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">f&quot;Setting an item of incompatible dtype is deprecated &quot;</span>
                <span class="s4">&quot;and will raise an error in a future version of pandas. &quot;</span>
                <span class="s4">f&quot;Value '</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s4">' has dtype incompatible with </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">, &quot;</span>
                <span class="s4">&quot;please explicitly cast to a compatible dtype first.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">new_dtype</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                <span class="s4">f&quot;Did not expect new dtype </span><span class="s0">{</span><span class="s1">new_dtype</span><span class="s0">} </span><span class="s4">to equal self.dtype &quot;</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">. Please report a bug at &quot;</span>
                <span class="s4">&quot;https://github.com/pandas-dev/pandas/issues.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">new_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">],</span>
        <span class="s1">downcast</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">caller</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">downcast </span><span class="s0">is False</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">blocks</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s3"># TODO: does it matter that self.dtype might not match blocks[i].dtype?</span>
            <span class="s3"># GH#44241 We downcast regardless of the argument;</span>
            <span class="s3">#  respecting 'downcast=None' may be worthwhile at some point,</span>
            <span class="s3">#  but ATM it breaks too much existing code.</span>
            <span class="s3"># split and convert the blocks</span>

            <span class="s0">if </span><span class="s1">caller </span><span class="s2">== </span><span class="s4">&quot;fillna&quot; </span><span class="s0">and </span><span class="s1">get_option</span><span class="s2">(</span><span class="s4">&quot;future.no_silent_downcasting&quot;</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">blocks</span>

            <span class="s1">nbs </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">(</span>
                <span class="s2">[</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">not </span><span class="s1">using_cow</span><span class="s2">) </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">caller </span><span class="s2">== </span><span class="s4">&quot;fillna&quot;</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">all</span><span class="s2">(</span>
                    <span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s3"># GH#54261</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                        <span class="s4">&quot;Downcasting object dtype arrays on .fillna, .ffill, .bfill &quot;</span>
                        <span class="s4">&quot;is deprecated and will change in a future version. &quot;</span>
                        <span class="s4">&quot;Call result.infer_objects(copy=False) instead. &quot;</span>
                        <span class="s4">&quot;To opt-in to the future &quot;</span>
                        <span class="s4">&quot;behavior, set &quot;</span>
                        <span class="s4">&quot;`pd.set_option('future.no_silent_downcasting', True)`&quot;</span><span class="s2">,</span>
                        <span class="s1">FutureWarning</span><span class="s2">,</span>
                        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                    <span class="s2">)</span>

            <span class="s0">return </span><span class="s1">nbs</span>

        <span class="s0">elif </span><span class="s1">downcast </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">blocks</span>
        <span class="s0">elif </span><span class="s1">caller </span><span class="s2">== </span><span class="s4">&quot;where&quot; </span><span class="s0">and </span><span class="s1">get_option</span><span class="s2">(</span><span class="s4">&quot;future.no_silent_downcasting&quot;</span><span class="s2">) </span><span class="s0">is True</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">blocks</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">nbs </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">_downcast_2d</span><span class="s2">(</span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">])</span>

        <span class="s3"># When _maybe_downcast is called with caller=&quot;where&quot;, it is either</span>
        <span class="s3">#  a) with downcast=False, which is a no-op (the desired future behavior)</span>
        <span class="s3">#  b) with downcast=&quot;infer&quot;, which is _not_ passed by the user.</span>
        <span class="s3"># In the latter case the future behavior is to stop doing inference,</span>
        <span class="s3">#  so we issue a warning if and only if some inference occurred.</span>
        <span class="s0">if </span><span class="s1">caller </span><span class="s2">== </span><span class="s4">&quot;where&quot;</span><span class="s2">:</span>
            <span class="s3"># GH#53656</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">) </span><span class="s0">or </span><span class="s1">any</span><span class="s2">(</span>
                <span class="s1">left</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">right</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">nbs</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s3"># In this case _maybe_downcast was _not_ a no-op, so the behavior</span>
                <span class="s3">#  will change, so we issue a warning.</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s4">&quot;Downcasting behavior in Series and DataFrame methods 'where', &quot;</span>
                    <span class="s4">&quot;'mask', and 'clip' is deprecated. In a future &quot;</span>
                    <span class="s4">&quot;version this will not infer object dtypes or cast all-round &quot;</span>
                    <span class="s4">&quot;floats to integers. Instead call &quot;</span>
                    <span class="s4">&quot;result.infer_objects(copy=False) for object inference, &quot;</span>
                    <span class="s4">&quot;or cast round floats explicitly. To opt-in to the future &quot;</span>
                    <span class="s4">&quot;behavior, set &quot;</span>
                    <span class="s4">&quot;`pd.set_option('future.no_silent_downcasting', True)`&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">nbs</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">maybe_split</span>
    <span class="s0">def </span><span class="s1">_downcast_2d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        downcast specialized to 2D case post-validation. 
 
        Refactored to allow use of maybe_split. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">maybe_downcast_to_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs </span><span class="s0">if </span><span class="s1">new_values </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values </span><span class="s0">else None</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">convert</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Attempt to coerce any object types to better types. Return a copy 
        of the block (if copy = True). 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_object</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">copy </span><span class="s0">and </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()] </span><span class="s0">if </span><span class="s1">copy </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">blocks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">split_and_operate</span><span class="s2">(</span>
                <span class="s1">Block</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;O&quot; </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">):</span>
                <span class="s3"># Avoid fragmenting the block if convert is a no-op</span>
                <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()] </span><span class="s0">if </span><span class="s1">copy </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">blocks</span>

        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s3"># the check above ensures we only get here with values.shape[0] == 1,</span>
            <span class="s3"># avoid doing .ravel as that might make a copy</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s1">res_values </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">maybe_convert_objects</span><span class="s2">(</span>
            <span class="s1">values</span><span class="s2">,  </span><span class="s3"># type: ignore[arg-type]</span>
            <span class="s1">convert_non_numeric</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">copy </span><span class="s0">and </span><span class="s1">res_values </span><span class="s0">is </span><span class="s1">values</span><span class="s2">:</span>
            <span class="s1">res_values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">elif </span><span class="s1">res_values </span><span class="s0">is </span><span class="s1">values</span><span class="s2">:</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>

        <span class="s1">res_values </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">res_values </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">convert_dtypes</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">infer_objects</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">convert_string</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">convert_integer</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">convert_boolean</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">convert_floating</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">dtype_backend</span><span class="s2">: </span><span class="s1">DtypeBackend </span><span class="s2">= </span><span class="s4">&quot;numpy_nullable&quot;</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">infer_objects </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_object</span><span class="s2">:</span>
            <span class="s1">blks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">(</span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">blks </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">]</span>

        <span class="s0">if not </span><span class="s1">any</span><span class="s2">(</span>
            <span class="s2">[</span><span class="s1">convert_floating</span><span class="s2">, </span><span class="s1">convert_integer</span><span class="s2">, </span><span class="s1">convert_boolean</span><span class="s2">, </span><span class="s1">convert_string</span><span class="s2">]</span>
        <span class="s2">):</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blks</span><span class="s2">]</span>

        <span class="s1">rbs </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blks</span><span class="s2">:</span>
            <span class="s3"># Determine dtype column by column</span>
            <span class="s1">sub_blks </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">] </span><span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1 </span><span class="s0">else </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
            <span class="s1">dtypes </span><span class="s2">= [</span>
                <span class="s1">convert_dtypes</span><span class="s2">(</span>
                    <span class="s1">b</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
                    <span class="s1">convert_string</span><span class="s2">,</span>
                    <span class="s1">convert_integer</span><span class="s2">,</span>
                    <span class="s1">convert_boolean</span><span class="s2">,</span>
                    <span class="s1">convert_floating</span><span class="s2">,</span>
                    <span class="s1">infer_objects</span><span class="s2">,</span>
                    <span class="s1">dtype_backend</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">sub_blks</span>
            <span class="s2">]</span>
            <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">dtypes</span><span class="s2">):</span>
                <span class="s3"># Avoid block splitting if no dtype changes</span>
                <span class="s1">rbs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">))</span>
                <span class="s0">continue</span>

            <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">sub_blks</span><span class="s2">):</span>
                <span class="s1">rbs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">squeeze</span><span class="s2">=</span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">1</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">rbs</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Array-Like Methods</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DtypeObj</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">IgnoreRaise </span><span class="s2">= </span><span class="s4">&quot;raise&quot;</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">squeeze</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Coerce to the new dtype. 
 
        Parameters 
        ---------- 
        dtype : np.dtype or ExtensionDtype 
        copy : bool, default False 
            copy if indicated 
        errors : str, {'raise', 'ignore'}, default 'raise' 
            - ``raise`` : allow exceptions to be raised 
            - ``ignore`` : suppress exceptions. On error return original object 
        using_cow: bool, default False 
            Signaling if copy on write copy logic is used. 
        squeeze : bool, default False 
            squeeze values to ndim=1 if only one column is given 
 
        Returns 
        ------- 
        Block 
        &quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">if </span><span class="s1">squeeze </span><span class="s0">and </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s0">and </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Can not squeeze with more than one column.&quot;</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, :]  </span><span class="s3"># type: ignore[call-overload]</span>

        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">astype_array_safe</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">)</span>

        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">)</span>

        <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">using_cow </span><span class="s0">or not </span><span class="s1">copy</span><span class="s2">) </span><span class="s0">and </span><span class="s1">astype_is_view</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>

        <span class="s1">newb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">newb</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">f&quot;cannot set astype for copy = [</span><span class="s0">{</span><span class="s1">copy</span><span class="s0">}</span><span class="s4">] for dtype &quot;</span>
                <span class="s4">f&quot;(</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s0">} </span><span class="s4">[</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">]) to different shape &quot;</span>
                <span class="s4">f&quot;(</span><span class="s0">{</span><span class="s1">newb</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s0">} </span><span class="s4">[</span><span class="s0">{</span><span class="s1">newb</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">])&quot;</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">newb</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">get_values_for_csv</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">float_format</span><span class="s2">, </span><span class="s1">date_format</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">, </span><span class="s1">na_rep</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s4">&quot;nan&quot;</span><span class="s2">, </span><span class="s1">quoting</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;convert to our native types format&quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">get_values_for_csv</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">,</span>
            <span class="s1">na_rep</span><span class="s2">=</span><span class="s1">na_rep</span><span class="s2">,</span>
            <span class="s1">quoting</span><span class="s2">=</span><span class="s1">quoting</span><span class="s2">,</span>
            <span class="s1">float_format</span><span class="s2">=</span><span class="s1">float_format</span><span class="s2">,</span>
            <span class="s1">date_format</span><span class="s2">=</span><span class="s1">date_format</span><span class="s2">,</span>
            <span class="s1">decimal</span><span class="s2">=</span><span class="s1">decimal</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deep</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;copy constructor&quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">deep</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Copy-on-Write Helpers</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">using_cow </span><span class="s0">and </span><span class="s1">inplace</span><span class="s2">:</span>
            <span class="s1">deep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">()</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s1">deep</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">blk</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_get_refs_and_copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">copy </span><span class="s2">= </span><span class="s0">not </span><span class="s1">inplace</span>
        <span class="s0">if </span><span class="s1">inplace</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_cow </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>
        <span class="s0">return </span><span class="s1">copy</span><span class="s2">, </span><span class="s1">refs</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Replace</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">replace</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">to_replace</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s3"># mask may be pre-computed if we're called from replace_list</span>
        <span class="s1">mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        replace the to_replace value with value, possible to create new 
        blocks here this is just a call to putmask. 
        &quot;&quot;&quot;</span>

        <span class="s3"># Note: the checks we do in NDFrame.replace ensure we never get</span>
        <span class="s3">#  here with listlike to_replace or value, as those cases</span>
        <span class="s3">#  go through replace_list</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">Categorical</span><span class="s2">):</span>
            <span class="s3"># TODO: avoid special-casing</span>
            <span class="s3"># GH49404</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Categorical</span><span class="s2">, </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">values</span><span class="s2">.</span><span class="s1">_replace</span><span class="s2">(</span><span class="s1">to_replace</span><span class="s2">=</span><span class="s1">to_replace</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">blk</span><span class="s2">]</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_element</span><span class="s2">(</span><span class="s1">to_replace</span><span class="s2">):</span>
            <span class="s3"># We cannot hold `to_replace`, so we know immediately that</span>
            <span class="s3">#  replacing it is a no-op.</span>
            <span class="s3"># Note: If to_replace were a list, NDFrame.replace would call</span>
            <span class="s3">#  replace_list instead of replace.</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">missing</span><span class="s2">.</span><span class="s1">mask_missing</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">to_replace</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s3"># Note: we get here with test_replace_extension_other incorrectly</span>
            <span class="s3">#  bc _can_hold_element is incorrect.</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_element</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
            <span class="s3"># TODO(CoW): Maybe split here as well into columns where mask has True</span>
            <span class="s3"># and rest?</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>
            <span class="s1">putmask_inplace</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">inplace</span>
                <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
                <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
                <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
            <span class="s2">):</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                        <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                        <span class="s1">FutureWarning</span><span class="s2">,</span>
                        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                    <span class="s2">)</span>
                    <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if not </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_object </span><span class="s0">and </span><span class="s1">value </span><span class="s0">is None</span><span class="s2">):</span>
                <span class="s3"># if the user *explicitly* gave None, we keep None, otherwise</span>
                <span class="s3">#  may downcast to NaN</span>
                <span class="s0">if </span><span class="s1">get_option</span><span class="s2">(</span><span class="s4">&quot;future.no_silent_downcasting&quot;</span><span class="s2">) </span><span class="s0">is True</span><span class="s2">:</span>
                    <span class="s1">blocks </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">blocks </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">(</span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) &gt; </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">blocks</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
                        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                            <span class="s3"># GH#54710</span>
                            <span class="s4">&quot;Downcasting behavior in `replace` is deprecated and &quot;</span>
                            <span class="s4">&quot;will be removed in a future version. To retain the old &quot;</span>
                            <span class="s4">&quot;behavior, explicitly call &quot;</span>
                            <span class="s4">&quot;`result.infer_objects(copy=False)`. &quot;</span>
                            <span class="s4">&quot;To opt-in to the future &quot;</span>
                            <span class="s4">&quot;behavior, set &quot;</span>
                            <span class="s4">&quot;`pd.set_option('future.no_silent_downcasting', True)`&quot;</span><span class="s2">,</span>
                            <span class="s1">FutureWarning</span><span class="s2">,</span>
                            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                        <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">blocks </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">blocks</span>

        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None or </span><span class="s1">value </span><span class="s0">is </span><span class="s1">NA</span><span class="s2">:</span>
                <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span>
                <span class="s1">to_replace</span><span class="s2">=</span><span class="s1">to_replace</span><span class="s2">,</span>
                <span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
                <span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># split so that we only upcast where necessary</span>
            <span class="s1">blocks </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()):</span>
                <span class="s1">blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span>
                    <span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">replace</span><span class="s2">(</span>
                        <span class="s1">nb</span><span class="s2">,</span>
                        <span class="s1">to_replace</span><span class="s2">=</span><span class="s1">to_replace</span><span class="s2">,</span>
                        <span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
                        <span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                        <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">],</span>
                        <span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">blocks</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_replace_regex</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">to_replace</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Replace elements by the given value. 
 
        Parameters 
        ---------- 
        to_replace : object or pattern 
            Scalar to replace or regular expression to match. 
        value : object 
            Replacement object. 
        inplace : bool, default False 
            Perform inplace modification. 
        mask : array-like of bool, optional 
            True indicate corresponding element is ignored. 
        using_cow: bool, default False 
            Specifying if copy on write is enabled. 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_element</span><span class="s2">(</span><span class="s1">to_replace</span><span class="s2">):</span>
            <span class="s3"># i.e. only if self.is_object is True, but could in principle include a</span>
            <span class="s3">#  String ExtensionBlock</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s1">rx </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">to_replace</span><span class="s2">)</span>

        <span class="s1">block </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>

        <span class="s1">replace_regex</span><span class="s2">(</span><span class="s1">block</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">rx</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">inplace</span>
            <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">nbs </span><span class="s2">= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">(</span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
        <span class="s1">opt </span><span class="s2">= </span><span class="s1">get_option</span><span class="s2">(</span><span class="s4">&quot;future.no_silent_downcasting&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">) &gt; </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">nbs</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">opt</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s3"># GH#54710</span>
                <span class="s4">&quot;Downcasting behavior in `replace` is deprecated and &quot;</span>
                <span class="s4">&quot;will be removed in a future version. To retain the old &quot;</span>
                <span class="s4">&quot;behavior, explicitly call `result.infer_objects(copy=False)`. &quot;</span>
                <span class="s4">&quot;To opt-in to the future &quot;</span>
                <span class="s4">&quot;behavior, set &quot;</span>
                <span class="s4">&quot;`pd.set_option('future.no_silent_downcasting', True)`&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">nbs</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">replace_list</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">src_list</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">],</span>
        <span class="s1">dest_list</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">],</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">regex</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        See BlockManager.replace_list docstring. 
        &quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">Categorical</span><span class="s2">):</span>
            <span class="s3"># TODO: avoid special-casing</span>
            <span class="s3"># GH49404</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Categorical</span><span class="s2">, </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">values</span><span class="s2">.</span><span class="s1">_replace</span><span class="s2">(</span><span class="s1">to_replace</span><span class="s2">=</span><span class="s1">src_list</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">dest_list</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">blk</span><span class="s2">]</span>

        <span class="s3"># Exclude anything that we know we won't contain</span>
        <span class="s1">pairs </span><span class="s2">= [</span>
            <span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">src_list</span><span class="s2">, </span><span class="s1">dest_list</span><span class="s2">) </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_element</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">pairs</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s3"># shortcut, nothing to replace</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s1">src_len </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">pairs</span><span class="s2">) - </span><span class="s6">1</span>

        <span class="s0">if </span><span class="s1">is_string_dtype</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s3"># Calculate the mask once, prior to the call of comp</span>
            <span class="s3"># in order to avoid repeating the same computations</span>
            <span class="s1">na_mask </span><span class="s2">= ~</span><span class="s1">isna</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">masks</span><span class="s2">: </span><span class="s1">Iterable</span><span class="s2">[</span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]] = (</span>
                <span class="s1">extract_bool_array</span><span class="s2">(</span>
                    <span class="s1">cast</span><span class="s2">(</span>
                        <span class="s1">ArrayLike</span><span class="s2">,</span>
                        <span class="s1">compare_or_regex_search</span><span class="s2">(</span>
                            <span class="s1">values</span><span class="s2">, </span><span class="s1">s</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">regex</span><span class="s2">=</span><span class="s1">regex</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">na_mask</span>
                        <span class="s2">),</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pairs</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># GH#38086 faster if we know we dont need to check for regex</span>
            <span class="s1">masks </span><span class="s2">= (</span><span class="s1">missing</span><span class="s2">.</span><span class="s1">mask_missing</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">s</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pairs</span><span class="s2">)</span>
        <span class="s3"># Materialize if inplace = True, since the masks can change</span>
        <span class="s3"># as we replace</span>
        <span class="s0">if </span><span class="s1">inplace</span><span class="s2">:</span>
            <span class="s1">masks </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">masks</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
            <span class="s3"># Don't set up refs here, otherwise we will think that we have</span>
            <span class="s3"># references when we check again later</span>
            <span class="s1">rb </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">rb </span><span class="s2">= [</span><span class="s1">self </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">inplace</span>
            <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">opt </span><span class="s2">= </span><span class="s1">get_option</span><span class="s2">(</span><span class="s4">&quot;future.no_silent_downcasting&quot;</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, ((</span><span class="s1">src</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">), </span><span class="s1">mask</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">pairs</span><span class="s2">, </span><span class="s1">masks</span><span class="s2">)):</span>
            <span class="s1">convert </span><span class="s2">= </span><span class="s1">i </span><span class="s2">== </span><span class="s1">src_len  </span><span class="s3"># only convert once at the end</span>
            <span class="s1">new_rb</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>

            <span class="s3"># GH-39338: _replace_coerce can split a block into</span>
            <span class="s3"># single-column blocks, so track the index so we know</span>
            <span class="s3"># where to index into the mask</span>
            <span class="s0">for </span><span class="s1">blk_num</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">rb</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">rb</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s1">m </span><span class="s2">= </span><span class="s1">mask</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">mib </span><span class="s2">= </span><span class="s1">mask</span>
                    <span class="s0">assert not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mib</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">)</span>
                    <span class="s1">m </span><span class="s2">= </span><span class="s1">mib</span><span class="s2">[</span><span class="s1">blk_num </span><span class="s2">: </span><span class="s1">blk_num </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>

                <span class="s3"># error: Argument &quot;mask&quot; to &quot;_replace_coerce&quot; of &quot;Block&quot; has</span>
                <span class="s3"># incompatible type &quot;Union[ExtensionArray, ndarray[Any, Any], bool]&quot;;</span>
                <span class="s3"># expected &quot;ndarray[Any, dtype[bool_]]&quot;</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_replace_coerce</span><span class="s2">(</span>
                    <span class="s1">to_replace</span><span class="s2">=</span><span class="s1">src</span><span class="s2">,</span>
                    <span class="s1">value</span><span class="s2">=</span><span class="s1">dest</span><span class="s2">,</span>
                    <span class="s1">mask</span><span class="s2">=</span><span class="s1">m</span><span class="s2">,</span>
                    <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
                    <span class="s1">regex</span><span class="s2">=</span><span class="s1">regex</span><span class="s2">,</span>
                    <span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">,</span>
                <span class="s2">)</span>

                <span class="s0">if </span><span class="s1">using_cow </span><span class="s0">and </span><span class="s1">i </span><span class="s2">!= </span><span class="s1">src_len</span><span class="s2">:</span>
                    <span class="s3"># This is ugly, but we have to get rid of intermediate refs</span>
                    <span class="s3"># that did not go out of scope yet, otherwise we will trigger</span>
                    <span class="s3"># many unnecessary copies</span>
                    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">result</span><span class="s2">:</span>
                        <span class="s1">ref </span><span class="s2">= </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
                        <span class="s1">b</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">referenced_blocks</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span>
                            <span class="s1">b</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">referenced_blocks</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">)</span>
                        <span class="s2">)</span>

                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s0">not </span><span class="s1">opt</span>
                    <span class="s0">and </span><span class="s1">convert</span>
                    <span class="s0">and </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_object</span>
                    <span class="s0">and not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">x </span><span class="s0">is None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dest_list</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s3"># GH#44498 avoid unwanted cast-back</span>
                    <span class="s1">nbs </span><span class="s2">= []</span>
                    <span class="s0">for </span><span class="s1">res_blk </span><span class="s0">in </span><span class="s1">result</span><span class="s2">:</span>
                        <span class="s1">converted </span><span class="s2">= </span><span class="s1">res_blk</span><span class="s2">.</span><span class="s1">convert</span><span class="s2">(</span>
                            <span class="s1">copy</span><span class="s2">=</span><span class="s0">True and not </span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span>
                        <span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">converted</span><span class="s2">) &gt; </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">converted</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">res_blk</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
                            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                                <span class="s3"># GH#54710</span>
                                <span class="s4">&quot;Downcasting behavior in `replace` is deprecated &quot;</span>
                                <span class="s4">&quot;and will be removed in a future version. To &quot;</span>
                                <span class="s4">&quot;retain the old behavior, explicitly call &quot;</span>
                                <span class="s4">&quot;`result.infer_objects(copy=False)`. &quot;</span>
                                <span class="s4">&quot;To opt-in to the future &quot;</span>
                                <span class="s4">&quot;behavior, set &quot;</span>
                                <span class="s4">&quot;`pd.set_option('future.no_silent_downcasting', True)`&quot;</span><span class="s2">,</span>
                                <span class="s1">FutureWarning</span><span class="s2">,</span>
                                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                            <span class="s2">)</span>
                        <span class="s1">nbs</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">converted</span><span class="s2">)</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">nbs</span>
                <span class="s1">new_rb</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
            <span class="s1">rb </span><span class="s2">= </span><span class="s1">new_rb</span>
        <span class="s0">return </span><span class="s1">rb</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_replace_coerce</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">to_replace</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">],</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">regex</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Replace value corresponding to the given boolean array with another 
        value. 
 
        Parameters 
        ---------- 
        to_replace : object or pattern 
            Scalar to replace or regular expression to match. 
        value : object 
            Replacement object. 
        mask : np.ndarray[bool] 
            True indicate corresponding element is ignored. 
        inplace : bool, default True 
            Perform inplace modification. 
        regex : bool, default False 
            If true, perform regular expression substitution. 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">should_use_regex</span><span class="s2">(</span><span class="s1">regex</span><span class="s2">, </span><span class="s1">to_replace</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_replace_regex</span><span class="s2">(</span>
                <span class="s1">to_replace</span><span class="s2">,</span>
                <span class="s1">value</span><span class="s2">,</span>
                <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
                <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s3"># gh-45601, gh-45836, gh-46634</span>
                <span class="s0">if </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                    <span class="s1">has_ref </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">()</span>
                    <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">), </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s2">(</span><span class="s1">nb </span><span class="s0">is </span><span class="s1">self </span><span class="s0">or </span><span class="s1">using_cow</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">inplace</span><span class="s2">:</span>
                        <span class="s1">nb </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                    <span class="s0">elif </span><span class="s1">inplace </span><span class="s0">and </span><span class="s1">has_ref </span><span class="s0">and </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">() </span><span class="s0">and </span><span class="s1">using_cow</span><span class="s2">:</span>
                        <span class="s3"># no copy in astype and we had refs before</span>
                        <span class="s1">nb </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                    <span class="s1">putmask_inplace</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">nb</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span>
                <span class="s1">to_replace</span><span class="s2">=</span><span class="s1">to_replace</span><span class="s2">,</span>
                <span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
                <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
                <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">,</span>
                <span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">,</span>
            <span class="s2">)</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># 2D Methods - Shared by NumpyBlock and NDArrayBackedExtensionBlock</span>
    <span class="s3">#  but not ExtensionBlock</span>

    <span class="s0">def </span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        For compatibility with 1D-only ExtensionArrays. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">arg</span>

    <span class="s0">def </span><span class="s1">_unwrap_setitem_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        For compatibility with 1D-only ExtensionArrays. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">indexer</span>

    <span class="s3"># NB: this cannot be made cache_readonly because in mgr.set_values we pin</span>
    <span class="s3">#  new .values that can have different shape GH#42631</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Shape</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s0">def </span><span class="s1">iget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">] | </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s3"># In the case where we have a tuple[slice, int], the slice will always</span>
        <span class="s3">#  be slice(None)</span>
        <span class="s3"># Note: only reached with self.ndim == 2</span>
        <span class="s3"># Invalid index type &quot;Union[int, Tuple[int, int], Tuple[slice, int]]&quot;</span>
        <span class="s3"># for &quot;Union[ndarray[Any, Any], ExtensionArray]&quot;; expected type</span>
        <span class="s3"># &quot;Union[int, integer[Any]]&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]  </span><span class="s3"># type: ignore[index]</span>

    <span class="s0">def </span><span class="s1">_slice</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">slicer</span><span class="s2">: </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">] | </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return a slice of my values&quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">slicer</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">set_inplace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">locs</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Modify block values in-place with new item value. 
 
        If copy=True, first copy the underlying values in place before modifying 
        (for Copy-on-Write). 
 
        Notes 
        ----- 
        `set_inplace` never creates a new array or new Block, whereas `setitem` 
        _may_ create a new array and always creates a new Block. 
 
        Caller is responsible for checking values.dtype == self.dtype. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">locs</span><span class="s2">] = </span><span class="s1">values</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">take_nd</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">indexer</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt</span><span class="s2">,</span>
        <span class="s1">new_mgr_locs</span><span class="s2">: </span><span class="s1">BlockPlacement </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Take values according to indexer and return them as a block. 
        &quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">fill_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>
            <span class="s1">allow_fill </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">allow_fill </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s3"># Note: algos.take_nd has upcast logic similar to coerce_to_target_dtype</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span>
            <span class="s1">values</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span>
        <span class="s2">)</span>

        <span class="s3"># Called from three places in managers, all of which satisfy</span>
        <span class="s3">#  these assertions</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ExtensionBlock</span><span class="s2">):</span>
            <span class="s3"># NB: in this case, the 'axis' kwarg will be ignored in the</span>
            <span class="s3">#  algos.take_nd call above.</span>
            <span class="s0">assert not </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s2">)</span>
        <span class="s0">assert not </span><span class="s2">(</span><span class="s1">axis </span><span class="s2">== </span><span class="s6">0 </span><span class="s0">and </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">new_mgr_locs </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">new_mgr_locs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span>

        <span class="s0">if </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_unstack</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">unstacker</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">,</span>
        <span class="s1">new_placement</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
        <span class="s1">needs_masking</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">],</span>
    <span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a list of unstacked blocks of self 
 
        Parameters 
        ---------- 
        unstacker : reshape._Unstacker 
        fill_value : int 
            Only used in ExtensionBlock._unstack 
        new_placement : np.ndarray[np.intp] 
        allow_fill : bool 
        needs_masking : np.ndarray[bool] 
 
        Returns 
        ------- 
        blocks : list of Block 
            New blocks of unstacked values. 
        mask : array-like of bool 
            The mask of columns of `blocks` we should keep. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">get_new_values</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span>
        <span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s3"># TODO: in all tests we have mask.all(); can we rely on that?</span>

        <span class="s3"># Note: these next two lines ensure that</span>
        <span class="s3">#  mask.sum() == sum(len(nb.mgr_locs) for nb in blocks)</span>
        <span class="s3">#  which the calling function needs in order to pass verify_integrity=False</span>
        <span class="s3">#  to the BlockManager constructor</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s1">new_placement </span><span class="s2">= </span><span class="s1">new_placement</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>

        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">new_placement</span><span class="s2">)</span>
        <span class="s1">blocks </span><span class="s2">= [</span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)]</span>
        <span class="s0">return </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">mask</span>

    <span class="s3"># ---------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Attempt self.values[indexer] = value, possibly creating a new array. 
 
        Parameters 
        ---------- 
        indexer : tuple, list-like, array-like, slice, int 
            The subset of self.values to set 
        value : object 
            The value being set 
        using_cow: bool, default False 
            Signaling if CoW is used. 
 
        Returns 
        ------- 
        Block 
 
        Notes 
        ----- 
        `indexer` is a direct slice/positional indexer. `value` must 
        be a compatible shape. 
        &quot;&quot;&quot;</span>

        <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_standardize_fill_value</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

        <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s3"># length checking</span>
        <span class="s1">check_setitem_lengths</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s3"># GH48933: extract_array would convert a pd.Series value to np.ndarray</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">casted </span><span class="s2">= </span><span class="s1">np_can_hold_element</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">LossySetitemError</span><span class="s2">:</span>
            <span class="s3"># current dtype cannot store value, coerce to common dtype</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
                <span class="s3"># TODO: avoid having to construct values[indexer]</span>
                <span class="s1">vi </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">vi</span><span class="s2">):</span>
                    <span class="s3"># checking lib.is_scalar here fails on</span>
                    <span class="s3">#  test_iloc_setitem_custom_object</span>
                    <span class="s1">casted </span><span class="s2">= </span><span class="s1">setitem_datetimelike_compat</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vi</span><span class="s2">), </span><span class="s1">casted</span><span class="s2">)</span>

            <span class="s1">self </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">casted</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">casted</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">casted</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s3"># NumPy 1.25 deprecation: https://github.com/numpy/numpy/pull/10615</span>
                <span class="s1">casted </span><span class="s2">= </span><span class="s1">casted</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, ...]</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">values</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">casted</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">casted</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                        <span class="s4">&quot;setting an array element with a sequence.&quot;</span>
                    <span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>
                <span class="s0">raise</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">putmask</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, </span><span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        putmask the data to the block; it is possible that we may create a 
        new dtype of block 
 
        Return the resulting block(s). 
 
        Parameters 
        ---------- 
        mask : np.ndarray[bool], SparseArray[bool], or BooleanArray 
        new : a ndarray/object 
        using_cow: bool, default False 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_mask </span><span class="s2">= </span><span class="s1">mask</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s1">mask</span><span class="s2">, </span><span class="s1">noop </span><span class="s2">= </span><span class="s1">validate_putmask</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
        <span class="s0">assert not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, (</span><span class="s1">ABCIndex</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">new </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>

        <span class="s1">new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_standardize_fill_value</span><span class="s2">(</span><span class="s1">new</span><span class="s2">)</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">noop</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">casted </span><span class="s2">= </span><span class="s1">np_can_hold_element</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">new</span><span class="s2">)</span>

            <span class="s1">self </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

            <span class="s1">putmask_without_repeat</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">casted</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">LossySetitemError</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s3"># no need to split columns</span>

                <span class="s0">if not </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">new</span><span class="s2">):</span>
                    <span class="s3"># using just new[indexer] can't save us the need to cast</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span>
                        <span class="s1">new</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span>
                    <span class="s2">).</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">, </span><span class="s1">new</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">indexer </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">]</span>
                    <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">new</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">], </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">nb</span><span class="s2">]</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>

                <span class="s1">res_blocks </span><span class="s2">= []</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">):</span>
                    <span class="s1">n </span><span class="s2">= </span><span class="s1">new</span>
                    <span class="s0">if </span><span class="s1">is_array</span><span class="s2">:</span>
                        <span class="s3"># we have a different value per-column</span>
                        <span class="s1">n </span><span class="s2">= </span><span class="s1">new</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>

                    <span class="s1">submask </span><span class="s2">= </span><span class="s1">orig_mask</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
                    <span class="s1">rbs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">submask</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rbs</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">res_blocks</span>

    <span class="s0">def </span><span class="s1">where</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">_downcast</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s1">bool </span><span class="s2">= </span><span class="s4">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        evaluate the block; return result block(s) from the result 
 
        Parameters 
        ---------- 
        other : a ndarray/object 
        cond : np.ndarray[bool], SparseArray[bool], or BooleanArray 
        _downcast : str or None, default &quot;infer&quot; 
            Private because we only specify it when calling from fillna. 
 
        Returns 
        ------- 
        List[Block] 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">cond</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s0">assert not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, (</span><span class="s1">ABCIndex</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">))</span>

        <span class="s1">transpose </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span>

        <span class="s1">cond </span><span class="s2">= </span><span class="s1">extract_bool_array</span><span class="s2">(</span><span class="s1">cond</span><span class="s2">)</span>

        <span class="s3"># EABlocks override where</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s1">orig_other </span><span class="s2">= </span><span class="s1">other</span>
        <span class="s0">if </span><span class="s1">transpose</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s1">icond</span><span class="s2">, </span><span class="s1">noop </span><span class="s2">= </span><span class="s1">validate_putmask</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, ~</span><span class="s1">cond</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">noop</span><span class="s2">:</span>
            <span class="s3"># GH-39595: Always return a copy; short-circuit up/downcasting</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>

        <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_standardize_fill_value</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># try/except here is equivalent to a self._can_hold_element check,</span>
            <span class="s3">#  but this gets us back 'casted' which we will reuse below;</span>
            <span class="s3">#  without using 'casted', expressions.where may do unwanted upcasts.</span>
            <span class="s1">casted </span><span class="s2">= </span><span class="s1">np_can_hold_element</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">LossySetitemError</span><span class="s2">):</span>
            <span class="s3"># we cannot coerce, return a compat dtype</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s3"># no need to split columns</span>

                <span class="s1">block </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                <span class="s1">blocks </span><span class="s2">= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
                    <span class="s1">blocks</span><span class="s2">, </span><span class="s1">downcast</span><span class="s2">=</span><span class="s1">_downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;where&quot;</span>
                <span class="s2">)</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># since _maybe_downcast would split blocks anyway, we</span>
                <span class="s3">#  can avoid some potential upcast/downcast by splitting</span>
                <span class="s3">#  on the front end.</span>
                <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">))</span>

                <span class="s1">res_blocks </span><span class="s2">= []</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">):</span>
                    <span class="s1">oth </span><span class="s2">= </span><span class="s1">other</span>
                    <span class="s0">if </span><span class="s1">is_array</span><span class="s2">:</span>
                        <span class="s3"># we have a different value per-column</span>
                        <span class="s1">oth </span><span class="s2">= </span><span class="s1">other</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>

                    <span class="s1">submask </span><span class="s2">= </span><span class="s1">cond</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
                    <span class="s1">rbs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span>
                        <span class="s1">oth</span><span class="s2">, </span><span class="s1">submask</span><span class="s2">, </span><span class="s1">_downcast</span><span class="s2">=</span><span class="s1">_downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span>
                    <span class="s2">)</span>
                    <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rbs</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">res_blocks</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">casted</span>
            <span class="s1">alt </span><span class="s2">= </span><span class="s1">setitem_datetimelike_compat</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">icond</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">alt </span><span class="s0">is not </span><span class="s1">other</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) &lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">):</span>
                    <span class="s3"># call np.where with other to get the appropriate ValueError</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(~</span><span class="s1">icond</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                        <span class="s4">&quot;This should not be reached; call to np.where above is &quot;</span>
                        <span class="s4">&quot;expected to raise ValueError. Please report a bug at &quot;</span>
                        <span class="s4">&quot;github.com/pandas-dev/pandas&quot;</span>
                    <span class="s2">)</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">icond</span><span class="s2">, </span><span class="s1">alt</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># By the time we get here, we should have all Series/Index</span>
                <span class="s3">#  args extracted to ndarray</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                    <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                <span class="s2">):</span>
                    <span class="s3"># If we don't do this broadcasting here, then expressions.where</span>
                    <span class="s3">#  will broadcast a 1D other to be row-like instead of</span>
                    <span class="s3">#  column-like.</span>
                    <span class="s1">other </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">other</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                    <span class="s3"># If lengths don't match (or len(other)==1), we will raise</span>
                    <span class="s3">#  inside expressions.where, see test_series_where</span>

                <span class="s3"># Note: expressions.where may upcast.</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">expressions</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(~</span><span class="s1">icond</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
                <span class="s3"># The np_can_hold_element check _should_ ensure that we always</span>
                <span class="s3">#  have result.dtype == self.dtype here.</span>

        <span class="s0">if </span><span class="s1">transpose</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">fillna</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        fillna on the block with the value. If we fail, then convert to 
        block to hold objects instead and try again 
        &quot;&quot;&quot;</span>
        <span class="s3"># Caller is responsible for validating limit; if int it is strictly positive</span>
        <span class="s1">inplace </span><span class="s2">= </span><span class="s1">validate_bool_kwarg</span><span class="s2">(</span><span class="s1">inplace</span><span class="s2">, </span><span class="s4">&quot;inplace&quot;</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_na</span><span class="s2">:</span>
            <span class="s3"># can short-circuit the isna call</span>
            <span class="s1">noop </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">mask</span><span class="s2">, </span><span class="s1">noop </span><span class="s2">= </span><span class="s1">validate_putmask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">noop</span><span class="s2">:</span>
            <span class="s3"># we can't process the value, but nothing to do</span>
            <span class="s0">if </span><span class="s1">inplace</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
                <span class="s3"># Arbitrarily imposing the convention that we ignore downcast</span>
                <span class="s3">#  on no-op when inplace=True</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># GH#45423 consistent downcasting on no-ops.</span>
                <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">not </span><span class="s1">using_cow</span><span class="s2">)</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
                    <span class="s2">[</span><span class="s1">nb</span><span class="s2">], </span><span class="s1">downcast</span><span class="s2">=</span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fillna&quot;</span>
                <span class="s2">)</span>
                <span class="s0">return </span><span class="s1">nbs</span>

        <span class="s0">if </span><span class="s1">limit </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">mask</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">) &gt; </span><span class="s1">limit</span><span class="s2">] = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">inplace</span><span class="s2">:</span>
            <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span>
                <span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">already_warned</span><span class="s2">=</span><span class="s1">already_warned</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># without _downcast, we would break</span>
            <span class="s3">#  test_fillna_dtype_conversion_equiv_replace</span>
            <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, ~</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">_downcast</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s3"># Note: blk._maybe_downcast vs self._maybe_downcast(nbs)</span>
        <span class="s3">#  makes a difference bc blk may have object dtype, which has</span>
        <span class="s3">#  different behavior in _maybe_downcast.</span>
        <span class="s0">return </span><span class="s1">extend_blocks</span><span class="s2">(</span>
            <span class="s2">[</span>
                <span class="s1">blk</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
                    <span class="s2">[</span><span class="s1">blk</span><span class="s2">], </span><span class="s1">downcast</span><span class="s2">=</span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fillna&quot;</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">nbs</span>
            <span class="s2">]</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">pad_or_backfill</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">FillnaOptions</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;inside&quot;</span><span class="s2">, </span><span class="s4">&quot;outside&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;infer&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_na</span><span class="s2">:</span>
            <span class="s3"># If there are no NAs, then interpolate is a no-op</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s1">copy</span><span class="s2">, </span><span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_refs_and_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>

        <span class="s3"># Dispatch to the NumpyExtensionArray method.</span>
        <span class="s3"># We know self.array_values is a NumpyExtensionArray bc EABlock overrides</span>
        <span class="s1">vals </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">NumpyExtensionArray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_values</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">vals </span><span class="s2">= </span><span class="s1">vals</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">vals</span><span class="s2">.</span><span class="s1">_pad_or_backfill</span><span class="s2">(</span>
            <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">,</span>
            <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
            <span class="s1">limit_area</span><span class="s2">=</span><span class="s1">limit_area</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">copy</span>
            <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s1">data </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">([</span><span class="s1">nb</span><span class="s2">], </span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fillna&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">interpolate</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">InterpolateOptions</span><span class="s2">,</span>
        <span class="s1">index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">limit_direction</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;forward&quot;</span><span class="s2">, </span><span class="s4">&quot;backward&quot;</span><span class="s2">, </span><span class="s4">&quot;both&quot;</span><span class="s2">] = </span><span class="s4">&quot;forward&quot;</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;inside&quot;</span><span class="s2">, </span><span class="s4">&quot;outside&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;infer&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s1">inplace </span><span class="s2">= </span><span class="s1">validate_bool_kwarg</span><span class="s2">(</span><span class="s1">inplace</span><span class="s2">, </span><span class="s4">&quot;inplace&quot;</span><span class="s2">)</span>
        <span class="s3"># error: Non-overlapping equality check [...]</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s4">&quot;asfreq&quot;</span><span class="s2">:  </span><span class="s3"># type: ignore[comparison-overlap]</span>
            <span class="s3"># clean_fill_method used to allow this</span>
            <span class="s1">missing</span><span class="s2">.</span><span class="s1">clean_fill_method</span><span class="s2">(</span><span class="s1">method</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_na</span><span class="s2">:</span>
            <span class="s3"># If there are no NAs, then interpolate is a no-op</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s3"># TODO(3.0): this case will not be reachable once GH#53638 is enforced</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s3"># only deal with floats</span>
            <span class="s3"># bc we already checked that can_hold_na, we don't have int dtype here</span>
            <span class="s3"># test_interp_basic checks that we make a copy here</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">] </span><span class="s0">if </span><span class="s1">inplace </span><span class="s0">else </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s1">copy</span><span class="s2">, </span><span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_refs_and_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>

        <span class="s3"># Dispatch to the EA method.</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_values</span><span class="s2">.</span><span class="s1">interpolate</span><span class="s2">(</span>
            <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">,</span>
            <span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">,</span>
            <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
            <span class="s1">limit_direction</span><span class="s2">=</span><span class="s1">limit_direction</span><span class="s2">,</span>
            <span class="s1">limit_area</span><span class="s2">=</span><span class="s1">limit_area</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">copy</span>
            <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">([</span><span class="s1">nb</span><span class="s2">], </span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;interpolate&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;return block for the diff of the values&quot;&quot;&quot;</span>
        <span class="s3"># only reached with ndim == 2</span>
        <span class="s3"># TODO(EA2D): transpose will be unnecessary with 2D EAs</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">).</span><span class="s1">T</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block</span><span class="s2">(</span><span class="s1">values</span><span class="s2">=</span><span class="s1">new_values</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">shift</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;shift the block by periods, possibly upcast&quot;&quot;&quot;</span>
        <span class="s3"># convert integer to float if necessary. need to do a lot more than</span>
        <span class="s3"># that, handle boolean etc also</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s6">1</span>

        <span class="s3"># Note: periods is never 0 here, as that is handled at the top of</span>
        <span class="s3">#  NDFrame.shift.  If that ever changes, we can do a check for periods=0</span>
        <span class="s3">#  and possibly avoid coercing.</span>

        <span class="s0">if not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_scalar</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">) </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s3"># with object dtype there is nothing to promote, and the user can</span>
            <span class="s3">#  pass pretty much any weird fill_value they like</span>
            <span class="s3"># see test_shift_object_non_scalar_fill</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;fill_value must be a scalar&quot;</span><span class="s2">)</span>

        <span class="s1">fill_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_standardize_fill_value</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># error: Argument 1 to &quot;np_can_hold_element&quot; has incompatible type</span>
            <span class="s3"># &quot;Union[dtype[Any], ExtensionDtype]&quot;; expected &quot;dtype[Any]&quot;</span>
            <span class="s1">casted </span><span class="s2">= </span><span class="s1">np_can_hold_element</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value  </span><span class="s3"># type: ignore[arg-type]</span>
            <span class="s2">)</span>
        <span class="s0">except </span><span class="s1">LossySetitemError</span><span class="s2">:</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">(</span><span class="s1">periods</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">shift</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">casted</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">)]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">quantile</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">qs</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,  </span><span class="s3"># with dtype float64</span>
        <span class="s1">interpolation</span><span class="s2">: </span><span class="s1">QuantileInterpolation </span><span class="s2">= </span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        compute the quantiles of the 
 
        Parameters 
        ---------- 
        qs : Index 
            The quantiles to be computed in float64. 
        interpolation : str, default 'linear' 
            Type of interpolation. 
 
        Returns 
        ------- 
        Block 
        &quot;&quot;&quot;</span>
        <span class="s3"># We should always have ndim == 2 because Series dispatches to DataFrame</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span>
        <span class="s0">assert </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">)  </span><span class="s3"># caller is responsible for this</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">quantile_compat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">.</span><span class="s1">_values</span><span class="s2">), </span><span class="s1">interpolation</span><span class="s2">)</span>
        <span class="s3"># ensure_block_shape needed for cases where we start with EA and result</span>
        <span class="s3">#  is ndarray, e.g. IntegerArray, SparseArray</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">round</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">decimals</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Rounds the values. 
        If the block is not of an integer or float dtype, nothing happens. 
        This is consistent with DataFrame.round behavivor. 
        (Note: Series.round would raise) 
 
        Parameters 
        ---------- 
        decimals: int, 
            Number of decimal places to round to. 
            Caller is responsible for validating this 
        using_cow: bool, 
            Whether Copy on Write is enabled right now 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_numeric </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_bool</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">not </span><span class="s1">using_cow</span><span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s3"># TODO: round only defined on BaseMaskedArray</span>
        <span class="s3"># Series also does this, so would need to fix both places</span>
        <span class="s3"># error: Item &quot;ExtensionArray&quot; of &quot;Union[ndarray[Any, Any], ExtensionArray]&quot;</span>
        <span class="s3"># has no attribute &quot;round&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">decimals</span><span class="s2">)  </span><span class="s3"># type: ignore[union-attr]</span>
        <span class="s0">if </span><span class="s1">values </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s3"># Normally would need to do this before, but</span>
                <span class="s3"># numpy only returns same array when round operation</span>
                <span class="s3"># is no-op</span>
                <span class="s3"># https://github.com/numpy/numpy/blob/486878b37fc7439a3b2b87747f50db9b62fea8eb/numpy/core/src/multiarray/calculation.c#L625-L636</span>
                <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s3"># ---------------------------------------------------------------------</span>
    <span class="s3"># Abstract Methods Overridden By EABackedBlock and NumpyBlock</span>

    <span class="s0">def </span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Deletes the locs from the block. 
 
        We split the block to avoid copying the underlying data. We create new 
        blocks for every connected segment of the initial block that is not deleted. 
        The new blocks point to the initial array. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
            <span class="s1">loc </span><span class="s2">= [</span><span class="s1">loc</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)]</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">) &gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">IndexError</span>

        <span class="s3"># Add one out-of-bounds indexer as maximum to collect</span>
        <span class="s3"># all columns after our last indexer if any</span>
        <span class="s1">loc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">loc</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]]])</span>
        <span class="s1">mgr_locs_arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">.</span><span class="s1">as_array</span>
        <span class="s1">new_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>

        <span class="s1">previous_loc </span><span class="s2">= -</span><span class="s6">1</span>
        <span class="s3"># TODO(CoW): This is tricky, if parent block goes out of scope</span>
        <span class="s3"># all split blocks are referencing each other even though they</span>
        <span class="s3"># don't share data</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">() </span><span class="s0">else None</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">loc</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">idx </span><span class="s2">== </span><span class="s1">previous_loc </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s3"># There is no column between current and last idx</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot; matches</span>
                <span class="s3"># argument type &quot;Tuple[slice, slice]&quot;</span>
                <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">previous_loc </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">: </span><span class="s1">idx</span><span class="s2">, :]  </span><span class="s3"># type: ignore[call-overload]</span>
                <span class="s1">locs </span><span class="s2">= </span><span class="s1">mgr_locs_arr</span><span class="s2">[</span><span class="s1">previous_loc </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">: </span><span class="s1">idx</span><span class="s2">]</span>
                <span class="s1">nb </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span>
                    <span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">locs</span><span class="s2">), </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span>
                <span class="s2">)</span>
                <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>

            <span class="s1">previous_loc </span><span class="s2">= </span><span class="s1">idx</span>

        <span class="s0">return </span><span class="s1">new_blocks</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_view</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return a boolean if I am possibly a view&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">array_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        The array that Series.array returns. Always an ExtensionArray. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        return an internal format, currently just the ndarray 
        this is often overridden to handle to_dense like operations 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">EABackedBlock</span><span class="s2">(</span><span class="s1">Block</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Mixin for Block subclasses backed by ExtensionArray. 
    &quot;&quot;&quot;</span>

    <span class="s1">values</span><span class="s2">: </span><span class="s1">ExtensionArray</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">shift</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Shift the block by `periods`. 
 
        Dispatches to underlying ExtensionArray and re-boxes in an 
        ExtensionBlock. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Transpose since EA.shift is always along axis=0, while we want to shift</span>
        <span class="s3">#  along rows.</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">(</span><span class="s1">periods</span><span class="s2">=</span><span class="s1">periods</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">).</span><span class="s1">T</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">)]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Attempt self.values[indexer] = value, possibly creating a new array. 
 
        This differs from Block.setitem by not allowing setitem to change 
        the dtype of the Block. 
 
        Parameters 
        ---------- 
        indexer : tuple, list-like, array-like, slice, int 
            The subset of self.values to set 
        value : object 
            The value being set 
        using_cow: bool, default False 
            Signaling if CoW is used. 
 
        Returns 
        ------- 
        Block 
 
        Notes 
        ----- 
        `indexer` is a direct slice/positional indexer. `value` must 
        be a compatible shape. 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_indexer </span><span class="s2">= </span><span class="s1">indexer</span>
        <span class="s1">orig_value </span><span class="s2">= </span><span class="s1">value</span>

        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_unwrap_setitem_indexer</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s3"># TODO(GH#45419): string[pyarrow] tests break if we transpose</span>
            <span class="s3">#  unconditionally</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">check_setitem_lengths</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">values</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">):</span>
                <span class="s3"># see TestSetitemFloatIntervalWithIntIntervalValues</span>
                <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_value</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">orig_indexer</span><span class="s2">, </span><span class="s1">orig_value</span><span class="s2">)</span>

            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">NDArrayBackedExtensionBlock</span><span class="s2">):</span>
                <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_value</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">orig_indexer</span><span class="s2">, </span><span class="s1">orig_value</span><span class="s2">)</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">where</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">_downcast</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s1">bool </span><span class="s2">= </span><span class="s4">&quot;infer&quot;</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s3"># _downcast private bc we only specify it when calling from fillna</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s1">cond </span><span class="s2">= </span><span class="s1">extract_bool_array</span><span class="s2">(</span><span class="s1">cond</span><span class="s2">)</span>

        <span class="s1">orig_other </span><span class="s2">= </span><span class="s1">other</span>
        <span class="s1">orig_cond </span><span class="s2">= </span><span class="s1">cond</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s1">cond </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">cond</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>

        <span class="s1">icond</span><span class="s2">, </span><span class="s1">noop </span><span class="s2">= </span><span class="s1">validate_putmask</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, ~</span><span class="s1">cond</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">noop</span><span class="s2">:</span>
            <span class="s3"># GH#44181, GH#45135</span>
            <span class="s3"># Avoid a) raising for Interval/PeriodDtype and b) unnecessary object upcast</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()]</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">res_values </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">_where</span><span class="s2">(</span><span class="s1">cond</span><span class="s2">, </span><span class="s1">other</span><span class="s2">).</span><span class="s1">T</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">):</span>
                    <span class="s3"># TestSetitemFloatIntervalWithIntIntervalValues</span>
                    <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">)</span>
                    <span class="s1">nbs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">, </span><span class="s1">orig_cond</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
                        <span class="s1">nbs</span><span class="s2">, </span><span class="s1">downcast</span><span class="s2">=</span><span class="s1">_downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;where&quot;</span>
                    <span class="s2">)</span>

                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">NDArrayBackedExtensionBlock</span><span class="s2">):</span>
                    <span class="s3"># NB: not (yet) the same as</span>
                    <span class="s3">#  isinstance(values, NDArrayBackedExtensionArray)</span>
                    <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">)</span>
                    <span class="s1">nbs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">, </span><span class="s1">orig_cond</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">(</span>
                        <span class="s1">nbs</span><span class="s2">, </span><span class="s1">downcast</span><span class="s2">=</span><span class="s1">_downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;where&quot;</span>
                    <span class="s2">)</span>

                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># Same pattern we use in Block.putmask</span>
                <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">orig_other</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">))</span>

                <span class="s1">res_blocks </span><span class="s2">= []</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">):</span>
                    <span class="s1">n </span><span class="s2">= </span><span class="s1">orig_other</span>
                    <span class="s0">if </span><span class="s1">is_array</span><span class="s2">:</span>
                        <span class="s3"># we have a different value per-column</span>
                        <span class="s1">n </span><span class="s2">= </span><span class="s1">orig_other</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>

                    <span class="s1">submask </span><span class="s2">= </span><span class="s1">orig_cond</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
                    <span class="s1">rbs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">submask</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">)</span>
                    <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rbs</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">res_blocks</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">nb</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">putmask</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, </span><span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        See Block.putmask.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">extract_bool_array</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">new </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fill_value</span>

        <span class="s1">orig_new </span><span class="s2">= </span><span class="s1">new</span>
        <span class="s1">orig_mask </span><span class="s2">= </span><span class="s1">mask</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">new</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)]</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">warn_copy_on_write</span><span class="s2">()</span>
            <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
        <span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
                <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">self </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># Caller is responsible for ensuring matching lengths</span>
            <span class="s1">values</span><span class="s2">.</span><span class="s1">_putmask</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">, </span><span class="s1">new</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">):</span>
                    <span class="s3"># Discussion about what we want to support in the general</span>
                    <span class="s3">#  case GH#39584</span>
                    <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_new</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">orig_mask</span><span class="s2">, </span><span class="s1">orig_new</span><span class="s2">)</span>

                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">NDArrayBackedExtensionBlock</span><span class="s2">):</span>
                    <span class="s3"># NB: not (yet) the same as</span>
                    <span class="s3">#  isinstance(values, NDArrayBackedExtensionArray)</span>
                    <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coerce_to_target_dtype</span><span class="s2">(</span><span class="s1">orig_new</span><span class="s2">, </span><span class="s1">warn_on_upcast</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">orig_mask</span><span class="s2">, </span><span class="s1">orig_new</span><span class="s2">)</span>

                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># Same pattern we use in Block.putmask</span>
                <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">orig_new</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">))</span>

                <span class="s1">res_blocks </span><span class="s2">= []</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">):</span>
                    <span class="s1">n </span><span class="s2">= </span><span class="s1">orig_new</span>
                    <span class="s0">if </span><span class="s1">is_array</span><span class="s2">:</span>
                        <span class="s3"># we have a different value per-column</span>
                        <span class="s1">n </span><span class="s2">= </span><span class="s1">orig_new</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>

                    <span class="s1">submask </span><span class="s2">= </span><span class="s1">orig_mask</span><span class="s2">[:, </span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
                    <span class="s1">rbs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">submask</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
                    <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rbs</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">res_blocks</span>

        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s3"># This will be unnecessary if/when __array_function__ is implemented</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)]</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s3"># We get here through to_stata</span>
            <span class="s0">return </span><span class="s2">[]</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">array_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">get_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        return object dtype as boxed values, such as Timestamps/Timedelta 
        &quot;&quot;&quot;</span>
        <span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s3"># TODO(EA2D): reshape not needed with 2D EAs</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">values</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">pad_or_backfill</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">FillnaOptions</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;inside&quot;</span><span class="s2">, </span><span class="s4">&quot;outside&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s4">&quot;infer&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

        <span class="s1">kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = {</span><span class="s4">&quot;method&quot;</span><span class="s2">: </span><span class="s1">method</span><span class="s2">, </span><span class="s4">&quot;limit&quot;</span><span class="s2">: </span><span class="s1">limit</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s4">&quot;limit_area&quot; </span><span class="s0">in </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">_pad_or_backfill</span><span class="s2">).</span><span class="s1">parameters</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">&quot;limit_area&quot;</span><span class="s2">] = </span><span class="s1">limit_area</span>
        <span class="s0">elif </span><span class="s1">limit_area </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">values</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">does not implement limit_area &quot;</span>
                <span class="s4">&quot;(added in pandas 2.2). 3rd-party ExtnsionArray authors &quot;</span>
                <span class="s4">&quot;need to add this argument to _pad_or_backfill.&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s0">and </span><span class="s1">axis </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s3"># NDArrayBackedExtensionArray.fillna assumes axis=0</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">_pad_or_backfill</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">).</span><span class="s1">T</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">_pad_or_backfill</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">)]</span>


<span class="s0">class </span><span class="s1">ExtensionBlock</span><span class="s2">(</span><span class="s1">EABackedBlock</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Block for holding extension types. 
 
    Notes 
    ----- 
    This holds all 3rd-party extension array types. It's also the immediate 
    parent class for our internal extension types' blocks. 
 
    ExtensionArrays are limited to 1-D. 
    &quot;&quot;&quot;</span>

    <span class="s1">values</span><span class="s2">: </span><span class="s1">ExtensionArray</span>

    <span class="s0">def </span><span class="s1">fillna</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">using_cow</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">already_warned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">):</span>
            <span class="s3"># Block.fillna handles coercion (test_fillna_interval)</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">fillna</span><span class="s2">(</span>
                <span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
                <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
                <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
                <span class="s1">downcast</span><span class="s2">=</span><span class="s1">downcast</span><span class="s2">,</span>
                <span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">,</span>
                <span class="s1">already_warned</span><span class="s2">=</span><span class="s1">already_warned</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">using_cow </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_hold_na </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">copy</span><span class="s2">, </span><span class="s1">refs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_refs_and_copy</span><span class="s2">(</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">)</span>

            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">fillna</span><span class="s2">(</span>
                    <span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span>
                <span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s3"># 3rd party EA that has not implemented copy keyword yet</span>
                <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">fillna</span><span class="s2">(</span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>
                <span class="s3"># issue the warning *after* retrying, in case the TypeError</span>
                <span class="s3">#  was caused by an invalid fill_value</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s3"># GH#53278</span>
                    <span class="s4">&quot;ExtensionArray.fillna added a 'copy' keyword in pandas &quot;</span>
                    <span class="s4">&quot;2.1.0. In a future version, ExtensionArray subclasses will &quot;</span>
                    <span class="s4">&quot;need to implement this keyword or an exception will be &quot;</span>
                    <span class="s4">&quot;raised. In the interim, the keyword is ignored by &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s2">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s0">not </span><span class="s1">copy</span>
                    <span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
                    <span class="s0">and </span><span class="s1">already_warned </span><span class="s0">is not None</span>
                    <span class="s0">and not </span><span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already</span>
                <span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">():</span>
                        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                            <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                            <span class="s1">FutureWarning</span><span class="s2">,</span>
                            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                        <span class="s2">)</span>
                        <span class="s1">already_warned</span><span class="s2">.</span><span class="s1">warned_already </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_maybe_downcast</span><span class="s2">([</span><span class="s1">nb</span><span class="s2">], </span><span class="s1">downcast</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_cow</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fillna&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Shape</span><span class="s2">:</span>
        <span class="s3"># TODO(EA2D): override unnecessary with 2D EAs</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">),)</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">iget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">] | </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]):</span>
        <span class="s3"># In the case where we have a tuple[slice, int], the slice will always</span>
        <span class="s3">#  be slice(None)</span>
        <span class="s3"># We _could_ make the annotation more specific, but mypy would</span>
        <span class="s3">#  complain about override mismatch:</span>
        <span class="s3">#  Literal[0] | tuple[Literal[0], int] | tuple[slice, int]</span>

        <span class="s3"># Note: only reached with self.ndim == 2</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s3"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s1">col</span><span class="s2">, </span><span class="s1">loc </span><span class="s2">= </span><span class="s1">i</span>
            <span class="s0">if not </span><span class="s1">com</span><span class="s2">.</span><span class="s1">is_null_slice</span><span class="s2">(</span><span class="s1">col</span><span class="s2">) </span><span class="s0">and </span><span class="s1">col </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">only contains one item&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">col</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
                <span class="s3"># the is_null_slice check above assures that col is slice(None)</span>
                <span class="s3">#  so what we want is a view on all our columns and row loc</span>
                <span class="s0">if </span><span class="s1">loc </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                    <span class="s1">loc </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>
                <span class="s3"># Note: loc:loc+1 vs [[loc]] makes a difference when called</span>
                <span class="s3">#  from fast_xs because we want to get a view back.</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">loc </span><span class="s2">: </span><span class="s1">loc </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">only contains one item&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">set_inplace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">locs</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3"># When an ndarray, we should have locs.tolist() == [0]</span>
        <span class="s3"># When a BlockPlacement we should have list(locs) == [0]</span>
        <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[:] = </span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">_maybe_squeeze_arg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        If necessary, squeeze a (N, 1) ndarray to (N,) 
        &quot;&quot;&quot;</span>
        <span class="s3"># e.g. if we are passed a 2D mask for putmask</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">+ </span><span class="s6">1</span>
        <span class="s2">):</span>
            <span class="s3"># TODO(EA2D): unnecessary with 2D EAs</span>
            <span class="s0">assert </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">1</span>
            <span class="s3"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot;</span>
            <span class="s3"># matches argument type &quot;Tuple[slice, int]&quot;</span>
            <span class="s1">arg </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">[:, </span><span class="s6">0</span><span class="s2">]  </span><span class="s3"># type: ignore[call-overload]</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">):</span>
            <span class="s3"># 2022-01-06 only reached for setitem</span>
            <span class="s3"># TODO: should we avoid getting here with DataFrame?</span>
            <span class="s0">assert </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">1</span>
            <span class="s1">arg </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">_ixs</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">1</span><span class="s2">).</span><span class="s1">_values</span>

        <span class="s0">return </span><span class="s1">arg</span>

    <span class="s0">def </span><span class="s1">_unwrap_setitem_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adapt a 2D-indexer to our 1D values. 
 
        This is intended for 'setitem', not 'iget' or '_slice'. 
        &quot;&quot;&quot;</span>
        <span class="s3"># TODO: ATM this doesn't work for iget/_slice, can we change that?</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s3"># TODO(EA2D): not needed with 2D EAs</span>
            <span class="s3">#  Should never have length &gt; 2.  Caller is responsible for checking.</span>
            <span class="s3">#  Length 1 is reached vis setitem_single_block and setitem_single_column</span>
            <span class="s3">#  each of which pass indexer=(pi,)</span>
            <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">indexer</span><span class="s2">):</span>
                <span class="s3"># GH#44703 went through indexing.maybe_convert_ix</span>
                <span class="s1">first</span><span class="s2">, </span><span class="s1">second </span><span class="s2">= </span><span class="s1">indexer</span>
                <span class="s0">if not </span><span class="s2">(</span>
                    <span class="s1">second</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s2">(</span><span class="s1">second </span><span class="s2">== </span><span class="s6">0</span><span class="s2">).</span><span class="s1">all</span><span class="s2">() </span><span class="s0">and </span><span class="s1">first</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">1</span>
                <span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                        <span class="s4">&quot;This should not be reached. Please report a bug at &quot;</span>
                        <span class="s4">&quot;github.com/pandas-dev/pandas/&quot;</span>
                    <span class="s2">)</span>
                <span class="s1">indexer </span><span class="s2">= </span><span class="s1">first</span><span class="s2">[:, </span><span class="s6">0</span><span class="s2">]</span>

            <span class="s0">elif </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_integer</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]) </span><span class="s0">and </span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s3"># reached via setitem_single_block passing the whole indexer</span>
                <span class="s1">indexer </span><span class="s2">= </span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s0">elif </span><span class="s1">com</span><span class="s2">.</span><span class="s1">is_null_slice</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
                <span class="s1">indexer </span><span class="s2">= </span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s0">elif </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]) </span><span class="s0">and </span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">1</span><span class="s2">][</span><span class="s6">0</span><span class="s2">] == </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">indexer </span><span class="s2">= </span><span class="s1">indexer</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                    <span class="s4">&quot;This should not be reached. Please report a bug at &quot;</span>
                    <span class="s4">&quot;github.com/pandas-dev/pandas/&quot;</span>
                <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">indexer</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_view</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Extension arrays are never treated as views.&quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s3"># error: Cannot override writeable attribute with read-only property</span>
    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_numeric</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">_is_numeric</span>

    <span class="s0">def </span><span class="s1">_slice</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">slicer</span><span class="s2">: </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">] | </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a slice of my values. 
 
        Parameters 
        ---------- 
        slicer : slice, ndarray[int], or ndarray[bool] 
            Valid (non-reducing) indexer for self.values. 
 
        Returns 
        ------- 
        ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s3"># Notes: ndarray[bool] is only reachable when via get_rows_with_mask, which</span>
        <span class="s3">#  is only for Series, i.e. self.ndim == 1.</span>

        <span class="s3"># return same dims as we currently have</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s3"># reached via getitem_block via _slice_take_blocks_ax0</span>
            <span class="s3"># TODO(EA2D): won't be necessary with 2D EAs</span>

            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">slicer</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                    <span class="s4">&quot;invalid slicing for a 1-ndim ExtensionArray&quot;</span><span class="s2">, </span><span class="s1">slicer</span>
                <span class="s2">)</span>
            <span class="s3"># GH#32959 only full-slicers along fake-dim0 are valid</span>
            <span class="s3"># TODO(EA2D): won't be necessary with 2D EAs</span>
            <span class="s3"># range(1) instead of self._mgr_locs to avoid exception on [::-1]</span>
            <span class="s3">#  see test_iloc_getitem_slice_negative_step_ea_block</span>
            <span class="s1">new_locs </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)[</span><span class="s1">slicer</span><span class="s2">]</span>
            <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_locs</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                    <span class="s4">&quot;invalid slicing for a 1-ndim ExtensionArray&quot;</span><span class="s2">, </span><span class="s1">slicer</span>
                <span class="s2">)</span>
            <span class="s1">slicer </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">slicer</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">slice_block_rows</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">slicer</span><span class="s2">: </span><span class="s1">slice</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Perform __getitem__-like specialized to slicing along index. 
        &quot;&quot;&quot;</span>
        <span class="s3"># GH#42787 in principle this is equivalent to values[..., slicer], but we don't</span>
        <span class="s3"># require subclasses of ExtensionArray to support that form (for now).</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">slicer</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_unstack</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">unstacker</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">,</span>
        <span class="s1">new_placement</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
        <span class="s1">needs_masking</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">],</span>
    <span class="s2">):</span>
        <span class="s3"># ExtensionArray-safe unstack.</span>
        <span class="s3"># We override Block._unstack, which unstacks directly on the</span>
        <span class="s3"># values of the array. For EA-backed blocks, this would require</span>
        <span class="s3"># converting to a 2-D ndarray of objects.</span>
        <span class="s3"># Instead, we unstack an ndarray of integer positions, followed by</span>
        <span class="s3"># a `take` on the actual values.</span>

        <span class="s3"># Caller is responsible for ensuring self.shape[-1] == len(unstacker.index)</span>
        <span class="s1">new_values</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">arange_result</span>

        <span class="s3"># Note: these next two lines ensure that</span>
        <span class="s3">#  mask.sum() == sum(len(nb.mgr_locs) for nb in blocks)</span>
        <span class="s3">#  which the calling function needs in order to pass verify_integrity=False</span>
        <span class="s3">#  to the BlockManager constructor</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s1">new_placement </span><span class="s2">= </span><span class="s1">new_placement</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>

        <span class="s3"># needs_masking[i] calculated once in BlockManager.unstack tells</span>
        <span class="s3">#  us if there are any -1s in the relevant indices.  When False,</span>
        <span class="s3">#  that allows us to go through a faster path in 'take', among</span>
        <span class="s3">#  other things avoiding e.g. Categorical._validate_scalar.</span>
        <span class="s1">blocks </span><span class="s2">= [</span>
            <span class="s3"># TODO: could cast to object depending on fill_value?</span>
            <span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span>
                    <span class="s1">indices</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">needs_masking</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span>
                <span class="s2">),</span>
                <span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">place</span><span class="s2">),</span>
                <span class="s1">ndim</span><span class="s2">=</span><span class="s6">2</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, (</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">place</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">new_placement</span><span class="s2">))</span>
        <span class="s2">]</span>
        <span class="s0">return </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">mask</span>


<span class="s0">class </span><span class="s1">NumpyBlock</span><span class="s2">(</span><span class="s1">Block</span><span class="s2">):</span>
    <span class="s1">values</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s1">__slots__ </span><span class="s2">= ()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_view</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return a boolean if I am possibly a view&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">base </span><span class="s0">is not None</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">array_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">NumpyExtensionArray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">_dtype_obj</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">_dtype_obj</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_numeric</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">kind </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind</span>

        <span class="s0">return </span><span class="s1">kind </span><span class="s0">in </span><span class="s4">&quot;fciub&quot;</span>


<span class="s0">class </span><span class="s1">NumericBlock</span><span class="s2">(</span><span class="s1">NumpyBlock</span><span class="s2">):</span>
    <span class="s3"># this Block type is kept for backwards-compatibility</span>
    <span class="s3"># TODO(3.0): delete and remove deprecation in __init__.py.</span>
    <span class="s1">__slots__ </span><span class="s2">= ()</span>


<span class="s0">class </span><span class="s1">ObjectBlock</span><span class="s2">(</span><span class="s1">NumpyBlock</span><span class="s2">):</span>
    <span class="s3"># this Block type is kept for backwards-compatibility</span>
    <span class="s3"># TODO(3.0): delete and remove deprecation in __init__.py.</span>
    <span class="s1">__slots__ </span><span class="s2">= ()</span>


<span class="s0">class </span><span class="s1">NDArrayBackedExtensionBlock</span><span class="s2">(</span><span class="s1">EABackedBlock</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Block backed by an NDArrayBackedExtensionArray 
    &quot;&quot;&quot;</span>

    <span class="s1">values</span><span class="s2">: </span><span class="s1">NDArrayBackedExtensionArray</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_view</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;return a boolean if I am possibly a view&quot;&quot;&quot;</span>
        <span class="s3"># check the ndarray values of the DatetimeIndex values</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">_ndarray</span><span class="s2">.</span><span class="s1">base </span><span class="s0">is not None</span>


<span class="s0">class </span><span class="s1">DatetimeLikeBlock</span><span class="s2">(</span><span class="s1">NDArrayBackedExtensionBlock</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Block for datetime64[ns], timedelta64[ns].&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>
    <span class="s1">is_numeric </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">values</span><span class="s2">: </span><span class="s1">DatetimeArray </span><span class="s2">| </span><span class="s1">TimedeltaArray</span>


<span class="s0">class </span><span class="s1">DatetimeTZBlock</span><span class="s2">(</span><span class="s1">DatetimeLikeBlock</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;implement a datetime64 block with a tz attribute&quot;&quot;&quot;</span>

    <span class="s1">values</span><span class="s2">: </span><span class="s1">DatetimeArray</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>


<span class="s3"># -----------------------------------------------------------------</span>
<span class="s3"># Constructor Helpers</span>


<span class="s0">def </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Input validation for values passed to __init__. Ensure that 
    any datetime64/timedelta64 dtypes are in nanoseconds.  Ensure 
    that we do not have string dtypes. 
 
    Parameters 
    ---------- 
    values : np.ndarray or ExtensionArray 
 
    Returns 
    ------- 
    values : np.ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s3"># Caller is responsible for ensuring NumpyExtensionArray is already extracted.</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, (</span><span class="s1">DatetimeArray</span><span class="s2">, </span><span class="s1">TimedeltaArray</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">values</span><span class="s2">.</span><span class="s1">freq </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s3"># freq is only stored in DatetimeIndex/TimedeltaIndex, not in Series/DataFrame</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">_with_freq</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">get_block_type</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">) </span><span class="s1">-&gt; type</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Find the appropriate Block subclass to use for the given values and dtype. 
 
    Parameters 
    ---------- 
    dtype : numpy or pandas dtype 
 
    Returns 
    ------- 
    cls : class, subclass of Block 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">DatetimeTZBlock</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">PeriodDtype</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">NDArrayBackedExtensionBlock</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
        <span class="s3"># Note: need to be sure NumpyExtensionArray is unwrapped before we get here</span>
        <span class="s0">return </span><span class="s1">ExtensionBlock</span>

    <span class="s3"># We use kind checks because it is much more performant</span>
    <span class="s3">#  than is_foo_dtype</span>
    <span class="s1">kind </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind</span>
    <span class="s0">if </span><span class="s1">kind </span><span class="s0">in </span><span class="s4">&quot;Mm&quot;</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">DatetimeLikeBlock</span>

    <span class="s0">return </span><span class="s1">NumpyBlock</span>


<span class="s0">def </span><span class="s1">new_block_2d</span><span class="s2">(</span>
    <span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
<span class="s2">):</span>
    <span class="s3"># new_block specialized to case with</span>
    <span class="s3">#  ndim=2</span>
    <span class="s3">#  isinstance(placement, BlockPlacement)</span>
    <span class="s3">#  check_ndim/ensure_block_shape already checked</span>
    <span class="s1">klass </span><span class="s2">= </span><span class="s1">get_block_type</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">values </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">klass</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s6">2</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">placement</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">new_block</span><span class="s2">(</span>
    <span class="s1">values</span><span class="s2">,</span>
    <span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
    <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
    <span class="s3"># caller is responsible for ensuring:</span>
    <span class="s3"># - values is NOT a NumpyExtensionArray</span>
    <span class="s3"># - check_ndim/ensure_block_shape already checked</span>
    <span class="s3"># - maybe_coerce_values already called/unnecessary</span>
    <span class="s1">klass </span><span class="s2">= </span><span class="s1">get_block_type</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">klass</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">placement</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_ndim</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    ndim inference and validation. 
 
    Validates that values.ndim and ndim are consistent. 
    Validates that len(values) and len(placement) are consistent. 
 
    Parameters 
    ---------- 
    values : array-like 
    placement : BlockPlacement 
    ndim : int 
 
    Raises 
    ------ 
    ValueError : the number of dimensions do not match 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s1">ndim</span><span class="s2">:</span>
        <span class="s3"># Check for both np.ndarray and ExtensionArray</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Wrong number of dimensions. &quot;</span>
            <span class="s4">f&quot;values.ndim &gt; ndim [</span><span class="s0">{</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">} </span><span class="s4">&gt; </span><span class="s0">{</span><span class="s1">ndim</span><span class="s0">}</span><span class="s4">]&quot;</span>
        <span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s3"># TODO(EA2D): special case not needed with 2D EAs</span>
        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Wrong number of dimensions. &quot;</span>
                <span class="s4">f&quot;values.ndim != ndim [</span><span class="s0">{</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">} </span><span class="s4">!= </span><span class="s0">{</span><span class="s1">ndim</span><span class="s0">}</span><span class="s4">]&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">f&quot;Wrong number of items passed </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span><span class="s0">}</span><span class="s4">, &quot;</span>
                <span class="s4">f&quot;placement implies </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">)</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s3"># TODO(EA2D): special case unnecessary with 2D EAs</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;need to split&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">extract_pandas_array</span><span class="s2">(</span>
    <span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj </span><span class="s2">| </span><span class="s0">None</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">DtypeObj </span><span class="s2">| </span><span class="s0">None</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Ensure that we don't allow NumpyExtensionArray / NumpyEADtype in internals. 
    &quot;&quot;&quot;</span>
    <span class="s3"># For now, blocks should be backed by ndarrays when possible.</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">ABCNumpyExtensionArray</span><span class="s2">):</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s0">and </span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s3"># TODO(EA2D): special case not needed with 2D EAs</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">NumpyEADtype</span><span class="s2">):</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span>

    <span class="s0">return </span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span>


<span class="s3"># -----------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">extend_blocks</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot;return a new extended blocks, given the result&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">blocks </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">blocks </span><span class="s2">= []</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">result</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
                <span class="s1">blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">Block</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">blocks</span>


<span class="s0">def </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Reshape if possible to have values.ndim == ndim. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s1">ndim</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s3"># TODO(EA2D): https://github.com/pandas-dev/pandas/issues/23023</span>
            <span class="s3"># block.shape is incorrect for &quot;2D&quot; ExtensionArrays</span>
            <span class="s3"># We can't, and don't need to, reshape.</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s4">&quot;np.ndarray | DatetimeArray | TimedeltaArray&quot;</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">external_values</span><span class="s2">(</span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    The array that Series.values returns (public attribute). 
 
    This has some historical constraints, and is overridden in block 
    subclasses to return the correct array (e.g. period returns 
    object ndarray and datetimetz a datetime64[ns] ndarray instead of 
    proper extension array). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, (</span><span class="s1">PeriodArray</span><span class="s2">, </span><span class="s1">IntervalArray</span><span class="s2">)):</span>
        <span class="s0">return </span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, (</span><span class="s1">DatetimeArray</span><span class="s2">, </span><span class="s1">TimedeltaArray</span><span class="s2">)):</span>
        <span class="s3"># NB: for datetime64tz this is different from np.asarray(values), since</span>
        <span class="s3">#  that returns an object-dtype ndarray of Timestamps.</span>
        <span class="s3"># Avoid raising in .astype in casting from dt64tz to dt64</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">_ndarray</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">view</span><span class="s2">()</span>
        <span class="s1">values</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">writeable </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s3"># TODO(CoW) we should also mark our ExtensionArrays as read-only</span>

    <span class="s0">return </span><span class="s1">values</span>
</pre>
</body>
</html>