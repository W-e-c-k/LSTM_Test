<html>
<head>
<title>well_known_types.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
well_known_types.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0">#</span>
<span class="s0"># Use of this source code is governed by a BSD-style</span>
<span class="s0"># license that can be found in the LICENSE file or at</span>
<span class="s0"># https://developers.google.com/open-source/licenses/bsd</span>

<span class="s2">&quot;&quot;&quot;Contains well known classes. 
 
This files defines well known classes which need extra maintenance including: 
  - Any 
  - Duration 
  - FieldMask 
  - Struct 
  - Timestamp 
&quot;&quot;&quot;</span>

<span class="s1">__author__ </span><span class="s3">= </span><span class="s4">'jieluo@google.com (Jie Luo)'</span>

<span class="s5">import </span><span class="s1">calendar</span>
<span class="s5">import </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span>
<span class="s5">import </span><span class="s1">datetime</span>

<span class="s5">from </span><span class="s1">google</span><span class="s3">.</span><span class="s1">protobuf</span><span class="s3">.</span><span class="s1">internal </span><span class="s5">import </span><span class="s1">field_mask</span>

<span class="s1">FieldMask </span><span class="s3">= </span><span class="s1">field_mask</span><span class="s3">.</span><span class="s1">FieldMask</span>

<span class="s1">_TIMESTAMPFOMAT </span><span class="s3">= </span><span class="s4">'%Y-%m-%dT%H:%M:%S'</span>
<span class="s1">_NANOS_PER_SECOND </span><span class="s3">= </span><span class="s6">1000000000</span>
<span class="s1">_NANOS_PER_MILLISECOND </span><span class="s3">= </span><span class="s6">1000000</span>
<span class="s1">_NANOS_PER_MICROSECOND </span><span class="s3">= </span><span class="s6">1000</span>
<span class="s1">_MILLIS_PER_SECOND </span><span class="s3">= </span><span class="s6">1000</span>
<span class="s1">_MICROS_PER_SECOND </span><span class="s3">= </span><span class="s6">1000000</span>
<span class="s1">_SECONDS_PER_DAY </span><span class="s3">= </span><span class="s6">24 </span><span class="s3">* </span><span class="s6">3600</span>
<span class="s1">_DURATION_SECONDS_MAX </span><span class="s3">= </span><span class="s6">315576000000</span>

<span class="s1">_EPOCH_DATETIME_NAIVE </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">(</span><span class="s6">1970</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">tzinfo</span><span class="s3">=</span><span class="s5">None</span><span class="s3">)</span>
<span class="s1">_EPOCH_DATETIME_AWARE </span><span class="s3">= </span><span class="s1">_EPOCH_DATETIME_NAIVE</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span>
    <span class="s1">tzinfo</span><span class="s3">=</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timezone</span><span class="s3">.</span><span class="s1">utc</span>
<span class="s3">)</span>


<span class="s5">class </span><span class="s1">Any</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Class for Any Message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ </span><span class="s3">= ()</span>

  <span class="s5">def </span><span class="s1">Pack</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">type_url_prefix</span><span class="s3">=</span><span class="s4">'type.googleapis.com/'</span><span class="s3">,</span>
           <span class="s1">deterministic</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Packs the specified message into current Any message.&quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">type_url_prefix</span><span class="s3">) &lt; </span><span class="s6">1 </span><span class="s5">or </span><span class="s1">type_url_prefix</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s4">'/'</span><span class="s3">:</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">type_url </span><span class="s3">= </span><span class="s4">'%s/%s' </span><span class="s3">% (</span><span class="s1">type_url_prefix</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">DESCRIPTOR</span><span class="s3">.</span><span class="s1">full_name</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">type_url </span><span class="s3">= </span><span class="s4">'%s%s' </span><span class="s3">% (</span><span class="s1">type_url_prefix</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">DESCRIPTOR</span><span class="s3">.</span><span class="s1">full_name</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">SerializeToString</span><span class="s3">(</span><span class="s1">deterministic</span><span class="s3">=</span><span class="s1">deterministic</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">Unpack</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Unpacks the current Any message into specified message.&quot;&quot;&quot;</span>
    <span class="s1">descriptor </span><span class="s3">= </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">DESCRIPTOR</span>
    <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Is</span><span class="s3">(</span><span class="s1">descriptor</span><span class="s3">):</span>
      <span class="s5">return False</span>
    <span class="s1">msg</span><span class="s3">.</span><span class="s1">ParseFromString</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s5">return True</span>

  <span class="s5">def </span><span class="s1">TypeName</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Returns the protobuf type name of the inner message.&quot;&quot;&quot;</span>
    <span class="s0"># Only last part is to be used: b/25630112</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type_url</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'/'</span><span class="s3">)[-</span><span class="s6">1</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">Is</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">descriptor</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Checks if this Any represents the given protobuf type.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s4">'/' </span><span class="s5">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type_url </span><span class="s5">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">TypeName</span><span class="s3">() == </span><span class="s1">descriptor</span><span class="s3">.</span><span class="s1">full_name</span>


<span class="s5">class </span><span class="s1">Timestamp</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Class for Timestamp message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ </span><span class="s3">= ()</span>

  <span class="s5">def </span><span class="s1">ToJsonString</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to RFC 3339 date string format. 
 
    Returns: 
      A string converted from timestamp. The string is always Z-normalized 
      and uses 3, 6 or 9 fractional digits as required to represent the 
      exact time. Example of the return format: '1972-01-01T10:00:20.021Z' 
    &quot;&quot;&quot;</span>
    <span class="s1">nanos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">% </span><span class="s1">_NANOS_PER_SECOND</span>
    <span class="s1">total_sec </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">+ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">- </span><span class="s1">nanos</span><span class="s3">) // </span><span class="s1">_NANOS_PER_SECOND</span>
    <span class="s1">seconds </span><span class="s3">= </span><span class="s1">total_sec </span><span class="s3">% </span><span class="s1">_SECONDS_PER_DAY</span>
    <span class="s1">days </span><span class="s3">= (</span><span class="s1">total_sec </span><span class="s3">- </span><span class="s1">seconds</span><span class="s3">) // </span><span class="s1">_SECONDS_PER_DAY</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">(</span><span class="s6">1970</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) + </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">, </span><span class="s1">seconds</span><span class="s3">)</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">isoformat</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e9</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># If there are 0 fractional digits, the fractional</span>
      <span class="s0"># point '.' should be omitted when serializing.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'Z'</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e6</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># Serialize 3 fractional digits.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%03dZ' </span><span class="s3">% (</span><span class="s1">nanos </span><span class="s3">/ </span><span class="s6">1e6</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e3</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># Serialize 6 fractional digits.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%06dZ' </span><span class="s3">% (</span><span class="s1">nanos </span><span class="s3">/ </span><span class="s6">1e3</span><span class="s3">)</span>
    <span class="s0"># Serialize 9 fractional digits.</span>
    <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%09dZ' </span><span class="s3">% </span><span class="s1">nanos</span>

  <span class="s5">def </span><span class="s1">FromJsonString</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a RFC 3339 date string format to Timestamp. 
 
    Args: 
      value: A date string. Any fractional digits (or none) and any offset are 
          accepted as long as they fit into nano-seconds precision. 
          Example of accepted format: '1972-01-01T10:00:20.021-05:00' 
 
    Raises: 
      ValueError: On parsing problems. 
    &quot;&quot;&quot;</span>
    <span class="s5">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Timestamp JSON value not a string: {!r}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
    <span class="s1">timezone_offset </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">'Z'</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">timezone_offset </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
      <span class="s1">timezone_offset </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">'+'</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">timezone_offset </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
      <span class="s1">timezone_offset </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">rfind</span><span class="s3">(</span><span class="s4">'-'</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">timezone_offset </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
          <span class="s4">'Failed to parse timestamp: missing valid timezone offset.'</span><span class="s3">)</span>
    <span class="s1">time_value </span><span class="s3">= </span><span class="s1">value</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:</span><span class="s1">timezone_offset</span><span class="s3">]</span>
    <span class="s0"># Parse datetime and nanos.</span>
    <span class="s1">point_position </span><span class="s3">= </span><span class="s1">time_value</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">point_position </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
      <span class="s1">second_value </span><span class="s3">= </span><span class="s1">time_value</span>
      <span class="s1">nano_value </span><span class="s3">= </span><span class="s4">''</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s1">second_value </span><span class="s3">= </span><span class="s1">time_value</span><span class="s3">[:</span><span class="s1">point_position</span><span class="s3">]</span>
      <span class="s1">nano_value </span><span class="s3">= </span><span class="s1">time_value</span><span class="s3">[</span><span class="s1">point_position </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">:]</span>
    <span class="s5">if </span><span class="s4">'t' </span><span class="s5">in </span><span class="s1">second_value</span><span class="s3">:</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
          <span class="s4">'time data </span><span class="s5">\'</span><span class="s4">{0}</span><span class="s5">\' </span><span class="s4">does not match format </span><span class="s5">\'</span><span class="s4">%Y-%m-%dT%H:%M:%S</span><span class="s5">\'</span><span class="s4">, '</span>
          <span class="s4">'lowercase </span><span class="s5">\'</span><span class="s4">t</span><span class="s5">\' </span><span class="s4">is not accepted'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">second_value</span><span class="s3">))</span>
    <span class="s1">date_object </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">strptime</span><span class="s3">(</span><span class="s1">second_value</span><span class="s3">, </span><span class="s1">_TIMESTAMPFOMAT</span><span class="s3">)</span>
    <span class="s1">td </span><span class="s3">= </span><span class="s1">date_object </span><span class="s3">- </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">(</span><span class="s6">1970</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">seconds </span><span class="s3">= </span><span class="s1">td</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">+ </span><span class="s1">td</span><span class="s3">.</span><span class="s1">days </span><span class="s3">* </span><span class="s1">_SECONDS_PER_DAY</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nano_value</span><span class="s3">) &gt; </span><span class="s6">9</span><span class="s3">:</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
          <span class="s4">'Failed to parse Timestamp: nanos {0} more than '</span>
          <span class="s4">'9 fractional digits.'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">nano_value</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">nano_value</span><span class="s3">:</span>
      <span class="s1">nanos </span><span class="s3">= </span><span class="s1">round</span><span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s4">'0.' </span><span class="s3">+ </span><span class="s1">nano_value</span><span class="s3">) * </span><span class="s6">1e9</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s1">nanos </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s0"># Parse timezone offsets.</span>
    <span class="s5">if </span><span class="s1">value</span><span class="s3">[</span><span class="s1">timezone_offset</span><span class="s3">] == </span><span class="s4">'Z'</span><span class="s3">:</span>
      <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) != </span><span class="s1">timezone_offset </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Failed to parse timestamp: invalid trailing'</span>
                         <span class="s4">' data {0}.'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s1">timezone </span><span class="s3">= </span><span class="s1">value</span><span class="s3">[</span><span class="s1">timezone_offset</span><span class="s3">:]</span>
      <span class="s1">pos </span><span class="s3">= </span><span class="s1">timezone</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">':'</span><span class="s3">)</span>
      <span class="s5">if </span><span class="s1">pos </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">'Invalid timezone offset value: {0}.'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">timezone</span><span class="s3">))</span>
      <span class="s5">if </span><span class="s1">timezone</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">'+'</span><span class="s3">:</span>
        <span class="s1">seconds </span><span class="s3">-= (</span><span class="s1">int</span><span class="s3">(</span><span class="s1">timezone</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:</span><span class="s1">pos</span><span class="s3">])*</span><span class="s6">60</span><span class="s3">+</span><span class="s1">int</span><span class="s3">(</span><span class="s1">timezone</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:]))*</span><span class="s6">60</span>
      <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">seconds </span><span class="s3">+= (</span><span class="s1">int</span><span class="s3">(</span><span class="s1">timezone</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:</span><span class="s1">pos</span><span class="s3">])*</span><span class="s6">60</span><span class="s3">+</span><span class="s1">int</span><span class="s3">(</span><span class="s1">timezone</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:]))*</span><span class="s6">60</span>
    <span class="s0"># Set seconds and nanos</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">seconds</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">nanos</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">GetCurrentTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Get the current UTC into Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">FromDatetime</span><span class="s3">(</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">utcnow</span><span class="s3">())</span>

  <span class="s5">def </span><span class="s1">ToNanoseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to nanoseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_NANOS_PER_SECOND </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span>

  <span class="s5">def </span><span class="s1">ToMicroseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to microseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_MICROS_PER_SECOND </span><span class="s3">+</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">// </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">ToMilliseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to milliseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_MILLIS_PER_SECOND </span><span class="s3">+</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">// </span><span class="s1">_NANOS_PER_MILLISECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">ToSeconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to seconds since epoch.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds</span>

  <span class="s5">def </span><span class="s1">FromNanoseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nanos</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts nanoseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">nanos </span><span class="s3">// </span><span class="s1">_NANOS_PER_SECOND</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s1">nanos </span><span class="s3">% </span><span class="s1">_NANOS_PER_SECOND</span>

  <span class="s5">def </span><span class="s1">FromMicroseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">micros</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts microseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">micros </span><span class="s3">// </span><span class="s1">_MICROS_PER_SECOND</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= (</span><span class="s1">micros </span><span class="s3">% </span><span class="s1">_MICROS_PER_SECOND</span><span class="s3">) * </span><span class="s1">_NANOS_PER_MICROSECOND</span>

  <span class="s5">def </span><span class="s1">FromMilliseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">millis</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts milliseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">millis </span><span class="s3">// </span><span class="s1">_MILLIS_PER_SECOND</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= (</span><span class="s1">millis </span><span class="s3">% </span><span class="s1">_MILLIS_PER_SECOND</span><span class="s3">) * </span><span class="s1">_NANOS_PER_MILLISECOND</span>

  <span class="s5">def </span><span class="s1">FromSeconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">seconds</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts seconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">seconds</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s6">0</span>

  <span class="s5">def </span><span class="s1">ToDatetime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tzinfo</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to a datetime. 
 
    Args: 
      tzinfo: A datetime.tzinfo subclass; defaults to None. 
 
    Returns: 
      If tzinfo is None, returns a timezone-naive UTC datetime (with no timezone 
      information, i.e. not aware that it's UTC). 
 
      Otherwise, returns a timezone-aware datetime in the input timezone. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Using datetime.fromtimestamp for this would avoid constructing an extra</span>
    <span class="s0"># timedelta object and possibly an extra datetime. Unfortuantely, that has</span>
    <span class="s0"># the disadvantage of not handling the full precision (on all platforms, see</span>
    <span class="s0"># https://github.com/python/cpython/issues/109849) or full range (on some</span>
    <span class="s0"># platforms, see https://github.com/python/cpython/issues/110042) of</span>
    <span class="s0"># datetime.</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span>
        <span class="s1">seconds</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds</span><span class="s3">,</span>
        <span class="s1">microseconds</span><span class="s3">=</span><span class="s1">_RoundTowardZero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">, </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s5">if </span><span class="s1">tzinfo </span><span class="s5">is None</span><span class="s3">:</span>
      <span class="s5">return </span><span class="s1">_EPOCH_DATETIME_NAIVE </span><span class="s3">+ </span><span class="s1">delta</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s0"># Note the tz conversion has to come after the timedelta arithmetic.</span>
      <span class="s5">return </span><span class="s3">(</span><span class="s1">_EPOCH_DATETIME_AWARE </span><span class="s3">+ </span><span class="s1">delta</span><span class="s3">).</span><span class="s1">astimezone</span><span class="s3">(</span><span class="s1">tzinfo</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">FromDatetime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts datetime to Timestamp. 
 
    Args: 
      dt: A datetime. If it's timezone-naive, it's assumed to be in UTC. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Using this guide: http://wiki.python.org/moin/WorkingWithTime</span>
    <span class="s0"># And this conversion guide: http://docs.python.org/library/time.html</span>

    <span class="s0"># Turn the date parameter into a tuple (struct_time) that can then be</span>
    <span class="s0"># manipulated into a long value of seconds.  During the conversion from</span>
    <span class="s0"># struct_time to long, the source date in UTC, and so it follows that the</span>
    <span class="s0"># correct transformation is calendar.timegm()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">calendar</span><span class="s3">.</span><span class="s1">timegm</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">utctimetuple</span><span class="s3">())</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">microsecond </span><span class="s3">* </span><span class="s1">_NANOS_PER_MICROSECOND</span>


<span class="s5">class </span><span class="s1">Duration</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Class for Duration message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ </span><span class="s3">= ()</span>

  <span class="s5">def </span><span class="s1">ToJsonString</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Duration to string format. 
 
    Returns: 
      A string converted from self. The string format will contains 
      3, 6, or 9 fractional digits depending on the precision required to 
      represent the exact Duration value. For example: &quot;1s&quot;, &quot;1.010s&quot;, 
      &quot;1.000000100s&quot;, &quot;-3.100s&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">_CheckDurationValid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s1">result </span><span class="s3">= </span><span class="s4">'-'</span>
      <span class="s1">seconds </span><span class="s3">= - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">+ </span><span class="s1">int</span><span class="s3">((</span><span class="s6">0 </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">) // </span><span class="s6">1e9</span><span class="s3">)</span>
      <span class="s1">nanos </span><span class="s3">= (</span><span class="s6">0 </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">) % </span><span class="s6">1e9</span>
    <span class="s5">else</span><span class="s3">:</span>
      <span class="s1">result </span><span class="s3">= </span><span class="s4">''</span>
      <span class="s1">seconds </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">+ </span><span class="s1">int</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">// </span><span class="s6">1e9</span><span class="s3">)</span>
      <span class="s1">nanos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e9</span>
    <span class="s1">result </span><span class="s3">+= </span><span class="s4">'%d' </span><span class="s3">% </span><span class="s1">seconds</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e9</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># If there are 0 fractional digits, the fractional</span>
      <span class="s0"># point '.' should be omitted when serializing.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'s'</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e6</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># Serialize 3 fractional digits.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%03ds' </span><span class="s3">% (</span><span class="s1">nanos </span><span class="s3">/ </span><span class="s6">1e6</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">% </span><span class="s6">1e3</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s0"># Serialize 6 fractional digits.</span>
      <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%06ds' </span><span class="s3">% (</span><span class="s1">nanos </span><span class="s3">/ </span><span class="s6">1e3</span><span class="s3">)</span>
    <span class="s0"># Serialize 9 fractional digits.</span>
    <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s4">'.%09ds' </span><span class="s3">% </span><span class="s1">nanos</span>

  <span class="s5">def </span><span class="s1">FromJsonString</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts a string to Duration. 
 
    Args: 
      value: A string to be converted. The string must end with 's'. Any 
          fractional digits (or none) are accepted as long as they fit into 
          precision. For example: &quot;1s&quot;, &quot;1.01s&quot;, &quot;1.0000001s&quot;, &quot;-3.100s 
 
    Raises: 
      ValueError: On parsing problems. 
    &quot;&quot;&quot;</span>
    <span class="s5">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Duration JSON value not a string: {!r}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) &lt; </span><span class="s6">1 </span><span class="s5">or </span><span class="s1">value</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s4">'s'</span><span class="s3">:</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
          <span class="s4">'Duration must end with letter &quot;s&quot;: {0}.'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
    <span class="s5">try</span><span class="s3">:</span>
      <span class="s1">pos </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)</span>
      <span class="s5">if </span><span class="s1">pos </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">seconds </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">nanos </span><span class="s3">= </span><span class="s6">0</span>
      <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">seconds </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[:</span><span class="s1">pos</span><span class="s3">])</span>
        <span class="s5">if </span><span class="s1">value</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">'-'</span><span class="s3">:</span>
          <span class="s1">nanos </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">round</span><span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s4">'-0{0}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">: -</span><span class="s6">1</span><span class="s3">])) *</span><span class="s6">1e9</span><span class="s3">))</span>
        <span class="s5">else</span><span class="s3">:</span>
          <span class="s1">nanos </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">round</span><span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s4">'0{0}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">: -</span><span class="s6">1</span><span class="s3">])) *</span><span class="s6">1e9</span><span class="s3">))</span>
      <span class="s1">_CheckDurationValid</span><span class="s3">(</span><span class="s1">seconds</span><span class="s3">, </span><span class="s1">nanos</span><span class="s3">)</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">seconds</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s1">nanos</span>
    <span class="s5">except </span><span class="s1">ValueError </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
      <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
          <span class="s4">'Couldn</span><span class="s5">\'</span><span class="s4">t parse duration: {0} : {1}.'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>

  <span class="s5">def </span><span class="s1">ToNanoseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to nanoseconds.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_NANOS_PER_SECOND </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span>

  <span class="s5">def </span><span class="s1">ToMicroseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to microseconds.&quot;&quot;&quot;</span>
    <span class="s1">micros </span><span class="s3">= </span><span class="s1">_RoundTowardZero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">, </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_MICROS_PER_SECOND </span><span class="s3">+ </span><span class="s1">micros</span>

  <span class="s5">def </span><span class="s1">ToMilliseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to milliseconds.&quot;&quot;&quot;</span>
    <span class="s1">millis </span><span class="s3">= </span><span class="s1">_RoundTowardZero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">, </span><span class="s1">_NANOS_PER_MILLISECOND</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">* </span><span class="s1">_MILLIS_PER_SECOND </span><span class="s3">+ </span><span class="s1">millis</span>

  <span class="s5">def </span><span class="s1">ToSeconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to seconds.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds</span>

  <span class="s5">def </span><span class="s1">FromNanoseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nanos</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts nanoseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">_NormalizeDuration</span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">// </span><span class="s1">_NANOS_PER_SECOND</span><span class="s3">,</span>
                            <span class="s1">nanos </span><span class="s3">% </span><span class="s1">_NANOS_PER_SECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">FromMicroseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">micros</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts microseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">_NormalizeDuration</span><span class="s3">(</span>
        <span class="s1">micros </span><span class="s3">// </span><span class="s1">_MICROS_PER_SECOND</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">micros </span><span class="s3">% </span><span class="s1">_MICROS_PER_SECOND</span><span class="s3">) * </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">FromMilliseconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">millis</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts milliseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">_NormalizeDuration</span><span class="s3">(</span>
        <span class="s1">millis </span><span class="s3">// </span><span class="s1">_MILLIS_PER_SECOND</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">millis </span><span class="s3">% </span><span class="s1">_MILLIS_PER_SECOND</span><span class="s3">) * </span><span class="s1">_NANOS_PER_MILLISECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">FromSeconds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">seconds</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts seconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">seconds</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s6">0</span>

  <span class="s5">def </span><span class="s1">ToTimedelta</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Duration to timedelta.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">datetime</span><span class="s3">.</span><span class="s1">timedelta</span><span class="s3">(</span>
        <span class="s1">seconds</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">seconds</span><span class="s3">, </span><span class="s1">microseconds</span><span class="s3">=</span><span class="s1">_RoundTowardZero</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos</span><span class="s3">, </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">))</span>

  <span class="s5">def </span><span class="s1">FromTimedelta</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">td</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Converts timedelta to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">_NormalizeDuration</span><span class="s3">(</span><span class="s1">td</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">+ </span><span class="s1">td</span><span class="s3">.</span><span class="s1">days </span><span class="s3">* </span><span class="s1">_SECONDS_PER_DAY</span><span class="s3">,</span>
                            <span class="s1">td</span><span class="s3">.</span><span class="s1">microseconds </span><span class="s3">* </span><span class="s1">_NANOS_PER_MICROSECOND</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">_NormalizeDuration</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">seconds</span><span class="s3">, </span><span class="s1">nanos</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Set Duration by seconds and nanos.&quot;&quot;&quot;</span>
    <span class="s0"># Force nanos to be negative if the duration is negative.</span>
    <span class="s5">if </span><span class="s1">seconds </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">nanos </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
      <span class="s1">seconds </span><span class="s3">+= </span><span class="s6">1</span>
      <span class="s1">nanos </span><span class="s3">-= </span><span class="s1">_NANOS_PER_SECOND</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">seconds </span><span class="s3">= </span><span class="s1">seconds</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">nanos </span><span class="s3">= </span><span class="s1">nanos</span>


<span class="s5">def </span><span class="s1">_CheckDurationValid</span><span class="s3">(</span><span class="s1">seconds</span><span class="s3">, </span><span class="s1">nanos</span><span class="s3">):</span>
  <span class="s5">if </span><span class="s1">seconds </span><span class="s3">&lt; -</span><span class="s1">_DURATION_SECONDS_MAX </span><span class="s5">or </span><span class="s1">seconds </span><span class="s3">&gt; </span><span class="s1">_DURATION_SECONDS_MAX</span><span class="s3">:</span>
    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
        <span class="s4">'Duration is not valid: Seconds {0} must be in range '</span>
        <span class="s4">'[-315576000000, 315576000000].'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">seconds</span><span class="s3">))</span>
  <span class="s5">if </span><span class="s1">nanos </span><span class="s3">&lt;= -</span><span class="s1">_NANOS_PER_SECOND </span><span class="s5">or </span><span class="s1">nanos </span><span class="s3">&gt;= </span><span class="s1">_NANOS_PER_SECOND</span><span class="s3">:</span>
    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
        <span class="s4">'Duration is not valid: Nanos {0} must be in range '</span>
        <span class="s4">'[-999999999, 999999999].'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">nanos</span><span class="s3">))</span>
  <span class="s5">if </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">seconds </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) </span><span class="s5">or </span><span class="s3">(</span><span class="s1">nanos </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">seconds </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">):</span>
    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
        <span class="s4">'Duration is not valid: Sign mismatch.'</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_RoundTowardZero</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">divider</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Truncates the remainder part after division.&quot;&quot;&quot;</span>
  <span class="s0"># For some languages, the sign of the remainder is implementation</span>
  <span class="s0"># dependent if any of the operands is negative. Here we enforce</span>
  <span class="s0"># &quot;rounded toward zero&quot; semantics. For example, for (-5) / 2 an</span>
  <span class="s0"># implementation may give -3 as the result with the remainder being</span>
  <span class="s0"># 1. This function ensures we always return -2 (closer to zero).</span>
  <span class="s1">result </span><span class="s3">= </span><span class="s1">value </span><span class="s3">// </span><span class="s1">divider</span>
  <span class="s1">remainder </span><span class="s3">= </span><span class="s1">value </span><span class="s3">% </span><span class="s1">divider</span>
  <span class="s5">if </span><span class="s1">result </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">remainder </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">result </span><span class="s3">+ </span><span class="s6">1</span>
  <span class="s5">else</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">result</span>


<span class="s5">def </span><span class="s1">_SetStructValue</span><span class="s3">(</span><span class="s1">struct_value</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
  <span class="s5">if </span><span class="s1">value </span><span class="s5">is None</span><span class="s3">:</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">null_value </span><span class="s3">= </span><span class="s6">0</span>
  <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">):</span>
    <span class="s0"># Note: this check must come before the number check because in Python</span>
    <span class="s0"># True and False are also considered numbers.</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">bool_value </span><span class="s3">= </span><span class="s1">value</span>
  <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">string_value </span><span class="s3">= </span><span class="s1">value</span>
  <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)):</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">number_value </span><span class="s3">= </span><span class="s1">value</span>
  <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">dict</span><span class="s3">, </span><span class="s1">Struct</span><span class="s3">)):</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
  <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">ListValue</span><span class="s3">)):</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">list_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">list_value</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
  <span class="s5">else</span><span class="s3">:</span>
    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Unexpected type'</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_GetStructValue</span><span class="s3">(</span><span class="s1">struct_value</span><span class="s3">):</span>
  <span class="s1">which </span><span class="s3">= </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">WhichOneof</span><span class="s3">(</span><span class="s4">'kind'</span><span class="s3">)</span>
  <span class="s5">if </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'struct_value'</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">struct_value</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'null_value'</span><span class="s3">:</span>
    <span class="s5">return None</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'number_value'</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">number_value</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'string_value'</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">string_value</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'bool_value'</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">bool_value</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'list_value'</span><span class="s3">:</span>
    <span class="s5">return </span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">list_value</span>
  <span class="s5">elif </span><span class="s1">which </span><span class="s5">is None</span><span class="s3">:</span>
    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Value not set'</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">Struct</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Class for Struct message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ </span><span class="s3">= ()</span>

  <span class="s5">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s5">return </span><span class="s1">_GetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">])</span>

  <span class="s5">def </span><span class="s1">__contains__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">):</span>
    <span class="s5">return </span><span class="s1">item </span><span class="s5">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span>

  <span class="s5">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">_SetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">value</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">__delitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s5">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s5">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">__iter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s5">return </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>

  <span class="s5">def </span><span class="s1">values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s5">return </span><span class="s3">[</span><span class="s1">self</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] </span><span class="s5">for </span><span class="s1">key </span><span class="s5">in </span><span class="s1">self</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">items</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s5">return </span><span class="s3">[(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">self</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]) </span><span class="s5">for </span><span class="s1">key </span><span class="s5">in </span><span class="s1">self</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">get_or_create_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Returns a list for this key, creating if it didn't exist already.&quot;&quot;&quot;</span>
    <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">HasField</span><span class="s3">(</span><span class="s4">'list_value'</span><span class="s3">):</span>
      <span class="s0"># Clear will mark list_value modified which will indeed create a list.</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">list_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">list_value</span>

  <span class="s5">def </span><span class="s1">get_or_create_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Returns a struct for this key, creating if it didn't exist already.&quot;&quot;&quot;</span>
    <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">HasField</span><span class="s3">(</span><span class="s4">'struct_value'</span><span class="s3">):</span>
      <span class="s0"># Clear will mark struct_value modified which will indeed create a struct.</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">struct_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">struct_value</span>

  <span class="s5">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dictionary</span><span class="s3">):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s5">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s5">in </span><span class="s1">dictionary</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
      <span class="s1">_SetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">value</span><span class="s3">)</span>

<span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableMapping</span><span class="s3">.</span><span class="s1">register</span><span class="s3">(</span><span class="s1">Struct</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">ListValue</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
  <span class="s2">&quot;&quot;&quot;Class for ListValue message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ </span><span class="s3">= ()</span>

  <span class="s5">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s5">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">_SetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(), </span><span class="s1">value</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">elem_seq</span><span class="s3">):</span>
    <span class="s5">for </span><span class="s1">value </span><span class="s5">in </span><span class="s1">elem_seq</span><span class="s3">:</span>
      <span class="s1">self</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Retrieves item by the specified index.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">_GetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">index</span><span class="s3">))</span>

  <span class="s5">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">_SetStructValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">index</span><span class="s3">), </span><span class="s1">value</span><span class="s3">)</span>

  <span class="s5">def </span><span class="s1">__delitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s5">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">items</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)):</span>
      <span class="s5">yield </span><span class="s1">self</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

  <span class="s5">def </span><span class="s1">add_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Appends and returns a struct value as the next value in the list.&quot;&quot;&quot;</span>
    <span class="s1">struct_value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">add</span><span class="s3">().</span><span class="s1">struct_value</span>
    <span class="s0"># Clear will mark struct_value modified which will indeed create a struct.</span>
    <span class="s1">struct_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s5">return </span><span class="s1">struct_value</span>

  <span class="s5">def </span><span class="s1">add_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Appends and returns a list value as the next value in the list.&quot;&quot;&quot;</span>
    <span class="s1">list_value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">add</span><span class="s3">().</span><span class="s1">list_value</span>
    <span class="s0"># Clear will mark list_value modified which will indeed create a list.</span>
    <span class="s1">list_value</span><span class="s3">.</span><span class="s1">Clear</span><span class="s3">()</span>
    <span class="s5">return </span><span class="s1">list_value</span>

<span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableSequence</span><span class="s3">.</span><span class="s1">register</span><span class="s3">(</span><span class="s1">ListValue</span><span class="s3">)</span>


<span class="s0"># LINT.IfChange(wktbases)</span>
<span class="s1">WKTBASES </span><span class="s3">= {</span>
    <span class="s4">'google.protobuf.Any'</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s4">'google.protobuf.Duration'</span><span class="s3">: </span><span class="s1">Duration</span><span class="s3">,</span>
    <span class="s4">'google.protobuf.FieldMask'</span><span class="s3">: </span><span class="s1">FieldMask</span><span class="s3">,</span>
    <span class="s4">'google.protobuf.ListValue'</span><span class="s3">: </span><span class="s1">ListValue</span><span class="s3">,</span>
    <span class="s4">'google.protobuf.Struct'</span><span class="s3">: </span><span class="s1">Struct</span><span class="s3">,</span>
    <span class="s4">'google.protobuf.Timestamp'</span><span class="s3">: </span><span class="s1">Timestamp</span><span class="s3">,</span>
<span class="s3">}</span>
<span class="s0"># LINT.ThenChange(//depot/google.protobuf/compiler/python/pyi_generator.cc:wktbases)</span>
</pre>
</body>
</html>