<html>
<head>
<title>xsltext.pxi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
xsltext.pxi</font>
</center></td></tr></table>
<pre><span class="s0"># XSLT extension elements</span>

<span class="s0">cdef class XSLTExtension:</span>
    <span class="s0">&quot;&quot;&quot;Base class of an XSLT extension element.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def execute(self, context, self_node, input_node, output_parent):</span>
        <span class="s0">&quot;&quot;&quot;execute(self, context, self_node, input_node, output_parent)</span>
        <span class="s0">Execute this extension element.</span>

        <span class="s0">Subclasses must override this method.  They may append</span>
        <span class="s0">elements to the `output_parent` element here, or set its text</span>
        <span class="s0">content.  To this end, the `input_node` provides read-only</span>
        <span class="s0">access to the current node in the input document, and the</span>
        <span class="s0">`self_node` points to the extension element in the stylesheet.</span>

        <span class="s0">Note that the `output_parent` parameter may be `None` if there</span>
        <span class="s0">is no parent element in the current context (e.g. no content</span>
        <span class="s0">was added to the output tree yet).</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def apply_templates(self, _XSLTContext context not None, node, output_parent=None,</span>
                        <span class="s0">*, elements_only=False, remove_blank_text=False):</span>
        <span class="s0">&quot;&quot;&quot;apply_templates(self, context, node, output_parent=None, elements_only=False, remove_blank_text=False)</span>

        <span class="s0">Call this method to retrieve the result of applying templates</span>
        <span class="s0">to an element.</span>

        <span class="s0">The return value is a list of elements or text strings that</span>
        <span class="s0">were generated by the XSLT processor.  If you pass</span>
        <span class="s0">``elements_only=True``, strings will be discarded from the result</span>
        <span class="s0">list.  The option ``remove_blank_text=True`` will only discard</span>
        <span class="s0">strings that consist entirely of whitespace (e.g. formatting).</span>
        <span class="s0">These options do not apply to Elements, only to bare string results.</span>

        <span class="s0">If you pass an Element as `output_parent` parameter, the result</span>
        <span class="s0">will instead be appended to the element (including attributes</span>
        <span class="s0">etc.) and the return value will be `None`.  This is a safe way</span>
        <span class="s0">to generate content into the output document directly, without</span>
        <span class="s0">having to take care of special values like text or attributes.</span>
        <span class="s0">Note that the string discarding options will be ignored in this</span>
        <span class="s0">case.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_parent</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef xmlNode* c_context_node</span>
        <span class="s0">assert context._xsltCtxt is not NULL, &quot;XSLT context not initialised&quot;</span>
        <span class="s0">c_context_node = _roNodeOf(node)</span>
        <span class="s0">#assert c_context_node.doc is context._xsltContext.node.doc, \</span>
        <span class="s0">#    &quot;switching input documents during transformation is not currently supported&quot;</span>

        <span class="s0">if output_parent is not None:</span>
            <span class="s0">c_parent = _nonRoNodeOf(output_parent)</span>
        <span class="s0">else:</span>
            <span class="s0">c_parent = tree.xmlNewDocNode(</span>
                <span class="s0">context._xsltCtxt.output, NULL, &lt;unsigned char*&gt;&quot;fake-parent&quot;, NULL)</span>

        <span class="s0">c_node = context._xsltCtxt.insert</span>
        <span class="s0">context._xsltCtxt.insert = c_parent</span>
        <span class="s0">xslt.xsltProcessOneNode(</span>
            <span class="s0">context._xsltCtxt, c_context_node, NULL)</span>
        <span class="s0">context._xsltCtxt.insert = c_node</span>

        <span class="s0">if output_parent is not None:</span>
            <span class="s0">return None</span>

        <span class="s0">try:</span>
            <span class="s0">return self._collectXSLTResultContent(</span>
                <span class="s0">context, c_parent, elements_only, remove_blank_text)</span>
        <span class="s0">finally:</span>
            <span class="s0"># free all intermediate nodes that will not be freed by proxies</span>
            <span class="s0">tree.xmlFreeNode(c_parent)</span>

    <span class="s0">def process_children(self, _XSLTContext context not None, output_parent=None,</span>
                         <span class="s0">*, elements_only=False, remove_blank_text=False):</span>
        <span class="s0">&quot;&quot;&quot;process_children(self, context, output_parent=None, elements_only=False, remove_blank_text=False)</span>

        <span class="s0">Call this method to process the XSLT content of the extension</span>
        <span class="s0">element itself.</span>

        <span class="s0">The return value is a list of elements or text strings that</span>
        <span class="s0">were generated by the XSLT processor.  If you pass</span>
        <span class="s0">``elements_only=True``, strings will be discarded from the result</span>
        <span class="s0">list.  The option ``remove_blank_text=True`` will only discard</span>
        <span class="s0">strings that consist entirely of whitespace (e.g. formatting).</span>
        <span class="s0">These options do not apply to Elements, only to bare string results.</span>

        <span class="s0">If you pass an Element as `output_parent` parameter, the result</span>
        <span class="s0">will instead be appended to the element (including attributes</span>
        <span class="s0">etc.) and the return value will be `None`.  This is a safe way</span>
        <span class="s0">to generate content into the output document directly, without</span>
        <span class="s0">having to take care of special values like text or attributes.</span>
        <span class="s0">Note that the string discarding options will be ignored in this</span>
        <span class="s0">case.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_parent</span>
        <span class="s0">cdef xslt.xsltTransformContext* c_ctxt = context._xsltCtxt</span>
        <span class="s0">cdef xmlNode* c_old_output_parent = c_ctxt.insert</span>
        <span class="s0">assert context._xsltCtxt is not NULL, &quot;XSLT context not initialised&quot;</span>

        <span class="s0"># output_parent node is used for adding results instead of</span>
        <span class="s0"># elements list used in apply_templates, that's easier and allows to</span>
        <span class="s0"># use attributes added to extension element with &lt;xsl:attribute&gt;.</span>

        <span class="s0">if output_parent is not None:</span>
            <span class="s0">c_parent = _nonRoNodeOf(output_parent)</span>
        <span class="s0">else:</span>
            <span class="s0">c_parent = tree.xmlNewDocNode(</span>
                <span class="s0">context._xsltCtxt.output, NULL, &lt;unsigned char*&gt;&quot;fake-parent&quot;, NULL)</span>

        <span class="s0">c_ctxt.insert = c_parent</span>
        <span class="s0">xslt.xsltApplyOneTemplate(c_ctxt,</span>
            <span class="s0">c_ctxt.node, c_ctxt.inst.children, NULL, NULL)</span>
        <span class="s0">c_ctxt.insert = c_old_output_parent</span>

        <span class="s0">if output_parent is not None:</span>
            <span class="s0">return None</span>

        <span class="s0">try:</span>
            <span class="s0">return self._collectXSLTResultContent(</span>
                <span class="s0">context, c_parent, elements_only, remove_blank_text)</span>
        <span class="s0">finally:</span>
            <span class="s0"># free all intermediate nodes that will not be freed by proxies</span>
            <span class="s0">tree.xmlFreeNode(c_parent)</span>

    <span class="s0">cdef _collectXSLTResultContent(self, _XSLTContext context, xmlNode* c_parent,</span>
                                   <span class="s0">bint elements_only, bint remove_blank_text):</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef xmlNode* c_next</span>
        <span class="s0">cdef _ReadOnlyProxy proxy</span>
        <span class="s0">cdef list results = [] # or maybe _collectAttributes(c_parent, 2) ?</span>
        <span class="s0">c_node = c_parent.children</span>
        <span class="s0">while c_node is not NULL:</span>
            <span class="s0">c_next = c_node.next</span>
            <span class="s0">if c_node.type == tree.XML_TEXT_NODE:</span>
                <span class="s0">if not elements_only:</span>
                    <span class="s0">s = funicode(c_node.content)</span>
                    <span class="s0">if not remove_blank_text or s.strip():</span>
                        <span class="s0">results.append(s)</span>
                    <span class="s0">s = None</span>
            <span class="s0">elif c_node.type == tree.XML_ELEMENT_NODE:</span>
                <span class="s0">proxy = _newReadOnlyProxy(</span>
                    <span class="s0">context._extension_element_proxy, c_node)</span>
                <span class="s0">results.append(proxy)</span>
                <span class="s0"># unlink node and make sure it will be freed later on</span>
                <span class="s0">tree.xmlUnlinkNode(c_node)</span>
                <span class="s0">proxy.free_after_use()</span>
            <span class="s0">else:</span>
                <span class="s0">raise TypeError, \</span>
                    <span class="s0">f&quot;unsupported XSLT result type: {c_node.type}&quot;</span>
            <span class="s0">c_node = c_next</span>
        <span class="s0">return results</span>


<span class="s0">cdef _registerXSLTExtensions(xslt.xsltTransformContext* c_ctxt,</span>
                             <span class="s0">extension_dict):</span>
    <span class="s0">for ns_utf, name_utf in extension_dict:</span>
        <span class="s0">xslt.xsltRegisterExtElement(</span>
            <span class="s0">c_ctxt, _xcstr(name_utf), _xcstr(ns_utf),</span>
            <span class="s0">&lt;xslt.xsltTransformFunction&gt;_callExtensionElement)</span>

<span class="s0">cdef void _callExtensionElement(xslt.xsltTransformContext* c_ctxt,</span>
                                <span class="s0">xmlNode* c_context_node,</span>
                                <span class="s0">xmlNode* c_inst_node,</span>
                                <span class="s0">void* dummy) noexcept with gil:</span>
    <span class="s0">cdef _XSLTContext context</span>
    <span class="s0">cdef XSLTExtension extension</span>
    <span class="s0">cdef python.PyObject* dict_result</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">cdef _ReadOnlyProxy context_node = None, self_node = None</span>
    <span class="s0">cdef object output_parent # not restricted to ro-nodes</span>
    <span class="s0">c_uri = _getNs(c_inst_node)</span>
    <span class="s0">if c_uri is NULL:</span>
        <span class="s0"># not allowed, and should never happen</span>
        <span class="s0">return</span>
    <span class="s0">if c_ctxt.xpathCtxt.userData is NULL:</span>
        <span class="s0"># just for safety, should never happen</span>
        <span class="s0">return</span>
    <span class="s0">context = &lt;_XSLTContext&gt;c_ctxt.xpathCtxt.userData</span>
    <span class="s0">try:</span>
        <span class="s0">try:</span>
            <span class="s0">dict_result = python.PyDict_GetItem(</span>
                <span class="s0">context._extension_elements, (c_uri, c_inst_node.name))</span>
            <span class="s0">if dict_result is NULL:</span>
                <span class="s0">raise KeyError, f&quot;extension element {funicode(c_inst_node.name)} not found&quot;</span>
            <span class="s0">extension = &lt;object&gt;dict_result</span>

            <span class="s0">try:</span>
                <span class="s0"># build the context proxy nodes</span>
                <span class="s0">self_node = _newReadOnlyProxy(None, c_inst_node)</span>
                <span class="s0">if _isElement(c_ctxt.insert):</span>
                    <span class="s0">output_parent = _newAppendOnlyProxy(self_node, c_ctxt.insert)</span>
                <span class="s0">else:</span>
                    <span class="s0"># may be the document node or other stuff</span>
                    <span class="s0">output_parent = _newOpaqueAppendOnlyNodeWrapper(c_ctxt.insert)</span>
                <span class="s0">if c_context_node.type in (tree.XML_DOCUMENT_NODE,</span>
                                           <span class="s0">tree.XML_HTML_DOCUMENT_NODE):</span>
                    <span class="s0">c_node = tree.xmlDocGetRootElement(&lt;xmlDoc*&gt;c_context_node)</span>
                    <span class="s0">if c_node is not NULL:</span>
                        <span class="s0">context_node = _newReadOnlyProxy(self_node, c_node)</span>
                    <span class="s0">else:</span>
                        <span class="s0">context_node = None</span>
                <span class="s0">elif c_context_node.type in (tree.XML_ATTRIBUTE_NODE,</span>
                                             <span class="s0">tree.XML_TEXT_NODE,</span>
                                             <span class="s0">tree.XML_CDATA_SECTION_NODE):</span>
                    <span class="s0"># this isn't easy to support using read-only</span>
                    <span class="s0"># nodes, as the smart-string factory must</span>
                    <span class="s0"># instantiate the parent proxy somehow...</span>
                    <span class="s0">raise TypeError(f&quot;Unsupported element type: {c_context_node.type}&quot;)</span>
                <span class="s0">else:</span>
                    <span class="s0">context_node  = _newReadOnlyProxy(self_node, c_context_node)</span>

                <span class="s0"># run the XSLT extension</span>
                <span class="s0">context._extension_element_proxy = self_node</span>
                <span class="s0">extension.execute(context, self_node, context_node, output_parent)</span>
            <span class="s0">finally:</span>
                <span class="s0">context._extension_element_proxy = None</span>
                <span class="s0">if self_node is not None:</span>
                    <span class="s0">_freeReadOnlyProxies(self_node)</span>
        <span class="s0">except Exception as e:</span>
            <span class="s0">try:</span>
                <span class="s0">e = unicode(e).encode(&quot;UTF-8&quot;)</span>
            <span class="s0">except:</span>
                <span class="s0">e = repr(e).encode(&quot;UTF-8&quot;)</span>
            <span class="s0">message = python.PyBytes_FromFormat(</span>
                <span class="s0">&quot;Error executing extension element '%s': %s&quot;,</span>
                <span class="s0">c_inst_node.name, _cstr(e))</span>
            <span class="s0">xslt.xsltTransformError(c_ctxt, NULL, c_inst_node, &quot;%s&quot;, message)</span>
            <span class="s0">context._exc._store_raised()</span>
        <span class="s0">except:</span>
            <span class="s0"># just in case</span>
            <span class="s0">message = python.PyBytes_FromFormat(</span>
                <span class="s0">&quot;Error executing extension element '%s'&quot;, c_inst_node.name)</span>
            <span class="s0">xslt.xsltTransformError(c_ctxt, NULL, c_inst_node, &quot;%s&quot;, message)</span>
            <span class="s0">context._exc._store_raised()</span>
    <span class="s0">except:</span>
        <span class="s0"># no Python functions here - everything can fail...</span>
        <span class="s0">xslt.xsltTransformError(c_ctxt, NULL, c_inst_node,</span>
                                <span class="s0">&quot;Error during XSLT extension element evaluation&quot;)</span>
        <span class="s0">context._exc._store_raised()</span>
    <span class="s0">finally:</span>
        <span class="s0">return  # swallow any further exceptions</span>
</pre>
</body>
</html>