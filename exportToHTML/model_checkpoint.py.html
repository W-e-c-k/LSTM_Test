<html>
<head>
<title>model_checkpoint.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
model_checkpoint.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">callbacks</span><span class="s2">.</span><span class="s1">callback </span><span class="s0">import </span><span class="s1">Callback</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">file_utils</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">io_utils</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.callbacks.ModelCheckpoint&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ModelCheckpoint</span><span class="s2">(</span><span class="s1">Callback</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Callback to save the Keras model or model weights at some frequency. 
 
    `ModelCheckpoint` callback is used in conjunction with training using 
    `model.fit()` to save a model or weights (in a checkpoint file) at some 
    interval, so the model or weights can be loaded later to continue the 
    training from the state saved. 
 
    A few options this callback provides include: 
 
    - Whether to only keep the model that has achieved the &quot;best performance&quot; so 
      far, or whether to save the model at the end of every epoch regardless of 
      performance. 
    - Definition of &quot;best&quot;; which quantity to monitor and whether it should be 
      maximized or minimized. 
    - The frequency it should save at. Currently, the callback supports saving 
      at the end of every epoch, or after a fixed number of training batches. 
    - Whether only weights are saved, or the whole model is saved. 
 
    Example: 
 
    ```python 
    model.compile(loss=..., optimizer=..., 
                  metrics=['accuracy']) 
 
    EPOCHS = 10 
    checkpoint_filepath = '/tmp/ckpt/checkpoint.model.keras' 
    model_checkpoint_callback = keras.callbacks.ModelCheckpoint( 
        filepath=checkpoint_filepath, 
        monitor='val_accuracy', 
        mode='max', 
        save_best_only=True) 
 
    # Model is saved at the end of every epoch, if it's the best seen so far. 
    model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback]) 
 
    # The model (that are considered the best) can be loaded as - 
    keras.models.load_model(checkpoint_filepath) 
 
    # Alternatively, one could checkpoint just the model weights as - 
    checkpoint_filepath = '/tmp/ckpt/checkpoint.weights.h5' 
    model_checkpoint_callback = keras.callbacks.ModelCheckpoint( 
        filepath=checkpoint_filepath, 
        save_weights_only=True, 
        monitor='val_accuracy', 
        mode='max', 
        save_best_only=True) 
 
    # Model weights are saved at the end of every epoch, if it's the best seen 
    # so far. 
    model.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback]) 
 
    # The model weights (that are considered the best) can be loaded as - 
    model.load_weights(checkpoint_filepath) 
    ``` 
 
    Args: 
        filepath: string or `PathLike`, path to save the model file. 
            `filepath` can contain named formatting options, 
            which will be filled the value of `epoch` and keys in `logs` 
            (passed in `on_epoch_end`). 
            The `filepath` name needs to end with `&quot;.weights.h5&quot;` when 
            `save_weights_only=True` or should end with `&quot;.keras&quot;` when 
            checkpoint saving the whole model (default). 
            For example: 
            if `filepath` is `&quot;{epoch:02d}-{val_loss:.2f}.keras&quot;`, then the 
            model checkpoints will be saved with the epoch number and the 
            validation loss in the filename. The directory of the filepath 
            should not be reused by any other callbacks to avoid conflicts. 
        monitor: The metric name to monitor. Typically the metrics are set by 
            the `Model.compile` method. Note: 
            * Prefix the name with `&quot;val_&quot;` to monitor validation metrics. 
            * Use `&quot;loss&quot;` or `&quot;val_loss&quot;` to monitor the model's total loss. 
            * If you specify metrics as strings, like `&quot;accuracy&quot;`, pass the 
                same string (with or without the `&quot;val_&quot;` prefix). 
            * If you pass `metrics.Metric` objects, `monitor` should be set to 
                `metric.name` 
            * If you're not sure about the metric names you can check the 
                contents of the `history.history` dictionary returned by 
                `history = model.fit()` 
            * Multi-output models set additional prefixes on the metric names. 
        verbose: Verbosity mode, 0 or 1. Mode 0 is silent, and mode 1 
            displays messages when the callback takes an action. 
        save_best_only: if `save_best_only=True`, it only saves when the model 
            is considered the &quot;best&quot; and the latest best model according to the 
            quantity monitored will not be overwritten. If `filepath` doesn't 
            contain formatting options like `{epoch}` then `filepath` will be 
            overwritten by each new better model. 
        mode: one of {`&quot;auto&quot;`, `&quot;min&quot;`, `&quot;max&quot;`}. If `save_best_only=True`, the 
            decision to overwrite the current save file is made based on either 
            the maximization or the minimization of the monitored quantity. 
            For `val_acc`, this should be `&quot;max&quot;`, for `val_loss` this should be 
            `&quot;min&quot;`, etc. In `&quot;auto&quot;` mode, the mode is set to `&quot;max&quot;` if the 
            quantities monitored are `&quot;acc&quot;` or start with `&quot;fmeasure&quot;` and are 
            set to `&quot;min&quot;` for the rest of the quantities. 
        save_weights_only: if `True`, then only the model's weights will be 
            saved (`model.save_weights(filepath)`), else the full model is 
            saved (`model.save(filepath)`). 
        save_freq: `&quot;epoch&quot;` or integer. When using `&quot;epoch&quot;`, the callback 
            saves the model after each epoch. When using integer, the callback 
            saves the model at end of this many batches. If the `Model` is 
            compiled with `steps_per_execution=N`, then the saving criteria will 
            be checked every Nth batch. Note that if the saving isn't aligned to 
            epochs, the monitored metric may potentially be less reliable (it 
            could reflect as little as 1 batch, since the metrics get reset 
            every epoch). Defaults to `&quot;epoch&quot;`. 
        initial_value_threshold: Floating point initial &quot;best&quot; value of the 
            metric to be monitored. Only applies if `save_best_value=True`. Only 
            overwrites the model weights already saved if the performance of 
            current model is better than this value. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">filepath</span><span class="s2">,</span>
        <span class="s1">monitor</span><span class="s2">=</span><span class="s3">&quot;val_loss&quot;</span><span class="s2">,</span>
        <span class="s1">verbose</span><span class="s2">=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">save_best_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">save_weights_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">mode</span><span class="s2">=</span><span class="s3">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">save_freq</span><span class="s2">=</span><span class="s3">&quot;epoch&quot;</span><span class="s2">,</span>
        <span class="s1">initial_value_threshold</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">monitor </span><span class="s2">= </span><span class="s1">monitor</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">verbose </span><span class="s2">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">filepath </span><span class="s2">= </span><span class="s1">file_utils</span><span class="s2">.</span><span class="s1">path_to_string</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">save_best_only </span><span class="s2">= </span><span class="s1">save_best_only</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">save_weights_only </span><span class="s2">= </span><span class="s1">save_weights_only</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq </span><span class="s2">= </span><span class="s1">save_freq</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_batches_seen_since_last_saving </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_batch_seen </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= </span><span class="s1">initial_value_threshold</span>

        <span class="s0">if </span><span class="s1">mode </span><span class="s0">not in </span><span class="s2">[</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s2">]:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s3">f&quot;ModelCheckpoint mode '</span><span class="s0">{</span><span class="s1">mode</span><span class="s0">}</span><span class="s3">' is unknown, &quot;</span>
                <span class="s3">&quot;fallback to auto mode.&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">mode </span><span class="s2">= </span><span class="s3">&quot;auto&quot;</span>

        <span class="s0">if </span><span class="s1">mode </span><span class="s2">== </span><span class="s3">&quot;min&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">monitor_op </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">less</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s0">elif </span><span class="s1">mode </span><span class="s2">== </span><span class="s3">&quot;max&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">monitor_op </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">greater</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s3">&quot;acc&quot; </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">&quot;fmeasure&quot;</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">monitor_op </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">greater</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">monitor_op </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">less</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq </span><span class="s2">!= </span><span class="s3">&quot;epoch&quot; </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">f&quot;Unrecognized save_freq: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq</span><span class="s0">}</span><span class="s3">. &quot;</span>
                <span class="s3">&quot;Expected save_freq are 'epoch' or integer values&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">save_weights_only</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s3">&quot;.weights.h5&quot;</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">&quot;When using `save_weights_only=True` in `ModelCheckpoint`&quot;</span>
                    <span class="s3">&quot;, the filepath provided must end in `.weights.h5` &quot;</span>
                    <span class="s3">&quot;(Keras weights format). Received: &quot;</span>
                    <span class="s3">f&quot;filepath=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s3">&quot;.keras&quot;</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">&quot;The filepath provided must end in `.keras` &quot;</span>
                    <span class="s3">&quot;(Keras model format). Received: &quot;</span>
                    <span class="s3">f&quot;filepath=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">on_train_batch_end</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_should_save_on_batch</span><span class="s2">(</span><span class="s1">batch</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_model</span><span class="s2">(</span><span class="s1">epoch</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_current_epoch</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">=</span><span class="s1">batch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">=</span><span class="s1">logs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">on_epoch_begin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_current_epoch </span><span class="s2">= </span><span class="s1">epoch</span>

    <span class="s0">def </span><span class="s1">on_epoch_end</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq </span><span class="s2">== </span><span class="s3">&quot;epoch&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_save_model</span><span class="s2">(</span><span class="s1">epoch</span><span class="s2">=</span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">=</span><span class="s1">logs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_should_save_on_batch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Handles batch-level saving logic, supports steps_per_execution.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq </span><span class="s2">== </span><span class="s3">&quot;epoch&quot;</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">batch </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_batch_seen</span><span class="s2">:  </span><span class="s6"># New epoch.</span>
            <span class="s1">add_batches </span><span class="s2">= </span><span class="s1">batch </span><span class="s2">+ </span><span class="s5">1  </span><span class="s6"># batches are zero-indexed.</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">add_batches </span><span class="s2">= </span><span class="s1">batch </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_batch_seen</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_batches_seen_since_last_saving </span><span class="s2">+= </span><span class="s1">add_batches</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_batch_seen </span><span class="s2">= </span><span class="s1">batch</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_batches_seen_since_last_saving </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_freq</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_batches_seen_since_last_saving </span><span class="s2">= </span><span class="s5">0</span>
            <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_save_model</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Saves the model. 
 
        Args: 
            epoch: the epoch this iteration is in. 
            batch: the batch this iteration is in. `None` if the `save_freq` 
                is set to `&quot;epoch&quot;`. 
            logs: the `logs` dict passed in to `on_batch_end` or `on_epoch_end`. 
        &quot;&quot;&quot;</span>
        <span class="s1">logs </span><span class="s2">= </span><span class="s1">logs </span><span class="s0">or </span><span class="s2">{}</span>

        <span class="s1">filepath </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_file_path</span><span class="s2">(</span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">)</span>
        <span class="s6"># Create host directory if it doesn't exist.</span>
        <span class="s1">dirname </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dirname </span><span class="s0">and not </span><span class="s1">file_utils</span><span class="s2">.</span><span class="s1">exists</span><span class="s2">(</span><span class="s1">dirname</span><span class="s2">):</span>
            <span class="s1">file_utils</span><span class="s2">.</span><span class="s1">makedirs</span><span class="s2">(</span><span class="s1">dirname</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_best_only</span><span class="s2">:</span>
                <span class="s1">current </span><span class="s2">= </span><span class="s1">logs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">current </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                        <span class="s3">f&quot;Can save best model only with </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor</span><span class="s0">} </span><span class="s3">&quot;</span>
                        <span class="s3">&quot;available, skipping.&quot;</span><span class="s2">,</span>
                        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">elif </span><span class="s2">(</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">current</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
                    <span class="s0">or </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">is_tensor</span><span class="s2">(</span><span class="s1">current</span><span class="s2">)</span>
                <span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">current</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                        <span class="s3">&quot;Can save best model only when `monitor` is &quot;</span>
                        <span class="s3">f&quot;a scalar value. Received: </span><span class="s0">{</span><span class="s1">current</span><span class="s0">}</span><span class="s3">. &quot;</span>
                        <span class="s3">&quot;Falling back to `save_best_only=False`.&quot;</span>
                    <span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">model</span><span class="s2">.</span><span class="s1">save</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor_op</span><span class="s2">(</span><span class="s1">current</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verbose </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                            <span class="s1">io_utils</span><span class="s2">.</span><span class="s1">print_msg</span><span class="s2">(</span>
                                <span class="s3">f&quot;</span><span class="s0">\n</span><span class="s3">Epoch </span><span class="s0">{</span><span class="s1">epoch </span><span class="s2">+ </span><span class="s5">1</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor</span><span class="s0">} </span><span class="s3">&quot;</span>
                                <span class="s3">&quot;improved &quot;</span>
                                <span class="s3">f&quot;from </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">best</span><span class="s0">:</span><span class="s3">.5f</span><span class="s0">} </span><span class="s3">to </span><span class="s0">{</span><span class="s1">current</span><span class="s0">:</span><span class="s3">.5f</span><span class="s0">}</span><span class="s3">, &quot;</span>
                                <span class="s3">f&quot;saving model to </span><span class="s0">{</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
                            <span class="s2">)</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">best </span><span class="s2">= </span><span class="s1">current</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_weights_only</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">model</span><span class="s2">.</span><span class="s1">save_weights</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">model</span><span class="s2">.</span><span class="s1">save</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verbose </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                            <span class="s1">io_utils</span><span class="s2">.</span><span class="s1">print_msg</span><span class="s2">(</span>
                                <span class="s3">f&quot;</span><span class="s0">\n</span><span class="s3">Epoch </span><span class="s0">{</span><span class="s1">epoch </span><span class="s2">+ </span><span class="s5">1</span><span class="s0">}</span><span class="s3">: &quot;</span>
                                <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">monitor</span><span class="s0">} </span><span class="s3">did not improve &quot;</span>
                                <span class="s3">f&quot;from </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">best</span><span class="s0">:</span><span class="s3">.5f</span><span class="s0">}</span><span class="s3">&quot;</span>
                            <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verbose </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s1">io_utils</span><span class="s2">.</span><span class="s1">print_msg</span><span class="s2">(</span>
                        <span class="s3">f&quot;</span><span class="s0">\n</span><span class="s3">Epoch </span><span class="s0">{</span><span class="s1">epoch </span><span class="s2">+ </span><span class="s5">1</span><span class="s0">}</span><span class="s3">: saving model to </span><span class="s0">{</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
                    <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">save_weights_only</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">model</span><span class="s2">.</span><span class="s1">save_weights</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">model</span><span class="s2">.</span><span class="s1">save</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">IsADirectoryError</span><span class="s2">:  </span><span class="s6"># h5py 3.x</span>
            <span class="s0">raise </span><span class="s1">IOError</span><span class="s2">(</span>
                <span class="s3">&quot;Please specify a non-directory filepath for &quot;</span>
                <span class="s3">&quot;ModelCheckpoint. Filepath used is an existing &quot;</span>
                <span class="s3">f&quot;directory: </span><span class="s0">{</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>
        <span class="s0">except </span><span class="s1">IOError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:  </span><span class="s6"># h5py 2.x</span>
            <span class="s6"># `e.errno` appears to be `None` so checking the content of</span>
            <span class="s6"># `e.args[0]`.</span>
            <span class="s0">if </span><span class="s3">&quot;is a directory&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]).</span><span class="s1">lower</span><span class="s2">():</span>
                <span class="s0">raise </span><span class="s1">IOError</span><span class="s2">(</span>
                    <span class="s3">&quot;Please specify a non-directory filepath for &quot;</span>
                    <span class="s3">&quot;ModelCheckpoint. Filepath used is an existing &quot;</span>
                    <span class="s3">f&quot;directory: f</span><span class="s0">{</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s2">)</span>
            <span class="s6"># Re-throw the error for any other causes.</span>
            <span class="s0">raise </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">_get_file_path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">epoch</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">, </span><span class="s1">logs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the file path for checkpoint.&quot;&quot;&quot;</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s6"># `filepath` may contain placeholders such as</span>
            <span class="s6"># `{epoch:02d}`,`{batch:02d}` and `{mape:.2f}`. A mismatch between</span>
            <span class="s6"># logged metrics and the path's placeholders can cause formatting to</span>
            <span class="s6"># fail.</span>
            <span class="s0">if </span><span class="s1">batch </span><span class="s0">is None or </span><span class="s3">&quot;batch&quot; </span><span class="s0">in </span><span class="s1">logs</span><span class="s2">:</span>
                <span class="s1">file_path </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">epoch</span><span class="s2">=</span><span class="s1">epoch </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">logs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">file_path </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                    <span class="s1">epoch</span><span class="s2">=</span><span class="s1">epoch </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">batch</span><span class="s2">=</span><span class="s1">batch </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">logs</span>
                <span class="s2">)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span>
                <span class="s3">f'Failed to format this callback filepath: &quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">filepath</span><span class="s0">}</span><span class="s3">&quot;. '</span>
                <span class="s3">f&quot;Reason: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">file_path</span>

    <span class="s0">def </span><span class="s1">_checkpoint_exists</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns whether the checkpoint `filepath` refers to exists.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">file_utils</span><span class="s2">.</span><span class="s1">exists</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_most_recently_modified_file_matching_pattern</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the most recently modified filepath matching pattern. 
 
        In the rare case where there are more than one pattern-matching file 
        having the same modified time that is most recent among all, return the 
        filepath that is largest (by `&gt;` operator, lexicographically using the 
        numeric equivalents). This provides a tie-breaker when multiple files 
        are most recent. Note that a larger `filepath` can sometimes indicate a 
        later time of modification (for instance, when epoch/batch is used as 
        formatting option), but not necessarily (when accuracy or loss is used). 
        The tie-breaker is put in the logic as best effort to return the most 
        recent, and to avoid undeterministic result. 
 
        Modified time of a file is obtained with `os.path.getmtime()`. 
 
        This utility function is best demonstrated via an example: 
 
        ```python 
        file_pattern = 'batch{batch:02d}epoch{epoch:02d}.keras' 
        test_dir = self.get_temp_dir() 
        path_pattern = os.path.join(test_dir, file_pattern) 
        file_paths = [ 
            os.path.join(test_dir, file_name) for file_name in 
            ['batch03epoch02.keras', 
             'batch02epoch02.keras', 'batch01epoch01.keras'] 
        ] 
        for file_path in file_paths: 
            # Write something to each of the files 
            ... 
        self.assertEqual( 
            _get_most_recently_modified_file_matching_pattern(path_pattern), 
            file_paths[-1]) 
        ``` 
 
        Args: 
            pattern: The file pattern that may optionally contain python 
                placeholder such as `{epoch:02d}`. 
 
        Returns: 
            The most recently modified file's full filepath matching `pattern`. 
            If `pattern` does not contain any placeholder, this returns the 
            filepath that exactly matches `pattern`. Returns `None` if no match 
            is found. 
        &quot;&quot;&quot;</span>
        <span class="s1">dir_name </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">pattern</span><span class="s2">)</span>
        <span class="s1">base_name </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">basename</span><span class="s2">(</span><span class="s1">pattern</span><span class="s2">)</span>
        <span class="s1">base_name_regex </span><span class="s2">= </span><span class="s3">&quot;^&quot; </span><span class="s2">+ </span><span class="s1">re</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s3">r&quot;{.*}&quot;</span><span class="s2">, </span><span class="s3">r&quot;.*&quot;</span><span class="s2">, </span><span class="s1">base_name</span><span class="s2">) + </span><span class="s3">&quot;$&quot;</span>

        <span class="s1">latest_mod_time </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">file_path_with_latest_mod_time </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">n_file_with_latest_mod_time </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">file_path_with_largest_file_name </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">file_utils</span><span class="s2">.</span><span class="s1">exists</span><span class="s2">(</span><span class="s1">dir_name</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">file_name </span><span class="s0">in </span><span class="s1">os</span><span class="s2">.</span><span class="s1">listdir</span><span class="s2">(</span><span class="s1">dir_name</span><span class="s2">):</span>
                <span class="s6"># Only consider if `file_name` matches the pattern.</span>
                <span class="s0">if </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s1">base_name_regex</span><span class="s2">, </span><span class="s1">file_name</span><span class="s2">):</span>
                    <span class="s1">file_path </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">dir_name</span><span class="s2">, </span><span class="s1">file_name</span><span class="s2">)</span>
                    <span class="s1">mod_time </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">getmtime</span><span class="s2">(</span><span class="s1">file_path</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">file_path_with_largest_file_name </span><span class="s0">is None</span>
                        <span class="s0">or </span><span class="s1">file_path </span><span class="s2">&gt; </span><span class="s1">file_path_with_largest_file_name</span>
                    <span class="s2">):</span>
                        <span class="s1">file_path_with_largest_file_name </span><span class="s2">= </span><span class="s1">file_path</span>
                    <span class="s0">if </span><span class="s1">mod_time </span><span class="s2">&gt; </span><span class="s1">latest_mod_time</span><span class="s2">:</span>
                        <span class="s1">latest_mod_time </span><span class="s2">= </span><span class="s1">mod_time</span>
                        <span class="s1">file_path_with_latest_mod_time </span><span class="s2">= </span><span class="s1">file_path</span>
                        <span class="s6"># In the case a file with later modified time is found,</span>
                        <span class="s6"># reset the counter for the number of files with latest</span>
                        <span class="s6"># modified time.</span>
                        <span class="s1">n_file_with_latest_mod_time </span><span class="s2">= </span><span class="s5">1</span>
                    <span class="s0">elif </span><span class="s1">mod_time </span><span class="s2">== </span><span class="s1">latest_mod_time</span><span class="s2">:</span>
                        <span class="s6"># In the case a file has modified time tied with the</span>
                        <span class="s6"># most recent, increment the counter for the number of</span>
                        <span class="s6"># files with latest modified time by 1.</span>
                        <span class="s1">n_file_with_latest_mod_time </span><span class="s2">+= </span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">n_file_with_latest_mod_time </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s6"># Return the sole file that has most recent modified time.</span>
            <span class="s0">return </span><span class="s1">file_path_with_latest_mod_time</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s6"># If there are more than one file having latest modified time,</span>
            <span class="s6"># return the file path with the largest file name.</span>
            <span class="s0">return </span><span class="s1">file_path_with_largest_file_name</span>
</pre>
</body>
</html>