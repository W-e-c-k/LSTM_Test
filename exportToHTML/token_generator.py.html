<html>
<head>
<title>token_generator.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
token_generator.py</font>
</center></td></tr></table>
<pre><span class="s0"># coding=utf-8</span>
<span class="s2">&quot;&quot;&quot;Token generator for analyzing source code in logical units. 
 
This module contains the TokenGenerator used for annotating a parsed syntax tree 
with source code formatting. 
&quot;&quot;&quot;</span>
<span class="s0"># Copyright 2017 Google LLC</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">division</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">print_function</span>

<span class="s3">import </span><span class="s1">ast</span>
<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">tokenize</span>
<span class="s3">from </span><span class="s1">six </span><span class="s3">import </span><span class="s1">StringIO</span>

<span class="s3">from </span><span class="s1">pasta</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">formatting </span><span class="s3">as </span><span class="s1">fmt</span>
<span class="s3">from </span><span class="s1">pasta</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">fstring_utils</span>

<span class="s0"># Alias for extracting token names</span>
<span class="s1">TOKENS </span><span class="s4">= </span><span class="s1">tokenize</span>
<span class="s1">Token </span><span class="s4">= </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">namedtuple</span><span class="s4">(</span><span class="s5">'Token'</span><span class="s4">, (</span><span class="s5">'type'</span><span class="s4">, </span><span class="s5">'src'</span><span class="s4">, </span><span class="s5">'start'</span><span class="s4">, </span><span class="s5">'end'</span><span class="s4">, </span><span class="s5">'line'</span><span class="s4">))</span>
<span class="s1">FORMATTING_TOKENS </span><span class="s4">= (</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">INDENT</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">DEDENT</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NL</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NEWLINE</span><span class="s4">,</span>
                     <span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">COMMENT</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TokenGenerator</span><span class="s4">(</span><span class="s1">object</span><span class="s4">):</span>
  <span class="s2">&quot;&quot;&quot;Helper for sequentially parsing Python source code, token by token. 
 
  Holds internal state during parsing, including: 
  _tokens: List of tokens in the source code, as parsed by `tokenize` module. 
  _parens: Stack of open parenthesis at the current point in parsing. 
  _hints: Number of open parentheses, brackets, etc. at the current point. 
  _scope_stack: Stack containing tuples of nodes where the last parenthesis that 
    was open is related to one of the nodes on the top of the stack. 
  _lines: Full lines of the source code. 
  _i: Index of the last token that was parsed. Initially -1. 
  _loc: (lineno, column_offset) pair of the position in the source that has been 
     parsed to. This should be either the start or end of the token at index _i. 
 
  Arguments: 
    ignore_error_tokens: If True, will ignore error tokens. Otherwise, an error 
      token will cause an exception. This is useful when the source being parsed 
      contains invalid syntax, e.g. if it is in an fstring context. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">source</span><span class="s4">, </span><span class="s1">ignore_error_token</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">lines </span><span class="s4">= </span><span class="s1">source</span><span class="s4">.</span><span class="s1">splitlines</span><span class="s4">(</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">_generate_tokens</span><span class="s4">(</span><span class="s1">source</span><span class="s4">, </span><span class="s1">ignore_error_token</span><span class="s4">))</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_parens </span><span class="s4">= []</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_hints </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_scope_stack </span><span class="s4">= []</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_len </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">)</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">= -</span><span class="s6">1</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loc_begin</span><span class="s4">()</span>

  <span class="s3">def </span><span class="s1">chars_consumed</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">((</span><span class="s6">1</span><span class="s4">, </span><span class="s6">0</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span><span class="s4">))</span>

  <span class="s3">def </span><span class="s1">loc_begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Get the start column of the current location parsed to.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
      <span class="s3">return </span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">start</span>

  <span class="s3">def </span><span class="s1">loc_end</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Get the end column of the current location parsed to.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
      <span class="s3">return </span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span>

  <span class="s3">def </span><span class="s1">peek</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Get the next token without advancing.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_len</span><span class="s4">:</span>
      <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]</span>

  <span class="s3">def </span><span class="s1">peek_non_whitespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Get the next non-whitespace token without advancing.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">peek_conditional</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">t</span><span class="s4">: </span><span class="s1">t</span><span class="s4">.</span><span class="s1">type </span><span class="s3">not in </span><span class="s1">FORMATTING_TOKENS</span><span class="s4">)</span>

  <span class="s3">def </span><span class="s1">peek_conditional</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">condition</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Get the next token of the given type without advancing.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">next</span><span class="s4">((</span><span class="s1">t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">:] </span><span class="s3">if </span><span class="s1">condition</span><span class="s4">(</span><span class="s1">t</span><span class="s4">)), </span><span class="s3">None</span><span class="s4">)</span>

  <span class="s3">def </span><span class="s1">next</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">advance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Consume the next token and optionally advance the current location.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_len</span><span class="s4">:</span>
      <span class="s3">return None</span>
    <span class="s3">if </span><span class="s1">advance</span><span class="s4">:</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">]</span>

  <span class="s3">def </span><span class="s1">rewind</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">amount</span><span class="s4">=</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Rewind the token iterator.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">-= </span><span class="s1">amount</span>

  <span class="s3">def </span><span class="s1">whitespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">max_lines</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parses whitespace from the current _loc to the next non-whitespace. 
 
    Arguments: 
      max_lines: (optional int) Maximum number of lines to consider as part of 
        the whitespace. Valid values are None, 0 and 1. 
      comment: (boolean) If True, look for a trailing comment even when not in 
        a parenthesized scope. 
 
    Pre-condition: 
      `_loc' represents the point before which everything has been parsed and 
      after which nothing has been parsed. 
    Post-condition: 
      `_loc' is exactly at the character that was parsed to. 
    &quot;&quot;&quot;</span>
    <span class="s1">next_token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">peek</span><span class="s4">()</span>
    <span class="s3">if not </span><span class="s1">comment </span><span class="s3">and </span><span class="s1">next_token </span><span class="s3">and </span><span class="s1">next_token</span><span class="s4">.</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">COMMENT</span><span class="s4">:</span>
      <span class="s3">return </span><span class="s5">''</span>
    <span class="s3">def </span><span class="s1">predicate</span><span class="s4">(</span><span class="s1">token</span><span class="s4">):</span>
      <span class="s3">return </span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s4">(</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">INDENT</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">DEDENT</span><span class="s4">) </span><span class="s3">or</span>
              <span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">COMMENT </span><span class="s3">and </span><span class="s4">(</span><span class="s1">comment </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hints</span><span class="s4">) </span><span class="s3">or</span>
              <span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">ERRORTOKEN </span><span class="s3">and </span><span class="s1">token</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">' ' </span><span class="s3">or</span>
              <span class="s1">max_lines </span><span class="s3">is None and </span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s4">(</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NL</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NEWLINE</span><span class="s4">))</span>
    <span class="s1">whitespace </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s1">predicate</span><span class="s4">, </span><span class="s1">advance</span><span class="s4">=</span><span class="s3">False</span><span class="s4">))</span>
    <span class="s1">next_token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">peek</span><span class="s4">()</span>

    <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span><span class="s1">whitespace</span><span class="s4">,</span>
                               <span class="s4">((</span><span class="s1">next_token</span><span class="s4">,) </span><span class="s3">if </span><span class="s1">next_token </span><span class="s3">else </span><span class="s4">())):</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span><span class="s4">, </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>
      <span class="s3">if </span><span class="s1">tok </span><span class="s4">!= </span><span class="s1">next_token</span><span class="s4">:</span>
        <span class="s1">result </span><span class="s4">+= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">end</span>
      <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span>

    <span class="s0"># Eat a single newline character</span>
    <span class="s3">if </span><span class="s4">((</span><span class="s1">max_lines </span><span class="s3">is None or </span><span class="s1">max_lines </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and</span>
        <span class="s1">next_token </span><span class="s3">and </span><span class="s1">next_token</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s4">(</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NL</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NEWLINE</span><span class="s4">)):</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">().</span><span class="s1">src</span>

    <span class="s3">return </span><span class="s1">result</span>

  <span class="s3">def </span><span class="s1">block_whitespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">indent_level</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parses whitespace from the current _loc to the end of the block.&quot;&quot;&quot;</span>
    <span class="s0"># Get the normal suffix lines, but don't advance the token index unless</span>
    <span class="s0"># there is no indentation to account for</span>
    <span class="s1">start_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
    <span class="s1">full_whitespace </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">whitespace</span><span class="s4">(</span><span class="s1">comment</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">indent_level</span><span class="s4">:</span>
      <span class="s3">return </span><span class="s1">full_whitespace</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">= </span><span class="s1">start_i</span>

    <span class="s0"># Trim the full whitespace into only lines that match the indentation level</span>
    <span class="s1">lines </span><span class="s4">= </span><span class="s1">full_whitespace</span><span class="s4">.</span><span class="s1">splitlines</span><span class="s4">(</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">try</span><span class="s4">:</span>
      <span class="s1">last_line_idx </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">i </span><span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">line </span><span class="s3">in </span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">)))</span>
                           <span class="s3">if </span><span class="s1">line</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s1">indent_level </span><span class="s4">+ </span><span class="s5">'#'</span><span class="s4">))</span>
    <span class="s3">except </span><span class="s1">StopIteration</span><span class="s4">:</span>
      <span class="s0"># No comment lines at the end of this block</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span>
      <span class="s3">return </span><span class="s5">''</span>
    <span class="s1">lines </span><span class="s4">= </span><span class="s1">lines</span><span class="s4">[:</span><span class="s1">last_line_idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]</span>

    <span class="s0"># Advance the current location to the last token in the lines we've read</span>
    <span class="s1">end_line </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1 </span><span class="s4">+ </span><span class="s1">len</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">)</span>
    <span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">tok</span><span class="s4">: </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &lt; </span><span class="s1">end_line</span><span class="s4">))</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tokens</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span><span class="s4">].</span><span class="s1">end</span>
    <span class="s3">return </span><span class="s5">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">)</span>

  <span class="s3">def </span><span class="s1">dots</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">num_dots</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a number of dots. 
     
    This is to work around an oddity in python3's tokenizer, which treats three 
    `.` tokens next to each other in a FromImport's level as an ellipsis. This 
    parses until the expected number of dots have been seen. 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
    <span class="s1">dots_seen </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
    <span class="s3">while </span><span class="s1">dots_seen </span><span class="s4">&lt; </span><span class="s1">num_dots</span><span class="s4">:</span>
      <span class="s1">tok </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">()</span>
      <span class="s3">assert </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s3">in </span><span class="s4">(</span><span class="s5">'.'</span><span class="s4">, </span><span class="s5">'...'</span><span class="s4">)</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">prev_loc</span><span class="s4">, </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">) + </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span>
      <span class="s1">dots_seen </span><span class="s4">+= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span><span class="s4">.</span><span class="s1">count</span><span class="s4">(</span><span class="s5">'.'</span><span class="s4">)</span>
      <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
    <span class="s3">return </span><span class="s1">result</span>

  <span class="s3">def </span><span class="s1">open_scope</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">, </span><span class="s1">single_paren</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Open a parenthesized scope on the given node.&quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
    <span class="s1">parens </span><span class="s4">= []</span>
    <span class="s1">start_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
    <span class="s1">start_loc </span><span class="s4">= </span><span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>

    <span class="s0"># Eat whitespace or '(' tokens one at a time</span>
    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span>
        <span class="s3">lambda </span><span class="s1">t</span><span class="s4">: </span><span class="s1">t</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s1">FORMATTING_TOKENS </span><span class="s3">or </span><span class="s1">t</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">'('</span><span class="s4">):</span>
      <span class="s0"># Stores all the code up to and including this token</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">prev_loc</span><span class="s4">, </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>

      <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">'(' </span><span class="s3">and </span><span class="s1">single_paren </span><span class="s3">and </span><span class="s1">parens</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">rewind</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span>
        <span class="s3">break</span>

      <span class="s1">result </span><span class="s4">+= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span>
      <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">'('</span><span class="s4">:</span>
        <span class="s0"># Start a new scope</span>
        <span class="s1">parens</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">result</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
        <span class="s1">start_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
        <span class="s1">start_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
      <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>

    <span class="s3">if </span><span class="s1">parens</span><span class="s4">:</span>
      <span class="s0"># Add any additional whitespace on to the last open-paren</span>
      <span class="s1">next_tok </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">peek</span><span class="s4">()</span>
      <span class="s1">parens</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] += </span><span class="s1">result </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span><span class="s4">, </span><span class="s1">next_tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">next_tok</span><span class="s4">.</span><span class="s1">start</span>
      <span class="s0"># Add each paren onto the stack</span>
      <span class="s3">for </span><span class="s1">paren </span><span class="s3">in </span><span class="s1">parens</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_parens</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">paren</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_scope_stack</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
      <span class="s0"># No parens were encountered, then reset like this method did nothing</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">= </span><span class="s1">start_i</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">start_loc</span>

  <span class="s3">def </span><span class="s1">close_scope</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">, </span><span class="s1">prefix_attr</span><span class="s4">=</span><span class="s5">'prefix'</span><span class="s4">, </span><span class="s1">suffix_attr</span><span class="s4">=</span><span class="s5">'suffix'</span><span class="s4">,</span>
                  <span class="s1">trailing_comma</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">single_paren</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Close a parenthesized scope on the given node, if one is open.&quot;&quot;&quot;</span>
    <span class="s0"># Ensures the prefix + suffix are not None</span>
    <span class="s3">if </span><span class="s1">fmt</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">prefix_attr</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
      <span class="s1">fmt</span><span class="s4">.</span><span class="s1">set</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">prefix_attr</span><span class="s4">, </span><span class="s5">''</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">fmt</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">suffix_attr</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
      <span class="s1">fmt</span><span class="s4">.</span><span class="s1">set</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">suffix_attr</span><span class="s4">, </span><span class="s5">''</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parens </span><span class="s3">or </span><span class="s1">node </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scope_stack</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]:</span>
      <span class="s3">return</span>
    <span class="s1">symbols </span><span class="s4">= {</span><span class="s5">')'</span><span class="s4">}</span>
    <span class="s3">if </span><span class="s1">trailing_comma</span><span class="s4">:</span>
      <span class="s1">symbols</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s5">','</span><span class="s4">)</span>
    <span class="s1">parsed_to_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
    <span class="s1">parsed_to_loc </span><span class="s4">= </span><span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
    <span class="s1">encountered_paren </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>

    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span>
        <span class="s3">lambda </span><span class="s1">t</span><span class="s4">: </span><span class="s1">t</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s1">FORMATTING_TOKENS </span><span class="s3">or </span><span class="s1">t</span><span class="s4">.</span><span class="s1">src </span><span class="s3">in </span><span class="s1">symbols</span><span class="s4">):</span>
      <span class="s0"># Consume all space up to this token</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">prev_loc</span><span class="s4">, </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>
      <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">')' </span><span class="s3">and </span><span class="s1">single_paren </span><span class="s3">and </span><span class="s1">encountered_paren</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">rewind</span><span class="s4">()</span>
        <span class="s1">parsed_to_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
        <span class="s1">parsed_to_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span>
        <span class="s1">fmt</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">suffix_attr</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>
        <span class="s3">break</span>

      <span class="s0"># Consume the token itself</span>
      <span class="s1">result </span><span class="s4">+= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span>

      <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">')'</span><span class="s4">:</span>
        <span class="s0"># Close out the open scope</span>
        <span class="s1">encountered_paren </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_scope_stack</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
        <span class="s1">fmt</span><span class="s4">.</span><span class="s1">prepend</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">prefix_attr</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parens</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">())</span>
        <span class="s1">fmt</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">suffix_attr</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
        <span class="s1">parsed_to_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
        <span class="s1">parsed_to_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">end</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parens </span><span class="s3">or </span><span class="s1">node </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scope_stack</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]:</span>
          <span class="s3">break</span>
      <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">end</span>

    <span class="s0"># Reset back to the last place where we parsed anything</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">= </span><span class="s1">parsed_to_i</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">parsed_to_loc</span>

  <span class="s3">def </span><span class="s1">hint_open</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Indicates opening a group of parentheses or brackets.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_hints </span><span class="s4">+= </span><span class="s6">1</span>

  <span class="s3">def </span><span class="s1">hint_closed</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Indicates closing a group of parentheses or brackets.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_hints </span><span class="s4">-= </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hints </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
      <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Hint value negative'</span><span class="s4">)</span>

  <span class="s4">@</span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">contextmanager</span>
  <span class="s3">def </span><span class="s1">scope</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">trailing_comma</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Context manager to handle a parenthesized scope.&quot;&quot;&quot;</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">open_scope</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">single_paren</span><span class="s4">=(</span><span class="s1">attr </span><span class="s3">is not None</span><span class="s4">))</span>
    <span class="s3">yield</span>
    <span class="s3">if </span><span class="s1">attr</span><span class="s4">:</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">close_scope</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">prefix_attr</span><span class="s4">=</span><span class="s1">attr </span><span class="s4">+ </span><span class="s5">'_prefix'</span><span class="s4">,</span>
                       <span class="s1">suffix_attr</span><span class="s4">=</span><span class="s1">attr </span><span class="s4">+ </span><span class="s5">'_suffix'</span><span class="s4">,</span>
                       <span class="s1">trailing_comma</span><span class="s4">=</span><span class="s1">trailing_comma</span><span class="s4">,</span>
                       <span class="s1">single_paren</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">close_scope</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">trailing_comma</span><span class="s4">=</span><span class="s1">trailing_comma</span><span class="s4">)</span>

  <span class="s3">def </span><span class="s1">is_in_scope</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Return True iff there is a scope open.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parens </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hints</span>

  <span class="s3">def </span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a full string literal from the input.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">predicate</span><span class="s4">(</span><span class="s1">token</span><span class="s4">):</span>
      <span class="s3">return </span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s4">(</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">STRING</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">COMMENT</span><span class="s4">) </span><span class="s3">or</span>
              <span class="s1">self</span><span class="s4">.</span><span class="s1">is_in_scope</span><span class="s4">() </span><span class="s3">and </span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s3">in </span><span class="s4">(</span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NL</span><span class="s4">, </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NEWLINE</span><span class="s4">))</span>

    <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">eat_tokens</span><span class="s4">(</span><span class="s1">predicate</span><span class="s4">)</span>

  <span class="s3">def </span><span class="s1">eat_tokens</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">predicate</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse input from tokens while a given condition is met.&quot;&quot;&quot;</span>
    <span class="s1">content </span><span class="s4">= </span><span class="s5">''</span>
    <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
    <span class="s1">tok </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s1">predicate</span><span class="s4">, </span><span class="s1">advance</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
      <span class="s1">content </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">prev_loc</span><span class="s4">, </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>
      <span class="s1">content </span><span class="s4">+= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src</span>
      <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">end</span>

    <span class="s3">if </span><span class="s1">tok</span><span class="s4">:</span>
      <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">end</span>
    <span class="s3">return </span><span class="s1">content</span>

  <span class="s3">def </span><span class="s1">fstr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parses an fstring, including subexpressions. 
 
    Returns: 
      A generator function which, when repeatedly reads a chunk of the fstring 
      up until the next subexpression and yields that chunk, plus a new token 
      generator to use to parse the subexpression. The subexpressions in the 
      original fstring data are replaced by placeholders to make it possible to 
      fill them in with new values, if desired. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">fstr_parser</span><span class="s4">():</span>
      <span class="s0"># Reads the whole fstring as a string, then parses it char by char</span>
      <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">peek_non_whitespace</span><span class="s4">().</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">STRING</span><span class="s4">:</span>
        <span class="s0"># Normal fstrings are one ore more STRING tokens, maybe mixed with</span>
        <span class="s0"># spaces, e.g.: f&quot;Hello, {name}&quot;</span>
        <span class="s1">str_content </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">str</span><span class="s4">()</span>
      <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># Format specifiers in fstrings are also JoinedStr nodes, but these are</span>
        <span class="s0"># arbitrary expressions, e.g. in: f&quot;{value:{width}.{precision}}&quot;, the</span>
        <span class="s0"># format specifier is an fstring: &quot;{width}.{precision}&quot; but these are</span>
        <span class="s0"># not STRING tokens.</span>
        <span class="s3">def </span><span class="s1">fstr_eater</span><span class="s4">(</span><span class="s1">tok</span><span class="s4">):</span>
          <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">OP </span><span class="s3">and </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">'}'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">fstr_eater</span><span class="s4">.</span><span class="s1">level </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">:</span>
              <span class="s3">return False</span>
            <span class="s1">fstr_eater</span><span class="s4">.</span><span class="s1">level </span><span class="s4">-= </span><span class="s6">1</span>
          <span class="s3">if </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">type </span><span class="s4">== </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">OP </span><span class="s3">and </span><span class="s1">tok</span><span class="s4">.</span><span class="s1">src </span><span class="s4">== </span><span class="s5">'{'</span><span class="s4">:</span>
            <span class="s1">fstr_eater</span><span class="s4">.</span><span class="s1">level </span><span class="s4">+= </span><span class="s6">1</span>
          <span class="s3">return True</span>
        <span class="s1">fstr_eater</span><span class="s4">.</span><span class="s1">level </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">str_content </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">eat_tokens</span><span class="s4">(</span><span class="s1">fstr_eater</span><span class="s4">)</span>

      <span class="s1">indexed_chars </span><span class="s4">= </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">str_content</span><span class="s4">)</span>
      <span class="s1">val_idx </span><span class="s4">= </span><span class="s6">0</span>
      <span class="s1">i </span><span class="s4">= -</span><span class="s6">1</span>
      <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>
      <span class="s3">while </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">str_content</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">i</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">indexed_chars</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">+= </span><span class="s1">c</span>

        <span class="s0"># When an open bracket is encountered, start parsing a subexpression</span>
        <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">'{'</span><span class="s4">:</span>
          <span class="s0"># First check if this is part of an escape sequence</span>
          <span class="s0"># (f&quot;{{&quot; is used to escape a bracket literal)</span>
          <span class="s1">nexti</span><span class="s4">, </span><span class="s1">nextc </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">indexed_chars</span><span class="s4">)</span>
          <span class="s3">if </span><span class="s1">nextc </span><span class="s4">== </span><span class="s5">'{'</span><span class="s4">:</span>
            <span class="s1">result </span><span class="s4">+= </span><span class="s1">c</span>
            <span class="s3">continue</span>
          <span class="s1">indexed_chars </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">([(</span><span class="s1">nexti</span><span class="s4">, </span><span class="s1">nextc</span><span class="s4">)], </span><span class="s1">indexed_chars</span><span class="s4">)</span>

          <span class="s0"># Add a placeholder onto the result</span>
          <span class="s1">result </span><span class="s4">+= </span><span class="s1">fstring_utils</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">(</span><span class="s1">val_idx</span><span class="s4">) + </span><span class="s5">'}'</span>
          <span class="s1">val_idx </span><span class="s4">+= </span><span class="s6">1</span>

          <span class="s0"># Yield a new token generator to parse the subexpression only</span>
          <span class="s1">tg </span><span class="s4">= </span><span class="s1">TokenGenerator</span><span class="s4">(</span><span class="s1">str_content</span><span class="s4">[</span><span class="s1">i</span><span class="s4">+</span><span class="s6">1</span><span class="s4">:], </span><span class="s1">ignore_error_token</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
          <span class="s3">yield </span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">tg</span><span class="s4">)</span>
          <span class="s1">result </span><span class="s4">= </span><span class="s5">''</span>

          <span class="s0"># Skip the number of characters consumed by the subexpression</span>
          <span class="s3">for </span><span class="s1">tg_i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">tg</span><span class="s4">.</span><span class="s1">chars_consumed</span><span class="s4">()):</span>
            <span class="s1">i</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">indexed_chars</span><span class="s4">)</span>

          <span class="s0"># Eat up to and including the close bracket</span>
          <span class="s1">i</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">indexed_chars</span><span class="s4">)</span>
          <span class="s3">while </span><span class="s1">c </span><span class="s4">!= </span><span class="s5">'}'</span><span class="s4">:</span>
            <span class="s1">i</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">indexed_chars</span><span class="s4">)</span>
      <span class="s0"># Yield the rest of the fstring, when done</span>
      <span class="s3">yield </span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">fstr_parser</span>

  <span class="s3">def </span><span class="s1">_space_between</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">start_loc</span><span class="s4">, </span><span class="s1">end_loc</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse the space between a location and the next token&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">start_loc </span><span class="s4">&gt; </span><span class="s1">end_loc</span><span class="s4">:</span>
      <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'start_loc &gt; end_loc'</span><span class="s4">, </span><span class="s1">start_loc</span><span class="s4">, </span><span class="s1">end_loc</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">start_loc</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &gt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">):</span>
      <span class="s3">return </span><span class="s5">''</span>

    <span class="s1">prev_row</span><span class="s4">, </span><span class="s1">prev_col </span><span class="s4">= </span><span class="s1">start_loc</span>
    <span class="s1">end_row</span><span class="s4">, </span><span class="s1">end_col </span><span class="s4">= </span><span class="s1">end_loc</span>
    <span class="s3">if </span><span class="s1">prev_row </span><span class="s4">== </span><span class="s1">end_row</span><span class="s4">:</span>
      <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">[</span><span class="s1">prev_row </span><span class="s4">- </span><span class="s6">1</span><span class="s4">][</span><span class="s1">prev_col</span><span class="s4">:</span><span class="s1">end_col</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s5">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">[</span><span class="s1">prev_row </span><span class="s4">- </span><span class="s6">1</span><span class="s4">][</span><span class="s1">prev_col</span><span class="s4">:],),</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">[</span><span class="s1">prev_row</span><span class="s4">:</span><span class="s1">end_row </span><span class="s4">- </span><span class="s6">1</span><span class="s4">],</span>
        <span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">[</span><span class="s1">end_row </span><span class="s4">- </span><span class="s6">1</span><span class="s4">][:</span><span class="s1">end_col</span><span class="s4">],) </span><span class="s3">if </span><span class="s1">end_col </span><span class="s4">&gt; </span><span class="s6">0 </span><span class="s3">else </span><span class="s5">''</span><span class="s4">,</span>
    <span class="s4">))</span>

  <span class="s3">def </span><span class="s1">next_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse the next name token.&quot;&quot;&quot;</span>
    <span class="s1">last_i </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_i</span>
    <span class="s3">def </span><span class="s1">predicate</span><span class="s4">(</span><span class="s1">token</span><span class="s4">):</span>
      <span class="s3">return </span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s4">!= </span><span class="s1">TOKENS</span><span class="s4">.</span><span class="s1">NAME</span>

    <span class="s1">unused_tokens </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">takewhile</span><span class="s4">(</span><span class="s1">predicate</span><span class="s4">, </span><span class="s1">advance</span><span class="s4">=</span><span class="s3">False</span><span class="s4">))</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">(</span><span class="s1">advance</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_i </span><span class="s4">= </span><span class="s1">last_i</span>
    <span class="s3">return </span><span class="s1">result</span>

  <span class="s3">def </span><span class="s1">next_of_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">token_type</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a token of the given type and return it.&quot;&quot;&quot;</span>
    <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">token</span><span class="s4">.</span><span class="s1">type </span><span class="s4">!= </span><span class="s1">token_type</span><span class="s4">:</span>
      <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Expected %r but found %r</span><span class="s3">\n</span><span class="s5">line %d: %s&quot; </span><span class="s4">% (</span>
          <span class="s1">tokenize</span><span class="s4">.</span><span class="s1">tok_name</span><span class="s4">[</span><span class="s1">token_type</span><span class="s4">], </span><span class="s1">token</span><span class="s4">.</span><span class="s1">src</span><span class="s4">, </span><span class="s1">token</span><span class="s4">.</span><span class="s1">start</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
          <span class="s1">self</span><span class="s4">.</span><span class="s1">lines</span><span class="s4">[</span><span class="s1">token</span><span class="s4">.</span><span class="s1">start</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">]))</span>
    <span class="s3">return </span><span class="s1">token</span>

  <span class="s3">def </span><span class="s1">takewhile</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">condition</span><span class="s4">, </span><span class="s1">advance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse tokens as long as a condition holds on the next token.&quot;&quot;&quot;</span>
    <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
    <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">(</span><span class="s1">advance</span><span class="s4">=</span><span class="s1">advance</span><span class="s4">)</span>
    <span class="s3">while </span><span class="s1">token </span><span class="s3">is not None and </span><span class="s1">condition</span><span class="s4">(</span><span class="s1">token</span><span class="s4">):</span>
      <span class="s3">yield </span><span class="s1">token</span>
      <span class="s1">prev_loc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loc</span>
      <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">next</span><span class="s4">(</span><span class="s1">advance</span><span class="s4">=</span><span class="s1">advance</span><span class="s4">)</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">rewind</span><span class="s4">()</span>
    <span class="s1">self</span><span class="s4">.</span><span class="s1">_loc </span><span class="s4">= </span><span class="s1">prev_loc</span>


<span class="s3">def </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">):</span>
  <span class="s2">&quot;&quot;&quot;Get the closure of nodes that could begin a scope at this point. 
 
  For instance, when encountering a `(` when parsing a BinOp node, this could 
  indicate that the BinOp itself is parenthesized OR that the BinOp's left node 
  could be parenthesized. 
 
  E.g.: (a + b * c)   or   (a + b) * c   or   (a) + b * c 
        ^                  ^                  ^ 
 
  Arguments: 
    node: (ast.AST) Node encountered when opening a scope. 
 
  Returns: 
    A closure of nodes which that scope might apply to. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Attribute</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Subscript</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Assign</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">targets</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">AugAssign</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">target</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Expr</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Compare</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">left</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">BoolOp</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">values</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">BinOp</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">left</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Tuple</span><span class="s4">) </span><span class="s3">and </span><span class="s1">node</span><span class="s4">.</span><span class="s1">elts</span><span class="s4">:</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">elts</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">Call</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">func</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">GeneratorExp</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">elt</span><span class="s4">)</span>
  <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ast</span><span class="s4">.</span><span class="s1">IfExp</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,) + </span><span class="s1">_scope_helper</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">body</span><span class="s4">)</span>
  <span class="s3">return </span><span class="s4">(</span><span class="s1">node</span><span class="s4">,)</span>
   

<span class="s3">def </span><span class="s1">_generate_tokens</span><span class="s4">(</span><span class="s1">source</span><span class="s4">, </span><span class="s1">ignore_error_token</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
  <span class="s1">token_generator </span><span class="s4">= </span><span class="s1">tokenize</span><span class="s4">.</span><span class="s1">generate_tokens</span><span class="s4">(</span><span class="s1">StringIO</span><span class="s4">(</span><span class="s1">source</span><span class="s4">).</span><span class="s1">readline</span><span class="s4">)</span>
  <span class="s3">try</span><span class="s4">:</span>
    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">token_generator</span><span class="s4">:</span>
      <span class="s3">yield </span><span class="s1">Token</span><span class="s4">(*</span><span class="s1">tok</span><span class="s4">) </span>
  <span class="s3">except </span><span class="s1">tokenize</span><span class="s4">.</span><span class="s1">TokenError</span><span class="s4">:</span>
    <span class="s3">if not </span><span class="s1">ignore_error_token</span><span class="s4">:</span>
      <span class="s3">raise</span>
</pre>
</body>
</html>