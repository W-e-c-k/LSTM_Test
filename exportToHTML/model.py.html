<html>
<head>
<title>model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
model.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">layer </span><span class="s0">import </span><span class="s1">Layer</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models</span><span class="s2">.</span><span class="s1">variable_mapping </span><span class="s0">import </span><span class="s1">map_saveable_variables</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">saving_api</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">trainers </span><span class="s0">import </span><span class="s1">trainer </span><span class="s0">as </span><span class="s1">base_trainer</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">summary_utils</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">traceback_utils</span>

<span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s3">&quot;tensorflow&quot;</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">tensorflow</span><span class="s2">.</span><span class="s1">trainer </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">TensorFlowTrainer </span><span class="s0">as </span><span class="s1">Trainer</span><span class="s2">,</span>
    <span class="s2">)</span>
<span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s3">&quot;jax&quot;</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">jax</span><span class="s2">.</span><span class="s1">trainer </span><span class="s0">import </span><span class="s1">JAXTrainer </span><span class="s0">as </span><span class="s1">Trainer</span>
<span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s3">&quot;torch&quot;</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">torch</span><span class="s2">.</span><span class="s1">trainer </span><span class="s0">import </span><span class="s1">TorchTrainer </span><span class="s0">as </span><span class="s1">Trainer</span>
<span class="s0">elif </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">() == </span><span class="s3">&quot;numpy&quot;</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">trainer </span><span class="s0">import </span><span class="s1">NumpyTrainer </span><span class="s0">as </span><span class="s1">Trainer</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
        <span class="s3">f&quot;Backend '</span><span class="s0">{</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">backend</span><span class="s2">()</span><span class="s0">}</span><span class="s3">' must implement the Trainer class.&quot;</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">([</span><span class="s3">&quot;keras.Model&quot;</span><span class="s2">, </span><span class="s3">&quot;keras.models.Model&quot;</span><span class="s2">])</span>
<span class="s0">class </span><span class="s1">Model</span><span class="s2">(</span><span class="s1">Trainer</span><span class="s2">, </span><span class="s1">base_trainer</span><span class="s2">.</span><span class="s1">Trainer</span><span class="s2">, </span><span class="s1">Layer</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;A model grouping layers into an object with training/inference features. 
 
    There are three ways to instantiate a `Model`: 
 
    ## With the &quot;Functional API&quot; 
 
    You start from `Input`, 
    you chain layer calls to specify the model's forward pass, 
    and finally, you create your model from inputs and outputs: 
 
    ```python 
    inputs = keras.Input(shape=(37,)) 
    x = keras.layers.Dense(32, activation=&quot;relu&quot;)(inputs) 
    outputs = keras.layers.Dense(5, activation=&quot;softmax&quot;)(x) 
    model = keras.Model(inputs=inputs, outputs=outputs) 
    ``` 
 
    Note: Only dicts, lists, and tuples of input tensors are supported. Nested 
    inputs are not supported (e.g. lists of list or dicts of dict). 
 
    A new Functional API model can also be created by using the 
    intermediate tensors. This enables you to quickly extract sub-components 
    of the model. 
 
    Example: 
 
    ```python 
    inputs = keras.Input(shape=(None, None, 3)) 
    processed = keras.layers.RandomCrop(width=128, height=128)(inputs) 
    conv = keras.layers.Conv2D(filters=32, kernel_size=3)(processed) 
    pooling = keras.layers.GlobalAveragePooling2D()(conv) 
    feature = keras.layers.Dense(10)(pooling) 
 
    full_model = keras.Model(inputs, feature) 
    backbone = keras.Model(processed, conv) 
    activations = keras.Model(conv, feature) 
    ``` 
 
    Note that the `backbone` and `activations` models are not 
    created with `keras.Input` objects, but with the tensors that originate 
    from `keras.Input` objects. Under the hood, the layers and weights will 
    be shared across these models, so that user can train the `full_model`, and 
    use `backbone` or `activations` to do feature extraction. 
    The inputs and outputs of the model can be nested structures of tensors as 
    well, and the created models are standard Functional API models that support 
    all the existing APIs. 
 
    ## By subclassing the `Model` class 
 
    In that case, you should define your 
    layers in `__init__()` and you should implement the model's forward pass 
    in `call()`. 
 
    ```python 
    class MyModel(keras.Model): 
        def __init__(self): 
            super().__init__() 
            self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;) 
            self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;) 
 
        def call(self, inputs): 
            x = self.dense1(inputs) 
            return self.dense2(x) 
 
    model = MyModel() 
    ``` 
 
    If you subclass `Model`, you can optionally have 
    a `training` argument (boolean) in `call()`, which you can use to specify 
    a different behavior in training and inference: 
 
    ```python 
    class MyModel(keras.Model): 
        def __init__(self): 
            super().__init__() 
            self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;) 
            self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;) 
            self.dropout = keras.layers.Dropout(0.5) 
 
        def call(self, inputs, training=False): 
            x = self.dense1(inputs) 
            x = self.dropout(x, training=training) 
            return self.dense2(x) 
 
    model = MyModel() 
    ``` 
 
    Once the model is created, you can config the model with losses and metrics 
    with `model.compile()`, train the model with `model.fit()`, or use the model 
    to do prediction with `model.predict()`. 
 
    ## With the `Sequential` class 
 
    In addition, `keras.Sequential` is a special case of model where 
    the model is purely a stack of single-input, single-output layers. 
 
    ```python 
    model = keras.Sequential([ 
        keras.Input(shape=(None, None, 3)), 
        keras.layers.Conv2D(filters=32, kernel_size=3), 
    ]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s5"># Signature detection for usage of `Model` as a `Functional`</span>
        <span class="s0">if </span><span class="s1">functional_init_arguments</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">) </span><span class="s0">and </span><span class="s1">cls </span><span class="s2">== </span><span class="s1">Model</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models</span><span class="s2">.</span><span class="s1">functional </span><span class="s0">import </span><span class="s1">Functional</span>

            <span class="s0">return </span><span class="s1">Functional</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">Functional</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Model</span><span class="s2">, </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">Trainer</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models </span><span class="s0">import </span><span class="s1">functional</span>

        <span class="s5"># Signature detection for usage of a `Model` subclass</span>
        <span class="s5"># as a `Functional` subclass</span>
        <span class="s0">if </span><span class="s1">functional_init_arguments</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">inject_functional_model_class</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">)</span>
            <span class="s1">functional</span><span class="s2">.</span><span class="s1">Functional</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">Layer</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
            <span class="s3">f&quot;Model </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s3">does not have a `call()` &quot;</span>
            <span class="s3">&quot;method implemented.&quot;</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">layers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_flatten_layers</span><span class="s2">(</span><span class="s1">include_self</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">recursive</span><span class="s2">=</span><span class="s0">False</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s0">def </span><span class="s1">layers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">_</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span>
            <span class="s3">&quot;`Model.layers` attribute is reserved and should not be used. &quot;</span>
            <span class="s3">&quot;Please use another name.&quot;</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">filter_traceback</span>
    <span class="s0">def </span><span class="s1">get_layer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Retrieves a layer based on either its name (unique) or index. 
 
        If `name` and `index` are both provided, `index` will take precedence. 
        Indices are based on order of horizontal graph traversal (bottom-up). 
 
        Args: 
            name: String, name of layer. 
            index: Integer, index of layer. 
 
        Returns: 
            A layer instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None and </span><span class="s1">name </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Provide only a layer name or a layer index. Received: &quot;</span>
                <span class="s3">f&quot;index=</span><span class="s0">{</span><span class="s1">index</span><span class="s0">}</span><span class="s3">, name=</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">) &lt;= </span><span class="s1">index</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">f&quot;Was asked to retrieve layer at index </span><span class="s0">{</span><span class="s1">index</span><span class="s0">}</span><span class="s3">&quot;</span>
                    <span class="s3">f&quot; but model only has </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span>
                    <span class="s3">&quot; layers.&quot;</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">[</span><span class="s1">index</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">layer</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s1">name</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">layer</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">f&quot;No such layer: </span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">. Existing layers are: &quot;</span>
                <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">list</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">.</span><span class="s1">name </span><span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">)</span><span class="s0">}</span><span class="s3">.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;Provide either a layer name or layer index at `get_layer`.&quot;</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">filter_traceback</span>
    <span class="s0">def </span><span class="s1">summary</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">line_length</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">positions</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">print_fn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">expand_nested</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">show_trainable</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">layer_range</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Prints a string summary of the network. 
 
        Args: 
            line_length: Total length of printed lines 
                (e.g. set this to adapt the display to different 
                terminal window sizes). 
            positions: Relative or absolute positions of log elements 
                in each line. If not provided, becomes 
                `[0.3, 0.6, 0.70, 1.]`. Defaults to `None`. 
            print_fn: Print function to use. By default, prints to `stdout`. 
                If `stdout` doesn't work in your environment, change to `print`. 
                It will be called on each line of the summary. 
                You can set it to a custom function 
                in order to capture the string summary. 
            expand_nested: Whether to expand the nested models. 
                Defaults to `False`. 
            show_trainable: Whether to show if a layer is trainable. 
                Defaults to `False`. 
            layer_range: a list or tuple of 2 strings, 
                which is the starting layer name and ending layer name 
                (both inclusive) indicating the range of layers to be printed 
                in summary. It also accepts regex patterns instead of exact 
                names. In this case, the start predicate will be 
                the first element that matches `layer_range[0]` 
                and the end predicate will be the last element 
                that matches `layer_range[1]`. 
                By default `None` considers all layers of the model. 
 
        Raises: 
            ValueError: if `summary()` is called before the model is built. 
        &quot;&quot;&quot;</span>
        <span class="s1">summary_utils</span><span class="s2">.</span><span class="s1">print_summary</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">line_length</span><span class="s2">=</span><span class="s1">line_length</span><span class="s2">,</span>
            <span class="s1">positions</span><span class="s2">=</span><span class="s1">positions</span><span class="s2">,</span>
            <span class="s1">print_fn</span><span class="s2">=</span><span class="s1">print_fn</span><span class="s2">,</span>
            <span class="s1">expand_nested</span><span class="s2">=</span><span class="s1">expand_nested</span><span class="s2">,</span>
            <span class="s1">show_trainable</span><span class="s2">=</span><span class="s1">show_trainable</span><span class="s2">,</span>
            <span class="s1">layer_range</span><span class="s2">=</span><span class="s1">layer_range</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">filter_traceback</span>
    <span class="s0">def </span><span class="s1">save</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">zipped</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Saves a model as a `.keras` file. 
 
        Args: 
            filepath: `str` or `pathlib.Path` object. 
                The path where to save the model. Must end in `.keras` 
                (unless saving the model as an unzipped directory 
                via `zipped=False`). 
            overwrite: Whether we should overwrite any existing model at 
                the target location, or instead ask the user via 
                an interactive prompt. 
            zipped: Whether to save the model as a zipped `.keras` 
                archive (default when saving locally), or as an 
                unzipped directory (default when saving on the 
                Hugging Face Hub). 
 
        Example: 
 
        ```python 
        model = keras.Sequential( 
            [ 
                keras.layers.Dense(5, input_shape=(3,)), 
                keras.layers.Softmax(), 
            ], 
        ) 
        model.save(&quot;model.keras&quot;) 
        loaded_model = keras.saving.load_model(&quot;model.keras&quot;) 
        x = keras.random.uniform((10, 3)) 
        assert np.allclose(model.predict(x), loaded_model.predict(x)) 
        ``` 
 
        Note that `model.save()` is an alias for `keras.saving.save_model()`. 
 
        The saved `.keras` file contains: 
 
        - The model's configuration (architecture) 
        - The model's weights 
        - The model's optimizer's state (if any) 
 
        Thus models can be reinstantiated in the exact same state. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">saving_api</span><span class="s2">.</span><span class="s1">save_model</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s1">overwrite</span><span class="s2">, </span><span class="s1">zipped</span><span class="s2">=</span><span class="s1">zipped</span><span class="s2">, **</span><span class="s1">kwargs</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">filter_traceback</span>
    <span class="s0">def </span><span class="s1">save_weights</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Saves all layer weights to a `.weights.h5` file. 
 
        Args: 
            filepath: `str` or `pathlib.Path` object. 
                Path where to save the model. Must end in `.weights.h5`. 
            overwrite: Whether we should overwrite any existing model 
                at the target location, or instead ask the user 
                via an interactive prompt. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">saving_api</span><span class="s2">.</span><span class="s1">save_weights</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s1">overwrite</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">traceback_utils</span><span class="s2">.</span><span class="s1">filter_traceback</span>
    <span class="s0">def </span><span class="s1">load_weights</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">skip_mismatch</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Load weights from a file saved via `save_weights()`. 
 
        Weights are loaded based on the network's 
        topology. This means the architecture should be the same as when the 
        weights were saved. Note that layers that don't have weights are not 
        taken into account in the topological ordering, so adding or removing 
        layers is fine as long as they don't have weights. 
 
        **Partial weight loading** 
 
        If you have modified your model, for instance by adding a new layer 
        (with weights) or by changing the shape of the weights of a layer, 
        you can choose to ignore errors and continue loading 
        by setting `skip_mismatch=True`. In this case any layer with 
        mismatching weights will be skipped. A warning will be displayed 
        for each skipped layer. 
 
        Args: 
            filepath: String, path to the weights file to load. 
                It can either be a `.weights.h5` file 
                or a legacy `.h5` weights file. 
            skip_mismatch: Boolean, whether to skip loading of layers where 
                there is a mismatch in the number of weights, or a mismatch in 
                the shape of the weights. 
        &quot;&quot;&quot;</span>
        <span class="s1">saving_api</span><span class="s2">.</span><span class="s1">load_weights</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">skip_mismatch</span><span class="s2">=</span><span class="s1">skip_mismatch</span><span class="s2">, **</span><span class="s1">kwargs</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">quantize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Quantize the weights of the model. 
 
        Note that the model must be built first before calling this method. 
        `quantize` will recursively call `quantize(mode)` in all layers and 
        will be skipped if the layer doesn't implement the function. 
 
        Args: 
            mode: The mode of the quantization. Only 'int8' is supported at this 
                time. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">dtype_policies </span><span class="s0">import </span><span class="s1">QUANTIZATION_MODES</span>

        <span class="s1">type_check </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">&quot;type_check&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Unrecognized keyword arguments &quot;</span>
                <span class="s3">f&quot;passed to </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">kwargs</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">mode </span><span class="s0">not in </span><span class="s1">QUANTIZATION_MODES</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Invalid quantization mode. &quot;</span>
                <span class="s3">f&quot;Expected one of </span><span class="s0">{</span><span class="s1">QUANTIZATION_MODES</span><span class="s0">}</span><span class="s3">. Received: mode=</span><span class="s0">{</span><span class="s1">mode</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>
        <span class="s1">mode_changed </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_flatten_layers</span><span class="s2">():</span>
            <span class="s1">list_of_sublayers </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">layer</span><span class="s2">.</span><span class="s1">_flatten_layers</span><span class="s2">())</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">list_of_sublayers</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:  </span><span class="s5"># leaves of the model</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">layer</span><span class="s2">.</span><span class="s1">quantize</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">, </span><span class="s1">type_check</span><span class="s2">=</span><span class="s1">type_check</span><span class="s2">)</span>
                    <span class="s1">mode_changed </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">except </span><span class="s1">NotImplementedError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">))</span>
        <span class="s5"># We need to set these functions to `None` to remake them for changed</span>
        <span class="s5"># call function</span>
        <span class="s0">if </span><span class="s1">mode_changed</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">train_function </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">test_function </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">predict_function </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">build_from_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">config</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">config</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s3">&quot;input_shape&quot; </span><span class="s0">in </span><span class="s1">config</span><span class="s2">:</span>
            <span class="s5"># Case: all inputs are in the first arg (possibly nested).</span>
            <span class="s0">if </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">is_default</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">build</span><span class="s2">):</span>
                <span class="s1">status </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_build_by_run_for_single_pos_arg</span><span class="s2">(</span>
                    <span class="s1">config</span><span class="s2">[</span><span class="s3">&quot;input_shape&quot;</span><span class="s2">]</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">config</span><span class="s2">[</span><span class="s3">&quot;input_shape&quot;</span><span class="s2">])</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">except</span><span class="s2">:</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_build_shapes_dict </span><span class="s2">= </span><span class="s1">config</span>

        <span class="s0">elif </span><span class="s3">&quot;shapes_dict&quot; </span><span class="s0">in </span><span class="s1">config</span><span class="s2">:</span>
            <span class="s5"># Case: inputs were recorded as multiple keyword arguments.</span>
            <span class="s0">if </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">is_default</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">build</span><span class="s2">):</span>
                <span class="s1">status </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_build_by_run_for_kwargs</span><span class="s2">(</span><span class="s1">config</span><span class="s2">[</span><span class="s3">&quot;shapes_dict&quot;</span><span class="s2">])</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(**</span><span class="s1">config</span><span class="s2">[</span><span class="s3">&quot;shapes_dict&quot;</span><span class="s2">])</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">except</span><span class="s2">:</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_build_shapes_dict </span><span class="s2">= </span><span class="s1">config</span><span class="s2">[</span><span class="s3">&quot;shapes_dict&quot;</span><span class="s2">]</span>

        <span class="s0">if not </span><span class="s1">status</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s3">f&quot;Model '</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">' had a build config, but the model &quot;</span>
                <span class="s3">&quot;cannot be built automatically in &quot;</span>
                <span class="s3">&quot;`build_from_config(config)`. &quot;</span>
                <span class="s3">&quot;You should implement &quot;</span>
                <span class="s3">&quot;`def build_from_config(self, config)`, &quot;</span>
                <span class="s3">&quot;and you might also want to implement the method &quot;</span>
                <span class="s3">&quot; that generates the config at saving time, &quot;</span>
                <span class="s3">&quot;`def get_build_config(self)`. &quot;</span>
                <span class="s3">&quot;The method `build_from_config()` is meant to &quot;</span>
                <span class="s3">&quot;create the state of the model (i.e. its variables) &quot;</span>
                <span class="s3">&quot;upon deserialization.&quot;</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">,</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">to_json</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns a JSON string containing the network configuration. 
 
        To load a network from a JSON save file, use 
        `keras.models.model_from_json(json_string, custom_objects={...})`. 
 
        Args: 
            **kwargs: Additional keyword arguments to be passed to 
                `json.dumps()`. 
 
        Returns: 
            A JSON string. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">serialization_lib</span>

        <span class="s1">model_config </span><span class="s2">= </span><span class="s1">serialization_lib</span><span class="s2">.</span><span class="s1">serialize_keras_object</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">json</span><span class="s2">.</span><span class="s1">dumps</span><span class="s2">(</span><span class="s1">model_config</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">export</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">&quot;tf_saved_model&quot;</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Create a TF SavedModel artifact for inference. 
 
        **Note:** This can currently only be used with 
        the TensorFlow or JAX backends. 
 
        This method lets you export a model to a lightweight SavedModel artifact 
        that contains the model's forward pass only (its `call()` method) 
        and can be served via e.g. TF-Serving. The forward pass is registered 
        under the name `serve()` (see example below). 
 
        The original code of the model (including any custom layers you may 
        have used) is *no longer* necessary to reload the artifact -- it is 
        entirely standalone. 
 
        Args: 
            filepath: `str` or `pathlib.Path` object. Path where to save 
                the artifact. 
 
        Example: 
 
        ```python 
        # Create the artifact 
        model.export(&quot;path/to/location&quot;) 
 
        # Later, in a different process/environment... 
        reloaded_artifact = tf.saved_model.load(&quot;path/to/location&quot;) 
        predictions = reloaded_artifact.serve(input_data) 
        ``` 
 
        If you would like to customize your serving endpoints, you can 
        use the lower-level `keras.export.ExportArchive` class. The 
        `export()` method relies on `ExportArchive` internally. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">export </span><span class="s0">import </span><span class="s1">export_lib</span>

        <span class="s1">export_lib</span><span class="s2">.</span><span class="s1">export_model</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_config</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models</span><span class="s2">.</span><span class="s1">functional </span><span class="s0">import </span><span class="s1">Functional</span>

        <span class="s1">functional_config_keys </span><span class="s2">= [</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;layers&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;input_layers&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;output_layers&quot;</span><span class="s2">,</span>
        <span class="s2">]</span>
        <span class="s1">is_functional_config </span><span class="s2">= </span><span class="s1">all</span><span class="s2">(</span>
            <span class="s1">key </span><span class="s0">in </span><span class="s1">config </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">functional_config_keys</span>
        <span class="s2">)</span>
        <span class="s1">argspec </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getfullargspec</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">)</span>
        <span class="s1">functional_init_args </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getfullargspec</span><span class="s2">(</span><span class="s1">Functional</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">).</span><span class="s1">args</span><span class="s2">[</span>
            <span class="s6">1</span><span class="s2">:</span>
        <span class="s2">]</span>
        <span class="s1">revivable_as_functional </span><span class="s2">= (</span>
            <span class="s1">cls </span><span class="s0">in </span><span class="s2">{</span><span class="s1">Functional</span><span class="s2">, </span><span class="s1">Model</span><span class="s2">}</span>
            <span class="s0">or </span><span class="s1">argspec</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:] == </span><span class="s1">functional_init_args</span>
            <span class="s0">or </span><span class="s2">(</span><span class="s1">argspec</span><span class="s2">.</span><span class="s1">varargs </span><span class="s2">== </span><span class="s3">&quot;args&quot; </span><span class="s0">and </span><span class="s1">argspec</span><span class="s2">.</span><span class="s1">varkw </span><span class="s2">== </span><span class="s3">&quot;kwargs&quot;</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">is_functional_config </span><span class="s0">and </span><span class="s1">revivable_as_functional</span><span class="s2">:</span>
            <span class="s5"># Revive Functional model</span>
            <span class="s5"># (but not Functional subclasses with a custom __init__)</span>
            <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models</span><span class="s2">.</span><span class="s1">functional </span><span class="s0">import </span><span class="s1">functional_from_config</span>

            <span class="s0">return </span><span class="s1">functional_from_config</span><span class="s2">(</span>
                <span class="s1">cls</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">=</span><span class="s1">custom_objects</span>
            <span class="s2">)</span>

        <span class="s5"># Either the model has a custom __init__, or the config</span>
        <span class="s5"># does not contain all the information necessary to</span>
        <span class="s5"># revive a Functional model. This happens when the user creates</span>
        <span class="s5"># subclassed models where `get_config()` is returning</span>
        <span class="s5"># insufficient information to be considered a Functional model.</span>
        <span class="s5"># In this case, we fall back to provide all config into the</span>
        <span class="s5"># constructor of the class.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">cls</span><span class="s2">(**</span><span class="s1">config</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s3">&quot;Unable to revive model from config. When overriding &quot;</span>
                <span class="s3">&quot;the `get_config()` method, make sure that the &quot;</span>
                <span class="s3">&quot;returned config contains all items used as arguments &quot;</span>
                <span class="s3">f&quot;in the  constructor to </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s3">, &quot;</span>
                <span class="s3">&quot;which is the default behavior. &quot;</span>
                <span class="s3">&quot;You can override this default behavior by defining a &quot;</span>
                <span class="s3">&quot;`from_config(cls, config)` class method to specify &quot;</span>
                <span class="s3">&quot;how to create an &quot;</span>
                <span class="s3">f&quot;instance of </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s3">from its config.</span><span class="s0">\n\n</span><span class="s3">&quot;</span>
                <span class="s3">f&quot;Received config=</span><span class="s0">{</span><span class="s1">config</span><span class="s0">}\n\n</span><span class="s3">&quot;</span>
                <span class="s3">f&quot;Error encountered during deserialization: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_variable_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">store </span><span class="s2">= {}</span>
        <span class="s1">map_saveable_variables</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">store</span><span class="s2">=</span><span class="s1">store</span><span class="s2">, </span><span class="s1">visited_saveables</span><span class="s2">=</span><span class="s1">set</span><span class="s2">())</span>
        <span class="s0">return </span><span class="s1">store</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.models.model_from_json&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">model_from_json</span><span class="s2">(</span><span class="s1">json_string</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Parses a JSON model configuration string and returns a model instance. 
 
    Example: 
 
    &gt;&gt;&gt; model = keras.Sequential([ 
    ...     keras.layers.Dense(5, input_shape=(3,)), 
    ...     keras.layers.Softmax()]) 
    &gt;&gt;&gt; config = model.to_json() 
    &gt;&gt;&gt; loaded_model = keras.models.model_from_json(config) 
 
    Args: 
        json_string: JSON string encoding a model configuration. 
        custom_objects: Optional dictionary mapping names 
            (strings) to custom classes or functions to be 
            considered during deserialization. 
 
    Returns: 
        A Keras model instance (uncompiled). 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">serialization_lib</span>

    <span class="s1">model_config </span><span class="s2">= </span><span class="s1">json</span><span class="s2">.</span><span class="s1">loads</span><span class="s2">(</span><span class="s1">json_string</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">serialization_lib</span><span class="s2">.</span><span class="s1">deserialize_keras_object</span><span class="s2">(</span>
        <span class="s1">model_config</span><span class="s2">, </span><span class="s1">custom_objects</span><span class="s2">=</span><span class="s1">custom_objects</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">functional_init_arguments</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">)</span>
        <span class="s0">or </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1 </span><span class="s0">and </span><span class="s3">&quot;outputs&quot; </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">or </span><span class="s2">(</span><span class="s3">&quot;inputs&quot; </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s3">&quot;outputs&quot; </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">inject_functional_model_class</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Inject `Functional` into the hierarchy of this class if needed.&quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">models </span><span class="s0">import </span><span class="s1">functional</span>

    <span class="s0">if </span><span class="s1">cls </span><span class="s2">== </span><span class="s1">Model</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">functional</span><span class="s2">.</span><span class="s1">Functional</span>
    <span class="s5"># In case there is any multiple inheritance, we stop injecting the</span>
    <span class="s5"># class if keras model is not in its class hierarchy.</span>
    <span class="s0">if </span><span class="s1">cls </span><span class="s2">== </span><span class="s1">object</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">object</span>

    <span class="s1">cls</span><span class="s2">.</span><span class="s1">__bases__ </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
        <span class="s1">inject_functional_model_class</span><span class="s2">(</span><span class="s1">base</span><span class="s2">) </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__bases__</span>
    <span class="s2">)</span>
    <span class="s5"># Trigger any `__new__` class swapping that needed to happen on `Functional`</span>
    <span class="s5"># but did not because functional was not in the class hierarchy.</span>
    <span class="s1">cls</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">cls</span>
</pre>
</body>
</html>