<html>
<head>
<title>_ufuncs.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ufuncs.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># This file is automatically generated by _generate_pyx.py.</span>
<span class="s0"># Do not edit manually!</span>

<span class="s0">from libc.math cimport NAN</span>

<span class="s0">include &quot;_ufuncs_extra_code_common.pxi&quot;</span>
<span class="s0">include &quot;_ufuncs_extra_code.pxi&quot;</span>
<span class="s0">__all__ = ['agm', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'besselpoly', 'beta', 'betainc', 'betaincc', 'betainccinv', 'betaincinv', 'betaln', 'boxcox', 'boxcox1p', 'btdtr', 'btdtri', 'btdtria', 'btdtrib', 'cbrt', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'cosdg', 'cosm1', 'cotdg', 'dawsn', 'ellipe', 'ellipeinc', 'ellipj', 'ellipk', 'ellipkinc', 'ellipkm1', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp10', 'exp2', 'expm1', 'expn', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'fresnel', 'gammainc', 'gammaincc', 'gammainccinv', 'gammaincinv', 'gammasgn', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'huber', 'hyp0f1', 'hyp1f1', 'hyperu', 'i0', 'i0e', 'i1', 'i1e', 'inv_boxcox', 'inv_boxcox1p', 'j0', 'j1', 'k0', 'k0e', 'k1', 'k1e', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'log1p', 'log_ndtr', 'lpmv', 'modstruve', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'owens_t', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pseudo_huber', 'radian', 'rel_entr', 'round', 'shichi', 'sici', 'sindg', 'smirnov', 'smirnovi', 'spence', 'stdtr', 'stdtridf', 'stdtrit', 'struve', 'tandg', 'tklmbda', 'voigt_profile', 'wofz', 'wrightomega', 'xlog1py', 'xlogy', 'y0', 'y1', 'yn', 'zetac', 'geterr', 'seterr', 'errstate', 'jn', 'airy', 'airye', 'bei', 'beip', 'ber', 'berp', 'binom', 'exp1', 'expi', 'expit', 'exprel', 'gamma', 'gammaln', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'hyp2f1', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'jv', 'jve', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kv', 'kve', 'log_expit', 'log_wright_bessel', 'loggamma', 'logit', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'pbdv', 'pbvv', 'pbwa', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'psi', 'rgamma', 'sph_harm', 'wright_bessel', 'yv', 'yve']</span>
<span class="s0">cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0], &lt;double&gt;(&lt;double*&gt;ip4)[0], &lt;double&gt;(&lt;double*&gt;ip5)[0], &lt;double&gt;(&lt;double*&gt;ip6)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0], &lt;double&gt;(&lt;float*&gt;ip4)[0], &lt;double&gt;(&lt;float*&gt;ip5)[0], &lt;double&gt;(&lt;float*&gt;ip6)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip2)[0] == (&lt;long*&gt;ip2)[0] and &lt;int&gt;(&lt;long*&gt;ip3)[0] == (&lt;long*&gt;ip3)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(double, double, int, int, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;int&gt;(&lt;long*&gt;ip2)[0], &lt;int&gt;(&lt;long*&gt;ip3)[0], &lt;double&gt;(&lt;double*&gt;ip4)[0], &lt;double&gt;(&lt;double*&gt;ip5)[0], &lt;double&gt;(&lt;double*&gt;ip6)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddp_d_As_ddp_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef char *op1 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, Py_ssize_t, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip2)[0], &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
        <span class="s0">op1 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dpd__As_dpd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, Py_ssize_t, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_pd__As_pd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(Py_ssize_t, double) noexcept nogil&gt;func)(&lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_pdd__As_pdd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(Py_ssize_t, double, double) noexcept nogil&gt;func)(&lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_pddd__As_pddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(Py_ssize_t, double, double, double) noexcept nogil&gt;func)(&lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ppd__As_ppd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(Py_ssize_t, Py_ssize_t, double) noexcept nogil&gt;func)(&lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip0)[0], &lt;Py_ssize_t&gt;(&lt;Py_ssize_t*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float, float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0], &lt;float&gt;(&lt;float*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_fff__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float, float, float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0], &lt;float&gt;(&lt;float*&gt;ip1)[0], &lt;float&gt;(&lt;float*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_ffff__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float, float, float, float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0], &lt;float&gt;(&lt;float*&gt;ip1)[0], &lt;float&gt;(&lt;float*&gt;ip2)[0], &lt;float&gt;(&lt;float*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">(&lt;double complex *&gt;op1)[0] = &lt;double complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">(&lt;float complex *&gt;op1)[0] = &lt;float complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef char *op2 = args[4]</span>
    <span class="s0">cdef char *op3 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">(&lt;double *&gt;op2)[0] = &lt;double&gt;ov2</span>
        <span class="s0">(&lt;double *&gt;op3)[0] = &lt;double&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
        <span class="s0">op2 += steps[4]</span>
        <span class="s0">op3 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef char *op2 = args[4]</span>
    <span class="s0">cdef char *op3 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">(&lt;float *&gt;op2)[0] = &lt;float&gt;ov2</span>
        <span class="s0">(&lt;float *&gt;op3)[0] = &lt;float&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
        <span class="s0">op2 += steps[4]</span>
        <span class="s0">op3 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef int ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip0)[0] == (&lt;long*&gt;ip0)[0]:</span>
            <span class="s0">ov0 = (&lt;int(*)(int) noexcept nogil&gt;func)(&lt;int&gt;(&lt;long*&gt;ip0)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;int&gt;0xbad0bad0</span>
        <span class="s0">(&lt;long *&gt;op0)[0] = &lt;long&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosine_cdf &quot;cosine_cdf&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosine_invcdf &quot;cosine_invcdf&quot;(double) noexcept nogil</span>
<span class="s0">from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic</span>
<span class="s0">ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &amp;_func_ellip_harmonic</span>
<span class="s0">from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe</span>
<span class="s0">ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &amp;_func_ellip_harmonic_unsafe</span>
<span class="s0">from ._factorial cimport _factorial as _func__factorial</span>
<span class="s0">ctypedef double _proto__factorial_t(double) noexcept nogil</span>
<span class="s0">cdef _proto__factorial_t *_proto__factorial_t_var = &amp;_func__factorial</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_igam_fac &quot;cephes_igam_fac&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_kolmogc &quot;cephes_kolmogc&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_kolmogci &quot;cephes_kolmogci&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_kolmogp &quot;cephes_kolmogp&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_lanczos_sum_expg_scaled &quot;cephes_lanczos_sum_expg_scaled&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_lgam1p &quot;cephes_lgam1p&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_log1pmx &quot;cephes_log1pmx&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_riemann_zeta &quot;cephes_riemann_zeta&quot;(double) noexcept nogil</span>
<span class="s0">from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function</span>
<span class="s0">ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil</span>
<span class="s0">cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &amp;_func__sf_error_test_function</span>
<span class="s0">from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &amp;_func_smirnovc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_smirnovc_wrap &quot;cephes_smirnovc_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &amp;_func_smirnovci_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_smirnovci_wrap &quot;cephes_smirnovci_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &amp;_func_smirnovp_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_smirnovp_wrap &quot;cephes_smirnovp_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes__struve_asymp_large_z &quot;cephes__struve_asymp_large_z&quot;(double, double, Py_ssize_t, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes__struve_bessel_series &quot;cephes__struve_bessel_series&quot;(double, double, Py_ssize_t, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes__struve_power_series &quot;cephes__struve_power_series&quot;(double, double, Py_ssize_t, double *) noexcept nogil</span>
<span class="s0">from ._agm cimport agm as _func_agm</span>
<span class="s0">ctypedef double _proto_agm_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_agm_t *_proto_agm_t_var = &amp;_func_agm</span>
<span class="s0">from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe</span>
<span class="s0">ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &amp;_func_bdtr_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_bdtr_wrap &quot;cephes_bdtr_wrap&quot;(double, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe</span>
<span class="s0">ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &amp;_func_bdtrc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_bdtrc_wrap &quot;cephes_bdtrc_wrap&quot;(double, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe</span>
<span class="s0">ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &amp;_func_bdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_bdtri_wrap &quot;cephes_bdtri_wrap&quot;(double, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport bdtrik as _func_bdtrik</span>
<span class="s0">ctypedef double _proto_bdtrik_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtrik_t *_proto_bdtrik_t_var = &amp;_func_bdtrik</span>
<span class="s0">from ._cdflib_wrappers cimport bdtrin as _func_bdtrin</span>
<span class="s0">ctypedef double _proto_bdtrin_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtrin_t *_proto_bdtrin_t_var = &amp;_func_bdtrin</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_besselpoly &quot;cephes_besselpoly&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_beta &quot;cephes_beta&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_lbeta &quot;cephes_lbeta&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._boxcox cimport boxcox as _func_boxcox</span>
<span class="s0">ctypedef double _proto_boxcox_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_boxcox_t *_proto_boxcox_t_var = &amp;_func_boxcox</span>
<span class="s0">from ._boxcox cimport boxcox1p as _func_boxcox1p</span>
<span class="s0">ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &amp;_func_boxcox1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_btdtr &quot;cephes_btdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_btdtri &quot;cephes_btdtri&quot;(double, double, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport btdtria as _func_btdtria</span>
<span class="s0">ctypedef double _proto_btdtria_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_btdtria_t *_proto_btdtria_t_var = &amp;_func_btdtria</span>
<span class="s0">from ._cdflib_wrappers cimport btdtrib as _func_btdtrib</span>
<span class="s0">ctypedef double _proto_btdtrib_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_btdtrib_t *_proto_btdtrib_t_var = &amp;_func_btdtrib</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_cbrt &quot;cephes_cbrt&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_chdtr &quot;cephes_chdtr&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_chdtrc &quot;cephes_chdtrc&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_chdtri &quot;cephes_chdtri&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport chdtriv as _func_chdtriv</span>
<span class="s0">ctypedef double _proto_chdtriv_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_chdtriv_t *_proto_chdtriv_t_var = &amp;_func_chdtriv</span>
<span class="s0">from ._cdflib_wrappers cimport chndtr as _func_chndtr</span>
<span class="s0">ctypedef double _proto_chndtr_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_chndtr_t *_proto_chndtr_t_var = &amp;_func_chndtr</span>
<span class="s0">from ._cdflib_wrappers cimport chndtridf as _func_chndtridf</span>
<span class="s0">ctypedef double _proto_chndtridf_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_chndtridf_t *_proto_chndtridf_t_var = &amp;_func_chndtridf</span>
<span class="s0">from ._cdflib_wrappers cimport chndtrinc as _func_chndtrinc</span>
<span class="s0">ctypedef double _proto_chndtrinc_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_chndtrinc_t *_proto_chndtrinc_t_var = &amp;_func_chndtrinc</span>
<span class="s0">from ._cdflib_wrappers cimport chndtrix as _func_chndtrix</span>
<span class="s0">ctypedef double _proto_chndtrix_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_chndtrix_t *_proto_chndtrix_t_var = &amp;_func_chndtrix</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_cosdg &quot;cephes_cosdg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_cosm1 &quot;cephes_cosm1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_cotdg &quot;cephes_cotdg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ellpe &quot;cephes_ellpe&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ellie &quot;cephes_ellie&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cephes_ellpj_wrap &quot;cephes_ellpj_wrap&quot;(double, double, double *, double *, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_special_ellipk &quot;special_ellipk&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ellik &quot;cephes_ellik&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ellpk &quot;cephes_ellpk&quot;(double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport entr as _func_entr</span>
<span class="s0">ctypedef double _proto_entr_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_entr_t *_proto_entr_t_var = &amp;_func_entr</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_erf &quot;cephes_erf&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_erfc &quot;cephes_erfc&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_erfcinv &quot;cephes_erfcinv&quot;(double) noexcept nogil</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc</span>
<span class="s0">ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &amp;_func_eval_chebyc[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc</span>
<span class="s0">ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &amp;_func_eval_chebyc[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l</span>
<span class="s0">ctypedef double _proto_eval_chebyc_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &amp;_func_eval_chebyc_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys as _func_eval_chebys</span>
<span class="s0">ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &amp;_func_eval_chebys[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys as _func_eval_chebys</span>
<span class="s0">ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &amp;_func_eval_chebys[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l</span>
<span class="s0">ctypedef double _proto_eval_chebys_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &amp;_func_eval_chebys_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt</span>
<span class="s0">ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &amp;_func_eval_chebyt[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt</span>
<span class="s0">ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &amp;_func_eval_chebyt[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l</span>
<span class="s0">ctypedef double _proto_eval_chebyt_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &amp;_func_eval_chebyt_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu</span>
<span class="s0">ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &amp;_func_eval_chebyu[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu</span>
<span class="s0">ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &amp;_func_eval_chebyu[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l</span>
<span class="s0">ctypedef double _proto_eval_chebyu_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &amp;_func_eval_chebyu_l</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer</span>
<span class="s0">ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &amp;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer</span>
<span class="s0">ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &amp;_func_eval_gegenbauer[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l</span>
<span class="s0">ctypedef double _proto_eval_gegenbauer_l_t(Py_ssize_t, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &amp;_func_eval_gegenbauer_l</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre</span>
<span class="s0">ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &amp;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre</span>
<span class="s0">ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &amp;_func_eval_genlaguerre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l</span>
<span class="s0">ctypedef double _proto_eval_genlaguerre_l_t(Py_ssize_t, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &amp;_func_eval_genlaguerre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_hermite as _func_eval_hermite</span>
<span class="s0">ctypedef double _proto_eval_hermite_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &amp;_func_eval_hermite</span>
<span class="s0">from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm</span>
<span class="s0">ctypedef double _proto_eval_hermitenorm_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &amp;_func_eval_hermitenorm</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi</span>
<span class="s0">ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &amp;_func_eval_jacobi[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi</span>
<span class="s0">ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &amp;_func_eval_jacobi[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l</span>
<span class="s0">ctypedef double _proto_eval_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &amp;_func_eval_jacobi_l</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre</span>
<span class="s0">ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &amp;_func_eval_laguerre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre</span>
<span class="s0">ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &amp;_func_eval_laguerre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l</span>
<span class="s0">ctypedef double _proto_eval_laguerre_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &amp;_func_eval_laguerre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre as _func_eval_legendre</span>
<span class="s0">ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &amp;_func_eval_legendre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre as _func_eval_legendre</span>
<span class="s0">ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &amp;_func_eval_legendre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l</span>
<span class="s0">ctypedef double _proto_eval_legendre_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &amp;_func_eval_legendre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt</span>
<span class="s0">ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &amp;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &amp;_func_eval_sh_chebyt[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyt_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &amp;_func_eval_sh_chebyt_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu</span>
<span class="s0">ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &amp;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &amp;_func_eval_sh_chebyu[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyu_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &amp;_func_eval_sh_chebyu_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi</span>
<span class="s0">ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &amp;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi</span>
<span class="s0">ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &amp;_func_eval_sh_jacobi[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l</span>
<span class="s0">ctypedef double _proto_eval_sh_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &amp;_func_eval_sh_jacobi_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre</span>
<span class="s0">ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &amp;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre</span>
<span class="s0">ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &amp;_func_eval_sh_legendre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l</span>
<span class="s0">ctypedef double _proto_eval_sh_legendre_l_t(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &amp;_func_eval_sh_legendre_l</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_exp10 &quot;cephes_exp10&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_exp2 &quot;cephes_exp2&quot;(double) noexcept nogil</span>
<span class="s0">from ._cunity cimport cexpm1 as _func_cexpm1</span>
<span class="s0">ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &amp;_func_cexpm1</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_expm1 &quot;cephes_expm1&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport expn_unsafe as _func_expn_unsafe</span>
<span class="s0">ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &amp;_func_expn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_expn_wrap &quot;cephes_expn_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_fdtr &quot;cephes_fdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_fdtrc &quot;cephes_fdtrc&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_fdtri &quot;cephes_fdtri&quot;(double, double, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport fdtridfd as _func_fdtridfd</span>
<span class="s0">ctypedef double _proto_fdtridfd_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_fdtridfd_t *_proto_fdtridfd_t_var = &amp;_func_fdtridfd</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cephes_fresnl_wrap &quot;cephes_fresnl_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cfresnl_wrap &quot;cfresnl_wrap&quot;(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_igam &quot;cephes_igam&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_igamc &quot;cephes_igamc&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_igamci &quot;cephes_igamci&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_igami &quot;cephes_igami&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_gammasgn &quot;cephes_gammasgn&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_gdtr &quot;cephes_gdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_gdtrc &quot;cephes_gdtrc&quot;(double, double, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport gdtria as _func_gdtria</span>
<span class="s0">ctypedef double _proto_gdtria_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_gdtria_t *_proto_gdtria_t_var = &amp;_func_gdtria</span>
<span class="s0">from ._cdflib_wrappers cimport gdtrib as _func_gdtrib</span>
<span class="s0">ctypedef double _proto_gdtrib_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_gdtrib_t *_proto_gdtrib_t_var = &amp;_func_gdtrib</span>
<span class="s0">from ._cdflib_wrappers cimport gdtrix as _func_gdtrix</span>
<span class="s0">ctypedef double _proto_gdtrix_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_gdtrix_t *_proto_gdtrix_t_var = &amp;_func_gdtrix</span>
<span class="s0">from ._convex_analysis cimport huber as _func_huber</span>
<span class="s0">ctypedef double _proto_huber_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_huber_t *_proto_huber_t_var = &amp;_func_huber</span>
<span class="s0">from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx</span>
<span class="s0">ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &amp;_func__hyp0f1_cmplx</span>
<span class="s0">from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real</span>
<span class="s0">ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &amp;_func__hyp0f1_real</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_chyp1f1_wrap &quot;chyp1f1_wrap&quot;(double, double, double complex) noexcept nogil</span>
<span class="s0">from ._hypergeometric cimport hyperu as _func_hyperu</span>
<span class="s0">ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_hyperu_t *_proto_hyperu_t_var = &amp;_func_hyperu</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_i0 &quot;cephes_i0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_i0e &quot;cephes_i0e&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_i1 &quot;cephes_i1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_i1e &quot;cephes_i1e&quot;(double) noexcept nogil</span>
<span class="s0">from ._boxcox cimport inv_boxcox as _func_inv_boxcox</span>
<span class="s0">ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &amp;_func_inv_boxcox</span>
<span class="s0">from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p</span>
<span class="s0">ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &amp;_func_inv_boxcox1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_j0 &quot;cephes_j0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_j1 &quot;cephes_j1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_k0 &quot;cephes_k0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_k0e &quot;cephes_k0e&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_k1 &quot;cephes_k1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_k1e &quot;cephes_k1e&quot;(double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport kl_div as _func_kl_div</span>
<span class="s0">ctypedef double _proto_kl_div_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_kl_div_t *_proto_kl_div_t_var = &amp;_func_kl_div</span>
<span class="s0">from ._legacy cimport kn_unsafe as _func_kn_unsafe</span>
<span class="s0">ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &amp;_func_kn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_special_cyl_bessel_k_int &quot;special_cyl_bessel_k_int&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_kolmogi &quot;cephes_kolmogi&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_kolmogorov &quot;cephes_kolmogorov&quot;(double) noexcept nogil</span>
<span class="s0">from ._cunity cimport clog1p as _func_clog1p</span>
<span class="s0">ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_clog1p_t *_proto_clog1p_t_var = &amp;_func_clog1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_log1p &quot;cephes_log1p&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_pmv_wrap &quot;pmv_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_struve_l &quot;cephes_struve_l&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &amp;_func_nbdtr_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_nbdtr_wrap &quot;cephes_nbdtr_wrap&quot;(Py_ssize_t, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &amp;_func_nbdtrc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_nbdtrc_wrap &quot;cephes_nbdtrc_wrap&quot;(Py_ssize_t, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &amp;_func_nbdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_nbdtri_wrap &quot;cephes_nbdtri_wrap&quot;(Py_ssize_t, Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport nbdtrik as _func_nbdtrik</span>
<span class="s0">ctypedef double _proto_nbdtrik_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtrik_t *_proto_nbdtrik_t_var = &amp;_func_nbdtrik</span>
<span class="s0">from ._cdflib_wrappers cimport nbdtrin as _func_nbdtrin</span>
<span class="s0">ctypedef double _proto_nbdtrin_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtrin_t *_proto_nbdtrin_t_var = &amp;_func_nbdtrin</span>
<span class="s0">from ._cdflib_wrappers cimport ncfdtr as _func_ncfdtr</span>
<span class="s0">ctypedef double _proto_ncfdtr_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ncfdtr_t *_proto_ncfdtr_t_var = &amp;_func_ncfdtr</span>
<span class="s0">from ._cdflib_wrappers cimport ncfdtri as _func_ncfdtri</span>
<span class="s0">ctypedef double _proto_ncfdtri_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ncfdtri_t *_proto_ncfdtri_t_var = &amp;_func_ncfdtri</span>
<span class="s0">from ._cdflib_wrappers cimport ncfdtridfd as _func_ncfdtridfd</span>
<span class="s0">ctypedef double _proto_ncfdtridfd_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ncfdtridfd_t *_proto_ncfdtridfd_t_var = &amp;_func_ncfdtridfd</span>
<span class="s0">from ._cdflib_wrappers cimport ncfdtridfn as _func_ncfdtridfn</span>
<span class="s0">ctypedef double _proto_ncfdtridfn_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ncfdtridfn_t *_proto_ncfdtridfn_t_var = &amp;_func_ncfdtridfn</span>
<span class="s0">from ._cdflib_wrappers cimport ncfdtrinc as _func_ncfdtrinc</span>
<span class="s0">ctypedef double _proto_ncfdtrinc_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ncfdtrinc_t *_proto_ncfdtrinc_t_var = &amp;_func_ncfdtrinc</span>
<span class="s0">from ._cdflib_wrappers cimport nctdtr as _func_nctdtr</span>
<span class="s0">ctypedef double _proto_nctdtr_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nctdtr_t *_proto_nctdtr_t_var = &amp;_func_nctdtr</span>
<span class="s0">from ._cdflib_wrappers cimport nctdtridf as _func_nctdtridf</span>
<span class="s0">ctypedef double _proto_nctdtridf_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nctdtridf_t *_proto_nctdtridf_t_var = &amp;_func_nctdtridf</span>
<span class="s0">from ._cdflib_wrappers cimport nctdtrinc as _func_nctdtrinc</span>
<span class="s0">ctypedef double _proto_nctdtrinc_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nctdtrinc_t *_proto_nctdtrinc_t_var = &amp;_func_nctdtrinc</span>
<span class="s0">from ._cdflib_wrappers cimport nctdtrit as _func_nctdtrit</span>
<span class="s0">ctypedef double _proto_nctdtrit_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nctdtrit_t *_proto_nctdtrit_t_var = &amp;_func_nctdtrit</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ndtr &quot;cephes_ndtr&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_ndtri &quot;cephes_ndtri&quot;(double) noexcept nogil</span>
<span class="s0">from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp</span>
<span class="s0">ctypedef double _proto_ndtri_exp_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &amp;_func_ndtri_exp</span>
<span class="s0">from ._cdflib_wrappers cimport nrdtrimn as _func_nrdtrimn</span>
<span class="s0">ctypedef double _proto_nrdtrimn_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nrdtrimn_t *_proto_nrdtrimn_t_var = &amp;_func_nrdtrimn</span>
<span class="s0">from ._cdflib_wrappers cimport nrdtrisd as _func_nrdtrisd</span>
<span class="s0">ctypedef double _proto_nrdtrisd_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nrdtrisd_t *_proto_nrdtrisd_t_var = &amp;_func_nrdtrisd</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_owens_t &quot;cephes_owens_t&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_pdtr &quot;cephes_pdtr&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_pdtrc &quot;cephes_pdtrc&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe</span>
<span class="s0">ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &amp;_func_pdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_pdtri_wrap &quot;cephes_pdtri_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport pdtrik as _func_pdtrik</span>
<span class="s0">ctypedef double _proto_pdtrik_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_pdtrik_t *_proto_pdtrik_t_var = &amp;_func_pdtrik</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_poch &quot;cephes_poch&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber</span>
<span class="s0">ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &amp;_func_pseudo_huber</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_radian &quot;cephes_radian&quot;(double, double, double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport rel_entr as _func_rel_entr</span>
<span class="s0">ctypedef double _proto_rel_entr_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &amp;_func_rel_entr</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_round &quot;cephes_round&quot;(double) noexcept nogil</span>
<span class="s0">from ._sici cimport cshichi as _func_cshichi</span>
<span class="s0">ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef _proto_cshichi_t *_proto_cshichi_t_var = &amp;_func_cshichi</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cephes_shichi_wrap &quot;cephes_shichi_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">from ._sici cimport csici as _func_csici</span>
<span class="s0">ctypedef int _proto_csici_t(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef _proto_csici_t *_proto_csici_t_var = &amp;_func_csici</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cephes_sici_wrap &quot;cephes_sici_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_sindg &quot;cephes_sindg&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe</span>
<span class="s0">ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &amp;_func_smirnov_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_smirnov_wrap &quot;cephes_smirnov_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &amp;_func_smirnovi_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_smirnovi_wrap &quot;cephes_smirnovi_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">from ._spence cimport cspence as _func_cspence</span>
<span class="s0">ctypedef double complex _proto_cspence_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cspence_t *_proto_cspence_t_var = &amp;_func_cspence</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_spence &quot;cephes_spence&quot;(double) noexcept nogil</span>
<span class="s0">from ._cdflib_wrappers cimport stdtr as _func_stdtr</span>
<span class="s0">ctypedef double _proto_stdtr_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_stdtr_t *_proto_stdtr_t_var = &amp;_func_stdtr</span>
<span class="s0">from ._cdflib_wrappers cimport stdtridf as _func_stdtridf</span>
<span class="s0">ctypedef double _proto_stdtridf_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_stdtridf_t *_proto_stdtridf_t_var = &amp;_func_stdtridf</span>
<span class="s0">from ._cdflib_wrappers cimport stdtrit as _func_stdtrit</span>
<span class="s0">ctypedef double _proto_stdtrit_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_stdtrit_t *_proto_stdtrit_t_var = &amp;_func_stdtrit</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_struve_h &quot;cephes_struve_h&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_tandg &quot;cephes_tandg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_tukeylambdacdf &quot;cephes_tukeylambdacdf&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._xlogy cimport xlog1py as _func_xlog1py</span>
<span class="s0">ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &amp;_func_xlog1py[double]</span>
<span class="s0">from ._xlogy cimport xlog1py as _func_xlog1py</span>
<span class="s0">ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &amp;_func_xlog1py[double_complex]</span>
<span class="s0">from ._xlogy cimport xlogy as _func_xlogy</span>
<span class="s0">ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &amp;_func_xlogy[double]</span>
<span class="s0">from ._xlogy cimport xlogy as _func_xlogy</span>
<span class="s0">ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &amp;_func_xlogy[double_complex]</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_y0 &quot;cephes_y0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_y1 &quot;cephes_y1&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport yn_unsafe as _func_yn_unsafe</span>
<span class="s0">ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &amp;_func_yn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_yn_wrap &quot;cephes_yn_wrap&quot;(Py_ssize_t, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cephes_zetac &quot;cephes_zetac&quot;(double) noexcept nogil</span>
<span class="s0">cdef np.PyUFuncGenericFunction ufunc__beta_pdf_loops[2]</span>
<span class="s0">cdef void *ufunc__beta_pdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__beta_pdf_data[2]</span>
<span class="s0">cdef char ufunc__beta_pdf_types[8]</span>
<span class="s0">cdef char *ufunc__beta_pdf_doc = (</span>
    <span class="s0">&quot;_beta_pdf(x, a, b)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability density function of beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued such that :math:`0 \\leq x \\leq 1`,\n&quot;</span>
    <span class="s0">&quot;    the upper limit of integration\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;       Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__beta_pdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__beta_pdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__beta_pdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_pdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_pdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_pdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_pdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_pdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_pdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_pdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_pdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_beta_pdf_float</span>
<span class="s0">ufunc__beta_pdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_beta_pdf&quot;)</span>
<span class="s0">ufunc__beta_pdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_beta_pdf_double</span>
<span class="s0">ufunc__beta_pdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_beta_pdf&quot;)</span>
<span class="s0">ufunc__beta_pdf_data[0] = &amp;ufunc__beta_pdf_ptr[2*0]</span>
<span class="s0">ufunc__beta_pdf_data[1] = &amp;ufunc__beta_pdf_ptr[2*1]</span>
<span class="s0">_beta_pdf = np.PyUFunc_FromFuncAndData(ufunc__beta_pdf_loops, ufunc__beta_pdf_data, ufunc__beta_pdf_types, 2, 3, 1, 0, &quot;_beta_pdf&quot;, ufunc__beta_pdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__beta_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__beta_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__beta_ppf_data[2]</span>
<span class="s0">cdef char ufunc__beta_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__beta_ppf_doc = (</span>
    <span class="s0">&quot;_beta_ppf(x, a, b)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued such that :math:`0 \\leq x \\leq 1`,\n&quot;</span>
    <span class="s0">&quot;    the upper limit of integration\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;       Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__beta_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__beta_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__beta_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__beta_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__beta_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_beta_ppf_float</span>
<span class="s0">ufunc__beta_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_beta_ppf&quot;)</span>
<span class="s0">ufunc__beta_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_beta_ppf_double</span>
<span class="s0">ufunc__beta_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_beta_ppf&quot;)</span>
<span class="s0">ufunc__beta_ppf_data[0] = &amp;ufunc__beta_ppf_ptr[2*0]</span>
<span class="s0">ufunc__beta_ppf_data[1] = &amp;ufunc__beta_ppf_ptr[2*1]</span>
<span class="s0">_beta_ppf = np.PyUFunc_FromFuncAndData(ufunc__beta_ppf_loops, ufunc__beta_ppf_data, ufunc__beta_ppf_types, 2, 3, 1, 0, &quot;_beta_ppf&quot;, ufunc__beta_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__binom_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__binom_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__binom_cdf_data[2]</span>
<span class="s0">cdef char ufunc__binom_cdf_types[8]</span>
<span class="s0">cdef char *ufunc__binom_cdf_doc = (</span>
    <span class="s0">&quot;_binom_cdf(x, n, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__binom_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__binom_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__binom_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_cdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_cdf_float</span>
<span class="s0">ufunc__binom_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_cdf&quot;)</span>
<span class="s0">ufunc__binom_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_cdf_double</span>
<span class="s0">ufunc__binom_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_cdf&quot;)</span>
<span class="s0">ufunc__binom_cdf_data[0] = &amp;ufunc__binom_cdf_ptr[2*0]</span>
<span class="s0">ufunc__binom_cdf_data[1] = &amp;ufunc__binom_cdf_ptr[2*1]</span>
<span class="s0">_binom_cdf = np.PyUFunc_FromFuncAndData(ufunc__binom_cdf_loops, ufunc__binom_cdf_data, ufunc__binom_cdf_types, 2, 3, 1, 0, &quot;_binom_cdf&quot;, ufunc__binom_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__binom_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__binom_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__binom_isf_data[2]</span>
<span class="s0">cdef char ufunc__binom_isf_types[8]</span>
<span class="s0">cdef char *ufunc__binom_isf_doc = (</span>
    <span class="s0">&quot;_binom_isf(x, n, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse survival function of binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__binom_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__binom_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__binom_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_isf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_isf_float</span>
<span class="s0">ufunc__binom_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_isf&quot;)</span>
<span class="s0">ufunc__binom_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_isf_double</span>
<span class="s0">ufunc__binom_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_isf&quot;)</span>
<span class="s0">ufunc__binom_isf_data[0] = &amp;ufunc__binom_isf_ptr[2*0]</span>
<span class="s0">ufunc__binom_isf_data[1] = &amp;ufunc__binom_isf_ptr[2*1]</span>
<span class="s0">_binom_isf = np.PyUFunc_FromFuncAndData(ufunc__binom_isf_loops, ufunc__binom_isf_data, ufunc__binom_isf_types, 2, 3, 1, 0, &quot;_binom_isf&quot;, ufunc__binom_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__binom_pmf_loops[2]</span>
<span class="s0">cdef void *ufunc__binom_pmf_ptr[4]</span>
<span class="s0">cdef void *ufunc__binom_pmf_data[2]</span>
<span class="s0">cdef char ufunc__binom_pmf_types[8]</span>
<span class="s0">cdef char *ufunc__binom_pmf_doc = (</span>
    <span class="s0">&quot;_binom_pmf(x, n, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability mass function of binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__binom_pmf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__binom_pmf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__binom_pmf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_pmf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_pmf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_pmf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_pmf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_pmf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_pmf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_pmf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_pmf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_pmf_float</span>
<span class="s0">ufunc__binom_pmf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_pmf&quot;)</span>
<span class="s0">ufunc__binom_pmf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_pmf_double</span>
<span class="s0">ufunc__binom_pmf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_pmf&quot;)</span>
<span class="s0">ufunc__binom_pmf_data[0] = &amp;ufunc__binom_pmf_ptr[2*0]</span>
<span class="s0">ufunc__binom_pmf_data[1] = &amp;ufunc__binom_pmf_ptr[2*1]</span>
<span class="s0">_binom_pmf = np.PyUFunc_FromFuncAndData(ufunc__binom_pmf_loops, ufunc__binom_pmf_data, ufunc__binom_pmf_types, 2, 3, 1, 0, &quot;_binom_pmf&quot;, ufunc__binom_pmf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__binom_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__binom_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__binom_ppf_data[2]</span>
<span class="s0">cdef char ufunc__binom_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__binom_ppf_doc = (</span>
    <span class="s0">&quot;_binom_ppf(x, n, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__binom_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__binom_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__binom_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_ppf_float</span>
<span class="s0">ufunc__binom_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_ppf&quot;)</span>
<span class="s0">ufunc__binom_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_ppf_double</span>
<span class="s0">ufunc__binom_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_ppf&quot;)</span>
<span class="s0">ufunc__binom_ppf_data[0] = &amp;ufunc__binom_ppf_ptr[2*0]</span>
<span class="s0">ufunc__binom_ppf_data[1] = &amp;ufunc__binom_ppf_ptr[2*1]</span>
<span class="s0">_binom_ppf = np.PyUFunc_FromFuncAndData(ufunc__binom_ppf_loops, ufunc__binom_ppf_data, ufunc__binom_ppf_types, 2, 3, 1, 0, &quot;_binom_ppf&quot;, ufunc__binom_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__binom_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__binom_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__binom_sf_data[2]</span>
<span class="s0">cdef char ufunc__binom_sf_types[8]</span>
<span class="s0">cdef char *ufunc__binom_sf_doc = (</span>
    <span class="s0">&quot;_binom_sf(x, n, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__binom_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__binom_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__binom_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__binom_sf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__binom_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_sf_float</span>
<span class="s0">ufunc__binom_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_sf&quot;)</span>
<span class="s0">ufunc__binom_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_binom_sf_double</span>
<span class="s0">ufunc__binom_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_binom_sf&quot;)</span>
<span class="s0">ufunc__binom_sf_data[0] = &amp;ufunc__binom_sf_ptr[2*0]</span>
<span class="s0">ufunc__binom_sf_data[1] = &amp;ufunc__binom_sf_ptr[2*1]</span>
<span class="s0">_binom_sf = np.PyUFunc_FromFuncAndData(ufunc__binom_sf_loops, ufunc__binom_sf_data, ufunc__binom_sf_types, 2, 3, 1, 0, &quot;_binom_sf&quot;, ufunc__binom_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__cosine_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__cosine_cdf_data[2]</span>
<span class="s0">cdef char ufunc__cosine_cdf_types[4]</span>
<span class="s0">cdef char *ufunc__cosine_cdf_doc = (</span>
    <span class="s0">&quot;_cosine_cdf(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function (CDF) of the cosine distribution::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;             {             0,              x &lt; -pi\n&quot;</span>
    <span class="s0">&quot;    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi &lt;= x &lt;= pi\n&quot;</span>
    <span class="s0">&quot;             {             1,              x &gt; pi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The cosine distribution CDF evaluated at `x`.&quot;)</span>
<span class="s0">ufunc__cosine_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__cosine_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__cosine_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_cdf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_cdf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*0] = &lt;void*&gt;_func_cosine_cdf</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_cdf&quot;)</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*1] = &lt;void*&gt;_func_cosine_cdf</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_cdf&quot;)</span>
<span class="s0">ufunc__cosine_cdf_data[0] = &amp;ufunc__cosine_cdf_ptr[2*0]</span>
<span class="s0">ufunc__cosine_cdf_data[1] = &amp;ufunc__cosine_cdf_ptr[2*1]</span>
<span class="s0">_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, &quot;_cosine_cdf&quot;, ufunc__cosine_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]</span>
<span class="s0">cdef void *ufunc__cosine_invcdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__cosine_invcdf_data[2]</span>
<span class="s0">cdef char ufunc__cosine_invcdf_types[4]</span>
<span class="s0">cdef char *ufunc__cosine_invcdf_doc = (</span>
    <span class="s0">&quot;_cosine_invcdf(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the cumulative distribution function (CDF) of the cosine\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The CDF of the cosine distribution is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    cdf(x) = (pi + x + sin(x))/(2*pi)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function computes the inverse of cdf(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    `p` must contain real numbers in the interval ``0 &lt;= p &lt;= 1``.\n&quot;</span>
    <span class="s0">&quot;    `nan` is returned for values of `p` outside the interval [0, 1].\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of the cosine distribution CDF evaluated at `p`.&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__cosine_invcdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__cosine_invcdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_invcdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_invcdf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_invcdf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*0] = &lt;void*&gt;_func_cosine_invcdf</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_invcdf&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*1] = &lt;void*&gt;_func_cosine_invcdf</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_invcdf&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_data[0] = &amp;ufunc__cosine_invcdf_ptr[2*0]</span>
<span class="s0">ufunc__cosine_invcdf_data[1] = &amp;ufunc__cosine_invcdf_ptr[2*1]</span>
<span class="s0">_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, &quot;_cosine_invcdf&quot;, ufunc__cosine_invcdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]</span>
<span class="s0">cdef void *ufunc__ellip_harm_ptr[6]</span>
<span class="s0">cdef void *ufunc__ellip_harm_data[3]</span>
<span class="s0">cdef char ufunc__ellip_harm_types[24]</span>
<span class="s0">cdef char *ufunc__ellip_harm_doc = (</span>
    <span class="s0">&quot;Internal function, use `ellip_harm` instead.&quot;)</span>
<span class="s0">ufunc__ellip_harm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddddddd__As_fffffff_f</span>
<span class="s0">ufunc__ellip_harm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddiiddd__As_ddllddd_d</span>
<span class="s0">ufunc__ellip_harm_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddddddd__As_ddddddd_d</span>
<span class="s0">ufunc__ellip_harm_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[10] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__ellip_harm_types[11] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__ellip_harm_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[23] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_ptr[2*0] = &lt;void*&gt;_func_ellip_harmonic_unsafe</span>
<span class="s0">ufunc__ellip_harm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_ptr[2*1] = &lt;void*&gt;_func_ellip_harmonic</span>
<span class="s0">ufunc__ellip_harm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_ptr[2*2] = &lt;void*&gt;_func_ellip_harmonic_unsafe</span>
<span class="s0">ufunc__ellip_harm_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_data[0] = &amp;ufunc__ellip_harm_ptr[2*0]</span>
<span class="s0">ufunc__ellip_harm_data[1] = &amp;ufunc__ellip_harm_ptr[2*1]</span>
<span class="s0">ufunc__ellip_harm_data[2] = &amp;ufunc__ellip_harm_ptr[2*2]</span>
<span class="s0">_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, &quot;_ellip_harm&quot;, ufunc__ellip_harm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]</span>
<span class="s0">cdef void *ufunc__factorial_ptr[4]</span>
<span class="s0">cdef void *ufunc__factorial_data[2]</span>
<span class="s0">cdef char ufunc__factorial_types[4]</span>
<span class="s0">cdef char *ufunc__factorial_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__factorial_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__factorial_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__factorial_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__factorial_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__factorial_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__factorial_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__factorial_ptr[2*0] = &lt;void*&gt;_func__factorial</span>
<span class="s0">ufunc__factorial_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_factorial&quot;)</span>
<span class="s0">ufunc__factorial_ptr[2*1] = &lt;void*&gt;_func__factorial</span>
<span class="s0">ufunc__factorial_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_factorial&quot;)</span>
<span class="s0">ufunc__factorial_data[0] = &amp;ufunc__factorial_ptr[2*0]</span>
<span class="s0">ufunc__factorial_data[1] = &amp;ufunc__factorial_ptr[2*1]</span>
<span class="s0">_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, &quot;_factorial&quot;, ufunc__factorial_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_cdf_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_cdf_types[10]</span>
<span class="s0">cdef char *ufunc__hypergeom_cdf_doc = (</span>
    <span class="s0">&quot;_hypergeom_cdf(x, r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__hypergeom_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__hypergeom_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_cdf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_cdf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_cdf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_cdf_float</span>
<span class="s0">ufunc__hypergeom_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_cdf&quot;)</span>
<span class="s0">ufunc__hypergeom_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_cdf_double</span>
<span class="s0">ufunc__hypergeom_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_cdf&quot;)</span>
<span class="s0">ufunc__hypergeom_cdf_data[0] = &amp;ufunc__hypergeom_cdf_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_cdf_data[1] = &amp;ufunc__hypergeom_cdf_ptr[2*1]</span>
<span class="s0">_hypergeom_cdf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_cdf_loops, ufunc__hypergeom_cdf_data, ufunc__hypergeom_cdf_types, 2, 4, 1, 0, &quot;_hypergeom_cdf&quot;, ufunc__hypergeom_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_mean_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_mean_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_mean_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_mean_types[8]</span>
<span class="s0">cdef char *ufunc__hypergeom_mean_doc = (</span>
    <span class="s0">&quot;_hypergeom_mean(r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Mean of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_mean_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__hypergeom_mean_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__hypergeom_mean_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_mean_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_mean_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_mean_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_mean_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_mean_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_mean_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_mean_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_mean_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_mean_float</span>
<span class="s0">ufunc__hypergeom_mean_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_mean&quot;)</span>
<span class="s0">ufunc__hypergeom_mean_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_mean_double</span>
<span class="s0">ufunc__hypergeom_mean_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_mean&quot;)</span>
<span class="s0">ufunc__hypergeom_mean_data[0] = &amp;ufunc__hypergeom_mean_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_mean_data[1] = &amp;ufunc__hypergeom_mean_ptr[2*1]</span>
<span class="s0">_hypergeom_mean = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_mean_loops, ufunc__hypergeom_mean_data, ufunc__hypergeom_mean_types, 2, 3, 1, 0, &quot;_hypergeom_mean&quot;, ufunc__hypergeom_mean_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_pmf_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_pmf_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_pmf_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_pmf_types[10]</span>
<span class="s0">cdef char *ufunc__hypergeom_pmf_doc = (</span>
    <span class="s0">&quot;_hypergeom_pmf(x, r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability mass function of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_pmf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__hypergeom_pmf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__hypergeom_pmf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_pmf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_pmf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_pmf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_pmf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_pmf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_pmf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_pmf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_pmf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_pmf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_pmf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_pmf_float</span>
<span class="s0">ufunc__hypergeom_pmf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_pmf&quot;)</span>
<span class="s0">ufunc__hypergeom_pmf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_pmf_double</span>
<span class="s0">ufunc__hypergeom_pmf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_pmf&quot;)</span>
<span class="s0">ufunc__hypergeom_pmf_data[0] = &amp;ufunc__hypergeom_pmf_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_pmf_data[1] = &amp;ufunc__hypergeom_pmf_ptr[2*1]</span>
<span class="s0">_hypergeom_pmf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_pmf_loops, ufunc__hypergeom_pmf_data, ufunc__hypergeom_pmf_types, 2, 4, 1, 0, &quot;_hypergeom_pmf&quot;, ufunc__hypergeom_pmf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_sf_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_sf_types[10]</span>
<span class="s0">cdef char *ufunc__hypergeom_sf_doc = (</span>
    <span class="s0">&quot;_hypergeom_sf(x, r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__hypergeom_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__hypergeom_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_sf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_sf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_sf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_sf_float</span>
<span class="s0">ufunc__hypergeom_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_sf&quot;)</span>
<span class="s0">ufunc__hypergeom_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_sf_double</span>
<span class="s0">ufunc__hypergeom_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_sf&quot;)</span>
<span class="s0">ufunc__hypergeom_sf_data[0] = &amp;ufunc__hypergeom_sf_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_sf_data[1] = &amp;ufunc__hypergeom_sf_ptr[2*1]</span>
<span class="s0">_hypergeom_sf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_sf_loops, ufunc__hypergeom_sf_data, ufunc__hypergeom_sf_types, 2, 4, 1, 0, &quot;_hypergeom_sf&quot;, ufunc__hypergeom_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_skewness_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_skewness_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_skewness_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_skewness_types[8]</span>
<span class="s0">cdef char *ufunc__hypergeom_skewness_doc = (</span>
    <span class="s0">&quot;_hypergeom_skewness(r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Skewness of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_skewness_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__hypergeom_skewness_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__hypergeom_skewness_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_skewness_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_skewness_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_skewness_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_skewness_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_skewness_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_skewness_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_skewness_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_skewness_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_skewness_float</span>
<span class="s0">ufunc__hypergeom_skewness_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_skewness&quot;)</span>
<span class="s0">ufunc__hypergeom_skewness_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_skewness_double</span>
<span class="s0">ufunc__hypergeom_skewness_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_skewness&quot;)</span>
<span class="s0">ufunc__hypergeom_skewness_data[0] = &amp;ufunc__hypergeom_skewness_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_skewness_data[1] = &amp;ufunc__hypergeom_skewness_ptr[2*1]</span>
<span class="s0">_hypergeom_skewness = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_skewness_loops, ufunc__hypergeom_skewness_data, ufunc__hypergeom_skewness_types, 2, 3, 1, 0, &quot;_hypergeom_skewness&quot;, ufunc__hypergeom_skewness_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__hypergeom_variance_loops[2]</span>
<span class="s0">cdef void *ufunc__hypergeom_variance_ptr[4]</span>
<span class="s0">cdef void *ufunc__hypergeom_variance_data[2]</span>
<span class="s0">cdef char ufunc__hypergeom_variance_types[8]</span>
<span class="s0">cdef char *ufunc__hypergeom_variance_doc = (</span>
    <span class="s0">&quot;_hypergeom_variance(r, N, M)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Mean of hypergeometric distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r, N, M : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__hypergeom_variance_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__hypergeom_variance_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__hypergeom_variance_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_variance_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_variance_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_variance_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__hypergeom_variance_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_variance_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_variance_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_variance_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__hypergeom_variance_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_variance_float</span>
<span class="s0">ufunc__hypergeom_variance_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_variance&quot;)</span>
<span class="s0">ufunc__hypergeom_variance_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hypergeom_variance_double</span>
<span class="s0">ufunc__hypergeom_variance_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_hypergeom_variance&quot;)</span>
<span class="s0">ufunc__hypergeom_variance_data[0] = &amp;ufunc__hypergeom_variance_ptr[2*0]</span>
<span class="s0">ufunc__hypergeom_variance_data[1] = &amp;ufunc__hypergeom_variance_ptr[2*1]</span>
<span class="s0">_hypergeom_variance = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_variance_loops, ufunc__hypergeom_variance_data, ufunc__hypergeom_variance_types, 2, 3, 1, 0, &quot;_hypergeom_variance&quot;, ufunc__hypergeom_variance_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]</span>
<span class="s0">cdef void *ufunc__igam_fac_ptr[4]</span>
<span class="s0">cdef void *ufunc__igam_fac_data[2]</span>
<span class="s0">cdef char ufunc__igam_fac_types[6]</span>
<span class="s0">cdef char *ufunc__igam_fac_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__igam_fac_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__igam_fac_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__igam_fac_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_ptr[2*0] = &lt;void*&gt;_func_cephes_igam_fac</span>
<span class="s0">ufunc__igam_fac_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_igam_fac&quot;)</span>
<span class="s0">ufunc__igam_fac_ptr[2*1] = &lt;void*&gt;_func_cephes_igam_fac</span>
<span class="s0">ufunc__igam_fac_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_igam_fac&quot;)</span>
<span class="s0">ufunc__igam_fac_data[0] = &amp;ufunc__igam_fac_ptr[2*0]</span>
<span class="s0">ufunc__igam_fac_data[1] = &amp;ufunc__igam_fac_ptr[2*1]</span>
<span class="s0">_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, &quot;_igam_fac&quot;, ufunc__igam_fac_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__invgauss_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__invgauss_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__invgauss_isf_data[2]</span>
<span class="s0">cdef char ufunc__invgauss_isf_types[8]</span>
<span class="s0">cdef char *ufunc__invgauss_isf_doc = (</span>
    <span class="s0">&quot;_invgauss_isf(x, mu, s)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse survival function of inverse gaussian distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;mu : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;s : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__invgauss_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__invgauss_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__invgauss_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_isf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_invgauss_isf_float</span>
<span class="s0">ufunc__invgauss_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_invgauss_isf&quot;)</span>
<span class="s0">ufunc__invgauss_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_invgauss_isf_double</span>
<span class="s0">ufunc__invgauss_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_invgauss_isf&quot;)</span>
<span class="s0">ufunc__invgauss_isf_data[0] = &amp;ufunc__invgauss_isf_ptr[2*0]</span>
<span class="s0">ufunc__invgauss_isf_data[1] = &amp;ufunc__invgauss_isf_ptr[2*1]</span>
<span class="s0">_invgauss_isf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_isf_loops, ufunc__invgauss_isf_data, ufunc__invgauss_isf_types, 2, 3, 1, 0, &quot;_invgauss_isf&quot;, ufunc__invgauss_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__invgauss_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__invgauss_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__invgauss_ppf_data[2]</span>
<span class="s0">cdef char ufunc__invgauss_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__invgauss_ppf_doc = (</span>
    <span class="s0">&quot;_invgauss_ppf(x, mu)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of inverse gaussian distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;mu : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__invgauss_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__invgauss_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__invgauss_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__invgauss_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__invgauss_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_invgauss_ppf_float</span>
<span class="s0">ufunc__invgauss_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_invgauss_ppf&quot;)</span>
<span class="s0">ufunc__invgauss_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_invgauss_ppf_double</span>
<span class="s0">ufunc__invgauss_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_invgauss_ppf&quot;)</span>
<span class="s0">ufunc__invgauss_ppf_data[0] = &amp;ufunc__invgauss_ppf_ptr[2*0]</span>
<span class="s0">ufunc__invgauss_ppf_data[1] = &amp;ufunc__invgauss_ppf_ptr[2*1]</span>
<span class="s0">_invgauss_ppf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_ppf_loops, ufunc__invgauss_ppf_data, ufunc__invgauss_ppf_types, 2, 3, 1, 0, &quot;_invgauss_ppf&quot;, ufunc__invgauss_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogc_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogc_data[2]</span>
<span class="s0">cdef char ufunc__kolmogc_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogc_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogc_ptr[2*0] = &lt;void*&gt;_func_cephes_kolmogc</span>
<span class="s0">ufunc__kolmogc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogc&quot;)</span>
<span class="s0">ufunc__kolmogc_ptr[2*1] = &lt;void*&gt;_func_cephes_kolmogc</span>
<span class="s0">ufunc__kolmogc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogc&quot;)</span>
<span class="s0">ufunc__kolmogc_data[0] = &amp;ufunc__kolmogc_ptr[2*0]</span>
<span class="s0">ufunc__kolmogc_data[1] = &amp;ufunc__kolmogc_ptr[2*1]</span>
<span class="s0">_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, &quot;_kolmogc&quot;, ufunc__kolmogc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogci_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogci_data[2]</span>
<span class="s0">cdef char ufunc__kolmogci_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogci_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogci_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogci_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogci_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogci_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogci_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogci_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogci_ptr[2*0] = &lt;void*&gt;_func_cephes_kolmogci</span>
<span class="s0">ufunc__kolmogci_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogci&quot;)</span>
<span class="s0">ufunc__kolmogci_ptr[2*1] = &lt;void*&gt;_func_cephes_kolmogci</span>
<span class="s0">ufunc__kolmogci_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogci&quot;)</span>
<span class="s0">ufunc__kolmogci_data[0] = &amp;ufunc__kolmogci_ptr[2*0]</span>
<span class="s0">ufunc__kolmogci_data[1] = &amp;ufunc__kolmogci_ptr[2*1]</span>
<span class="s0">_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, &quot;_kolmogci&quot;, ufunc__kolmogci_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogp_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogp_data[2]</span>
<span class="s0">cdef char ufunc__kolmogp_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogp_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogp_ptr[2*0] = &lt;void*&gt;_func_cephes_kolmogp</span>
<span class="s0">ufunc__kolmogp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogp&quot;)</span>
<span class="s0">ufunc__kolmogp_ptr[2*1] = &lt;void*&gt;_func_cephes_kolmogp</span>
<span class="s0">ufunc__kolmogp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogp&quot;)</span>
<span class="s0">ufunc__kolmogp_data[0] = &amp;ufunc__kolmogp_ptr[2*0]</span>
<span class="s0">ufunc__kolmogp_data[1] = &amp;ufunc__kolmogp_ptr[2*1]</span>
<span class="s0">_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, &quot;_kolmogp&quot;, ufunc__kolmogp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]</span>
<span class="s0">cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]</span>
<span class="s0">cdef void *ufunc__lanczos_sum_expg_scaled_data[2]</span>
<span class="s0">cdef char ufunc__lanczos_sum_expg_scaled_types[4]</span>
<span class="s0">cdef char *ufunc__lanczos_sum_expg_scaled_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*0] = &lt;void*&gt;_func_cephes_lanczos_sum_expg_scaled</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lanczos_sum_expg_scaled&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*1] = &lt;void*&gt;_func_cephes_lanczos_sum_expg_scaled</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lanczos_sum_expg_scaled&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_data[0] = &amp;ufunc__lanczos_sum_expg_scaled_ptr[2*0]</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_data[1] = &amp;ufunc__lanczos_sum_expg_scaled_ptr[2*1]</span>
<span class="s0">_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, &quot;_lanczos_sum_expg_scaled&quot;, ufunc__lanczos_sum_expg_scaled_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]</span>
<span class="s0">cdef void *ufunc__lgam1p_ptr[4]</span>
<span class="s0">cdef void *ufunc__lgam1p_data[2]</span>
<span class="s0">cdef char ufunc__lgam1p_types[4]</span>
<span class="s0">cdef char *ufunc__lgam1p_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__lgam1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__lgam1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__lgam1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lgam1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lgam1p_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lgam1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lgam1p_ptr[2*0] = &lt;void*&gt;_func_cephes_lgam1p</span>
<span class="s0">ufunc__lgam1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lgam1p&quot;)</span>
<span class="s0">ufunc__lgam1p_ptr[2*1] = &lt;void*&gt;_func_cephes_lgam1p</span>
<span class="s0">ufunc__lgam1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lgam1p&quot;)</span>
<span class="s0">ufunc__lgam1p_data[0] = &amp;ufunc__lgam1p_ptr[2*0]</span>
<span class="s0">ufunc__lgam1p_data[1] = &amp;ufunc__lgam1p_ptr[2*1]</span>
<span class="s0">_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, &quot;_lgam1p&quot;, ufunc__lgam1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]</span>
<span class="s0">cdef void *ufunc__log1pmx_ptr[4]</span>
<span class="s0">cdef void *ufunc__log1pmx_data[2]</span>
<span class="s0">cdef char ufunc__log1pmx_types[4]</span>
<span class="s0">cdef char *ufunc__log1pmx_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__log1pmx_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__log1pmx_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__log1pmx_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__log1pmx_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__log1pmx_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__log1pmx_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__log1pmx_ptr[2*0] = &lt;void*&gt;_func_cephes_log1pmx</span>
<span class="s0">ufunc__log1pmx_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_log1pmx&quot;)</span>
<span class="s0">ufunc__log1pmx_ptr[2*1] = &lt;void*&gt;_func_cephes_log1pmx</span>
<span class="s0">ufunc__log1pmx_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_log1pmx&quot;)</span>
<span class="s0">ufunc__log1pmx_data[0] = &amp;ufunc__log1pmx_ptr[2*0]</span>
<span class="s0">ufunc__log1pmx_data[1] = &amp;ufunc__log1pmx_ptr[2*1]</span>
<span class="s0">_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, &quot;_log1pmx&quot;, ufunc__log1pmx_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_cdf_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_cdf_types[8]</span>
<span class="s0">cdef char *ufunc__nbinom_cdf_doc = (</span>
    <span class="s0">&quot;_nbinom_cdf(x, r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nbinom_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nbinom_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_cdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_cdf_float</span>
<span class="s0">ufunc__nbinom_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_cdf&quot;)</span>
<span class="s0">ufunc__nbinom_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_cdf_double</span>
<span class="s0">ufunc__nbinom_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_cdf&quot;)</span>
<span class="s0">ufunc__nbinom_cdf_data[0] = &amp;ufunc__nbinom_cdf_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_cdf_data[1] = &amp;ufunc__nbinom_cdf_ptr[2*1]</span>
<span class="s0">_nbinom_cdf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_cdf_loops, ufunc__nbinom_cdf_data, ufunc__nbinom_cdf_types, 2, 3, 1, 0, &quot;_nbinom_cdf&quot;, ufunc__nbinom_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_isf_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_isf_types[8]</span>
<span class="s0">cdef char *ufunc__nbinom_isf_doc = (</span>
    <span class="s0">&quot;_nbinom_isf(x, r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse survival function of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nbinom_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nbinom_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_isf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_isf_float</span>
<span class="s0">ufunc__nbinom_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_isf&quot;)</span>
<span class="s0">ufunc__nbinom_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_isf_double</span>
<span class="s0">ufunc__nbinom_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_isf&quot;)</span>
<span class="s0">ufunc__nbinom_isf_data[0] = &amp;ufunc__nbinom_isf_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_isf_data[1] = &amp;ufunc__nbinom_isf_ptr[2*1]</span>
<span class="s0">_nbinom_isf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_isf_loops, ufunc__nbinom_isf_data, ufunc__nbinom_isf_types, 2, 3, 1, 0, &quot;_nbinom_isf&quot;, ufunc__nbinom_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_kurtosis_excess_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_kurtosis_excess_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_kurtosis_excess_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_kurtosis_excess_types[6]</span>
<span class="s0">cdef char *ufunc__nbinom_kurtosis_excess_doc = (</span>
    <span class="s0">&quot;_nbinom_kurtosis_excess(r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kurtosis excess of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_float</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_double</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_data[0] = &amp;ufunc__nbinom_kurtosis_excess_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_kurtosis_excess_data[1] = &amp;ufunc__nbinom_kurtosis_excess_ptr[2*1]</span>
<span class="s0">_nbinom_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nbinom_kurtosis_excess_loops, ufunc__nbinom_kurtosis_excess_data, ufunc__nbinom_kurtosis_excess_types, 2, 2, 1, 0, &quot;_nbinom_kurtosis_excess&quot;, ufunc__nbinom_kurtosis_excess_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_mean_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_mean_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_mean_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_mean_types[6]</span>
<span class="s0">cdef char *ufunc__nbinom_mean_doc = (</span>
    <span class="s0">&quot;_nbinom_mean(r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Mean of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_mean_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nbinom_mean_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nbinom_mean_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_mean_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_mean_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_mean_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_mean_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_mean_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_mean_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_mean_float</span>
<span class="s0">ufunc__nbinom_mean_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_mean&quot;)</span>
<span class="s0">ufunc__nbinom_mean_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_mean_double</span>
<span class="s0">ufunc__nbinom_mean_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_mean&quot;)</span>
<span class="s0">ufunc__nbinom_mean_data[0] = &amp;ufunc__nbinom_mean_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_mean_data[1] = &amp;ufunc__nbinom_mean_ptr[2*1]</span>
<span class="s0">_nbinom_mean = np.PyUFunc_FromFuncAndData(ufunc__nbinom_mean_loops, ufunc__nbinom_mean_data, ufunc__nbinom_mean_types, 2, 2, 1, 0, &quot;_nbinom_mean&quot;, ufunc__nbinom_mean_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_pmf_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_pmf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_pmf_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_pmf_types[8]</span>
<span class="s0">cdef char *ufunc__nbinom_pmf_doc = (</span>
    <span class="s0">&quot;_nbinom_pmf(x, r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability mass function of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_pmf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nbinom_pmf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nbinom_pmf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_pmf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_pmf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_pmf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_pmf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_pmf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_pmf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_pmf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_pmf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_pmf_float</span>
<span class="s0">ufunc__nbinom_pmf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_pmf&quot;)</span>
<span class="s0">ufunc__nbinom_pmf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_pmf_double</span>
<span class="s0">ufunc__nbinom_pmf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_pmf&quot;)</span>
<span class="s0">ufunc__nbinom_pmf_data[0] = &amp;ufunc__nbinom_pmf_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_pmf_data[1] = &amp;ufunc__nbinom_pmf_ptr[2*1]</span>
<span class="s0">_nbinom_pmf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_pmf_loops, ufunc__nbinom_pmf_data, ufunc__nbinom_pmf_types, 2, 3, 1, 0, &quot;_nbinom_pmf&quot;, ufunc__nbinom_pmf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_ppf_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__nbinom_ppf_doc = (</span>
    <span class="s0">&quot;_nbinom_ppf(x, r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nbinom_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nbinom_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_ppf_float</span>
<span class="s0">ufunc__nbinom_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_ppf&quot;)</span>
<span class="s0">ufunc__nbinom_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_ppf_double</span>
<span class="s0">ufunc__nbinom_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_ppf&quot;)</span>
<span class="s0">ufunc__nbinom_ppf_data[0] = &amp;ufunc__nbinom_ppf_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_ppf_data[1] = &amp;ufunc__nbinom_ppf_ptr[2*1]</span>
<span class="s0">_nbinom_ppf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_ppf_loops, ufunc__nbinom_ppf_data, ufunc__nbinom_ppf_types, 2, 3, 1, 0, &quot;_nbinom_ppf&quot;, ufunc__nbinom_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_sf_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_sf_types[8]</span>
<span class="s0">cdef char *ufunc__nbinom_sf_doc = (</span>
    <span class="s0">&quot;_nbinom_sf(x, r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nbinom_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nbinom_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_sf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_sf_float</span>
<span class="s0">ufunc__nbinom_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_sf&quot;)</span>
<span class="s0">ufunc__nbinom_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_sf_double</span>
<span class="s0">ufunc__nbinom_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_sf&quot;)</span>
<span class="s0">ufunc__nbinom_sf_data[0] = &amp;ufunc__nbinom_sf_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_sf_data[1] = &amp;ufunc__nbinom_sf_ptr[2*1]</span>
<span class="s0">_nbinom_sf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_sf_loops, ufunc__nbinom_sf_data, ufunc__nbinom_sf_types, 2, 3, 1, 0, &quot;_nbinom_sf&quot;, ufunc__nbinom_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_skewness_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_skewness_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_skewness_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_skewness_types[6]</span>
<span class="s0">cdef char *ufunc__nbinom_skewness_doc = (</span>
    <span class="s0">&quot;_nbinom_skewness(r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Skewness of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_skewness_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nbinom_skewness_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nbinom_skewness_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_skewness_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_skewness_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_skewness_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_skewness_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_skewness_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_skewness_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_skewness_float</span>
<span class="s0">ufunc__nbinom_skewness_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_skewness&quot;)</span>
<span class="s0">ufunc__nbinom_skewness_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_skewness_double</span>
<span class="s0">ufunc__nbinom_skewness_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_skewness&quot;)</span>
<span class="s0">ufunc__nbinom_skewness_data[0] = &amp;ufunc__nbinom_skewness_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_skewness_data[1] = &amp;ufunc__nbinom_skewness_ptr[2*1]</span>
<span class="s0">_nbinom_skewness = np.PyUFunc_FromFuncAndData(ufunc__nbinom_skewness_loops, ufunc__nbinom_skewness_data, ufunc__nbinom_skewness_types, 2, 2, 1, 0, &quot;_nbinom_skewness&quot;, ufunc__nbinom_skewness_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nbinom_variance_loops[2]</span>
<span class="s0">cdef void *ufunc__nbinom_variance_ptr[4]</span>
<span class="s0">cdef void *ufunc__nbinom_variance_data[2]</span>
<span class="s0">cdef char ufunc__nbinom_variance_types[6]</span>
<span class="s0">cdef char *ufunc__nbinom_variance_doc = (</span>
    <span class="s0">&quot;_nbinom_variance(r, p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Variance of negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, integer-valued parameter\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nbinom_variance_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nbinom_variance_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nbinom_variance_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_variance_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_variance_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nbinom_variance_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_variance_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_variance_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nbinom_variance_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_variance_float</span>
<span class="s0">ufunc__nbinom_variance_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_variance&quot;)</span>
<span class="s0">ufunc__nbinom_variance_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nbinom_variance_double</span>
<span class="s0">ufunc__nbinom_variance_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nbinom_variance&quot;)</span>
<span class="s0">ufunc__nbinom_variance_data[0] = &amp;ufunc__nbinom_variance_ptr[2*0]</span>
<span class="s0">ufunc__nbinom_variance_data[1] = &amp;ufunc__nbinom_variance_ptr[2*1]</span>
<span class="s0">_nbinom_variance = np.PyUFunc_FromFuncAndData(ufunc__nbinom_variance_loops, ufunc__nbinom_variance_data, ufunc__nbinom_variance_types, 2, 2, 1, 0, &quot;_nbinom_variance&quot;, ufunc__nbinom_variance_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_cdf_data[2]</span>
<span class="s0">cdef char ufunc__ncf_cdf_types[10]</span>
<span class="s0">cdef char *ufunc__ncf_cdf_doc = (</span>
    <span class="s0">&quot;_ncf_cdf(x, v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__ncf_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__ncf_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_cdf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_cdf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_cdf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_cdf_float</span>
<span class="s0">ufunc__ncf_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_cdf&quot;)</span>
<span class="s0">ufunc__ncf_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_cdf_double</span>
<span class="s0">ufunc__ncf_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_cdf&quot;)</span>
<span class="s0">ufunc__ncf_cdf_data[0] = &amp;ufunc__ncf_cdf_ptr[2*0]</span>
<span class="s0">ufunc__ncf_cdf_data[1] = &amp;ufunc__ncf_cdf_ptr[2*1]</span>
<span class="s0">_ncf_cdf = np.PyUFunc_FromFuncAndData(ufunc__ncf_cdf_loops, ufunc__ncf_cdf_data, ufunc__ncf_cdf_types, 2, 4, 1, 0, &quot;_ncf_cdf&quot;, ufunc__ncf_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_isf_data[2]</span>
<span class="s0">cdef char ufunc__ncf_isf_types[10]</span>
<span class="s0">cdef char *ufunc__ncf_isf_doc = (</span>
    <span class="s0">&quot;_ncf_isf(x, v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse surivial function of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__ncf_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__ncf_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_isf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_isf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_isf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_isf_float</span>
<span class="s0">ufunc__ncf_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_isf&quot;)</span>
<span class="s0">ufunc__ncf_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_isf_double</span>
<span class="s0">ufunc__ncf_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_isf&quot;)</span>
<span class="s0">ufunc__ncf_isf_data[0] = &amp;ufunc__ncf_isf_ptr[2*0]</span>
<span class="s0">ufunc__ncf_isf_data[1] = &amp;ufunc__ncf_isf_ptr[2*1]</span>
<span class="s0">_ncf_isf = np.PyUFunc_FromFuncAndData(ufunc__ncf_isf_loops, ufunc__ncf_isf_data, ufunc__ncf_isf_types, 2, 4, 1, 0, &quot;_ncf_isf&quot;, ufunc__ncf_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_kurtosis_excess_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_kurtosis_excess_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_kurtosis_excess_data[2]</span>
<span class="s0">cdef char ufunc__ncf_kurtosis_excess_types[8]</span>
<span class="s0">cdef char *ufunc__ncf_kurtosis_excess_doc = (</span>
    <span class="s0">&quot;_ncf_kurtosis_excess(v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kurtosis excess of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_kurtosis_excess_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncf_kurtosis_excess_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_kurtosis_excess_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_kurtosis_excess_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_float</span>
<span class="s0">ufunc__ncf_kurtosis_excess_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__ncf_kurtosis_excess_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_double</span>
<span class="s0">ufunc__ncf_kurtosis_excess_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__ncf_kurtosis_excess_data[0] = &amp;ufunc__ncf_kurtosis_excess_ptr[2*0]</span>
<span class="s0">ufunc__ncf_kurtosis_excess_data[1] = &amp;ufunc__ncf_kurtosis_excess_ptr[2*1]</span>
<span class="s0">_ncf_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__ncf_kurtosis_excess_loops, ufunc__ncf_kurtosis_excess_data, ufunc__ncf_kurtosis_excess_types, 2, 3, 1, 0, &quot;_ncf_kurtosis_excess&quot;, ufunc__ncf_kurtosis_excess_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_mean_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_mean_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_mean_data[2]</span>
<span class="s0">cdef char ufunc__ncf_mean_types[8]</span>
<span class="s0">cdef char *ufunc__ncf_mean_doc = (</span>
    <span class="s0">&quot;_ncf_mean(v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Mean of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_mean_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncf_mean_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncf_mean_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_mean_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_mean_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_mean_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_mean_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_mean_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_mean_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_mean_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_mean_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_mean_float</span>
<span class="s0">ufunc__ncf_mean_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_mean&quot;)</span>
<span class="s0">ufunc__ncf_mean_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_mean_double</span>
<span class="s0">ufunc__ncf_mean_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_mean&quot;)</span>
<span class="s0">ufunc__ncf_mean_data[0] = &amp;ufunc__ncf_mean_ptr[2*0]</span>
<span class="s0">ufunc__ncf_mean_data[1] = &amp;ufunc__ncf_mean_ptr[2*1]</span>
<span class="s0">_ncf_mean = np.PyUFunc_FromFuncAndData(ufunc__ncf_mean_loops, ufunc__ncf_mean_data, ufunc__ncf_mean_types, 2, 3, 1, 0, &quot;_ncf_mean&quot;, ufunc__ncf_mean_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_pdf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_pdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_pdf_data[2]</span>
<span class="s0">cdef char ufunc__ncf_pdf_types[10]</span>
<span class="s0">cdef char *ufunc__ncf_pdf_doc = (</span>
    <span class="s0">&quot;_ncf_pdf(x, v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability density function of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_pdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__ncf_pdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__ncf_pdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_pdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_pdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_pdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_pdf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_pdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_pdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_pdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_pdf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_pdf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_pdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_pdf_float</span>
<span class="s0">ufunc__ncf_pdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_pdf&quot;)</span>
<span class="s0">ufunc__ncf_pdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_pdf_double</span>
<span class="s0">ufunc__ncf_pdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_pdf&quot;)</span>
<span class="s0">ufunc__ncf_pdf_data[0] = &amp;ufunc__ncf_pdf_ptr[2*0]</span>
<span class="s0">ufunc__ncf_pdf_data[1] = &amp;ufunc__ncf_pdf_ptr[2*1]</span>
<span class="s0">_ncf_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncf_pdf_loops, ufunc__ncf_pdf_data, ufunc__ncf_pdf_types, 2, 4, 1, 0, &quot;_ncf_pdf&quot;, ufunc__ncf_pdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_ppf_data[2]</span>
<span class="s0">cdef char ufunc__ncf_ppf_types[10]</span>
<span class="s0">cdef char *ufunc__ncf_ppf_doc = (</span>
    <span class="s0">&quot;_ncf_ppf(x, v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__ncf_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__ncf_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_ppf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_ppf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_ppf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_ppf_float</span>
<span class="s0">ufunc__ncf_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_ppf&quot;)</span>
<span class="s0">ufunc__ncf_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_ppf_double</span>
<span class="s0">ufunc__ncf_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_ppf&quot;)</span>
<span class="s0">ufunc__ncf_ppf_data[0] = &amp;ufunc__ncf_ppf_ptr[2*0]</span>
<span class="s0">ufunc__ncf_ppf_data[1] = &amp;ufunc__ncf_ppf_ptr[2*1]</span>
<span class="s0">_ncf_ppf = np.PyUFunc_FromFuncAndData(ufunc__ncf_ppf_loops, ufunc__ncf_ppf_data, ufunc__ncf_ppf_types, 2, 4, 1, 0, &quot;_ncf_ppf&quot;, ufunc__ncf_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_sf_data[2]</span>
<span class="s0">cdef char ufunc__ncf_sf_types[10]</span>
<span class="s0">cdef char *ufunc__ncf_sf_doc = (</span>
    <span class="s0">&quot;_ncf_sf(x, v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__ncf_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__ncf_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_sf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_sf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_sf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_sf_float</span>
<span class="s0">ufunc__ncf_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_sf&quot;)</span>
<span class="s0">ufunc__ncf_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_sf_double</span>
<span class="s0">ufunc__ncf_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_sf&quot;)</span>
<span class="s0">ufunc__ncf_sf_data[0] = &amp;ufunc__ncf_sf_ptr[2*0]</span>
<span class="s0">ufunc__ncf_sf_data[1] = &amp;ufunc__ncf_sf_ptr[2*1]</span>
<span class="s0">_ncf_sf = np.PyUFunc_FromFuncAndData(ufunc__ncf_sf_loops, ufunc__ncf_sf_data, ufunc__ncf_sf_types, 2, 4, 1, 0, &quot;_ncf_sf&quot;, ufunc__ncf_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_skewness_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_skewness_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_skewness_data[2]</span>
<span class="s0">cdef char ufunc__ncf_skewness_types[8]</span>
<span class="s0">cdef char *ufunc__ncf_skewness_doc = (</span>
    <span class="s0">&quot;_ncf_skewness(v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Skewness of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_skewness_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncf_skewness_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncf_skewness_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_skewness_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_skewness_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_skewness_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_skewness_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_skewness_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_skewness_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_skewness_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_skewness_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_skewness_float</span>
<span class="s0">ufunc__ncf_skewness_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_skewness&quot;)</span>
<span class="s0">ufunc__ncf_skewness_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_skewness_double</span>
<span class="s0">ufunc__ncf_skewness_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_skewness&quot;)</span>
<span class="s0">ufunc__ncf_skewness_data[0] = &amp;ufunc__ncf_skewness_ptr[2*0]</span>
<span class="s0">ufunc__ncf_skewness_data[1] = &amp;ufunc__ncf_skewness_ptr[2*1]</span>
<span class="s0">_ncf_skewness = np.PyUFunc_FromFuncAndData(ufunc__ncf_skewness_loops, ufunc__ncf_skewness_data, ufunc__ncf_skewness_types, 2, 3, 1, 0, &quot;_ncf_skewness&quot;, ufunc__ncf_skewness_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncf_variance_loops[2]</span>
<span class="s0">cdef void *ufunc__ncf_variance_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncf_variance_data[2]</span>
<span class="s0">cdef char ufunc__ncf_variance_types[8]</span>
<span class="s0">cdef char *ufunc__ncf_variance_doc = (</span>
    <span class="s0">&quot;_ncf_variance(v1, v2, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Variance of noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v1, v2, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncf_variance_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncf_variance_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncf_variance_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_variance_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_variance_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_variance_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncf_variance_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_variance_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_variance_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_variance_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncf_variance_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_variance_float</span>
<span class="s0">ufunc__ncf_variance_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_variance&quot;)</span>
<span class="s0">ufunc__ncf_variance_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncf_variance_double</span>
<span class="s0">ufunc__ncf_variance_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncf_variance&quot;)</span>
<span class="s0">ufunc__ncf_variance_data[0] = &amp;ufunc__ncf_variance_ptr[2*0]</span>
<span class="s0">ufunc__ncf_variance_data[1] = &amp;ufunc__ncf_variance_ptr[2*1]</span>
<span class="s0">_ncf_variance = np.PyUFunc_FromFuncAndData(ufunc__ncf_variance_loops, ufunc__ncf_variance_data, ufunc__ncf_variance_types, 2, 3, 1, 0, &quot;_ncf_variance&quot;, ufunc__ncf_variance_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_cdf_data[2]</span>
<span class="s0">cdef char ufunc__nct_cdf_types[8]</span>
<span class="s0">cdef char *ufunc__nct_cdf_doc = (</span>
    <span class="s0">&quot;_nct_cdf(x, v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nct_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nct_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_cdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_cdf_float</span>
<span class="s0">ufunc__nct_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_cdf&quot;)</span>
<span class="s0">ufunc__nct_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_cdf_double</span>
<span class="s0">ufunc__nct_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_cdf&quot;)</span>
<span class="s0">ufunc__nct_cdf_data[0] = &amp;ufunc__nct_cdf_ptr[2*0]</span>
<span class="s0">ufunc__nct_cdf_data[1] = &amp;ufunc__nct_cdf_ptr[2*1]</span>
<span class="s0">_nct_cdf = np.PyUFunc_FromFuncAndData(ufunc__nct_cdf_loops, ufunc__nct_cdf_data, ufunc__nct_cdf_types, 2, 3, 1, 0, &quot;_nct_cdf&quot;, ufunc__nct_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_isf_data[2]</span>
<span class="s0">cdef char ufunc__nct_isf_types[8]</span>
<span class="s0">cdef char *ufunc__nct_isf_doc = (</span>
    <span class="s0">&quot;_nct_isf(x, v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse surivial function of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nct_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nct_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_isf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_isf_float</span>
<span class="s0">ufunc__nct_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_isf&quot;)</span>
<span class="s0">ufunc__nct_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_isf_double</span>
<span class="s0">ufunc__nct_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_isf&quot;)</span>
<span class="s0">ufunc__nct_isf_data[0] = &amp;ufunc__nct_isf_ptr[2*0]</span>
<span class="s0">ufunc__nct_isf_data[1] = &amp;ufunc__nct_isf_ptr[2*1]</span>
<span class="s0">_nct_isf = np.PyUFunc_FromFuncAndData(ufunc__nct_isf_loops, ufunc__nct_isf_data, ufunc__nct_isf_types, 2, 3, 1, 0, &quot;_nct_isf&quot;, ufunc__nct_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_kurtosis_excess_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_kurtosis_excess_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_kurtosis_excess_data[2]</span>
<span class="s0">cdef char ufunc__nct_kurtosis_excess_types[6]</span>
<span class="s0">cdef char *ufunc__nct_kurtosis_excess_doc = (</span>
    <span class="s0">&quot;_nct_kurtosis_excess(v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kurtosis excess of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_kurtosis_excess_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nct_kurtosis_excess_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_kurtosis_excess_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_kurtosis_excess_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_float</span>
<span class="s0">ufunc__nct_kurtosis_excess_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__nct_kurtosis_excess_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_double</span>
<span class="s0">ufunc__nct_kurtosis_excess_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_kurtosis_excess&quot;)</span>
<span class="s0">ufunc__nct_kurtosis_excess_data[0] = &amp;ufunc__nct_kurtosis_excess_ptr[2*0]</span>
<span class="s0">ufunc__nct_kurtosis_excess_data[1] = &amp;ufunc__nct_kurtosis_excess_ptr[2*1]</span>
<span class="s0">_nct_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nct_kurtosis_excess_loops, ufunc__nct_kurtosis_excess_data, ufunc__nct_kurtosis_excess_types, 2, 2, 1, 0, &quot;_nct_kurtosis_excess&quot;, ufunc__nct_kurtosis_excess_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_mean_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_mean_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_mean_data[2]</span>
<span class="s0">cdef char ufunc__nct_mean_types[6]</span>
<span class="s0">cdef char *ufunc__nct_mean_doc = (</span>
    <span class="s0">&quot;_nct_mean(v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Mean of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_mean_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nct_mean_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nct_mean_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_mean_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_mean_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_mean_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_mean_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_mean_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_mean_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_mean_float</span>
<span class="s0">ufunc__nct_mean_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_mean&quot;)</span>
<span class="s0">ufunc__nct_mean_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_mean_double</span>
<span class="s0">ufunc__nct_mean_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_mean&quot;)</span>
<span class="s0">ufunc__nct_mean_data[0] = &amp;ufunc__nct_mean_ptr[2*0]</span>
<span class="s0">ufunc__nct_mean_data[1] = &amp;ufunc__nct_mean_ptr[2*1]</span>
<span class="s0">_nct_mean = np.PyUFunc_FromFuncAndData(ufunc__nct_mean_loops, ufunc__nct_mean_data, ufunc__nct_mean_types, 2, 2, 1, 0, &quot;_nct_mean&quot;, ufunc__nct_mean_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_ppf_data[2]</span>
<span class="s0">cdef char ufunc__nct_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__nct_ppf_doc = (</span>
    <span class="s0">&quot;_nct_ppf(x, v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nct_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nct_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_ppf_float</span>
<span class="s0">ufunc__nct_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_ppf&quot;)</span>
<span class="s0">ufunc__nct_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_ppf_double</span>
<span class="s0">ufunc__nct_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_ppf&quot;)</span>
<span class="s0">ufunc__nct_ppf_data[0] = &amp;ufunc__nct_ppf_ptr[2*0]</span>
<span class="s0">ufunc__nct_ppf_data[1] = &amp;ufunc__nct_ppf_ptr[2*1]</span>
<span class="s0">_nct_ppf = np.PyUFunc_FromFuncAndData(ufunc__nct_ppf_loops, ufunc__nct_ppf_data, ufunc__nct_ppf_types, 2, 3, 1, 0, &quot;_nct_ppf&quot;, ufunc__nct_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_sf_data[2]</span>
<span class="s0">cdef char ufunc__nct_sf_types[8]</span>
<span class="s0">cdef char *ufunc__nct_sf_doc = (</span>
    <span class="s0">&quot;_nct_sf(x, v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__nct_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__nct_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_sf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_sf_float</span>
<span class="s0">ufunc__nct_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_sf&quot;)</span>
<span class="s0">ufunc__nct_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_sf_double</span>
<span class="s0">ufunc__nct_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_sf&quot;)</span>
<span class="s0">ufunc__nct_sf_data[0] = &amp;ufunc__nct_sf_ptr[2*0]</span>
<span class="s0">ufunc__nct_sf_data[1] = &amp;ufunc__nct_sf_ptr[2*1]</span>
<span class="s0">_nct_sf = np.PyUFunc_FromFuncAndData(ufunc__nct_sf_loops, ufunc__nct_sf_data, ufunc__nct_sf_types, 2, 3, 1, 0, &quot;_nct_sf&quot;, ufunc__nct_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_skewness_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_skewness_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_skewness_data[2]</span>
<span class="s0">cdef char ufunc__nct_skewness_types[6]</span>
<span class="s0">cdef char *ufunc__nct_skewness_doc = (</span>
    <span class="s0">&quot;_nct_skewness(v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Skewness of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_skewness_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nct_skewness_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nct_skewness_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_skewness_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_skewness_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_skewness_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_skewness_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_skewness_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_skewness_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_skewness_float</span>
<span class="s0">ufunc__nct_skewness_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_skewness&quot;)</span>
<span class="s0">ufunc__nct_skewness_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_skewness_double</span>
<span class="s0">ufunc__nct_skewness_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_skewness&quot;)</span>
<span class="s0">ufunc__nct_skewness_data[0] = &amp;ufunc__nct_skewness_ptr[2*0]</span>
<span class="s0">ufunc__nct_skewness_data[1] = &amp;ufunc__nct_skewness_ptr[2*1]</span>
<span class="s0">_nct_skewness = np.PyUFunc_FromFuncAndData(ufunc__nct_skewness_loops, ufunc__nct_skewness_data, ufunc__nct_skewness_types, 2, 2, 1, 0, &quot;_nct_skewness&quot;, ufunc__nct_skewness_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__nct_variance_loops[2]</span>
<span class="s0">cdef void *ufunc__nct_variance_ptr[4]</span>
<span class="s0">cdef void *ufunc__nct_variance_data[2]</span>
<span class="s0">cdef char ufunc__nct_variance_types[6]</span>
<span class="s0">cdef char *ufunc__nct_variance_doc = (</span>
    <span class="s0">&quot;_nct_variance(v, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Variance of noncentral t-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__nct_variance_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc__nct_variance_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__nct_variance_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_variance_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_variance_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__nct_variance_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_variance_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_variance_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__nct_variance_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_variance_float</span>
<span class="s0">ufunc__nct_variance_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_variance&quot;)</span>
<span class="s0">ufunc__nct_variance_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_nct_variance_double</span>
<span class="s0">ufunc__nct_variance_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_nct_variance&quot;)</span>
<span class="s0">ufunc__nct_variance_data[0] = &amp;ufunc__nct_variance_ptr[2*0]</span>
<span class="s0">ufunc__nct_variance_data[1] = &amp;ufunc__nct_variance_ptr[2*1]</span>
<span class="s0">_nct_variance = np.PyUFunc_FromFuncAndData(ufunc__nct_variance_loops, ufunc__nct_variance_data, ufunc__nct_variance_types, 2, 2, 1, 0, &quot;_nct_variance&quot;, ufunc__nct_variance_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncx2_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncx2_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncx2_cdf_data[2]</span>
<span class="s0">cdef char ufunc__ncx2_cdf_types[8]</span>
<span class="s0">cdef char *ufunc__ncx2_cdf_doc = (</span>
    <span class="s0">&quot;_ncx2_cdf(x, k, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of Non-central chi-squared distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;k, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncx2_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncx2_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncx2_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_cdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_cdf_float</span>
<span class="s0">ufunc__ncx2_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_cdf&quot;)</span>
<span class="s0">ufunc__ncx2_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_cdf_double</span>
<span class="s0">ufunc__ncx2_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_cdf&quot;)</span>
<span class="s0">ufunc__ncx2_cdf_data[0] = &amp;ufunc__ncx2_cdf_ptr[2*0]</span>
<span class="s0">ufunc__ncx2_cdf_data[1] = &amp;ufunc__ncx2_cdf_ptr[2*1]</span>
<span class="s0">_ncx2_cdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_cdf_loops, ufunc__ncx2_cdf_data, ufunc__ncx2_cdf_types, 2, 3, 1, 0, &quot;_ncx2_cdf&quot;, ufunc__ncx2_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncx2_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncx2_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncx2_isf_data[2]</span>
<span class="s0">cdef char ufunc__ncx2_isf_types[8]</span>
<span class="s0">cdef char *ufunc__ncx2_isf_doc = (</span>
    <span class="s0">&quot;_ncx2_isf(x, k, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse survival function of Non-central chi-squared distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;k, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncx2_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncx2_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncx2_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_isf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_isf_float</span>
<span class="s0">ufunc__ncx2_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_isf&quot;)</span>
<span class="s0">ufunc__ncx2_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_isf_double</span>
<span class="s0">ufunc__ncx2_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_isf&quot;)</span>
<span class="s0">ufunc__ncx2_isf_data[0] = &amp;ufunc__ncx2_isf_ptr[2*0]</span>
<span class="s0">ufunc__ncx2_isf_data[1] = &amp;ufunc__ncx2_isf_ptr[2*1]</span>
<span class="s0">_ncx2_isf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_isf_loops, ufunc__ncx2_isf_data, ufunc__ncx2_isf_types, 2, 3, 1, 0, &quot;_ncx2_isf&quot;, ufunc__ncx2_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncx2_pdf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncx2_pdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncx2_pdf_data[2]</span>
<span class="s0">cdef char ufunc__ncx2_pdf_types[8]</span>
<span class="s0">cdef char *ufunc__ncx2_pdf_doc = (</span>
    <span class="s0">&quot;_ncx2_pdf(x, k, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Probability density function of Non-central chi-squared distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;k, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncx2_pdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncx2_pdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncx2_pdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_pdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_pdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_pdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_pdf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_pdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_pdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_pdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_pdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_pdf_float</span>
<span class="s0">ufunc__ncx2_pdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_pdf&quot;)</span>
<span class="s0">ufunc__ncx2_pdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_pdf_double</span>
<span class="s0">ufunc__ncx2_pdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_pdf&quot;)</span>
<span class="s0">ufunc__ncx2_pdf_data[0] = &amp;ufunc__ncx2_pdf_ptr[2*0]</span>
<span class="s0">ufunc__ncx2_pdf_data[1] = &amp;ufunc__ncx2_pdf_ptr[2*1]</span>
<span class="s0">_ncx2_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_pdf_loops, ufunc__ncx2_pdf_data, ufunc__ncx2_pdf_types, 2, 3, 1, 0, &quot;_ncx2_pdf&quot;, ufunc__ncx2_pdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncx2_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncx2_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncx2_ppf_data[2]</span>
<span class="s0">cdef char ufunc__ncx2_ppf_types[8]</span>
<span class="s0">cdef char *ufunc__ncx2_ppf_doc = (</span>
    <span class="s0">&quot;_ncx2_ppf(x, k, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of Non-central chi-squared distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;k, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncx2_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncx2_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncx2_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_ppf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_ppf_float</span>
<span class="s0">ufunc__ncx2_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_ppf&quot;)</span>
<span class="s0">ufunc__ncx2_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_ppf_double</span>
<span class="s0">ufunc__ncx2_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_ppf&quot;)</span>
<span class="s0">ufunc__ncx2_ppf_data[0] = &amp;ufunc__ncx2_ppf_ptr[2*0]</span>
<span class="s0">ufunc__ncx2_ppf_data[1] = &amp;ufunc__ncx2_ppf_ptr[2*1]</span>
<span class="s0">_ncx2_ppf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_ppf_loops, ufunc__ncx2_ppf_data, ufunc__ncx2_ppf_types, 2, 3, 1, 0, &quot;_ncx2_ppf&quot;, ufunc__ncx2_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ncx2_sf_loops[2]</span>
<span class="s0">cdef void *ufunc__ncx2_sf_ptr[4]</span>
<span class="s0">cdef void *ufunc__ncx2_sf_data[2]</span>
<span class="s0">cdef char ufunc__ncx2_sf_types[8]</span>
<span class="s0">cdef char *ufunc__ncx2_sf_doc = (</span>
    <span class="s0">&quot;_ncx2_sf(x, k, l)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Survival function of Non-central chi-squared distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive real-valued\n&quot;</span>
    <span class="s0">&quot;k, l : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__ncx2_sf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc__ncx2_sf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc__ncx2_sf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_sf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_sf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_sf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ncx2_sf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_sf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_sf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_sf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ncx2_sf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_sf_float</span>
<span class="s0">ufunc__ncx2_sf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_sf&quot;)</span>
<span class="s0">ufunc__ncx2_sf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ncx2_sf_double</span>
<span class="s0">ufunc__ncx2_sf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ncx2_sf&quot;)</span>
<span class="s0">ufunc__ncx2_sf_data[0] = &amp;ufunc__ncx2_sf_ptr[2*0]</span>
<span class="s0">ufunc__ncx2_sf_data[1] = &amp;ufunc__ncx2_sf_ptr[2*1]</span>
<span class="s0">_ncx2_sf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_sf_loops, ufunc__ncx2_sf_data, ufunc__ncx2_sf_types, 2, 3, 1, 0, &quot;_ncx2_sf&quot;, ufunc__ncx2_sf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__riemann_zeta_loops[2]</span>
<span class="s0">cdef void *ufunc__riemann_zeta_ptr[4]</span>
<span class="s0">cdef void *ufunc__riemann_zeta_data[2]</span>
<span class="s0">cdef char ufunc__riemann_zeta_types[4]</span>
<span class="s0">cdef char *ufunc__riemann_zeta_doc = (</span>
    <span class="s0">&quot;Internal function, use `zeta` instead.&quot;)</span>
<span class="s0">ufunc__riemann_zeta_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__riemann_zeta_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__riemann_zeta_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__riemann_zeta_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__riemann_zeta_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__riemann_zeta_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*0] = &lt;void*&gt;_func_cephes_riemann_zeta</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_riemann_zeta&quot;)</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*1] = &lt;void*&gt;_func_cephes_riemann_zeta</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_riemann_zeta&quot;)</span>
<span class="s0">ufunc__riemann_zeta_data[0] = &amp;ufunc__riemann_zeta_ptr[2*0]</span>
<span class="s0">ufunc__riemann_zeta_data[1] = &amp;ufunc__riemann_zeta_ptr[2*1]</span>
<span class="s0">_riemann_zeta = np.PyUFunc_FromFuncAndData(ufunc__riemann_zeta_loops, ufunc__riemann_zeta_data, ufunc__riemann_zeta_types, 2, 1, 1, 0, &quot;_riemann_zeta&quot;, ufunc__riemann_zeta_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]</span>
<span class="s0">cdef void *ufunc__sf_error_test_function_ptr[2]</span>
<span class="s0">cdef void *ufunc__sf_error_test_function_data[1]</span>
<span class="s0">cdef char ufunc__sf_error_test_function_types[2]</span>
<span class="s0">cdef char *ufunc__sf_error_test_function_doc = (</span>
    <span class="s0">&quot;Private function; do not use.&quot;)</span>
<span class="s0">ufunc__sf_error_test_function_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_i__As_l_l</span>
<span class="s0">ufunc__sf_error_test_function_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__sf_error_test_function_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__sf_error_test_function_ptr[2*0] = &lt;void*&gt;_func__sf_error_test_function</span>
<span class="s0">ufunc__sf_error_test_function_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sf_error_test_function&quot;)</span>
<span class="s0">ufunc__sf_error_test_function_data[0] = &amp;ufunc__sf_error_test_function_ptr[2*0]</span>
<span class="s0">_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, &quot;_sf_error_test_function&quot;, ufunc__sf_error_test_function_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__skewnorm_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__skewnorm_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__skewnorm_cdf_data[2]</span>
<span class="s0">cdef char ufunc__skewnorm_cdf_types[10]</span>
<span class="s0">cdef char *ufunc__skewnorm_cdf_doc = (</span>
    <span class="s0">&quot;_skewnorm_cdf(x, l, sc, sh)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative density function of skewnorm distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sc : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sh : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__skewnorm_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__skewnorm_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__skewnorm_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_cdf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_cdf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_cdf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_cdf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_cdf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_cdf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_cdf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_cdf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_cdf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_cdf_float</span>
<span class="s0">ufunc__skewnorm_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_cdf&quot;)</span>
<span class="s0">ufunc__skewnorm_cdf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_cdf_double</span>
<span class="s0">ufunc__skewnorm_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_cdf&quot;)</span>
<span class="s0">ufunc__skewnorm_cdf_data[0] = &amp;ufunc__skewnorm_cdf_ptr[2*0]</span>
<span class="s0">ufunc__skewnorm_cdf_data[1] = &amp;ufunc__skewnorm_cdf_ptr[2*1]</span>
<span class="s0">_skewnorm_cdf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_cdf_loops, ufunc__skewnorm_cdf_data, ufunc__skewnorm_cdf_types, 2, 4, 1, 0, &quot;_skewnorm_cdf&quot;, ufunc__skewnorm_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__skewnorm_isf_loops[2]</span>
<span class="s0">cdef void *ufunc__skewnorm_isf_ptr[4]</span>
<span class="s0">cdef void *ufunc__skewnorm_isf_data[2]</span>
<span class="s0">cdef char ufunc__skewnorm_isf_types[10]</span>
<span class="s0">cdef char *ufunc__skewnorm_isf_doc = (</span>
    <span class="s0">&quot;_skewnorm_isf(x, l, sc, sh)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse surivial function of skewnorm distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sc : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sh : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__skewnorm_isf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__skewnorm_isf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__skewnorm_isf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_isf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_isf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_isf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_isf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_isf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_isf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_isf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_isf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_isf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_isf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_isf_float</span>
<span class="s0">ufunc__skewnorm_isf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_isf&quot;)</span>
<span class="s0">ufunc__skewnorm_isf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_isf_double</span>
<span class="s0">ufunc__skewnorm_isf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_isf&quot;)</span>
<span class="s0">ufunc__skewnorm_isf_data[0] = &amp;ufunc__skewnorm_isf_ptr[2*0]</span>
<span class="s0">ufunc__skewnorm_isf_data[1] = &amp;ufunc__skewnorm_isf_ptr[2*1]</span>
<span class="s0">_skewnorm_isf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_isf_loops, ufunc__skewnorm_isf_data, ufunc__skewnorm_isf_types, 2, 4, 1, 0, &quot;_skewnorm_isf&quot;, ufunc__skewnorm_isf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__skewnorm_ppf_loops[2]</span>
<span class="s0">cdef void *ufunc__skewnorm_ppf_ptr[4]</span>
<span class="s0">cdef void *ufunc__skewnorm_ppf_data[2]</span>
<span class="s0">cdef char ufunc__skewnorm_ppf_types[10]</span>
<span class="s0">cdef char *ufunc__skewnorm_ppf_doc = (</span>
    <span class="s0">&quot;_skewnorm_ppf(x, l, sc, sh)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Percent point function of skewnorm distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued\n&quot;</span>
    <span class="s0">&quot;l : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sc : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;sh : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray&quot;)</span>
<span class="s0">ufunc__skewnorm_ppf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ffff__As_ffff_f</span>
<span class="s0">ufunc__skewnorm_ppf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc__skewnorm_ppf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_ppf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_ppf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_ppf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_ppf_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__skewnorm_ppf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_ppf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_ppf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_ppf_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_ppf_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__skewnorm_ppf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_ppf_float</span>
<span class="s0">ufunc__skewnorm_ppf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_ppf&quot;)</span>
<span class="s0">ufunc__skewnorm_ppf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_skewnorm_ppf_double</span>
<span class="s0">ufunc__skewnorm_ppf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_skewnorm_ppf&quot;)</span>
<span class="s0">ufunc__skewnorm_ppf_data[0] = &amp;ufunc__skewnorm_ppf_ptr[2*0]</span>
<span class="s0">ufunc__skewnorm_ppf_data[1] = &amp;ufunc__skewnorm_ppf_ptr[2*1]</span>
<span class="s0">_skewnorm_ppf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_ppf_loops, ufunc__skewnorm_ppf_data, ufunc__skewnorm_ppf_types, 2, 4, 1, 0, &quot;_skewnorm_ppf&quot;, ufunc__skewnorm_ppf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovc_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovc_data[3]</span>
<span class="s0">cdef char ufunc__smirnovc_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovc_doc = (</span>
    <span class="s0">&quot;_smirnovc(n, d)\n&quot;</span>
    <span class="s0">&quot; Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc__smirnovc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovc_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__smirnovc_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_ptr[2*0] = &lt;void*&gt;_func_cephes_smirnovc_wrap</span>
<span class="s0">ufunc__smirnovc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_ptr[2*1] = &lt;void*&gt;_func_smirnovc_unsafe</span>
<span class="s0">ufunc__smirnovc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_ptr[2*2] = &lt;void*&gt;_func_smirnovc_unsafe</span>
<span class="s0">ufunc__smirnovc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_data[0] = &amp;ufunc__smirnovc_ptr[2*0]</span>
<span class="s0">ufunc__smirnovc_data[1] = &amp;ufunc__smirnovc_ptr[2*1]</span>
<span class="s0">ufunc__smirnovc_data[2] = &amp;ufunc__smirnovc_ptr[2*2]</span>
<span class="s0">_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, &quot;_smirnovc&quot;, ufunc__smirnovc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovci_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovci_data[3]</span>
<span class="s0">cdef char ufunc__smirnovci_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovci_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovci_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc__smirnovci_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovci_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovci_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__smirnovci_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_ptr[2*0] = &lt;void*&gt;_func_cephes_smirnovci_wrap</span>
<span class="s0">ufunc__smirnovci_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_ptr[2*1] = &lt;void*&gt;_func_smirnovci_unsafe</span>
<span class="s0">ufunc__smirnovci_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_ptr[2*2] = &lt;void*&gt;_func_smirnovci_unsafe</span>
<span class="s0">ufunc__smirnovci_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_data[0] = &amp;ufunc__smirnovci_ptr[2*0]</span>
<span class="s0">ufunc__smirnovci_data[1] = &amp;ufunc__smirnovci_ptr[2*1]</span>
<span class="s0">ufunc__smirnovci_data[2] = &amp;ufunc__smirnovci_ptr[2*2]</span>
<span class="s0">_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, &quot;_smirnovci&quot;, ufunc__smirnovci_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovp_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovp_data[3]</span>
<span class="s0">cdef char ufunc__smirnovp_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovp_doc = (</span>
    <span class="s0">&quot;_smirnovp(n, p)\n&quot;</span>
    <span class="s0">&quot; Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc__smirnovp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovp_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovp_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__smirnovp_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_ptr[2*0] = &lt;void*&gt;_func_cephes_smirnovp_wrap</span>
<span class="s0">ufunc__smirnovp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_ptr[2*1] = &lt;void*&gt;_func_smirnovp_unsafe</span>
<span class="s0">ufunc__smirnovp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_ptr[2*2] = &lt;void*&gt;_func_smirnovp_unsafe</span>
<span class="s0">ufunc__smirnovp_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_data[0] = &amp;ufunc__smirnovp_ptr[2*0]</span>
<span class="s0">ufunc__smirnovp_data[1] = &amp;ufunc__smirnovp_ptr[2*1]</span>
<span class="s0">ufunc__smirnovp_data[2] = &amp;ufunc__smirnovp_ptr[2*2]</span>
<span class="s0">_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, &quot;_smirnovp&quot;, ufunc__smirnovp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__stirling2_inexact_loops[2]</span>
<span class="s0">cdef void *ufunc__stirling2_inexact_ptr[4]</span>
<span class="s0">cdef void *ufunc__stirling2_inexact_data[2]</span>
<span class="s0">cdef char ufunc__stirling2_inexact_types[6]</span>
<span class="s0">cdef char *ufunc__stirling2_inexact_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__stirling2_inexact_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__stirling2_inexact_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__stirling2_inexact_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__stirling2_inexact_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__stirling2_inexact_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__stirling2_inexact_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__stirling2_inexact_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__stirling2_inexact_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__stirling2_inexact_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export__stirling2_inexact</span>
<span class="s0">ufunc__stirling2_inexact_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_stirling2_inexact&quot;)</span>
<span class="s0">ufunc__stirling2_inexact_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export__stirling2_inexact</span>
<span class="s0">ufunc__stirling2_inexact_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_stirling2_inexact&quot;)</span>
<span class="s0">ufunc__stirling2_inexact_data[0] = &amp;ufunc__stirling2_inexact_ptr[2*0]</span>
<span class="s0">ufunc__stirling2_inexact_data[1] = &amp;ufunc__stirling2_inexact_ptr[2*1]</span>
<span class="s0">_stirling2_inexact = np.PyUFunc_FromFuncAndData(ufunc__stirling2_inexact_loops, ufunc__stirling2_inexact_data, ufunc__stirling2_inexact_types, 2, 2, 1, 0, &quot;_stirling2_inexact&quot;, ufunc__stirling2_inexact_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_asymp_large_z_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_asymp_large_z_data[1]</span>
<span class="s0">cdef char ufunc__struve_asymp_large_z_types[5]</span>
<span class="s0">cdef char *ufunc__struve_asymp_large_z_doc = (</span>
    <span class="s0">&quot;_struve_asymp_large_z(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using asymptotic expansion\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_asymp_large_z_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddp_d_As_ddp_dd</span>
<span class="s0">ufunc__struve_asymp_large_z_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[2] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__struve_asymp_large_z_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_ptr[2*0] = &lt;void*&gt;_func_cephes__struve_asymp_large_z</span>
<span class="s0">ufunc__struve_asymp_large_z_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_asymp_large_z&quot;)</span>
<span class="s0">ufunc__struve_asymp_large_z_data[0] = &amp;ufunc__struve_asymp_large_z_ptr[2*0]</span>
<span class="s0">_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, &quot;_struve_asymp_large_z&quot;, ufunc__struve_asymp_large_z_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_bessel_series_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_bessel_series_data[1]</span>
<span class="s0">cdef char ufunc__struve_bessel_series_types[5]</span>
<span class="s0">cdef char *ufunc__struve_bessel_series_doc = (</span>
    <span class="s0">&quot;_struve_bessel_series(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using Bessel function series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_bessel_series_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddp_d_As_ddp_dd</span>
<span class="s0">ufunc__struve_bessel_series_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[2] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__struve_bessel_series_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_ptr[2*0] = &lt;void*&gt;_func_cephes__struve_bessel_series</span>
<span class="s0">ufunc__struve_bessel_series_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_bessel_series&quot;)</span>
<span class="s0">ufunc__struve_bessel_series_data[0] = &amp;ufunc__struve_bessel_series_ptr[2*0]</span>
<span class="s0">_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, &quot;_struve_bessel_series&quot;, ufunc__struve_bessel_series_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_power_series_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_power_series_data[1]</span>
<span class="s0">cdef char ufunc__struve_power_series_types[5]</span>
<span class="s0">cdef char *ufunc__struve_power_series_doc = (</span>
    <span class="s0">&quot;_struve_power_series(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using power series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_power_series_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddp_d_As_ddp_dd</span>
<span class="s0">ufunc__struve_power_series_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[2] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc__struve_power_series_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_ptr[2*0] = &lt;void*&gt;_func_cephes__struve_power_series</span>
<span class="s0">ufunc__struve_power_series_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_power_series&quot;)</span>
<span class="s0">ufunc__struve_power_series_data[0] = &amp;ufunc__struve_power_series_ptr[2*0]</span>
<span class="s0">_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, &quot;_struve_power_series&quot;, ufunc__struve_power_series_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]</span>
<span class="s0">cdef void *ufunc_agm_ptr[4]</span>
<span class="s0">cdef void *ufunc_agm_data[2]</span>
<span class="s0">cdef char ufunc_agm_types[6]</span>
<span class="s0">cdef char *ufunc_agm_doc = (</span>
    <span class="s0">&quot;agm(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the arithmetic-geometric mean of `a` and `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Start with a_0 = a and b_0 = b and iteratively compute::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    a_{n+1} = (a_n + b_n)/2\n&quot;</span>
    <span class="s0">&quot;    b_{n+1} = sqrt(a_n*b_n)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;a_n and b_n converge to the same limit as n increases; their common\n&quot;</span>
    <span class="s0">&quot;limit is agm(a, b).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real values only. If the values are both negative, the result\n&quot;</span>
    <span class="s0">&quot;    is negative. If one value is negative and the other is positive,\n&quot;</span>
    <span class="s0">&quot;    `nan` is returned.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The arithmetic-geometric mean of `a` and `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import agm\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 24.0, 6.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; agm(a, b)\n&quot;</span>
    <span class="s0">&quot;13.458171481725614\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that result to the iteration:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; while a != b:\n&quot;</span>
    <span class="s0">&quot;...     a, b = (a + b)/2, np.sqrt(a*b)\n&quot;</span>
    <span class="s0">&quot;...     print(\&quot;a = %19.16f  b=%19.16f\&quot; % (a, b))\n&quot;</span>
    <span class="s0">&quot;...\n&quot;</span>
    <span class="s0">&quot;a = 15.0000000000000000  b=12.0000000000000000\n&quot;</span>
    <span class="s0">&quot;a = 13.5000000000000000  b=13.4164078649987388\n&quot;</span>
    <span class="s0">&quot;a = 13.4582039324993694  b=13.4581390309909850\n&quot;</span>
    <span class="s0">&quot;a = 13.4581714817451772  b=13.4581714817060547\n&quot;</span>
    <span class="s0">&quot;a = 13.4581714817256159  b=13.4581714817256159\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When array-like arguments are given, broadcasting applies:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = np.array([6, 12, 24, 48])    # b has shape (4,).\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; agm(a, b)\n&quot;</span>
    <span class="s0">&quot;array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n&quot;</span>
    <span class="s0">&quot;       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n&quot;</span>
    <span class="s0">&quot;       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])&quot;)</span>
<span class="s0">ufunc_agm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_agm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_agm_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_ptr[2*0] = &lt;void*&gt;_func_agm</span>
<span class="s0">ufunc_agm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;agm&quot;)</span>
<span class="s0">ufunc_agm_ptr[2*1] = &lt;void*&gt;_func_agm</span>
<span class="s0">ufunc_agm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;agm&quot;)</span>
<span class="s0">ufunc_agm_data[0] = &amp;ufunc_agm_ptr[2*0]</span>
<span class="s0">ufunc_agm_data[1] = &amp;ufunc_agm_ptr[2*1]</span>
<span class="s0">agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, &quot;agm&quot;, ufunc_agm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtr_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtr_data[3]</span>
<span class="s0">cdef char ufunc_bdtr_types[12]</span>
<span class="s0">cdef char *ufunc_bdtr_doc = (</span>
    <span class="s0">&quot;bdtr(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Binomial distribution cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtr}(k, n, p) =\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (double), rounded down to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of `floor(k)` or fewer successes in `n` independent events with\n&quot;</span>
    <span class="s0">&quot;    success probabilities of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtr}(k, n, p) =\n&quot;</span>
    <span class="s0">&quot;    I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dpd__As_dpd_d</span>
<span class="s0">ufunc_bdtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[5] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_bdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_ptr[2*0] = &lt;void*&gt;_func_bdtr_unsafe</span>
<span class="s0">ufunc_bdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_bdtr_wrap</span>
<span class="s0">ufunc_bdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_ptr[2*2] = &lt;void*&gt;_func_bdtr_unsafe</span>
<span class="s0">ufunc_bdtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_data[0] = &amp;ufunc_bdtr_ptr[2*0]</span>
<span class="s0">ufunc_bdtr_data[1] = &amp;ufunc_bdtr_ptr[2*1]</span>
<span class="s0">ufunc_bdtr_data[2] = &amp;ufunc_bdtr_ptr[2*2]</span>
<span class="s0">bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, &quot;bdtr&quot;, ufunc_bdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtrc_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtrc_data[3]</span>
<span class="s0">cdef char ufunc_bdtrc_types[12]</span>
<span class="s0">cdef char *ufunc_bdtrc_doc = (</span>
    <span class="s0">&quot;bdtrc(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Binomial distribution survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n&quot;</span>
    <span class="s0">&quot;density,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtrc}(k, n, p) =\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (double), rounded down to nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (int)\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of `floor(k) + 1` or more successes in `n` independent\n&quot;</span>
    <span class="s0">&quot;    events with success probabilities of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;betainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dpd__As_dpd_d</span>
<span class="s0">ufunc_bdtrc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[5] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_bdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_ptr[2*0] = &lt;void*&gt;_func_bdtrc_unsafe</span>
<span class="s0">ufunc_bdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_ptr[2*1] = &lt;void*&gt;_func_cephes_bdtrc_wrap</span>
<span class="s0">ufunc_bdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_ptr[2*2] = &lt;void*&gt;_func_bdtrc_unsafe</span>
<span class="s0">ufunc_bdtrc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_data[0] = &amp;ufunc_bdtrc_ptr[2*0]</span>
<span class="s0">ufunc_bdtrc_data[1] = &amp;ufunc_bdtrc_ptr[2*1]</span>
<span class="s0">ufunc_bdtrc_data[2] = &amp;ufunc_bdtrc_ptr[2*2]</span>
<span class="s0">bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, &quot;bdtrc&quot;, ufunc_bdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtri_data[3]</span>
<span class="s0">cdef char ufunc_bdtri_types[12]</span>
<span class="s0">cdef char *ufunc_bdtri_doc = (</span>
    <span class="s0">&quot;bdtri(k, n, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the event probability `p` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the binomial probability density is equal to the given cumulative\n&quot;</span>
    <span class="s0">&quot;probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (float), rounded down to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (float)\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;p : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;betaincinv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The computation is carried out using the inverse beta integral function\n&quot;</span>
    <span class="s0">&quot;and the relation,::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    1 - p = betaincinv(n - k, k + 1, y).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dpd__As_dpd_d</span>
<span class="s0">ufunc_bdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[5] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_bdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_ptr[2*0] = &lt;void*&gt;_func_bdtri_unsafe</span>
<span class="s0">ufunc_bdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_ptr[2*1] = &lt;void*&gt;_func_cephes_bdtri_wrap</span>
<span class="s0">ufunc_bdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_ptr[2*2] = &lt;void*&gt;_func_bdtri_unsafe</span>
<span class="s0">ufunc_bdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_data[0] = &amp;ufunc_bdtri_ptr[2*0]</span>
<span class="s0">ufunc_bdtri_data[1] = &amp;ufunc_bdtri_ptr[2*1]</span>
<span class="s0">ufunc_bdtri_data[2] = &amp;ufunc_bdtri_ptr[2*2]</span>
<span class="s0">bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, &quot;bdtri&quot;, ufunc_bdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_bdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_bdtrik_data[2]</span>
<span class="s0">cdef char ufunc_bdtrik_types[8]</span>
<span class="s0">cdef char *ufunc_bdtrik_doc = (</span>
    <span class="s0">&quot;bdtrik(y, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the number of successes `k` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the Binomial probability density for `n` events with probability\n&quot;</span>
    <span class="s0">&quot;`p` is equal to the given cumulative probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Success probability (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;k : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of successes `k` such that `bdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n&quot;</span>
    <span class="s0">&quot;cumulative incomplete beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `k` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`. The search relies on the monotonicity of `y` with `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.&quot;)</span>
<span class="s0">ufunc_bdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_ptr[2*0] = &lt;void*&gt;_func_bdtrik</span>
<span class="s0">ufunc_bdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrik&quot;)</span>
<span class="s0">ufunc_bdtrik_ptr[2*1] = &lt;void*&gt;_func_bdtrik</span>
<span class="s0">ufunc_bdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrik&quot;)</span>
<span class="s0">ufunc_bdtrik_data[0] = &amp;ufunc_bdtrik_ptr[2*0]</span>
<span class="s0">ufunc_bdtrik_data[1] = &amp;ufunc_bdtrik_ptr[2*1]</span>
<span class="s0">bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, &quot;bdtrik&quot;, ufunc_bdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]</span>
<span class="s0">cdef void *ufunc_bdtrin_ptr[4]</span>
<span class="s0">cdef void *ufunc_bdtrin_data[2]</span>
<span class="s0">cdef char ufunc_bdtrin_types[8]</span>
<span class="s0">cdef char *ufunc_bdtrin_doc = (</span>
    <span class="s0">&quot;bdtrin(k, y, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the number of events `n` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the Binomial probability density for events with probability `p` is\n&quot;</span>
    <span class="s0">&quot;equal to the given cumulative probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (float).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Success probability (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;n : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of events `n` such that `bdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n&quot;</span>
    <span class="s0">&quot;cumulative incomplete beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `n` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`. The search relies on the monotonicity of `y` with `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.&quot;)</span>
<span class="s0">ufunc_bdtrin_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrin_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrin_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_ptr[2*0] = &lt;void*&gt;_func_bdtrin</span>
<span class="s0">ufunc_bdtrin_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrin&quot;)</span>
<span class="s0">ufunc_bdtrin_ptr[2*1] = &lt;void*&gt;_func_bdtrin</span>
<span class="s0">ufunc_bdtrin_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrin&quot;)</span>
<span class="s0">ufunc_bdtrin_data[0] = &amp;ufunc_bdtrin_ptr[2*0]</span>
<span class="s0">ufunc_bdtrin_data[1] = &amp;ufunc_bdtrin_ptr[2*1]</span>
<span class="s0">bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, &quot;bdtrin&quot;, ufunc_bdtrin_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]</span>
<span class="s0">cdef void *ufunc_besselpoly_ptr[4]</span>
<span class="s0">cdef void *ufunc_besselpoly_data[2]</span>
<span class="s0">cdef char ufunc_besselpoly_types[8]</span>
<span class="s0">cdef char *ufunc_besselpoly_doc = (</span>
    <span class="s0">&quot;besselpoly(a, lmb, nu, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Weighted integral of the Bessel function of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n&quot;</span>
    <span class="s0">&quot;:math:`\\nu=nu`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Scale factor inside the Bessel function.\n&quot;</span>
    <span class="s0">&quot;lmb : array_like\n&quot;</span>
    <span class="s0">&quot;    Power of `x`\n&quot;</span>
    <span class="s0">&quot;nu : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the Bessel function.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function for one parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import besselpoly\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; besselpoly(1, 1, 1)\n&quot;</span>
    <span class="s0">&quot;0.24449718372863877\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function for different scale factors.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; factors = np.array([0., 3., 6.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; besselpoly(factors, 1, 1)\n&quot;</span>
    <span class="s0">&quot;array([ 0.        , -0.00549029,  0.00140174])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for varying powers, orders and scales.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; powers = np.linspace(0, 10, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scales = [1, 2]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; all_combinations = [(order, scale) for order in orders\n&quot;</span>
    <span class="s0">&quot;...                     for scale in scales]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for order, scale in all_combinations:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(powers, besselpoly(scale, powers, order),\n&quot;</span>
    <span class="s0">&quot;...             label=rf\&quot;$\\nu={order}, a={scale}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r\&quot;$\\lambda$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(r\&quot;$\\int_0^1 x^{\\lambda} J_{\\nu}(2ax)\\,dx$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_besselpoly_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_besselpoly_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_besselpoly_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_ptr[2*0] = &lt;void*&gt;_func_cephes_besselpoly</span>
<span class="s0">ufunc_besselpoly_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;besselpoly&quot;)</span>
<span class="s0">ufunc_besselpoly_ptr[2*1] = &lt;void*&gt;_func_cephes_besselpoly</span>
<span class="s0">ufunc_besselpoly_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;besselpoly&quot;)</span>
<span class="s0">ufunc_besselpoly_data[0] = &amp;ufunc_besselpoly_ptr[2*0]</span>
<span class="s0">ufunc_besselpoly_data[1] = &amp;ufunc_besselpoly_ptr[2*1]</span>
<span class="s0">besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, &quot;besselpoly&quot;, ufunc_besselpoly_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]</span>
<span class="s0">cdef void *ufunc_beta_ptr[4]</span>
<span class="s0">cdef void *ufunc_beta_data[2]</span>
<span class="s0">cdef char ufunc_beta_types[6]</span>
<span class="s0">cdef char *ufunc_beta_doc = (</span>
    <span class="s0">&quot;beta(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined in [1]_ as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    B(a, b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt\n&quot;</span>
    <span class="s0">&quot;            = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued arguments\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function result\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;betainc :  the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betaln : the natural logarithm of the absolute\n&quot;</span>
    <span class="s0">&quot;         value of the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;       Eq. 5.12.1. https://dlmf.nist.gov/5.12\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The beta function relates to the gamma function by the\n&quot;</span>
    <span class="s0">&quot;definition given above:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(2, 3)\n&quot;</span>
    <span class="s0">&quot;0.08333333333333333\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)\n&quot;</span>
    <span class="s0">&quot;0.08333333333333333\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;As this relationship demonstrates, the beta function\n&quot;</span>
    <span class="s0">&quot;is symmetric:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(1.7, 2.4)\n&quot;</span>
    <span class="s0">&quot;0.16567527689031739\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(2.4, 1.7)\n&quot;</span>
    <span class="s0">&quot;0.16567527689031739\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function satisfies :math:`B(1, b) = 1/b`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(1, 4)\n&quot;</span>
    <span class="s0">&quot;0.25&quot;)</span>
<span class="s0">ufunc_beta_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_beta_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_beta_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_ptr[2*0] = &lt;void*&gt;_func_cephes_beta</span>
<span class="s0">ufunc_beta_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beta&quot;)</span>
<span class="s0">ufunc_beta_ptr[2*1] = &lt;void*&gt;_func_cephes_beta</span>
<span class="s0">ufunc_beta_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beta&quot;)</span>
<span class="s0">ufunc_beta_data[0] = &amp;ufunc_beta_ptr[2*0]</span>
<span class="s0">ufunc_beta_data[1] = &amp;ufunc_beta_ptr[2*1]</span>
<span class="s0">beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, &quot;beta&quot;, ufunc_beta_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]</span>
<span class="s0">cdef void *ufunc_betainc_ptr[4]</span>
<span class="s0">cdef void *ufunc_betainc_data[2]</span>
<span class="s0">cdef char ufunc_betainc_types[8]</span>
<span class="s0">cdef char *ufunc_betainc_doc = (</span>
    <span class="s0">&quot;betainc(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the regularized incomplete beta function, defined as [1]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n&quot;</span>
    <span class="s0">&quot;    t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`0 \\leq x \\leq 1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the cumulative distribution function for the beta\n&quot;</span>
    <span class="s0">&quot;distribution; its range is [0, 1].\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;       Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued such that :math:`0 \\leq x \\leq 1`,\n&quot;</span>
    <span class="s0">&quot;    the upper limit of integration\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;beta : beta function\n&quot;</span>
    <span class="s0">&quot;betaincinv : inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betaincc : complement of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.beta : beta distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The term *regularized* in the name of this function refers to the\n&quot;</span>
    <span class="s0">&quot;scaling of the function by the gamma function terms shown in the\n&quot;</span>
    <span class="s0">&quot;formula.  When not qualified as *regularized*, the name *incomplete\n&quot;</span>
    <span class="s0">&quot;beta function* often refers to just the integral expression,\n&quot;</span>
    <span class="s0">&quot;without the gamma terms.  One can use the function `beta` from\n&quot;</span>
    <span class="s0">&quot;`scipy.special` to get this \&quot;nonregularized\&quot; incomplete beta\n&quot;</span>
    <span class="s0">&quot;function by multiplying the result of ``betainc(a, b, x)`` by\n&quot;</span>
    <span class="s0">&quot;``beta(a, b)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Let :math:`B(a, b)` be the `beta` function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The coefficient in terms of `gamma` is equal to\n&quot;</span>
    <span class="s0">&quot;:math:`1/B(a, b)`. Also, when :math:`x=1`\n&quot;</span>
    <span class="s0">&quot;the integral is equal to :math:`B(a, b)`.\n&quot;</span>
    <span class="s0">&quot;Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(0.2, 3.5, 1.0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It satisfies\n&quot;</span>
    <span class="s0">&quot;:math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n&quot;</span>
    <span class="s0">&quot;where :math:`F` is the hypergeometric function `hyp2f1`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = 1.4, 3.1, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n&quot;</span>
    <span class="s0">&quot;0.8148904036225295\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.8148904036225296\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This functions satisfies the relationship\n&quot;</span>
    <span class="s0">&quot;:math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(2.2, 3.1, 0.4)\n&quot;</span>
    <span class="s0">&quot;0.49339638807619446\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n&quot;</span>
    <span class="s0">&quot;0.49339638807619446&quot;)</span>
<span class="s0">ufunc_betainc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc_betainc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betainc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibeta_float</span>
<span class="s0">ufunc_betainc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainc&quot;)</span>
<span class="s0">ufunc_betainc_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibeta_double</span>
<span class="s0">ufunc_betainc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainc&quot;)</span>
<span class="s0">ufunc_betainc_data[0] = &amp;ufunc_betainc_ptr[2*0]</span>
<span class="s0">ufunc_betainc_data[1] = &amp;ufunc_betainc_ptr[2*1]</span>
<span class="s0">betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, &quot;betainc&quot;, ufunc_betainc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betaincc_loops[2]</span>
<span class="s0">cdef void *ufunc_betaincc_ptr[4]</span>
<span class="s0">cdef void *ufunc_betaincc_data[2]</span>
<span class="s0">cdef char ufunc_betaincc_types[8]</span>
<span class="s0">cdef char *ufunc_betaincc_doc = (</span>
    <span class="s0">&quot;betaincc(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complement of the regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the complement of the regularized incomplete beta function,\n&quot;</span>
    <span class="s0">&quot;defined as [1]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\bar{I}_x(a, b) = 1 - I_x(a, b)\n&quot;</span>
    <span class="s0">&quot;                    = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n&quot;</span>
    <span class="s0">&quot;                              t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`0 \\leq x \\leq 1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;       Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued such that :math:`0 \\leq x \\leq 1`,\n&quot;</span>
    <span class="s0">&quot;    the upper limit of integration\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc : regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betaincinv : inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betainccinv :\n&quot;</span>
    <span class="s0">&quot;    inverse of the complement of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;beta : beta function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.beta : beta distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.11.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import betaincc, betainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The naive calculation ``1 - betainc(a, b, x)`` loses precision when\n&quot;</span>
    <span class="s0">&quot;the values of ``betainc(a, b, x)`` are close to 1:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - betainc(0.5, 8, [0.9, 0.99, 0.999])\n&quot;</span>
    <span class="s0">&quot;array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;By using ``betaincc``, we get the correct values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaincc(0.5, 8, [0.9, 0.99, 0.999])\n&quot;</span>
    <span class="s0">&quot;array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25])&quot;)</span>
<span class="s0">ufunc_betaincc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc_betaincc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betaincc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincc_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibetac_float</span>
<span class="s0">ufunc_betaincc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincc&quot;)</span>
<span class="s0">ufunc_betaincc_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibetac_double</span>
<span class="s0">ufunc_betaincc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincc&quot;)</span>
<span class="s0">ufunc_betaincc_data[0] = &amp;ufunc_betaincc_ptr[2*0]</span>
<span class="s0">ufunc_betaincc_data[1] = &amp;ufunc_betaincc_ptr[2*1]</span>
<span class="s0">betaincc = np.PyUFunc_FromFuncAndData(ufunc_betaincc_loops, ufunc_betaincc_data, ufunc_betaincc_types, 2, 3, 1, 0, &quot;betaincc&quot;, ufunc_betaincc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betainccinv_loops[2]</span>
<span class="s0">cdef void *ufunc_betainccinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_betainccinv_data[2]</span>
<span class="s0">cdef char ufunc_betainccinv_types[8]</span>
<span class="s0">cdef char *ufunc_betainccinv_doc = (</span>
    <span class="s0">&quot;betainccinv(a, b, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the complemented regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes :math:`x` such that:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = 1 - I_x(a, b) = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`I_x` is the normalized incomplete beta function `betainc`\n&quot;</span>
    <span class="s0">&quot;and :math:`\\Gamma` is the `gamma` function [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued input\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc : regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betaincc : complement of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.11.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import betainccinv, betaincc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of `betaincc` for fixed\n&quot;</span>
    <span class="s0">&quot;values of :math:`a` and :math:`b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 1.2, 3.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = betaincc(a, b, 0.2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betainccinv(a, b, y)\n&quot;</span>
    <span class="s0">&quot;0.2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 7, 2.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = betainccinv(a, b, 0.875)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaincc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.875&quot;)</span>
<span class="s0">ufunc_betainccinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc_betainccinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betainccinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainccinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainccinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainccinv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainccinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainccinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainccinv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainccinv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainccinv_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibetac_inv_float</span>
<span class="s0">ufunc_betainccinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainccinv&quot;)</span>
<span class="s0">ufunc_betainccinv_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibetac_inv_double</span>
<span class="s0">ufunc_betainccinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainccinv&quot;)</span>
<span class="s0">ufunc_betainccinv_data[0] = &amp;ufunc_betainccinv_ptr[2*0]</span>
<span class="s0">ufunc_betainccinv_data[1] = &amp;ufunc_betainccinv_ptr[2*1]</span>
<span class="s0">betainccinv = np.PyUFunc_FromFuncAndData(ufunc_betainccinv_loops, ufunc_betainccinv_data, ufunc_betainccinv_types, 2, 3, 1, 0, &quot;betainccinv&quot;, ufunc_betainccinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]</span>
<span class="s0">cdef void *ufunc_betaincinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_betaincinv_data[2]</span>
<span class="s0">cdef char ufunc_betaincinv_types[8]</span>
<span class="s0">cdef char *ufunc_betaincinv_doc = (</span>
    <span class="s0">&quot;betaincinv(a, b, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes :math:`x` such that:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`I_x` is the normalized incomplete beta function `betainc`\n&quot;</span>
    <span class="s0">&quot;and :math:`\\Gamma` is the `gamma` function [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued input\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc : regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;gamma : gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of `betainc` for fixed\n&quot;</span>
    <span class="s0">&quot;values of :math:`a` and :math:`b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 1.2, 3.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = sc.betainc(a, b, 0.2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betaincinv(a, b, y)\n&quot;</span>
    <span class="s0">&quot;0.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 7.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = sc.betaincinv(a, b, 0.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.5&quot;)</span>
<span class="s0">ufunc_betaincinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_fff__As_fff_f</span>
<span class="s0">ufunc_betaincinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betaincinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibeta_inv_float</span>
<span class="s0">ufunc_betaincinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincinv&quot;)</span>
<span class="s0">ufunc_betaincinv_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_ibeta_inv_double</span>
<span class="s0">ufunc_betaincinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincinv&quot;)</span>
<span class="s0">ufunc_betaincinv_data[0] = &amp;ufunc_betaincinv_ptr[2*0]</span>
<span class="s0">ufunc_betaincinv_data[1] = &amp;ufunc_betaincinv_ptr[2*1]</span>
<span class="s0">betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, &quot;betaincinv&quot;, ufunc_betaincinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]</span>
<span class="s0">cdef void *ufunc_betaln_ptr[4]</span>
<span class="s0">cdef void *ufunc_betaln_data[2]</span>
<span class="s0">cdef char ufunc_betaln_types[6]</span>
<span class="s0">cdef char *ufunc_betaln_doc = (</span>
    <span class="s0">&quot;betaln(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Natural logarithm of absolute value of beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes ``ln(abs(beta(a, b)))``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the betaln function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;betainc :  the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;beta : the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import betaln, beta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)``\n&quot;</span>
    <span class="s0">&quot;is the same as ``log(beta(a, b))``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaln(3, 4)\n&quot;</span>
    <span class="s0">&quot;-4.0943445622221\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(beta(3, 4))\n&quot;</span>
    <span class="s0">&quot;-4.0943445622221\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the following ``beta(a, b)`` underflows to 0, so we can't compute\n&quot;</span>
    <span class="s0">&quot;the logarithm of the actual value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 400\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 900\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; beta(a, b)\n&quot;</span>
    <span class="s0">&quot;0.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can compute the logarithm of ``beta(a, b)`` by using `betaln`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaln(a, b)\n&quot;</span>
    <span class="s0">&quot;-804.3069951764146&quot;)</span>
<span class="s0">ufunc_betaln_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_betaln_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_betaln_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_ptr[2*0] = &lt;void*&gt;_func_cephes_lbeta</span>
<span class="s0">ufunc_betaln_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaln&quot;)</span>
<span class="s0">ufunc_betaln_ptr[2*1] = &lt;void*&gt;_func_cephes_lbeta</span>
<span class="s0">ufunc_betaln_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaln&quot;)</span>
<span class="s0">ufunc_betaln_data[0] = &amp;ufunc_betaln_ptr[2*0]</span>
<span class="s0">ufunc_betaln_data[1] = &amp;ufunc_betaln_ptr[2*1]</span>
<span class="s0">betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, &quot;betaln&quot;, ufunc_betaln_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]</span>
<span class="s0">cdef void *ufunc_boxcox_ptr[4]</span>
<span class="s0">cdef void *ufunc_boxcox_data[2]</span>
<span class="s0">cdef char ufunc_boxcox_types[6]</span>
<span class="s0">cdef char *ufunc_boxcox_doc = (</span>
    <span class="s0">&quot;boxcox(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Box-Cox transformation is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(x)                  if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `nan` if ``x &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;Returns `-inf` if ``x == 0`` and ``lmbda &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.14.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;array([   0.        ,   12.4       ,  126.09110641])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox(2, [0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([ 0.69314718,  1.        ,  1.5       ])&quot;)</span>
<span class="s0">ufunc_boxcox_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_boxcox_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_boxcox_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_ptr[2*0] = &lt;void*&gt;_func_boxcox</span>
<span class="s0">ufunc_boxcox_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox&quot;)</span>
<span class="s0">ufunc_boxcox_ptr[2*1] = &lt;void*&gt;_func_boxcox</span>
<span class="s0">ufunc_boxcox_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox&quot;)</span>
<span class="s0">ufunc_boxcox_data[0] = &amp;ufunc_boxcox_ptr[2*0]</span>
<span class="s0">ufunc_boxcox_data[1] = &amp;ufunc_boxcox_ptr[2*1]</span>
<span class="s0">boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, &quot;boxcox&quot;, ufunc_boxcox_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]</span>
<span class="s0">cdef void *ufunc_boxcox1p_ptr[4]</span>
<span class="s0">cdef void *ufunc_boxcox1p_data[2]</span>
<span class="s0">cdef char ufunc_boxcox1p_types[6]</span>
<span class="s0">cdef char *ufunc_boxcox1p_doc = (</span>
    <span class="s0">&quot;boxcox1p(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Box-Cox transformation of 1 + `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Box-Cox transformation computed by `boxcox1p` is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(1+x)                    if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `nan` if ``x &lt; -1``.\n&quot;</span>
    <span class="s0">&quot;Returns `-inf` if ``x == -1`` and ``lmbda &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.14.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox1p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox1p(1e-4, [0, 0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox1p([0.01, 0.1], 0.25)\n&quot;</span>
    <span class="s0">&quot;array([ 0.00996272,  0.09645476])&quot;)</span>
<span class="s0">ufunc_boxcox1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_boxcox1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_boxcox1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_ptr[2*0] = &lt;void*&gt;_func_boxcox1p</span>
<span class="s0">ufunc_boxcox1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox1p&quot;)</span>
<span class="s0">ufunc_boxcox1p_ptr[2*1] = &lt;void*&gt;_func_boxcox1p</span>
<span class="s0">ufunc_boxcox1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox1p&quot;)</span>
<span class="s0">ufunc_boxcox1p_data[0] = &amp;ufunc_boxcox1p_ptr[2*0]</span>
<span class="s0">ufunc_boxcox1p_data[1] = &amp;ufunc_boxcox1p_ptr[2*1]</span>
<span class="s0">boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, &quot;boxcox1p&quot;, ufunc_boxcox1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtr_data[2]</span>
<span class="s0">cdef char ufunc_btdtr_types[8]</span>
<span class="s0">cdef char *ufunc_btdtr_doc = (</span>
    <span class="s0">&quot;btdtr(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral from zero to `x` of the beta probability density\n&quot;</span>
    <span class="s0">&quot;function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. deprecated:: 1.12.0\n&quot;</span>
    <span class="s0">&quot;    This function is deprecated and will be removed from SciPy 1.14.0.\n&quot;</span>
    <span class="s0">&quot;    Use `scipy.special.betainc` instead.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (a &gt; 0).\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (b &gt; 0).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper limit of integration, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cumulative distribution function of the beta distribution with\n&quot;</span>
    <span class="s0">&quot;    parameters `a` and `b` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This function is identical to the incomplete beta integral function\n&quot;</span>
    <span class="s0">&quot;`betainc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `btdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_btdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_btdtr</span>
<span class="s0">ufunc_btdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtr&quot;)</span>
<span class="s0">ufunc_btdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_btdtr</span>
<span class="s0">ufunc_btdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtr&quot;)</span>
<span class="s0">ufunc_btdtr_data[0] = &amp;ufunc_btdtr_ptr[2*0]</span>
<span class="s0">ufunc_btdtr_data[1] = &amp;ufunc_btdtr_ptr[2*1]</span>
<span class="s0">btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, &quot;btdtr&quot;, ufunc_btdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtri_data[2]</span>
<span class="s0">cdef char ufunc_btdtri_types[8]</span>
<span class="s0">cdef char *ufunc_btdtri_doc = (</span>
    <span class="s0">&quot;btdtri(a, b, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the beta cumulative distribution function,\n&quot;</span>
    <span class="s0">&quot;`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. deprecated:: 1.12.0\n&quot;</span>
    <span class="s0">&quot;    This function is deprecated and will be removed from SciPy 1.14.0.\n&quot;</span>
    <span class="s0">&quot;    Use `scipy.special.betaincinv` instead.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`a` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`b` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The quantile corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betaincinv\n&quot;</span>
    <span class="s0">&quot;btdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of `x` is found by interval halving or Newton iterations.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n&quot;</span>
    <span class="s0">&quot;problem of finding the inverse of the incomplete beta integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_btdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_ptr[2*0] = &lt;void*&gt;_func_cephes_btdtri</span>
<span class="s0">ufunc_btdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtri&quot;)</span>
<span class="s0">ufunc_btdtri_ptr[2*1] = &lt;void*&gt;_func_cephes_btdtri</span>
<span class="s0">ufunc_btdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtri&quot;)</span>
<span class="s0">ufunc_btdtri_data[0] = &amp;ufunc_btdtri_ptr[2*0]</span>
<span class="s0">ufunc_btdtri_data[1] = &amp;ufunc_btdtri_ptr[2*1]</span>
<span class="s0">btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, &quot;btdtri&quot;, ufunc_btdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtria_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtria_data[2]</span>
<span class="s0">cdef char ufunc_btdtria_types[8]</span>
<span class="s0">cdef char *ufunc_btdtria_doc = (</span>
    <span class="s0">&quot;btdtria(p, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `btdtr` with respect to `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse of the beta cumulative distribution function, `btdtr`,\n&quot;</span>
    <span class="s0">&quot;considered as a function of `a`, returning the value of `a` for which\n&quot;</span>
    <span class="s0">&quot;`btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`b` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;a : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;btdtr : Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;btdtri : Inverse with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;btdtrib : Inverse with respect to `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n&quot;</span>
    <span class="s0">&quot;       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.&quot;)</span>
<span class="s0">ufunc_btdtria_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtria_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtria_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_ptr[2*0] = &lt;void*&gt;_func_btdtria</span>
<span class="s0">ufunc_btdtria_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtria&quot;)</span>
<span class="s0">ufunc_btdtria_ptr[2*1] = &lt;void*&gt;_func_btdtria</span>
<span class="s0">ufunc_btdtria_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtria&quot;)</span>
<span class="s0">ufunc_btdtria_data[0] = &amp;ufunc_btdtria_ptr[2*0]</span>
<span class="s0">ufunc_btdtria_data[1] = &amp;ufunc_btdtria_ptr[2*1]</span>
<span class="s0">btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, &quot;btdtria&quot;, ufunc_btdtria_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtrib_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtrib_data[2]</span>
<span class="s0">cdef char ufunc_btdtrib_types[8]</span>
<span class="s0">cdef char *ufunc_btdtrib_doc = (</span>
    <span class="s0">&quot;btdtria(a, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `btdtr` with respect to `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse of the beta cumulative distribution function, `btdtr`,\n&quot;</span>
    <span class="s0">&quot;considered as a function of `b`, returning the value of `b` for which\n&quot;</span>
    <span class="s0">&quot;`btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`a` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;b : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;btdtr : Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;btdtri : Inverse with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;btdtria : Inverse with respect to `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n&quot;</span>
    <span class="s0">&quot;       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.&quot;)</span>
<span class="s0">ufunc_btdtrib_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtrib_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtrib_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_ptr[2*0] = &lt;void*&gt;_func_btdtrib</span>
<span class="s0">ufunc_btdtrib_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtrib&quot;)</span>
<span class="s0">ufunc_btdtrib_ptr[2*1] = &lt;void*&gt;_func_btdtrib</span>
<span class="s0">ufunc_btdtrib_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtrib&quot;)</span>
<span class="s0">ufunc_btdtrib_data[0] = &amp;ufunc_btdtrib_ptr[2*0]</span>
<span class="s0">ufunc_btdtrib_data[1] = &amp;ufunc_btdtrib_ptr[2*1]</span>
<span class="s0">btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, &quot;btdtrib&quot;, ufunc_btdtrib_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]</span>
<span class="s0">cdef void *ufunc_cbrt_ptr[4]</span>
<span class="s0">cdef void *ufunc_cbrt_data[2]</span>
<span class="s0">cdef char ufunc_cbrt_types[4]</span>
<span class="s0">cdef char *ufunc_cbrt_doc = (</span>
    <span class="s0">&quot;cbrt(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Element-wise cube root of `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The cube root of each value in `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import cbrt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cbrt(8)\n&quot;</span>
    <span class="s0">&quot;2.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cbrt([-8, -3, 0.125, 1.331])\n&quot;</span>
    <span class="s0">&quot;array([-2.        , -1.44224957,  0.5       ,  1.1       ])&quot;)</span>
<span class="s0">ufunc_cbrt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cbrt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cbrt_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cbrt_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cbrt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cbrt_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cbrt_ptr[2*0] = &lt;void*&gt;_func_cephes_cbrt</span>
<span class="s0">ufunc_cbrt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cbrt&quot;)</span>
<span class="s0">ufunc_cbrt_ptr[2*1] = &lt;void*&gt;_func_cephes_cbrt</span>
<span class="s0">ufunc_cbrt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cbrt&quot;)</span>
<span class="s0">ufunc_cbrt_data[0] = &amp;ufunc_cbrt_ptr[2*0]</span>
<span class="s0">ufunc_cbrt_data[1] = &amp;ufunc_cbrt_ptr[2*1]</span>
<span class="s0">cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, &quot;cbrt&quot;, ufunc_cbrt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtr_data[2]</span>
<span class="s0">cdef char ufunc_chdtr_types[6]</span>
<span class="s0">cdef char *ufunc_chdtr_doc = (</span>
    <span class="s0">&quot;chdtr(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Chi square cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the left tail (from 0 to `x`) of the Chi\n&quot;</span>
    <span class="s0">&quot;square probability density function with `v` degrees of freedom:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;integral can be expressed in terms of the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function `gammainc` as\n&quot;</span>
    <span class="s0">&quot;``gammainc(v / 2, x / 2)``. [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtrc, chdtri, chdtriv, gammainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the regularized lower incomplete\n&quot;</span>
    <span class="s0">&quot;gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.arange(4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtr(v, x)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.68268949, 0.84270079, 0.91673548])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(v / 2, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.68268949, 0.84270079, 0.91673548])&quot;)</span>
<span class="s0">ufunc_chdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_chdtr</span>
<span class="s0">ufunc_chdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtr&quot;)</span>
<span class="s0">ufunc_chdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_chdtr</span>
<span class="s0">ufunc_chdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtr&quot;)</span>
<span class="s0">ufunc_chdtr_data[0] = &amp;ufunc_chdtr_ptr[2*0]</span>
<span class="s0">ufunc_chdtr_data[1] = &amp;ufunc_chdtr_ptr[2*1]</span>
<span class="s0">chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, &quot;chdtr&quot;, ufunc_chdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtrc_data[2]</span>
<span class="s0">cdef char ufunc_chdtrc_types[6]</span>
<span class="s0">cdef char *ufunc_chdtrc_doc = (</span>
    <span class="s0">&quot;chdtrc(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Chi square survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the right hand tail (from `x` to infinity)\n&quot;</span>
    <span class="s0">&quot;of the Chi square probability density function with `v` degrees of\n&quot;</span>
    <span class="s0">&quot;freedom:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;integral can be expressed in terms of the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function `gammaincc` as\n&quot;</span>
    <span class="s0">&quot;``gammaincc(v / 2, x / 2)``. [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Lower bound of the integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtr, chdtri, chdtriv, gammaincc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the regularized upper incomplete\n&quot;</span>
    <span class="s0">&quot;gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.arange(4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtrc(v, x)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.31731051, 0.15729921, 0.08326452])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(v / 2, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.31731051, 0.15729921, 0.08326452])&quot;)</span>
<span class="s0">ufunc_chdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_ptr[2*0] = &lt;void*&gt;_func_cephes_chdtrc</span>
<span class="s0">ufunc_chdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtrc&quot;)</span>
<span class="s0">ufunc_chdtrc_ptr[2*1] = &lt;void*&gt;_func_cephes_chdtrc</span>
<span class="s0">ufunc_chdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtrc&quot;)</span>
<span class="s0">ufunc_chdtrc_data[0] = &amp;ufunc_chdtrc_ptr[2*0]</span>
<span class="s0">ufunc_chdtrc_data[1] = &amp;ufunc_chdtrc_ptr[2*1]</span>
<span class="s0">chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, &quot;chdtrc&quot;, ufunc_chdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtri_data[2]</span>
<span class="s0">cdef char ufunc_chdtri_types[6]</span>
<span class="s0">cdef char *ufunc_chdtri_doc = (</span>
    <span class="s0">&quot;chdtri(v, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chdtrc` with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `x` such that ``chdtrc(v, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value so that the probability a Chi square random variable\n&quot;</span>
    <span class="s0">&quot;    with `v` degrees of freedom is greater than `x` equals `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtrc, chdtr, chdtriv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts `chdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v, p = 1, 0.3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtrc(v, sc.chdtri(v, p))\n&quot;</span>
    <span class="s0">&quot;0.3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtri(v, sc.chdtrc(v, x))\n&quot;</span>
    <span class="s0">&quot;1.0&quot;)</span>
<span class="s0">ufunc_chdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_ptr[2*0] = &lt;void*&gt;_func_cephes_chdtri</span>
<span class="s0">ufunc_chdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtri&quot;)</span>
<span class="s0">ufunc_chdtri_ptr[2*1] = &lt;void*&gt;_func_cephes_chdtri</span>
<span class="s0">ufunc_chdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtri&quot;)</span>
<span class="s0">ufunc_chdtri_data[0] = &amp;ufunc_chdtri_ptr[2*0]</span>
<span class="s0">ufunc_chdtri_data[1] = &amp;ufunc_chdtri_ptr[2*1]</span>
<span class="s0">chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, &quot;chdtri&quot;, ufunc_chdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtriv_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtriv_data[2]</span>
<span class="s0">cdef char ufunc_chdtriv_types[6]</span>
<span class="s0">cdef char *ufunc_chdtriv_doc = (</span>
    <span class="s0">&quot;chdtriv(p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chdtr` with respect to `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `v` such that ``chdtr(v, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability that the Chi square random variable is less than\n&quot;</span>
    <span class="s0">&quot;    or equal to `x`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtr, chdtrc, chdtri\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts `chdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p, x = 0.5, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtr(sc.chdtriv(p, x), x)\n&quot;</span>
    <span class="s0">&quot;0.5000000000202172\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtriv(sc.chdtr(v, x), v)\n&quot;</span>
    <span class="s0">&quot;1.0000000000000013&quot;)</span>
<span class="s0">ufunc_chdtriv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtriv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtriv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_ptr[2*0] = &lt;void*&gt;_func_chdtriv</span>
<span class="s0">ufunc_chdtriv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtriv&quot;)</span>
<span class="s0">ufunc_chdtriv_ptr[2*1] = &lt;void*&gt;_func_chdtriv</span>
<span class="s0">ufunc_chdtriv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtriv&quot;)</span>
<span class="s0">ufunc_chdtriv_data[0] = &amp;ufunc_chdtriv_ptr[2*0]</span>
<span class="s0">ufunc_chdtriv_data[1] = &amp;ufunc_chdtriv_ptr[2*1]</span>
<span class="s0">chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, &quot;chdtriv&quot;, ufunc_chdtriv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtr_data[2]</span>
<span class="s0">cdef char ufunc_chndtr_types[8]</span>
<span class="s0">cdef char *ufunc_chndtr_doc = (</span>
    <span class="s0">&quot;chndtr(x, df, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Non-central chi square cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function is given by:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n&quot;</span>
    <span class="s0">&quot;    e^{-\\lambda /2}\n&quot;</span>
    <span class="s0">&quot;    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\nu &gt; 0` is the degrees of freedom (``df``) and\n&quot;</span>
    <span class="s0">&quot;:math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the non-central chi square cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtrix, chndtridf, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_ptr[2*0] = &lt;void*&gt;_func_chndtr</span>
<span class="s0">ufunc_chndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtr&quot;)</span>
<span class="s0">ufunc_chndtr_ptr[2*1] = &lt;void*&gt;_func_chndtr</span>
<span class="s0">ufunc_chndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtr&quot;)</span>
<span class="s0">ufunc_chndtr_data[0] = &amp;ufunc_chndtr_ptr[2*0]</span>
<span class="s0">ufunc_chndtr_data[1] = &amp;ufunc_chndtr_ptr[2*1]</span>
<span class="s0">chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, &quot;chndtr&quot;, ufunc_chndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtridf_data[2]</span>
<span class="s0">cdef char ufunc_chndtridf_types[8]</span>
<span class="s0">cdef char *ufunc_chndtridf_doc = (</span>
    <span class="s0">&quot;chndtridf(x, p, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `df`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `df` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;df : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtrix, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_ptr[2*0] = &lt;void*&gt;_func_chndtridf</span>
<span class="s0">ufunc_chndtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtridf&quot;)</span>
<span class="s0">ufunc_chndtridf_ptr[2*1] = &lt;void*&gt;_func_chndtridf</span>
<span class="s0">ufunc_chndtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtridf&quot;)</span>
<span class="s0">ufunc_chndtridf_data[0] = &amp;ufunc_chndtridf_ptr[2*0]</span>
<span class="s0">ufunc_chndtridf_data[1] = &amp;ufunc_chndtridf_ptr[2*1]</span>
<span class="s0">chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, &quot;chndtridf&quot;, ufunc_chndtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtrinc_data[2]</span>
<span class="s0">cdef char ufunc_chndtrinc_types[8]</span>
<span class="s0">cdef char *ufunc_chndtrinc_doc = (</span>
    <span class="s0">&quot;chndtrinc(x, df, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `nc`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `df` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Non-centrality\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtrix, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_ptr[2*0] = &lt;void*&gt;_func_chndtrinc</span>
<span class="s0">ufunc_chndtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_ptr[2*1] = &lt;void*&gt;_func_chndtrinc</span>
<span class="s0">ufunc_chndtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_data[0] = &amp;ufunc_chndtrinc_ptr[2*0]</span>
<span class="s0">ufunc_chndtrinc_data[1] = &amp;ufunc_chndtrinc_ptr[2*1]</span>
<span class="s0">chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, &quot;chndtrinc&quot;, ufunc_chndtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtrix_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtrix_data[2]</span>
<span class="s0">cdef char ufunc_chndtrix_types[8]</span>
<span class="s0">cdef char *ufunc_chndtrix_doc = (</span>
    <span class="s0">&quot;chndtrix(p, df, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `x` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value so that the probability a non-central Chi square random variable\n&quot;</span>
    <span class="s0">&quot;    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n&quot;</span>
    <span class="s0">&quot;    `x` equals `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtridf, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrix_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtrix_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtrix_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_ptr[2*0] = &lt;void*&gt;_func_chndtrix</span>
<span class="s0">ufunc_chndtrix_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrix&quot;)</span>
<span class="s0">ufunc_chndtrix_ptr[2*1] = &lt;void*&gt;_func_chndtrix</span>
<span class="s0">ufunc_chndtrix_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrix&quot;)</span>
<span class="s0">ufunc_chndtrix_data[0] = &amp;ufunc_chndtrix_ptr[2*0]</span>
<span class="s0">ufunc_chndtrix_data[1] = &amp;ufunc_chndtrix_ptr[2*1]</span>
<span class="s0">chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, &quot;chndtrix&quot;, ufunc_chndtrix_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]</span>
<span class="s0">cdef void *ufunc_cosdg_ptr[4]</span>
<span class="s0">cdef void *ufunc_cosdg_data[2]</span>
<span class="s0">cdef char ufunc_cosdg_types[4]</span>
<span class="s0">cdef char *ufunc_cosdg_doc = (</span>
    <span class="s0">&quot;cosdg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cosine of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cosine of the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, tandg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using cosine directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 90 + 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cosdg(x)\n&quot;</span>
    <span class="s0">&quot;array([-0.,  0., -0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.cos(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16])&quot;)</span>
<span class="s0">ufunc_cosdg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cosdg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cosdg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosdg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosdg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosdg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosdg_ptr[2*0] = &lt;void*&gt;_func_cephes_cosdg</span>
<span class="s0">ufunc_cosdg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosdg&quot;)</span>
<span class="s0">ufunc_cosdg_ptr[2*1] = &lt;void*&gt;_func_cephes_cosdg</span>
<span class="s0">ufunc_cosdg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosdg&quot;)</span>
<span class="s0">ufunc_cosdg_data[0] = &amp;ufunc_cosdg_ptr[2*0]</span>
<span class="s0">ufunc_cosdg_data[1] = &amp;ufunc_cosdg_ptr[2*1]</span>
<span class="s0">cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, &quot;cosdg&quot;, ufunc_cosdg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]</span>
<span class="s0">cdef void *ufunc_cosm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_cosm1_data[2]</span>
<span class="s0">cdef char ufunc_cosm1_types[4]</span>
<span class="s0">cdef char *ufunc_cosm1_doc = (</span>
    <span class="s0">&quot;cosm1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;cos(x) - 1 for use when `x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real valued argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of ``cos(x) - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expm1, log1p\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than computing ``cos(x) - 1`` directly for\n&quot;</span>
    <span class="s0">&quot;``x`` around 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1e-30\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.cos(x) - 1\n&quot;</span>
    <span class="s0">&quot;0.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cosm1(x)\n&quot;</span>
    <span class="s0">&quot;-5.0000000000000005e-61&quot;)</span>
<span class="s0">ufunc_cosm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cosm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cosm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosm1_ptr[2*0] = &lt;void*&gt;_func_cephes_cosm1</span>
<span class="s0">ufunc_cosm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosm1&quot;)</span>
<span class="s0">ufunc_cosm1_ptr[2*1] = &lt;void*&gt;_func_cephes_cosm1</span>
<span class="s0">ufunc_cosm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosm1&quot;)</span>
<span class="s0">ufunc_cosm1_data[0] = &amp;ufunc_cosm1_ptr[2*0]</span>
<span class="s0">ufunc_cosm1_data[1] = &amp;ufunc_cosm1_ptr[2*1]</span>
<span class="s0">cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, &quot;cosm1&quot;, ufunc_cosm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]</span>
<span class="s0">cdef void *ufunc_cotdg_ptr[4]</span>
<span class="s0">cdef void *ufunc_cotdg_data[2]</span>
<span class="s0">cdef char ufunc_cotdg_types[4]</span>
<span class="s0">cdef char *ufunc_cotdg_doc = (</span>
    <span class="s0">&quot;cotdg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cotangent of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cotangent at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, cosdg, tandg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using cotangent directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 90 + 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cotdg(x)\n&quot;</span>
    <span class="s0">&quot;array([0., 0., 0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 / np.tan(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16])&quot;)</span>
<span class="s0">ufunc_cotdg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cotdg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cotdg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cotdg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cotdg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cotdg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cotdg_ptr[2*0] = &lt;void*&gt;_func_cephes_cotdg</span>
<span class="s0">ufunc_cotdg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cotdg&quot;)</span>
<span class="s0">ufunc_cotdg_ptr[2*1] = &lt;void*&gt;_func_cephes_cotdg</span>
<span class="s0">ufunc_cotdg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cotdg&quot;)</span>
<span class="s0">ufunc_cotdg_data[0] = &amp;ufunc_cotdg_ptr[2*0]</span>
<span class="s0">ufunc_cotdg_data[1] = &amp;ufunc_cotdg_ptr[2*1]</span>
<span class="s0">cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, &quot;cotdg&quot;, ufunc_cotdg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]</span>
<span class="s0">cdef void *ufunc_dawsn_ptr[8]</span>
<span class="s0">cdef void *ufunc_dawsn_data[4]</span>
<span class="s0">cdef char ufunc_dawsn_types[8]</span>
<span class="s0">cdef char *ufunc_dawsn_doc = (</span>
    <span class="s0">&quot;dawsn(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Dawson's integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    exp(-x**2) * integral(exp(t**2), t=0..x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Function parameter.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;wofz, erf, erfc, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-15, 15, num=1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.dawsn(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$dawsn(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_dawsn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_dawsn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_dawsn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_dawsn_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_dawsn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_dawsn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_dawsn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_dawsn_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_dawsn_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_dawsn_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_dawsn_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_dawsn_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_dawsn_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn</span>
<span class="s0">ufunc_dawsn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn</span>
<span class="s0">ufunc_dawsn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex</span>
<span class="s0">ufunc_dawsn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex</span>
<span class="s0">ufunc_dawsn_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_data[0] = &amp;ufunc_dawsn_ptr[2*0]</span>
<span class="s0">ufunc_dawsn_data[1] = &amp;ufunc_dawsn_ptr[2*1]</span>
<span class="s0">ufunc_dawsn_data[2] = &amp;ufunc_dawsn_ptr[2*2]</span>
<span class="s0">ufunc_dawsn_data[3] = &amp;ufunc_dawsn_ptr[2*3]</span>
<span class="s0">dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, &quot;dawsn&quot;, ufunc_dawsn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipe_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipe_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipe_data[2]</span>
<span class="s0">cdef char ufunc_ellipe_types[4]</span>
<span class="s0">cdef char *ufunc_ellipe_doc = (</span>
    <span class="s0">&quot;ellipe(m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Defines the parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;E : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpe`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For `m &gt; 0` the computation uses the approximation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) \\approx P(1-m) - (1-m) \\log(1-m) Q(1-m),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P` and :math:`Q` are tenth-order polynomials.  For\n&quot;</span>
    <span class="s0">&quot;`m &lt; 0`, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = E(m/(m - 1)) \\sqrt(1-m)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre E integral is related to Carlson's symmetric R_D or R_G\n&quot;</span>
    <span class="s0">&quot;functions in multiple ways [3]_. For example,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = 2 R_G(0, 1-k^2, 1) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;This function is used in finding the circumference of an\n&quot;</span>
    <span class="s0">&quot;ellipse with semi-major axis `a` and semi-minor axis `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 3.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 2.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; e_sq = 1.0 - b**2/a**2  # eccentricity squared\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Then the circumference is found using the following:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C = 4*a*special.ellipe(e_sq)  # circumference formula\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C\n&quot;</span>
    <span class="s0">&quot;17.868899204378693\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `a` and `b` are the same (meaning eccentricity is 0),\n&quot;</span>
    <span class="s0">&quot;this reduces to the circumference of a circle.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 4*a*special.ellipe(0.0)  # formula for ellipse with a = b\n&quot;</span>
    <span class="s0">&quot;21.991148575128552\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 2*np.pi*a  # formula for circle of radius a\n&quot;</span>
    <span class="s0">&quot;21.991148575128552&quot;)</span>
<span class="s0">ufunc_ellipe_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipe_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipe_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipe_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipe_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipe_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipe_ptr[2*0] = &lt;void*&gt;_func_cephes_ellpe</span>
<span class="s0">ufunc_ellipe_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipe&quot;)</span>
<span class="s0">ufunc_ellipe_ptr[2*1] = &lt;void*&gt;_func_cephes_ellpe</span>
<span class="s0">ufunc_ellipe_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipe&quot;)</span>
<span class="s0">ufunc_ellipe_data[0] = &amp;ufunc_ellipe_ptr[2*0]</span>
<span class="s0">ufunc_ellipe_data[1] = &amp;ufunc_ellipe_ptr[2*1]</span>
<span class="s0">ellipe = np.PyUFunc_FromFuncAndData(ufunc_ellipe_loops, ufunc_ellipe_data, ufunc_ellipe_types, 2, 1, 1, 0, &quot;ellipe&quot;, ufunc_ellipe_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipeinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipeinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipeinc_data[2]</span>
<span class="s0">cdef char ufunc_ellipeinc_types[6]</span>
<span class="s0">cdef char *ufunc_ellipeinc_doc = (</span>
    <span class="s0">&quot;ellipeinc(phi, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;phi : array_like\n&quot;</span>
    <span class="s0">&quot;    amplitude of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;E : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellie`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation uses arithmetic-geometric means algorithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre E incomplete integral can be related to combinations\n&quot;</span>
    <span class="s0">&quot;of Carlson's symmetric integrals R_D, R_F, and R_G in multiple\n&quot;</span>
    <span class="s0">&quot;ways [3]_. For example, with :math:`c = \\csc^2\\phi`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  E(\\phi, m) = R_F(c-1, c-k^2, c)\n&quot;</span>
    <span class="s0">&quot;    - \\frac{1}{3} k^2 R_D(c-1, c-k^2, c) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipeinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_ellipeinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_ellipeinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_ptr[2*0] = &lt;void*&gt;_func_cephes_ellie</span>
<span class="s0">ufunc_ellipeinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipeinc&quot;)</span>
<span class="s0">ufunc_ellipeinc_ptr[2*1] = &lt;void*&gt;_func_cephes_ellie</span>
<span class="s0">ufunc_ellipeinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipeinc&quot;)</span>
<span class="s0">ufunc_ellipeinc_data[0] = &amp;ufunc_ellipeinc_ptr[2*0]</span>
<span class="s0">ufunc_ellipeinc_data[1] = &amp;ufunc_ellipeinc_ptr[2*1]</span>
<span class="s0">ellipeinc = np.PyUFunc_FromFuncAndData(ufunc_ellipeinc_loops, ufunc_ellipeinc_data, ufunc_ellipeinc_types, 2, 2, 1, 0, &quot;ellipeinc&quot;, ufunc_ellipeinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipj_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipj_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipj_data[2]</span>
<span class="s0">cdef char ufunc_ellipj_types[12]</span>
<span class="s0">cdef char *ufunc_ellipj_doc = (</span>
    <span class="s0">&quot;ellipj(u, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Jacobian elliptic functions\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculates the Jacobian elliptic functions of parameter `m` between\n&quot;</span>
    <span class="s0">&quot;0 and 1, and real argument `u`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter.\n&quot;</span>
    <span class="s0">&quot;u : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;sn, cn, dn, ph : 4-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The returned functions::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;        sn(u|m), cn(u|m), dn(u|m)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    The value `ph` is such that if `u = ellipkinc(ph, m)`,\n&quot;</span>
    <span class="s0">&quot;    then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpj`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These functions are periodic, with quarter-period on the real axis\n&quot;</span>
    <span class="s0">&quot;equal to the complete elliptic integral `ellipk(m)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Relation to incomplete elliptic integral: If `u = ellipkinc(phi,m)`, then\n&quot;</span>
    <span class="s0">&quot;`sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`. The `phi` is called\n&quot;</span>
    <span class="s0">&quot;the amplitude of `u`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation is by means of the arithmetic-geometric mean algorithm,\n&quot;</span>
    <span class="s0">&quot;except when `m` is within 1e-9 of 0 or 1. In the latter case with `m`\n&quot;</span>
    <span class="s0">&quot;close to 1, the approximation applies only for `phi &lt; pi/2`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_ellipj_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dddd_As_ff_ffff</span>
<span class="s0">ufunc_ellipj_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dddd_As_dd_dddd</span>
<span class="s0">ufunc_ellipj_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_ptr[2*0] = &lt;void*&gt;_func_cephes_ellpj_wrap</span>
<span class="s0">ufunc_ellipj_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipj&quot;)</span>
<span class="s0">ufunc_ellipj_ptr[2*1] = &lt;void*&gt;_func_cephes_ellpj_wrap</span>
<span class="s0">ufunc_ellipj_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipj&quot;)</span>
<span class="s0">ufunc_ellipj_data[0] = &amp;ufunc_ellipj_ptr[2*0]</span>
<span class="s0">ufunc_ellipj_data[1] = &amp;ufunc_ellipj_ptr[2*1]</span>
<span class="s0">ellipj = np.PyUFunc_FromFuncAndData(ufunc_ellipj_loops, ufunc_ellipj_data, ufunc_ellipj_types, 2, 2, 4, 0, &quot;ellipj&quot;, ufunc_ellipj_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipk_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipk_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipk_data[2]</span>
<span class="s0">cdef char ufunc_ellipk_types[4]</span>
<span class="s0">cdef char *ufunc_ellipk_doc = (</span>
    <span class="s0">&quot;ellipk(m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    The parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind around m = 1\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For more precision around point m = 1, use `ellipkm1`, which this\n&quot;</span>
    <span class="s0">&quot;function calls.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [1]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre K integral is related to Carlson's symmetric R_F\n&quot;</span>
    <span class="s0">&quot;function by [2]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(m) = R_F(0, 1-k^2, 1) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipk_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipk_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipk_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipk_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipk_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipk_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipk_ptr[2*0] = &lt;void*&gt;_func_special_ellipk</span>
<span class="s0">ufunc_ellipk_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipk&quot;)</span>
<span class="s0">ufunc_ellipk_ptr[2*1] = &lt;void*&gt;_func_special_ellipk</span>
<span class="s0">ufunc_ellipk_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipk&quot;)</span>
<span class="s0">ufunc_ellipk_data[0] = &amp;ufunc_ellipk_ptr[2*0]</span>
<span class="s0">ufunc_ellipk_data[1] = &amp;ufunc_ellipk_ptr[2*1]</span>
<span class="s0">ellipk = np.PyUFunc_FromFuncAndData(ufunc_ellipk_loops, ufunc_ellipk_data, ufunc_ellipk_types, 2, 1, 1, 0, &quot;ellipk&quot;, ufunc_ellipk_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipkinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipkinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipkinc_data[2]</span>
<span class="s0">cdef char ufunc_ellipkinc_types[6]</span>
<span class="s0">cdef char *ufunc_ellipkinc_doc = (</span>
    <span class="s0">&quot;ellipkinc(phi, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is also called :math:`F(\\phi, m)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;phi : array_like\n&quot;</span>
    <span class="s0">&quot;    amplitude of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    parameter of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellik`.  The computation is\n&quot;</span>
    <span class="s0">&quot;carried out using the arithmetic-geometric mean algorithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre K incomplete integral (or F integral) is related to\n&quot;</span>
    <span class="s0">&quot;Carlson's symmetric R_F function [3]_.\n&quot;</span>
    <span class="s0">&quot;Setting :math:`c = \\csc^2\\phi`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: F(\\phi, m) = R_F(c-1, c-k^2, c) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipkinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_ellipkinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_ellipkinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_ptr[2*0] = &lt;void*&gt;_func_cephes_ellik</span>
<span class="s0">ufunc_ellipkinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkinc&quot;)</span>
<span class="s0">ufunc_ellipkinc_ptr[2*1] = &lt;void*&gt;_func_cephes_ellik</span>
<span class="s0">ufunc_ellipkinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkinc&quot;)</span>
<span class="s0">ufunc_ellipkinc_data[0] = &amp;ufunc_ellipkinc_ptr[2*0]</span>
<span class="s0">ufunc_ellipkinc_data[1] = &amp;ufunc_ellipkinc_ptr[2*1]</span>
<span class="s0">ellipkinc = np.PyUFunc_FromFuncAndData(ufunc_ellipkinc_loops, ufunc_ellipkinc_data, ufunc_ellipkinc_types, 2, 2, 1, 0, &quot;ellipkinc&quot;, ufunc_ellipkinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipkm1_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipkm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipkm1_data[2]</span>
<span class="s0">cdef char ufunc_ellipkm1_types[4]</span>
<span class="s0">cdef char *ufunc_ellipkm1_doc = (</span>
    <span class="s0">&quot;ellipkm1(p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the first kind around `m` = 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where `m = 1 - p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Defines the parameter of the elliptic integral as `m = 1 - p`.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpk`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For `p &lt;= 1`, computation uses the approximation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) \\approx P(p) - \\log(p) Q(p),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P` and :math:`Q` are tenth-order polynomials.  The\n&quot;</span>
    <span class="s0">&quot;argument `p` is used internally rather than `m` so that the logarithmic\n&quot;</span>
    <span class="s0">&quot;singularity at `m = 1` will be shifted to the origin; this preserves\n&quot;</span>
    <span class="s0">&quot;maximum accuracy.  For `p &gt; 1`, the identity\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) = K(1/p)/\\sqrt(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_ellipkm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipkm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipkm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkm1_ptr[2*0] = &lt;void*&gt;_func_cephes_ellpk</span>
<span class="s0">ufunc_ellipkm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkm1&quot;)</span>
<span class="s0">ufunc_ellipkm1_ptr[2*1] = &lt;void*&gt;_func_cephes_ellpk</span>
<span class="s0">ufunc_ellipkm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkm1&quot;)</span>
<span class="s0">ufunc_ellipkm1_data[0] = &amp;ufunc_ellipkm1_ptr[2*0]</span>
<span class="s0">ufunc_ellipkm1_data[1] = &amp;ufunc_ellipkm1_ptr[2*1]</span>
<span class="s0">ellipkm1 = np.PyUFunc_FromFuncAndData(ufunc_ellipkm1_loops, ufunc_ellipkm1_data, ufunc_ellipkm1_types, 2, 1, 1, 0, &quot;ellipkm1&quot;, ufunc_ellipkm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprc_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprc_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprc_data[4]</span>
<span class="s0">cdef char ufunc_elliprc_types[12]</span>
<span class="s0">cdef char *ufunc_elliprc_doc = (</span>
    <span class="s0">&quot;elliprc(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Degenerate symmetric elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RC is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{C}}(x, y) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{2} \\int_0^{+\\infty} (t + x)^{-1/2} (t + y)^{-1} dt\n&quot;</span>
    <span class="s0">&quot;       = R_{\\mathrm{F}}(x, y, y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x` can be any number in the\n&quot;</span>
    <span class="s0">&quot;    complex plane cut along the negative real axis. `y` must be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If `y` is real and negative, the Cauchy\n&quot;</span>
    <span class="s0">&quot;    principal value is returned. If both of `x` and `y` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;RC is a degenerate case of the symmetric integral RF: ``elliprc(x, y) ==\n&quot;</span>
    <span class="s0">&quot;elliprf(x, y, y)``. It is an elementary function rather than an elliptic\n&quot;</span>
    <span class="s0">&quot;integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E6\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(scale*x, scale*y)\n&quot;</span>
    <span class="s0">&quot;(0.5484493976710874-0.4169557678995833j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, y)/np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(0.5484493976710874-0.41695576789958333j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When the two arguments coincide, the integral is particularly\n&quot;</span>
    <span class="s0">&quot;simple:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.3041729818745595j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1/np.sqrt(x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Another simple case: the first argument vanishes:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(0, y)\n&quot;</span>
    <span class="s0">&quot;(0.6753125346116815-0.47779380263880866j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi/2/np.sqrt(y)\n&quot;</span>
    <span class="s0">&quot;(0.6753125346116815-0.4777938026388088j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `x` and `y` are both positive, we can express\n&quot;</span>
    <span class="s0">&quot;:math:`R_C(x,y)` in terms of more elementary functions.  For the\n&quot;</span>
    <span class="s0">&quot;case :math:`0 \\le x &lt; y`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 3.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, y)\n&quot;</span>
    <span class="s0">&quot;0.44942991498453444\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.arctan(np.sqrt((y-x)/x))/np.sqrt(y-x)\n&quot;</span>
    <span class="s0">&quot;0.44942991498453433\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;And for the case :math:`0 \\le y &lt; x`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 3.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x,y)\n&quot;</span>
    <span class="s0">&quot;0.4989837501576147\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log((np.sqrt(x)+np.sqrt(x-y))/np.sqrt(y))/np.sqrt(x-y)\n&quot;</span>
    <span class="s0">&quot;0.49898375015761476&quot;)</span>
<span class="s0">ufunc_elliprc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_elliprc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_elliprc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_elliprc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_elliprc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_data[0] = &amp;ufunc_elliprc_ptr[2*0]</span>
<span class="s0">ufunc_elliprc_data[1] = &amp;ufunc_elliprc_ptr[2*1]</span>
<span class="s0">ufunc_elliprc_data[2] = &amp;ufunc_elliprc_ptr[2*2]</span>
<span class="s0">ufunc_elliprc_data[3] = &amp;ufunc_elliprc_ptr[2*3]</span>
<span class="s0">elliprc = np.PyUFunc_FromFuncAndData(ufunc_elliprc_loops, ufunc_elliprc_data, ufunc_elliprc_types, 4, 2, 1, 0, &quot;elliprc&quot;, ufunc_elliprc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprd_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprd_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprd_data[4]</span>
<span class="s0">cdef char ufunc_elliprd_types[16]</span>
<span class="s0">cdef char *ufunc_elliprd_doc = (</span>
    <span class="s0">&quot;elliprd(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RD is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{D}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y)]^{-1/2} (t + z)^{-3/2}\n&quot;</span>
    <span class="s0">&quot;       dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x` or `y` can be any number in the\n&quot;</span>
    <span class="s0">&quot;    complex plane cut along the negative real axis, but at most one of them\n&quot;</span>
    <span class="s0">&quot;    can be zero, while `z` must be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric elliptic integral.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;RD is a degenerate case of the elliptic integral RJ: ``elliprd(x, y, z) ==\n&quot;</span>
    <span class="s0">&quot;elliprj(x, y, z, z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E5\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(-0.03703043835680379-0.24500934665683802j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, y, z)*np.power(scale, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.0370304383568038-0.24500934665683805j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All three arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, x, x)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151896-0.14051741840449586j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.power(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151894-0.14051741840449583j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The so-called \&quot;second lemniscate constant\&quot;:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(0, 2, 1)/3\n&quot;</span>
    <span class="s0">&quot;0.5990701173677961\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(0.75)**2/np.sqrt(2*np.pi)\n&quot;</span>
    <span class="s0">&quot;0.5990701173677959&quot;)</span>
<span class="s0">ufunc_elliprd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprd_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprd_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_data[0] = &amp;ufunc_elliprd_ptr[2*0]</span>
<span class="s0">ufunc_elliprd_data[1] = &amp;ufunc_elliprd_ptr[2*1]</span>
<span class="s0">ufunc_elliprd_data[2] = &amp;ufunc_elliprd_ptr[2*2]</span>
<span class="s0">ufunc_elliprd_data[3] = &amp;ufunc_elliprd_ptr[2*3]</span>
<span class="s0">elliprd = np.PyUFunc_FromFuncAndData(ufunc_elliprd_loops, ufunc_elliprd_data, ufunc_elliprd_types, 4, 3, 1, 0, &quot;elliprd&quot;, ufunc_elliprd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprf_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprf_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprf_data[4]</span>
<span class="s0">cdef char ufunc_elliprf_types[16]</span>
<span class="s0">cdef char *ufunc_elliprf_doc = (</span>
    <span class="s0">&quot;elliprf(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RF is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{F}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis, but at most one of\n&quot;</span>
    <span class="s0">&quot;    them can be zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n&quot;</span>
    <span class="s0">&quot;    value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order (cf.:\n&quot;</span>
    <span class="s0">&quot;https://dlmf.nist.gov/19.36.i) and the AGM algorithm for the complete\n&quot;</span>
    <span class="s0">&quot;integral. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E1\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(0.5328051227278146-0.4008623567957094j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(x, y, z)/np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(0.5328051227278147-0.4008623567957095j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All three arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(x, x, x)\n&quot;</span>
    <span class="s0">&quot;(0.42991731206146316-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1/np.sqrt(x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The so-called \&quot;first lemniscate constant\&quot;:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(0, 1, 2)\n&quot;</span>
    <span class="s0">&quot;1.3110287771460598\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(0.25)**2/(4*np.sqrt(2*np.pi))\n&quot;</span>
    <span class="s0">&quot;1.3110287771460598&quot;)</span>
<span class="s0">ufunc_elliprf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprf_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprf_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_data[0] = &amp;ufunc_elliprf_ptr[2*0]</span>
<span class="s0">ufunc_elliprf_data[1] = &amp;ufunc_elliprf_ptr[2*1]</span>
<span class="s0">ufunc_elliprf_data[2] = &amp;ufunc_elliprf_ptr[2*2]</span>
<span class="s0">ufunc_elliprf_data[3] = &amp;ufunc_elliprf_ptr[2*3]</span>
<span class="s0">elliprf = np.PyUFunc_FromFuncAndData(ufunc_elliprf_loops, ufunc_elliprf_data, ufunc_elliprf_types, 4, 3, 1, 0, &quot;elliprf&quot;, ufunc_elliprf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprg_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprg_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprg_data[4]</span>
<span class="s0">cdef char ufunc_elliprg_types[16]</span>
<span class="s0">cdef char *ufunc_elliprg_doc = (</span>
    <span class="s0">&quot;elliprg(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RG is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{G}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{4} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n&quot;</span>
    <span class="s0">&quot;       \\left(\\frac{x}{t + x} + \\frac{y}{t + y} + \\frac{z}{t + z}\\right) t\n&quot;</span>
    <span class="s0">&quot;       dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n&quot;</span>
    <span class="s0">&quot;    value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The implementation uses the relation [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    2 R_{\\mathrm{G}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       z R_{\\mathrm{F}}(x, y, z) -\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{3} (x - z) (y - z) R_{\\mathrm{D}}(x, y, z) +\n&quot;</span>
    <span class="s0">&quot;       \\sqrt{\\frac{x y}{z}}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the symmetry of `x`, `y`, `z` when at least one non-zero parameter can\n&quot;</span>
    <span class="s0">&quot;be chosen as the pivot. When one of the arguments is close to zero, the AGM\n&quot;</span>
    <span class="s0">&quot;method is applied instead. Other special cases are computed following Ref.\n&quot;</span>
    <span class="s0">&quot;[2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E1\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.20.ii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(1.195936862005246+0.8470988320464167j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(x, y, z)*np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(1.195936862005246+0.8470988320464165j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Simplifications:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(0, y, y)\n&quot;</span>
    <span class="s0">&quot;1.756203682760182\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.25*np.pi*np.sqrt(y)\n&quot;</span>
    <span class="s0">&quot;1.7562036827601817\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(0, 0, z)\n&quot;</span>
    <span class="s0">&quot;1.224744871391589\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.5*np.sqrt(z)\n&quot;</span>
    <span class="s0">&quot;1.224744871391589\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The surface area of a triaxial ellipsoid with semiaxes ``a``, ``b``, and\n&quot;</span>
    <span class="s0">&quot;``c`` is given by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    S = 4 \\pi a b c R_{\\mathrm{G}}(1 / a^2, 1 / b^2, 1 / c^2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def ellipsoid_area(a, b, c):\n&quot;</span>
    <span class="s0">&quot;...     r = 4.0 * np.pi * a * b * c\n&quot;</span>
    <span class="s0">&quot;...     return r * elliprg(1.0 / (a * a), 1.0 / (b * b), 1.0 / (c * c))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(ellipsoid_area(1, 3, 5))\n&quot;</span>
    <span class="s0">&quot;108.62688289491807&quot;)</span>
<span class="s0">ufunc_elliprg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprg_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprg_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_data[0] = &amp;ufunc_elliprg_ptr[2*0]</span>
<span class="s0">ufunc_elliprg_data[1] = &amp;ufunc_elliprg_ptr[2*1]</span>
<span class="s0">ufunc_elliprg_data[2] = &amp;ufunc_elliprg_ptr[2*2]</span>
<span class="s0">ufunc_elliprg_data[3] = &amp;ufunc_elliprg_ptr[2*3]</span>
<span class="s0">elliprg = np.PyUFunc_FromFuncAndData(ufunc_elliprg_loops, ufunc_elliprg_data, ufunc_elliprg_types, 4, 3, 1, 0, &quot;elliprg&quot;, ufunc_elliprg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprj_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprj_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprj_data[4]</span>
<span class="s0">cdef char ufunc_elliprj_types[20]</span>
<span class="s0">cdef char *ufunc_elliprj_doc = (</span>
    <span class="s0">&quot;elliprj(x, y, z, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RJ is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{J}}(x, y, z, p) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n&quot;</span>
    <span class="s0">&quot;       (t + p)^{-1} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. warning::\n&quot;</span>
    <span class="s0">&quot;    This function should be considered experimental when the inputs are\n&quot;</span>
    <span class="s0">&quot;    unbalanced.  Check correctness with another independent implementation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z, p : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` are numbers in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis (subject to further\n&quot;</span>
    <span class="s0">&quot;    constraints, see Notes), and at most one of them can be zero. `p` must\n&quot;</span>
    <span class="s0">&quot;    be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, `z`, and `p` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    If `p` is real and negative, while `x`, `y`, and `z` are real,\n&quot;</span>
    <span class="s0">&quot;    non-negative, and at most one of them is zero, the Cauchy principal\n&quot;</span>
    <span class="s0">&quot;    value is returned. [1]_ [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [3]_ The algorithm is slightly\n&quot;</span>
    <span class="s0">&quot;different from its earlier incarnation as it appears in [1]_, in that the\n&quot;</span>
    <span class="s0">&quot;call to `elliprc` (or ``atan``/``atanh``, see [4]_) is no longer needed in\n&quot;</span>
    <span class="s0">&quot;the inner loop. Asymptotic approximations are used where arguments differ\n&quot;</span>
    <span class="s0">&quot;widely in the order of magnitude. [5]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The input values are subject to certain sufficient but not necessary\n&quot;</span>
    <span class="s0">&quot;constraints when input arguments are complex. Notably, ``x``, ``y``, and\n&quot;</span>
    <span class="s0">&quot;``z`` must have non-negative real parts, unless two of them are\n&quot;</span>
    <span class="s0">&quot;non-negative and complex-conjugates to each other while the other is a real\n&quot;</span>
    <span class="s0">&quot;non-negative number. [1]_ If the inputs do not satisfy the sufficient\n&quot;</span>
    <span class="s0">&quot;condition described in Ref. [1]_ they are rejected outright with the output\n&quot;</span>
    <span class="s0">&quot;set to NaN.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the case where one of ``x``, ``y``, and ``z`` is equal to ``p``, the\n&quot;</span>
    <span class="s0">&quot;function ``elliprd`` should be preferred because of its less restrictive\n&quot;</span>
    <span class="s0">&quot;domain.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.20.iii\n&quot;</span>
    <span class="s0">&quot;.. [3] B. C. Carlson, J. FitzSimmons, \&quot;Reduction Theorems for Elliptic\n&quot;</span>
    <span class="s0">&quot;       Integrands with the Square Root of Two Quadratic Factors,\&quot; J.\n&quot;</span>
    <span class="s0">&quot;       Comput. Appl. Math., vol. 118, nos. 1-2, pp. 71-85, 2000.\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1016/S0377-0427(00)00282-X\n&quot;</span>
    <span class="s0">&quot;.. [4] F. Johansson, \&quot;Numerical Evaluation of Elliptic Functions, Elliptic\n&quot;</span>
    <span class="s0">&quot;       Integrals and Modular Forms,\&quot; in J. Blumlein, C. Schneider, P.\n&quot;</span>
    <span class="s0">&quot;       Paule, eds., \&quot;Elliptic Integrals, Elliptic Functions and Modular\n&quot;</span>
    <span class="s0">&quot;       Forms in Quantum Field Theory,\&quot; pp. 269-293, 2019 (Cham,\n&quot;</span>
    <span class="s0">&quot;       Switzerland: Springer Nature Switzerland)\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/1806.06725\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/978-3-030-04480-0\n&quot;</span>
    <span class="s0">&quot;.. [5] B. C. Carlson, J. L. Gustafson, \&quot;Asymptotic Approximations for\n&quot;</span>
    <span class="s0">&quot;       Symmetric Elliptic Integrals,\&quot; SIAM J. Math. Anls., vol. 25, no. 2,\n&quot;</span>
    <span class="s0">&quot;       pp. 288-303, 1994.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9310223\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1137/S0036141092228477\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprj\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = 7.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 - 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(scale*x, scale*y, scale*z, scale*p)\n&quot;</span>
    <span class="s0">&quot;(0.10834905565679157+0.19694950747103812j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, y, z, p)*np.power(scale, -1.5)\n&quot;</span>
    <span class="s0">&quot;(0.10834905565679556+0.19694950747103854j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Reduction to simpler elliptic integral:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, y, z, z)\n&quot;</span>
    <span class="s0">&quot;(0.08288462362195129-0.028376809745123258j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprd\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, y, z)\n&quot;</span>
    <span class="s0">&quot;(0.08288462362195136-0.028376809745123296j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, x, x, x)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151896-0.14051741840449586j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.power(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151894-0.14051741840449583j)&quot;)</span>
<span class="s0">ufunc_elliprj_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_elliprj_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_elliprj_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDDD__As_FFFF_F</span>
<span class="s0">ufunc_elliprj_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDDD__As_DDDD_D</span>
<span class="s0">ufunc_elliprj_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[12] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[16] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[17] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_data[0] = &amp;ufunc_elliprj_ptr[2*0]</span>
<span class="s0">ufunc_elliprj_data[1] = &amp;ufunc_elliprj_ptr[2*1]</span>
<span class="s0">ufunc_elliprj_data[2] = &amp;ufunc_elliprj_ptr[2*2]</span>
<span class="s0">ufunc_elliprj_data[3] = &amp;ufunc_elliprj_ptr[2*3]</span>
<span class="s0">elliprj = np.PyUFunc_FromFuncAndData(ufunc_elliprj_loops, ufunc_elliprj_data, ufunc_elliprj_types, 4, 4, 1, 0, &quot;elliprj&quot;, ufunc_elliprj_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_entr_loops[2]</span>
<span class="s0">cdef void *ufunc_entr_ptr[4]</span>
<span class="s0">cdef void *ufunc_entr_data[2]</span>
<span class="s0">cdef char ufunc_entr_types[4]</span>
<span class="s0">cdef char *ufunc_entr_doc = (</span>
    <span class="s0">&quot;entr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing entropy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\text{entr}(x) = \\begin{cases} - x \\log(x) &amp; x &gt; 0  \\\\ 0 &amp; x = 0\n&quot;</span>
    <span class="s0">&quot;          \\\\ -\\infty &amp; \\text{otherwise} \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the elementwise entropy function at the given points `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kl_div, rel_entr, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is concave.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see [1]_.\n&quot;</span>
    <span class="s0">&quot;Given a probability distribution :math:`p_1, \\ldots, p_n`,\n&quot;</span>
    <span class="s0">&quot;the definition of entropy in the context of *information theory* is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\sum_{i = 1}^n \\mathrm{entr}(p_i).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;To compute the latter quantity, use `scipy.stats.entropy`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`&quot;)</span>
<span class="s0">ufunc_entr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_entr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_entr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_entr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_entr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_entr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_entr_ptr[2*0] = &lt;void*&gt;_func_entr</span>
<span class="s0">ufunc_entr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;entr&quot;)</span>
<span class="s0">ufunc_entr_ptr[2*1] = &lt;void*&gt;_func_entr</span>
<span class="s0">ufunc_entr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;entr&quot;)</span>
<span class="s0">ufunc_entr_data[0] = &amp;ufunc_entr_ptr[2*0]</span>
<span class="s0">ufunc_entr_data[1] = &amp;ufunc_entr_ptr[2*1]</span>
<span class="s0">entr = np.PyUFunc_FromFuncAndData(ufunc_entr_loops, ufunc_entr_data, ufunc_entr_types, 2, 1, 1, 0, &quot;entr&quot;, ufunc_entr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erf_loops[4]</span>
<span class="s0">cdef void *ufunc_erf_ptr[8]</span>
<span class="s0">cdef void *ufunc_erf_data[4]</span>
<span class="s0">cdef char ufunc_erf_types[8]</span>
<span class="s0">cdef char *ufunc_erf_doc = (</span>
    <span class="s0">&quot;erf(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the error function of complex argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the error function at the given points `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erfc, erfinv, erfcinv, wofz, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The cumulative of the unit normal distribution is given by\n&quot;</span>
    <span class="s0">&quot;``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Error_function\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover,\n&quot;</span>
    <span class="s0">&quot;    1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n&quot;</span>
    <span class="s0">&quot;.. [3] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erf(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erf(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erf_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erf_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erf_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erf_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erf_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erf_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erf_ptr[2*0] = &lt;void*&gt;_func_cephes_erf</span>
<span class="s0">ufunc_erf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*1] = &lt;void*&gt;_func_cephes_erf</span>
<span class="s0">ufunc_erf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erf</span>
<span class="s0">ufunc_erf_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erf</span>
<span class="s0">ufunc_erf_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_data[0] = &amp;ufunc_erf_ptr[2*0]</span>
<span class="s0">ufunc_erf_data[1] = &amp;ufunc_erf_ptr[2*1]</span>
<span class="s0">ufunc_erf_data[2] = &amp;ufunc_erf_ptr[2*2]</span>
<span class="s0">ufunc_erf_data[3] = &amp;ufunc_erf_ptr[2*3]</span>
<span class="s0">erf = np.PyUFunc_FromFuncAndData(ufunc_erf_loops, ufunc_erf_data, ufunc_erf_types, 4, 1, 1, 0, &quot;erf&quot;, ufunc_erf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfc_loops[4]</span>
<span class="s0">cdef void *ufunc_erfc_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfc_data[4]</span>
<span class="s0">cdef char ufunc_erfc_types[8]</span>
<span class="s0">cdef char *ufunc_erfc_doc = (</span>
    <span class="s0">&quot;erfc(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complementary error function, ``1 - erf(x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfi, erfcx, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfc(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfc(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfc_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfc_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfc_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfc_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfc_ptr[2*0] = &lt;void*&gt;_func_cephes_erfc</span>
<span class="s0">ufunc_erfc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*1] = &lt;void*&gt;_func_cephes_erfc</span>
<span class="s0">ufunc_erfc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex</span>
<span class="s0">ufunc_erfc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex</span>
<span class="s0">ufunc_erfc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_data[0] = &amp;ufunc_erfc_ptr[2*0]</span>
<span class="s0">ufunc_erfc_data[1] = &amp;ufunc_erfc_ptr[2*1]</span>
<span class="s0">ufunc_erfc_data[2] = &amp;ufunc_erfc_ptr[2*2]</span>
<span class="s0">ufunc_erfc_data[3] = &amp;ufunc_erfc_ptr[2*3]</span>
<span class="s0">erfc = np.PyUFunc_FromFuncAndData(ufunc_erfc_loops, ufunc_erfc_data, ufunc_erfc_types, 4, 1, 1, 0, &quot;erfc&quot;, ufunc_erfc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfcinv_loops[2]</span>
<span class="s0">cdef void *ufunc_erfcinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_erfcinv_data[2]</span>
<span class="s0">cdef char ufunc_erfcinv_types[4]</span>
<span class="s0">cdef char *ufunc_erfcinv_doc = (</span>
    <span class="s0">&quot;erfcinv(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the complementary error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the inverse of the complementary error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the complex domain, there is no unique complex number w satisfying\n&quot;</span>
    <span class="s0">&quot;erfc(w)=z. This indicates a true inverse function would be multivalued.\n&quot;</span>
    <span class="s0">&quot;When the domain restricts to the real, 0 &lt; x &lt; 2, there is a unique real\n&quot;</span>
    <span class="s0">&quot;number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to inverse of the error function by erfcinv(1-x) = erfinv(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : ndarray\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate. Domain: [0, 2]\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;erfcinv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of erfc of y, element-wise\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf : Error function of a complex argument\n&quot;</span>
    <span class="s0">&quot;erfc : Complementary error function, ``1 - erf(x)``\n&quot;</span>
    <span class="s0">&quot;erfinv : Inverse of the error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import erfcinv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfcinv(0.5)\n&quot;</span>
    <span class="s0">&quot;0.4769362762044699\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(0.0, 2.0, num=11)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfcinv(y)\n&quot;</span>
    <span class="s0">&quot;array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345,\n&quot;</span>
    <span class="s0">&quot;       -0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 ,\n&quot;</span>
    <span class="s0">&quot;              -inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(0, 2, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(y, erfcinv(y))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('y')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('erfcinv(y)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfcinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfcinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfcinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcinv_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcinv_ptr[2*0] = &lt;void*&gt;_func_cephes_erfcinv</span>
<span class="s0">ufunc_erfcinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcinv&quot;)</span>
<span class="s0">ufunc_erfcinv_ptr[2*1] = &lt;void*&gt;_func_cephes_erfcinv</span>
<span class="s0">ufunc_erfcinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcinv&quot;)</span>
<span class="s0">ufunc_erfcinv_data[0] = &amp;ufunc_erfcinv_ptr[2*0]</span>
<span class="s0">ufunc_erfcinv_data[1] = &amp;ufunc_erfcinv_ptr[2*1]</span>
<span class="s0">erfcinv = np.PyUFunc_FromFuncAndData(ufunc_erfcinv_loops, ufunc_erfcinv_data, ufunc_erfcinv_types, 2, 1, 1, 0, &quot;erfcinv&quot;, ufunc_erfcinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfcx_loops[4]</span>
<span class="s0">cdef void *ufunc_erfcx_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfcx_data[4]</span>
<span class="s0">cdef char ufunc_erfcx_types[8]</span>
<span class="s0">cdef char *ufunc_erfcx_doc = (</span>
    <span class="s0">&quot;erfcx(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Scaled complementary error function, ``exp(x**2) * erfc(x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the scaled complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfc, erfi, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.12.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfcx(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfcx(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfcx_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfcx_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfcx_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfcx_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfcx_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcx_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcx_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcx_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcx_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfcx_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfcx_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfcx_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfcx_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx</span>
<span class="s0">ufunc_erfcx_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx</span>
<span class="s0">ufunc_erfcx_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex</span>
<span class="s0">ufunc_erfcx_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex</span>
<span class="s0">ufunc_erfcx_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_data[0] = &amp;ufunc_erfcx_ptr[2*0]</span>
<span class="s0">ufunc_erfcx_data[1] = &amp;ufunc_erfcx_ptr[2*1]</span>
<span class="s0">ufunc_erfcx_data[2] = &amp;ufunc_erfcx_ptr[2*2]</span>
<span class="s0">ufunc_erfcx_data[3] = &amp;ufunc_erfcx_ptr[2*3]</span>
<span class="s0">erfcx = np.PyUFunc_FromFuncAndData(ufunc_erfcx_loops, ufunc_erfcx_data, ufunc_erfcx_types, 4, 1, 1, 0, &quot;erfcx&quot;, ufunc_erfcx_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfi_loops[4]</span>
<span class="s0">cdef void *ufunc_erfi_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfi_data[4]</span>
<span class="s0">cdef char ufunc_erfi_types[8]</span>
<span class="s0">cdef char *ufunc_erfi_doc = (</span>
    <span class="s0">&quot;erfi(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Imaginary error function, ``-i erf(i z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the imaginary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfc, erfcx, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.12.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfi(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfi(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfi_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi</span>
<span class="s0">ufunc_erfi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi</span>
<span class="s0">ufunc_erfi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex</span>
<span class="s0">ufunc_erfi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex</span>
<span class="s0">ufunc_erfi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_data[0] = &amp;ufunc_erfi_ptr[2*0]</span>
<span class="s0">ufunc_erfi_data[1] = &amp;ufunc_erfi_ptr[2*1]</span>
<span class="s0">ufunc_erfi_data[2] = &amp;ufunc_erfi_ptr[2*2]</span>
<span class="s0">ufunc_erfi_data[3] = &amp;ufunc_erfi_ptr[2*3]</span>
<span class="s0">erfi = np.PyUFunc_FromFuncAndData(ufunc_erfi_loops, ufunc_erfi_data, ufunc_erfi_types, 4, 1, 1, 0, &quot;erfi&quot;, ufunc_erfi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfinv_loops[2]</span>
<span class="s0">cdef void *ufunc_erfinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_erfinv_data[2]</span>
<span class="s0">cdef char ufunc_erfinv_types[4]</span>
<span class="s0">cdef char *ufunc_erfinv_doc = (</span>
    <span class="s0">&quot;erfinv(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the inverse of the error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the complex domain, there is no unique complex number w satisfying\n&quot;</span>
    <span class="s0">&quot;erf(w)=z. This indicates a true inverse function would be multivalued.\n&quot;</span>
    <span class="s0">&quot;When the domain restricts to the real, -1 &lt; x &lt; 1, there is a unique real\n&quot;</span>
    <span class="s0">&quot;number satisfying erf(erfinv(x)) = x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : ndarray\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate. Domain: [-1, 1]\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;erfinv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of erf of y, element-wise\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf : Error function of a complex argument\n&quot;</span>
    <span class="s0">&quot;erfc : Complementary error function, ``1 - erf(x)``\n&quot;</span>
    <span class="s0">&quot;erfcinv : Inverse of the complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import erfinv, erf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfinv(0.5)\n&quot;</span>
    <span class="s0">&quot;0.4769362762044699\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(-1.0, 1.0, num=9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = erfinv(y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x\n&quot;</span>
    <span class="s0">&quot;array([       -inf, -0.81341985, -0.47693628, -0.22531206,  0.        ,\n&quot;</span>
    <span class="s0">&quot;        0.22531206,  0.47693628,  0.81341985,         inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that ``erf(erfinv(y))`` is ``y``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erf(x)\n&quot;</span>
    <span class="s0">&quot;array([-1.  , -0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(-1, 1, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(y, erfinv(y))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('y')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('erfinv(y)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_f__As_f_f</span>
<span class="s0">ufunc_erfinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfinv_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfinv_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_erfinv_float</span>
<span class="s0">ufunc_erfinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfinv&quot;)</span>
<span class="s0">ufunc_erfinv_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_erfinv_double</span>
<span class="s0">ufunc_erfinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfinv&quot;)</span>
<span class="s0">ufunc_erfinv_data[0] = &amp;ufunc_erfinv_ptr[2*0]</span>
<span class="s0">ufunc_erfinv_data[1] = &amp;ufunc_erfinv_ptr[2*1]</span>
<span class="s0">erfinv = np.PyUFunc_FromFuncAndData(ufunc_erfinv_loops, ufunc_erfinv_data, ufunc_erfinv_types, 2, 1, 1, 0, &quot;erfinv&quot;, ufunc_erfinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyc_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyc_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyc_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyc_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyc_doc = (</span>
    <span class="s0">&quot;eval_chebyc(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    C_n(x) = 2 T_n(x/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.11 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyt`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;C : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyc : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the first kind on [-2, 2]\n&quot;</span>
    <span class="s0">&quot;chebyc : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebycshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are a scaled version of the Chebyshev polynomials of the\n&quot;</span>
    <span class="s0">&quot;first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebyc(3, x)\n&quot;</span>
    <span class="s0">&quot;array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 2 * sc.eval_chebyt(3, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])&quot;)</span>
<span class="s0">ufunc_eval_chebyc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_chebyc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyc_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyc_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_chebyc_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*0] = &lt;void*&gt;_func_eval_chebyc_l</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*1] = &lt;void*&gt;_func_eval_chebyc[double]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*2] = &lt;void*&gt;_func_eval_chebyc[double_complex]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*3] = &lt;void*&gt;_func_eval_chebyc[double]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*4] = &lt;void*&gt;_func_eval_chebyc[double_complex]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_data[0] = &amp;ufunc_eval_chebyc_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyc_data[1] = &amp;ufunc_eval_chebyc_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyc_data[2] = &amp;ufunc_eval_chebyc_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyc_data[3] = &amp;ufunc_eval_chebyc_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyc_data[4] = &amp;ufunc_eval_chebyc_ptr[2*4]</span>
<span class="s0">eval_chebyc = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyc_loops, ufunc_eval_chebyc_data, ufunc_eval_chebyc_types, 5, 2, 1, 0, &quot;eval_chebyc&quot;, ufunc_eval_chebyc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebys_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebys_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebys_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebys_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebys_doc = (</span>
    <span class="s0">&quot;eval_chebys(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    S_n(x) = U_n(x/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` is a Chebyshev polynomial of the second\n&quot;</span>
    <span class="s0">&quot;kind. See 22.5.13 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyu`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;S : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebys : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the second kind on [-2, 2]\n&quot;</span>
    <span class="s0">&quot;chebys : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are a scaled version of the Chebyshev polynomials of the\n&quot;</span>
    <span class="s0">&quot;second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebys(3, x)\n&quot;</span>
    <span class="s0">&quot;array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebyu(3, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])&quot;)</span>
<span class="s0">ufunc_eval_chebys_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_chebys_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebys_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebys_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebys_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebys_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_chebys_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebys_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebys_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebys_ptr[2*0] = &lt;void*&gt;_func_eval_chebys_l</span>
<span class="s0">ufunc_eval_chebys_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*1] = &lt;void*&gt;_func_eval_chebys[double]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*2] = &lt;void*&gt;_func_eval_chebys[double_complex]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*3] = &lt;void*&gt;_func_eval_chebys[double]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*4] = &lt;void*&gt;_func_eval_chebys[double_complex]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_data[0] = &amp;ufunc_eval_chebys_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebys_data[1] = &amp;ufunc_eval_chebys_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebys_data[2] = &amp;ufunc_eval_chebys_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebys_data[3] = &amp;ufunc_eval_chebys_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebys_data[4] = &amp;ufunc_eval_chebys_ptr[2*4]</span>
<span class="s0">eval_chebys = np.PyUFunc_FromFuncAndData(ufunc_eval_chebys_loops, ufunc_eval_chebys_data, ufunc_eval_chebys_types, 5, 2, 1, 0, &quot;eval_chebys&quot;, ufunc_eval_chebys_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyt_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyt_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyt_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyt_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyt_doc = (</span>
    <span class="s0">&quot;eval_chebyt(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the first kind at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Chebyshev polynomials of the first kind can be defined via the\n&quot;</span>
    <span class="s0">&quot;Gauss hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.47 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;T : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyt : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;chebyu : Chebychev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This routine is numerically stable for `x` in ``[-1, 1]`` at least\n&quot;</span>
    <span class="s0">&quot;up to order ``10000``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_chebyt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_chebyt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyt_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyt_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyt_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyt_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_chebyt_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*0] = &lt;void*&gt;_func_eval_chebyt_l</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*1] = &lt;void*&gt;_func_eval_chebyt[double]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*2] = &lt;void*&gt;_func_eval_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*3] = &lt;void*&gt;_func_eval_chebyt[double]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*4] = &lt;void*&gt;_func_eval_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_data[0] = &amp;ufunc_eval_chebyt_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyt_data[1] = &amp;ufunc_eval_chebyt_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyt_data[2] = &amp;ufunc_eval_chebyt_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyt_data[3] = &amp;ufunc_eval_chebyt_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyt_data[4] = &amp;ufunc_eval_chebyt_ptr[2*4]</span>
<span class="s0">eval_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyt_loops, ufunc_eval_chebyt_data, ufunc_eval_chebyt_types, 5, 2, 1, 0, &quot;eval_chebyt&quot;, ufunc_eval_chebyt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyu_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyu_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyu_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyu_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyu_doc = (</span>
    <span class="s0">&quot;eval_chebyu(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the second kind at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Chebyshev polynomials of the second kind can be defined via\n&quot;</span>
    <span class="s0">&quot;the Gauss hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.48 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;U : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyu : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;chebyu : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_chebyu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_chebyu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyu_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyu_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyu_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyu_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_chebyu_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*0] = &lt;void*&gt;_func_eval_chebyu_l</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*1] = &lt;void*&gt;_func_eval_chebyu[double]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*2] = &lt;void*&gt;_func_eval_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*3] = &lt;void*&gt;_func_eval_chebyu[double]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*4] = &lt;void*&gt;_func_eval_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_data[0] = &amp;ufunc_eval_chebyu_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyu_data[1] = &amp;ufunc_eval_chebyu_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyu_data[2] = &amp;ufunc_eval_chebyu_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyu_data[3] = &amp;ufunc_eval_chebyu_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyu_data[4] = &amp;ufunc_eval_chebyu_ptr[2*4]</span>
<span class="s0">eval_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyu_loops, ufunc_eval_chebyu_data, ufunc_eval_chebyu_types, 5, 2, 1, 0, &quot;eval_chebyu&quot;, ufunc_eval_chebyu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_gegenbauer_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_gegenbauer_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_gegenbauer_data[5]</span>
<span class="s0">cdef char ufunc_eval_gegenbauer_types[20]</span>
<span class="s0">cdef char *ufunc_eval_gegenbauer_doc = (</span>
    <span class="s0">&quot;eval_gegenbauer(n, alpha, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Gegenbauer polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Gegenbauer polynomials can be defined via the Gauss\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    C_n^{(\\alpha)} = \\frac{(2\\alpha)_n}{\\Gamma(n + 1)}\n&quot;</span>
    <span class="s0">&quot;      {}_2F_1(-n, 2\\alpha + n; \\alpha + 1/2; (1 - z)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.46 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Gegenbauer polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;C : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Gegenbauer polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_gegenbauer : roots and quadrature weights of Gegenbauer\n&quot;</span>
    <span class="s0">&quot;                   polynomials\n&quot;</span>
    <span class="s0">&quot;gegenbauer : Gegenbauer polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pdd__As_pdd_d</span>
<span class="s0">ufunc_eval_gegenbauer_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_eval_gegenbauer_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_eval_gegenbauer_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_eval_gegenbauer_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_eval_gegenbauer_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_gegenbauer_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*0] = &lt;void*&gt;_func_eval_gegenbauer_l</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*1] = &lt;void*&gt;_func_eval_gegenbauer[double]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*2] = &lt;void*&gt;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*3] = &lt;void*&gt;_func_eval_gegenbauer[double]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*4] = &lt;void*&gt;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_data[0] = &amp;ufunc_eval_gegenbauer_ptr[2*0]</span>
<span class="s0">ufunc_eval_gegenbauer_data[1] = &amp;ufunc_eval_gegenbauer_ptr[2*1]</span>
<span class="s0">ufunc_eval_gegenbauer_data[2] = &amp;ufunc_eval_gegenbauer_ptr[2*2]</span>
<span class="s0">ufunc_eval_gegenbauer_data[3] = &amp;ufunc_eval_gegenbauer_ptr[2*3]</span>
<span class="s0">ufunc_eval_gegenbauer_data[4] = &amp;ufunc_eval_gegenbauer_ptr[2*4]</span>
<span class="s0">eval_gegenbauer = np.PyUFunc_FromFuncAndData(ufunc_eval_gegenbauer_loops, ufunc_eval_gegenbauer_data, ufunc_eval_gegenbauer_types, 5, 3, 1, 0, &quot;eval_gegenbauer&quot;, ufunc_eval_gegenbauer_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_genlaguerre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_genlaguerre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_genlaguerre_data[5]</span>
<span class="s0">cdef char ufunc_eval_genlaguerre_types[20]</span>
<span class="s0">cdef char *ufunc_eval_genlaguerre_doc = (</span>
    <span class="s0">&quot;eval_genlaguerre(n, alpha, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate generalized Laguerre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The generalized Laguerre polynomials can be defined via the\n&quot;</span>
    <span class="s0">&quot;confluent hypergeometric function :math:`{}_1F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    L_n^{(\\alpha)}(x) = \\binom{n + \\alpha}{n}\n&quot;</span>
    <span class="s0">&quot;      {}_1F_1(-n, \\alpha + 1, x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.54 in [AS]_ for details. The Laguerre\n&quot;</span>
    <span class="s0">&quot;polynomials are the special case where :math:`\\alpha = 0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the confluent hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter; must have ``alpha &gt; -1``\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the generalized Laguerre\n&quot;</span>
    <span class="s0">&quot;    polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the generalized Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_genlaguerre : roots and quadrature weights of generalized\n&quot;</span>
    <span class="s0">&quot;                    Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;genlaguerre : generalized Laguerre polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp1f1 : confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;eval_laguerre : evaluate Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pdd__As_pdd_d</span>
<span class="s0">ufunc_eval_genlaguerre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_eval_genlaguerre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_eval_genlaguerre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_eval_genlaguerre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_eval_genlaguerre_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_genlaguerre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*0] = &lt;void*&gt;_func_eval_genlaguerre_l</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*1] = &lt;void*&gt;_func_eval_genlaguerre[double]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*2] = &lt;void*&gt;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*3] = &lt;void*&gt;_func_eval_genlaguerre[double]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*4] = &lt;void*&gt;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_data[0] = &amp;ufunc_eval_genlaguerre_ptr[2*0]</span>
<span class="s0">ufunc_eval_genlaguerre_data[1] = &amp;ufunc_eval_genlaguerre_ptr[2*1]</span>
<span class="s0">ufunc_eval_genlaguerre_data[2] = &amp;ufunc_eval_genlaguerre_ptr[2*2]</span>
<span class="s0">ufunc_eval_genlaguerre_data[3] = &amp;ufunc_eval_genlaguerre_ptr[2*3]</span>
<span class="s0">ufunc_eval_genlaguerre_data[4] = &amp;ufunc_eval_genlaguerre_ptr[2*4]</span>
<span class="s0">eval_genlaguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_genlaguerre_loops, ufunc_eval_genlaguerre_data, ufunc_eval_genlaguerre_types, 5, 3, 1, 0, &quot;eval_genlaguerre&quot;, ufunc_eval_genlaguerre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_hermite_loops[1]</span>
<span class="s0">cdef void *ufunc_eval_hermite_ptr[2]</span>
<span class="s0">cdef void *ufunc_eval_hermite_data[1]</span>
<span class="s0">cdef char ufunc_eval_hermite_types[3]</span>
<span class="s0">cdef char *ufunc_eval_hermite_doc = (</span>
    <span class="s0">&quot;eval_hermite(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate physicist's Hermite polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2};\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;:math:`H_n` is a polynomial of degree :math:`n`. See 22.11.7 in\n&quot;</span>
    <span class="s0">&quot;[AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;H : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_hermite : roots and quadrature weights of physicist's\n&quot;</span>
    <span class="s0">&quot;                Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;hermite : physicist's Hermite polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.hermite.Hermite : Physicist's Hermite series\n&quot;</span>
    <span class="s0">&quot;eval_hermitenorm : evaluate Probabilist's Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_hermite_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_hermite_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_hermite_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermite_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermite_ptr[2*0] = &lt;void*&gt;_func_eval_hermite</span>
<span class="s0">ufunc_eval_hermite_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_hermite&quot;)</span>
<span class="s0">ufunc_eval_hermite_data[0] = &amp;ufunc_eval_hermite_ptr[2*0]</span>
<span class="s0">eval_hermite = np.PyUFunc_FromFuncAndData(ufunc_eval_hermite_loops, ufunc_eval_hermite_data, ufunc_eval_hermite_types, 1, 2, 1, 0, &quot;eval_hermite&quot;, ufunc_eval_hermite_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_hermitenorm_loops[1]</span>
<span class="s0">cdef void *ufunc_eval_hermitenorm_ptr[2]</span>
<span class="s0">cdef void *ufunc_eval_hermitenorm_data[1]</span>
<span class="s0">cdef char ufunc_eval_hermitenorm_types[3]</span>
<span class="s0">cdef char *ufunc_eval_hermitenorm_doc = (</span>
    <span class="s0">&quot;eval_hermitenorm(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate probabilist's (normalized) Hermite polynomial at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    He_n(x) = (-1)^n e^{x^2/2} \\frac{d^n}{dx^n} e^{-x^2/2};\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;:math:`He_n` is a polynomial of degree :math:`n`. See 22.11.8 in\n&quot;</span>
    <span class="s0">&quot;[AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;He : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_hermitenorm : roots and quadrature weights of probabilist's\n&quot;</span>
    <span class="s0">&quot;                    Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;hermitenorm : probabilist's Hermite polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series\n&quot;</span>
    <span class="s0">&quot;eval_hermite : evaluate physicist's Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_hermitenorm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_hermitenorm_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_hermitenorm_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermitenorm_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermitenorm_ptr[2*0] = &lt;void*&gt;_func_eval_hermitenorm</span>
<span class="s0">ufunc_eval_hermitenorm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_hermitenorm&quot;)</span>
<span class="s0">ufunc_eval_hermitenorm_data[0] = &amp;ufunc_eval_hermitenorm_ptr[2*0]</span>
<span class="s0">eval_hermitenorm = np.PyUFunc_FromFuncAndData(ufunc_eval_hermitenorm_loops, ufunc_eval_hermitenorm_data, ufunc_eval_hermitenorm_types, 1, 2, 1, 0, &quot;eval_hermitenorm&quot;, ufunc_eval_hermitenorm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_jacobi_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_jacobi_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_jacobi_data[5]</span>
<span class="s0">cdef char ufunc_eval_jacobi_types[25]</span>
<span class="s0">cdef char *ufunc_eval_jacobi_doc = (</span>
    <span class="s0">&quot;eval_jacobi(n, alpha, beta, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Jacobi polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Jacobi polynomials can be defined via the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n^{(\\alpha, \\beta)}(x) = \\frac{(\\alpha + 1)_n}{\\Gamma(n + 1)}\n&quot;</span>
    <span class="s0">&quot;      {}_2F_1(-n, 1 + \\alpha + \\beta + n; \\alpha + 1; (1 - z)/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n&quot;</span>
    <span class="s0">&quot;:math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.42 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;beta : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Jacobi polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_jacobi : roots and quadrature weights of Jacobi polynomials\n&quot;</span>
    <span class="s0">&quot;jacobi : Jacobi polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_jacobi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pddd__As_pddd_d</span>
<span class="s0">ufunc_eval_jacobi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_eval_jacobi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_fffF_F</span>
<span class="s0">ufunc_eval_jacobi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_eval_jacobi_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_dddD_D</span>
<span class="s0">ufunc_eval_jacobi_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_jacobi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[10] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[11] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[12] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[23] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[24] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*0] = &lt;void*&gt;_func_eval_jacobi_l</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*1] = &lt;void*&gt;_func_eval_jacobi[double]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*2] = &lt;void*&gt;_func_eval_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*3] = &lt;void*&gt;_func_eval_jacobi[double]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*4] = &lt;void*&gt;_func_eval_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_data[0] = &amp;ufunc_eval_jacobi_ptr[2*0]</span>
<span class="s0">ufunc_eval_jacobi_data[1] = &amp;ufunc_eval_jacobi_ptr[2*1]</span>
<span class="s0">ufunc_eval_jacobi_data[2] = &amp;ufunc_eval_jacobi_ptr[2*2]</span>
<span class="s0">ufunc_eval_jacobi_data[3] = &amp;ufunc_eval_jacobi_ptr[2*3]</span>
<span class="s0">ufunc_eval_jacobi_data[4] = &amp;ufunc_eval_jacobi_ptr[2*4]</span>
<span class="s0">eval_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_jacobi_loops, ufunc_eval_jacobi_data, ufunc_eval_jacobi_types, 5, 4, 1, 0, &quot;eval_jacobi&quot;, ufunc_eval_jacobi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_laguerre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_laguerre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_laguerre_data[5]</span>
<span class="s0">cdef char ufunc_eval_laguerre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_laguerre_doc = (</span>
    <span class="s0">&quot;eval_laguerre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Laguerre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Laguerre polynomials can be defined via the confluent\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_1F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    L_n(x) = {}_1F_1(-n, 1, x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:`n` is an\n&quot;</span>
    <span class="s0">&quot;integer the result is a polynomial of degree :math:`n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the confluent hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_laguerre : roots and quadrature weights of Laguerre\n&quot;</span>
    <span class="s0">&quot;                 polynomials\n&quot;</span>
    <span class="s0">&quot;laguerre : Laguerre polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.laguerre.Laguerre : Laguerre series\n&quot;</span>
    <span class="s0">&quot;eval_genlaguerre : evaluate generalized Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_laguerre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_laguerre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_laguerre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_laguerre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_laguerre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_laguerre_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_laguerre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*0] = &lt;void*&gt;_func_eval_laguerre_l</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*1] = &lt;void*&gt;_func_eval_laguerre[double]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*2] = &lt;void*&gt;_func_eval_laguerre[double_complex]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*3] = &lt;void*&gt;_func_eval_laguerre[double]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*4] = &lt;void*&gt;_func_eval_laguerre[double_complex]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_data[0] = &amp;ufunc_eval_laguerre_ptr[2*0]</span>
<span class="s0">ufunc_eval_laguerre_data[1] = &amp;ufunc_eval_laguerre_ptr[2*1]</span>
<span class="s0">ufunc_eval_laguerre_data[2] = &amp;ufunc_eval_laguerre_ptr[2*2]</span>
<span class="s0">ufunc_eval_laguerre_data[3] = &amp;ufunc_eval_laguerre_ptr[2*3]</span>
<span class="s0">ufunc_eval_laguerre_data[4] = &amp;ufunc_eval_laguerre_ptr[2*4]</span>
<span class="s0">eval_laguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_laguerre_loops, ufunc_eval_laguerre_data, ufunc_eval_laguerre_types, 5, 2, 1, 0, &quot;eval_laguerre&quot;, ufunc_eval_laguerre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_legendre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_legendre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_legendre_data[5]</span>
<span class="s0">cdef char ufunc_eval_legendre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_legendre_doc = (</span>
    <span class="s0">&quot;eval_legendre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Legendre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre polynomials can be defined via the Gauss\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.49 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_legendre : roots and quadrature weights of Legendre\n&quot;</span>
    <span class="s0">&quot;                 polynomials\n&quot;</span>
    <span class="s0">&quot;legendre : Legendre polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.legendre.Legendre : Legendre series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import eval_legendre\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the zero-order Legendre polynomial at x = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(0, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the first-order Legendre polynomial between -1 and 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; X = np.linspace(-1, 1, 5)  # Domain of Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(1, X)\n&quot;</span>
    <span class="s0">&quot;array([-1. , -0.5,  0. ,  0.5,  1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Legendre polynomials of order 0 through 4 at x = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; N = range(0, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(N, 0)\n&quot;</span>
    <span class="s0">&quot;array([ 1.   ,  0.   , -0.5  ,  0.   ,  0.375])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot Legendre polynomials of order 0 through 4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; X = np.linspace(-1, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for n in range(0, 5):\n&quot;</span>
    <span class="s0">&quot;...     y = eval_legendre(n, X)\n&quot;</span>
    <span class="s0">&quot;...     plt.plot(X, y, label=r'$P_{}(x)$'.format(n))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title(\&quot;Legendre Polynomials\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel(\&quot;x\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel(r'$P_n(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(loc='lower right')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_eval_legendre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_legendre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_legendre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_legendre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_legendre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_legendre_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_legendre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_legendre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_legendre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_legendre_ptr[2*0] = &lt;void*&gt;_func_eval_legendre_l</span>
<span class="s0">ufunc_eval_legendre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*1] = &lt;void*&gt;_func_eval_legendre[double]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*2] = &lt;void*&gt;_func_eval_legendre[double_complex]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*3] = &lt;void*&gt;_func_eval_legendre[double]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*4] = &lt;void*&gt;_func_eval_legendre[double_complex]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_data[0] = &amp;ufunc_eval_legendre_ptr[2*0]</span>
<span class="s0">ufunc_eval_legendre_data[1] = &amp;ufunc_eval_legendre_ptr[2*1]</span>
<span class="s0">ufunc_eval_legendre_data[2] = &amp;ufunc_eval_legendre_ptr[2*2]</span>
<span class="s0">ufunc_eval_legendre_data[3] = &amp;ufunc_eval_legendre_ptr[2*3]</span>
<span class="s0">ufunc_eval_legendre_data[4] = &amp;ufunc_eval_legendre_ptr[2*4]</span>
<span class="s0">eval_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_legendre_loops, ufunc_eval_legendre_data, ufunc_eval_legendre_types, 5, 2, 1, 0, &quot;eval_legendre&quot;, ufunc_eval_legendre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyt_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyt_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyt_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_chebyt_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_chebyt_doc = (</span>
    <span class="s0">&quot;eval_sh_chebyt(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Chebyshev polynomial of the first kind at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    T_n^*(x) = T_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.14 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyt`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;T : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_chebyt : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                  Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;sh_chebyt : shifted Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_chebyt_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_sh_chebyt_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*0] = &lt;void*&gt;_func_eval_sh_chebyt_l</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*1] = &lt;void*&gt;_func_eval_sh_chebyt[double]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*2] = &lt;void*&gt;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*3] = &lt;void*&gt;_func_eval_sh_chebyt[double]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*4] = &lt;void*&gt;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_data[0] = &amp;ufunc_eval_sh_chebyt_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[1] = &amp;ufunc_eval_sh_chebyt_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[2] = &amp;ufunc_eval_sh_chebyt_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[3] = &amp;ufunc_eval_sh_chebyt_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[4] = &amp;ufunc_eval_sh_chebyt_ptr[2*4]</span>
<span class="s0">eval_sh_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyt_loops, ufunc_eval_sh_chebyt_data, ufunc_eval_sh_chebyt_types, 5, 2, 1, 0, &quot;eval_sh_chebyt&quot;, ufunc_eval_sh_chebyt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyu_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyu_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyu_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_chebyu_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_chebyu_doc = (</span>
    <span class="s0">&quot;eval_sh_chebyu(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Chebyshev polynomial of the second kind at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    U_n^*(x) = U_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.15 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyu`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;U : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_chebyu : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                  Chebychev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;sh_chebyu : shifted Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_chebyu_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_sh_chebyu_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*0] = &lt;void*&gt;_func_eval_sh_chebyu_l</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*1] = &lt;void*&gt;_func_eval_sh_chebyu[double]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*2] = &lt;void*&gt;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*3] = &lt;void*&gt;_func_eval_sh_chebyu[double]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*4] = &lt;void*&gt;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_data[0] = &amp;ufunc_eval_sh_chebyu_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[1] = &amp;ufunc_eval_sh_chebyu_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[2] = &amp;ufunc_eval_sh_chebyu_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[3] = &amp;ufunc_eval_sh_chebyu_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[4] = &amp;ufunc_eval_sh_chebyu_ptr[2*4]</span>
<span class="s0">eval_sh_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyu_loops, ufunc_eval_sh_chebyu_data, ufunc_eval_sh_chebyu_types, 5, 2, 1, 0, &quot;eval_sh_chebyu&quot;, ufunc_eval_sh_chebyu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_jacobi_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_jacobi_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_jacobi_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_jacobi_types[25]</span>
<span class="s0">cdef char *ufunc_eval_sh_jacobi_doc = (</span>
    <span class="s0">&quot;eval_sh_jacobi(n, p, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Jacobi polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    G_n^{(p, q)}(x)\n&quot;</span>
    <span class="s0">&quot;      = \\binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P_n^{(\\cdot, \\cdot)}` is the n-th Jacobi\n&quot;</span>
    <span class="s0">&quot;polynomial. See 22.5.2 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `binom` and `eval_jacobi`.\n&quot;</span>
    <span class="s0">&quot;p : float\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;q : float\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;G : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Jacobi polynomial.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_jacobi : roots and quadrature weights of shifted Jacobi\n&quot;</span>
    <span class="s0">&quot;                  polynomials\n&quot;</span>
    <span class="s0">&quot;sh_jacobi : shifted Jacobi polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_jacobi : evaluate Jacobi polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pddd__As_pddd_d</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_fffF_F</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_dddD_D</span>
<span class="s0">ufunc_eval_sh_jacobi_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_sh_jacobi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[10] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[11] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[12] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[23] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[24] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*0] = &lt;void*&gt;_func_eval_sh_jacobi_l</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*1] = &lt;void*&gt;_func_eval_sh_jacobi[double]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*2] = &lt;void*&gt;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*3] = &lt;void*&gt;_func_eval_sh_jacobi[double]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*4] = &lt;void*&gt;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_data[0] = &amp;ufunc_eval_sh_jacobi_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[1] = &amp;ufunc_eval_sh_jacobi_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[2] = &amp;ufunc_eval_sh_jacobi_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[3] = &amp;ufunc_eval_sh_jacobi_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[4] = &amp;ufunc_eval_sh_jacobi_ptr[2*4]</span>
<span class="s0">eval_sh_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_jacobi_loops, ufunc_eval_sh_jacobi_data, ufunc_eval_sh_jacobi_types, 5, 4, 1, 0, &quot;eval_sh_jacobi&quot;, ufunc_eval_sh_jacobi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_legendre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_legendre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_legendre_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_legendre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_legendre_doc = (</span>
    <span class="s0">&quot;eval_sh_legendre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Legendre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n^*(x) = P_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P_n` is a Legendre polynomial. See 2.2.11 in [AS]_\n&quot;</span>
    <span class="s0">&quot;for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the value is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_legendre`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_legendre : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                    Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;sh_legendre : shifted Legendre polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_legendre : evaluate Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.legendre.Legendre : Legendre series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_eval_sh_legendre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_legendre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_legendre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_legendre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_legendre_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_eval_sh_legendre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*0] = &lt;void*&gt;_func_eval_sh_legendre_l</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*1] = &lt;void*&gt;_func_eval_sh_legendre[double]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*2] = &lt;void*&gt;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*3] = &lt;void*&gt;_func_eval_sh_legendre[double]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*4] = &lt;void*&gt;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_data[0] = &amp;ufunc_eval_sh_legendre_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_legendre_data[1] = &amp;ufunc_eval_sh_legendre_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_legendre_data[2] = &amp;ufunc_eval_sh_legendre_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_legendre_data[3] = &amp;ufunc_eval_sh_legendre_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_legendre_data[4] = &amp;ufunc_eval_sh_legendre_ptr[2*4]</span>
<span class="s0">eval_sh_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_legendre_loops, ufunc_eval_sh_legendre_data, ufunc_eval_sh_legendre_types, 5, 2, 1, 0, &quot;eval_sh_legendre&quot;, ufunc_eval_sh_legendre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exp10_loops[2]</span>
<span class="s0">cdef void *ufunc_exp10_ptr[4]</span>
<span class="s0">cdef void *ufunc_exp10_data[2]</span>
<span class="s0">cdef char ufunc_exp10_types[4]</span>
<span class="s0">cdef char *ufunc_exp10_doc = (</span>
    <span class="s0">&quot;exp10(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``10**x`` element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``10**x``, computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import exp10\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp10(3)\n&quot;</span>
    <span class="s0">&quot;1000.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp10(x)\n&quot;</span>
    <span class="s0">&quot;array([[  0.1       ,   0.31622777,   1.        ],\n&quot;</span>
    <span class="s0">&quot;       [  3.16227766,  10.        ,  31.6227766 ]])&quot;)</span>
<span class="s0">ufunc_exp10_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exp10_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exp10_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp10_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp10_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp10_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp10_ptr[2*0] = &lt;void*&gt;_func_cephes_exp10</span>
<span class="s0">ufunc_exp10_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp10&quot;)</span>
<span class="s0">ufunc_exp10_ptr[2*1] = &lt;void*&gt;_func_cephes_exp10</span>
<span class="s0">ufunc_exp10_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp10&quot;)</span>
<span class="s0">ufunc_exp10_data[0] = &amp;ufunc_exp10_ptr[2*0]</span>
<span class="s0">ufunc_exp10_data[1] = &amp;ufunc_exp10_ptr[2*1]</span>
<span class="s0">exp10 = np.PyUFunc_FromFuncAndData(ufunc_exp10_loops, ufunc_exp10_data, ufunc_exp10_types, 2, 1, 1, 0, &quot;exp10&quot;, ufunc_exp10_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exp2_loops[2]</span>
<span class="s0">cdef void *ufunc_exp2_ptr[4]</span>
<span class="s0">cdef void *ufunc_exp2_data[2]</span>
<span class="s0">cdef char ufunc_exp2_types[4]</span>
<span class="s0">cdef char *ufunc_exp2_doc = (</span>
    <span class="s0">&quot;exp2(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``2**x`` element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``2**x``, computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import exp2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp2(3)\n&quot;</span>
    <span class="s0">&quot;8.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp2(x)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.5       ,  0.70710678,  1.        ],\n&quot;</span>
    <span class="s0">&quot;       [ 1.41421356,  2.        ,  2.82842712]])&quot;)</span>
<span class="s0">ufunc_exp2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exp2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exp2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp2_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp2_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp2_ptr[2*0] = &lt;void*&gt;_func_cephes_exp2</span>
<span class="s0">ufunc_exp2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp2&quot;)</span>
<span class="s0">ufunc_exp2_ptr[2*1] = &lt;void*&gt;_func_cephes_exp2</span>
<span class="s0">ufunc_exp2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp2&quot;)</span>
<span class="s0">ufunc_exp2_data[0] = &amp;ufunc_exp2_ptr[2*0]</span>
<span class="s0">ufunc_exp2_data[1] = &amp;ufunc_exp2_ptr[2*1]</span>
<span class="s0">exp2 = np.PyUFunc_FromFuncAndData(ufunc_exp2_loops, ufunc_exp2_data, ufunc_exp2_types, 2, 1, 1, 0, &quot;exp2&quot;, ufunc_exp2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expm1_loops[4]</span>
<span class="s0">cdef void *ufunc_expm1_ptr[8]</span>
<span class="s0">cdef void *ufunc_expm1_data[4]</span>
<span class="s0">cdef char ufunc_expm1_types[8]</span>
<span class="s0">cdef char *ufunc_expm1_doc = (</span>
    <span class="s0">&quot;expm1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``exp(x) - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n&quot;</span>
    <span class="s0">&quot;of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n&quot;</span>
    <span class="s0">&quot;``expm1(x)`` is implemented to avoid the loss of precision that occurs when\n&quot;</span>
    <span class="s0">&quot;`x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``exp(x) - 1`` computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import expm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1(1.0)\n&quot;</span>
    <span class="s0">&quot;1.7182818284590451\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1([-0.2, -0.1, 0, 0.1, 0.2])\n&quot;</span>
    <span class="s0">&quot;array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The exact value of ``exp(7.5e-13) - 1`` is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    7.5000000000028125000000007031250000001318...*10**-13.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here is what ``expm1(7.5e-13)`` gives:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1(7.5e-13)\n&quot;</span>
    <span class="s0">&quot;7.5000000000028135e-13\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that to ``exp(7.5e-13) - 1``, where the subtraction results in\n&quot;</span>
    <span class="s0">&quot;a \&quot;catastrophic\&quot; loss of precision:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp(7.5e-13) - 1\n&quot;</span>
    <span class="s0">&quot;7.5006667543675576e-13&quot;)</span>
<span class="s0">ufunc_expm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_expm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_expm1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_expm1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_expm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expm1_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expm1_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expm1_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expm1_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expm1_ptr[2*0] = &lt;void*&gt;_func_cephes_expm1</span>
<span class="s0">ufunc_expm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*1] = &lt;void*&gt;_func_cephes_expm1</span>
<span class="s0">ufunc_expm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*2] = &lt;void*&gt;_func_cexpm1</span>
<span class="s0">ufunc_expm1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*3] = &lt;void*&gt;_func_cexpm1</span>
<span class="s0">ufunc_expm1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_data[0] = &amp;ufunc_expm1_ptr[2*0]</span>
<span class="s0">ufunc_expm1_data[1] = &amp;ufunc_expm1_ptr[2*1]</span>
<span class="s0">ufunc_expm1_data[2] = &amp;ufunc_expm1_ptr[2*2]</span>
<span class="s0">ufunc_expm1_data[3] = &amp;ufunc_expm1_ptr[2*3]</span>
<span class="s0">expm1 = np.PyUFunc_FromFuncAndData(ufunc_expm1_loops, ufunc_expm1_data, ufunc_expm1_types, 4, 1, 1, 0, &quot;expm1&quot;, ufunc_expm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expn_loops[3]</span>
<span class="s0">cdef void *ufunc_expn_ptr[6]</span>
<span class="s0">cdef void *ufunc_expn_data[3]</span>
<span class="s0">cdef char ufunc_expn_types[9]</span>
<span class="s0">cdef char *ufunc_expn_doc = (</span>
    <span class="s0">&quot;expn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Generalized exponential integral En.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For integer :math:`n \\geq 0` and real :math:`x \\geq 0` the\n&quot;</span>
    <span class="s0">&quot;generalized exponential integral is defined as [dlmf]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    E_n(x) = x^{n - 1} \\int_x^\\infty \\frac{e^{-t}}{t^n} dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-negative integers\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the generalized exponential integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;exp1 : special case of :math:`E_n` for :math:`n = 1`\n&quot;</span>
    <span class="s0">&quot;expi : related to :math:`E_n` when :math:`n = 1`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] Digital Library of Mathematical Functions, 8.19.2\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.19#E2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Its domain is nonnegative n and x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(-1, 1.0), sc.expn(1, -1.0)\n&quot;</span>
    <span class="s0">&quot;(nan, nan)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a pole at ``x = 0`` for ``n = 1, 2``; for larger ``n`` it\n&quot;</span>
    <span class="s0">&quot;is equal to ``1 / (n - 1)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn([0, 1, 2, 3, 4], 0)\n&quot;</span>
    <span class="s0">&quot;array([       inf,        inf, 1.        , 0.5       , 0.33333333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For n equal to 0 it reduces to ``exp(-x) / x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(0, x)\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp(-x) / x\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For n equal to 1 it reduces to `exp1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(1, x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])&quot;)</span>
<span class="s0">ufunc_expn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_expn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_expn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_expn_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_expn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_ptr[2*0] = &lt;void*&gt;_func_cephes_expn_wrap</span>
<span class="s0">ufunc_expn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_ptr[2*1] = &lt;void*&gt;_func_expn_unsafe</span>
<span class="s0">ufunc_expn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_ptr[2*2] = &lt;void*&gt;_func_expn_unsafe</span>
<span class="s0">ufunc_expn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_data[0] = &amp;ufunc_expn_ptr[2*0]</span>
<span class="s0">ufunc_expn_data[1] = &amp;ufunc_expn_ptr[2*1]</span>
<span class="s0">ufunc_expn_data[2] = &amp;ufunc_expn_ptr[2*2]</span>
<span class="s0">expn = np.PyUFunc_FromFuncAndData(ufunc_expn_loops, ufunc_expn_data, ufunc_expn_types, 3, 2, 1, 0, &quot;expn&quot;, ufunc_expn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtr_data[2]</span>
<span class="s0">cdef char ufunc_fdtr_types[8]</span>
<span class="s0">cdef char *ufunc_fdtr_doc = (</span>
    <span class="s0">&quot;fdtr(dfn, dfd, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;F cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the value of the cumulative distribution function of the\n&quot;</span>
    <span class="s0">&quot;F-distribution, also known as Snedecor's F-distribution or the\n&quot;</span>
    <span class="s0">&quot;Fisher-Snedecor distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F-distribution with parameters :math:`d_n` and :math:`d_d` is the\n&quot;</span>
    <span class="s0">&quot;distribution of the random variable,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    X = \\frac{U_n/d_n}{U_d/d_d},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` and :math:`U_d` are random variables distributed\n&quot;</span>
    <span class="s0">&quot;:math:`\\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom,\n&quot;</span>
    <span class="s0">&quot;respectively.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution inverse cumulative distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The regularized incomplete beta function is used, according to the\n&quot;</span>
    <span class="s0">&quot;formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtr`. The F distribution is also\n&quot;</span>
    <span class="s0">&quot;available as `scipy.stats.f`. Calling `fdtr` directly can improve\n&quot;</span>
    <span class="s0">&quot;performance compared to the ``cdf`` method of `scipy.stats.f` (see last\n&quot;</span>
    <span class="s0">&quot;example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr(1, 2, 1)\n&quot;</span>
    <span class="s0">&quot;0.5773502691896258\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.5, 2., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.4472136 , 0.70710678, 0.77459667])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtr_vals = fdtr(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtr_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;F distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtr`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).cdf(x)=fdtr(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr_res = fdtr(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr_res == f_dist_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_fdtr</span>
<span class="s0">ufunc_fdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtr&quot;)</span>
<span class="s0">ufunc_fdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_fdtr</span>
<span class="s0">ufunc_fdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtr&quot;)</span>
<span class="s0">ufunc_fdtr_data[0] = &amp;ufunc_fdtr_ptr[2*0]</span>
<span class="s0">ufunc_fdtr_data[1] = &amp;ufunc_fdtr_ptr[2*1]</span>
<span class="s0">fdtr = np.PyUFunc_FromFuncAndData(ufunc_fdtr_loops, ufunc_fdtr_data, ufunc_fdtr_types, 2, 3, 1, 0, &quot;fdtr&quot;, ufunc_fdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtrc_data[2]</span>
<span class="s0">cdef char ufunc_fdtrc_types[8]</span>
<span class="s0">cdef char *ufunc_fdtrc_doc = (</span>
    <span class="s0">&quot;fdtrc(dfn, dfd, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;F survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the complemented F-distribution function (the integral of the\n&quot;</span>
    <span class="s0">&quot;density from `x` to infinity).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The complemented F-distribution function with parameters `dfn` and\n&quot;</span>
    <span class="s0">&quot;    `dfd` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution inverse cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The regularized incomplete beta function is used, according to the\n&quot;</span>
    <span class="s0">&quot;formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtrc`. The F distribution is also\n&quot;</span>
    <span class="s0">&quot;available as `scipy.stats.f`. Calling `fdtrc` directly can improve\n&quot;</span>
    <span class="s0">&quot;performance compared to the ``sf`` method of `scipy.stats.f` (see last\n&quot;</span>
    <span class="s0">&quot;example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc(1, 2, 1)\n&quot;</span>
    <span class="s0">&quot;0.42264973081037427\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.5, 2., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.5527864 , 0.29289322, 0.22540333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtrc_vals = fdtrc(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtrc_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;F distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtrc`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``sf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).sf(x)=fdtrc(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc_res = fdtrc(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).sf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res == fdtrc_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_ptr[2*0] = &lt;void*&gt;_func_cephes_fdtrc</span>
<span class="s0">ufunc_fdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtrc&quot;)</span>
<span class="s0">ufunc_fdtrc_ptr[2*1] = &lt;void*&gt;_func_cephes_fdtrc</span>
<span class="s0">ufunc_fdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtrc&quot;)</span>
<span class="s0">ufunc_fdtrc_data[0] = &amp;ufunc_fdtrc_ptr[2*0]</span>
<span class="s0">ufunc_fdtrc_data[1] = &amp;ufunc_fdtrc_ptr[2*1]</span>
<span class="s0">fdtrc = np.PyUFunc_FromFuncAndData(ufunc_fdtrc_loops, ufunc_fdtrc_data, ufunc_fdtrc_types, 2, 3, 1, 0, &quot;fdtrc&quot;, ufunc_fdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtri_data[2]</span>
<span class="s0">cdef char ufunc_fdtri_types[8]</span>
<span class="s0">cdef char *ufunc_fdtri_doc = (</span>
    <span class="s0">&quot;fdtri(dfn, dfd, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the F-distribution CDF, `fdtr`, returning\n&quot;</span>
    <span class="s0">&quot;the `x` such that `fdtr(dfn, dfd, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The quantile corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The computation is carried out using the relation to the inverse\n&quot;</span>
    <span class="s0">&quot;regularized beta function, :math:`I^{-1}_x(a, b)`.  Let\n&quot;</span>
    <span class="s0">&quot;:math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    x = \\frac{d_d (1 - z)}{d_n z}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `p` is such that :math:`x &lt; 0.5`, the following relation is used\n&quot;</span>
    <span class="s0">&quot;instead for improved stability: let\n&quot;</span>
    <span class="s0">&quot;:math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    x = \\frac{d_d z'}{d_n (1 - z')}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Calling\n&quot;</span>
    <span class="s0">&quot;`fdtri` directly can improve performance compared to the ``ppf``\n&quot;</span>
    <span class="s0">&quot;method of `scipy.stats.f` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`fdtri` represents the inverse of the F distribution CDF which is\n&quot;</span>
    <span class="s0">&quot;available as `fdtr`. Here, we calculate the CDF for ``df1=1``, ``df2=2``\n&quot;</span>
    <span class="s0">&quot;at ``x=3``. `fdtri` then returns ``3`` given the same values for `df1`,\n&quot;</span>
    <span class="s0">&quot;`df2` and the computed CDF value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtri, fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df1, df2 = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value =  fdtr(df1, df2, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri(df1, df2, cdf_value)\n&quot;</span>
    <span class="s0">&quot;3.000000000000006\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.1, 0.4, 0.7])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.02020202, 0.38095238, 1.92156863])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [50, 10, 1, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [0.5, 1, 1, 5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtri_vals = fdtri(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtri_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; title = \&quot;F distribution inverse cumulative distribution function\&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(title)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 30)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtri`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``ppf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).ppf(x)=fdtri(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 0.7\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri_res = fdtri(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).ppf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res == fdtri_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_ptr[2*0] = &lt;void*&gt;_func_cephes_fdtri</span>
<span class="s0">ufunc_fdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtri&quot;)</span>
<span class="s0">ufunc_fdtri_ptr[2*1] = &lt;void*&gt;_func_cephes_fdtri</span>
<span class="s0">ufunc_fdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtri&quot;)</span>
<span class="s0">ufunc_fdtri_data[0] = &amp;ufunc_fdtri_ptr[2*0]</span>
<span class="s0">ufunc_fdtri_data[1] = &amp;ufunc_fdtri_ptr[2*1]</span>
<span class="s0">fdtri = np.PyUFunc_FromFuncAndData(ufunc_fdtri_loops, ufunc_fdtri_data, ufunc_fdtri_types, 2, 3, 1, 0, &quot;fdtri&quot;, ufunc_fdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtridfd_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtridfd_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtridfd_data[2]</span>
<span class="s0">cdef char ufunc_fdtridfd_types[8]</span>
<span class="s0">cdef char *ufunc_fdtridfd_doc = (</span>
    <span class="s0">&quot;fdtridfd(dfn, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `fdtr` vs dfd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfd : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    `dfd` such that ``fdtr(dfn, dfd, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution quantile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the F distribution cumulative distribution function for one\n&quot;</span>
    <span class="s0">&quot;parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtridfd, fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd, x = 10, 5, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = fdtr(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.7700248806501017\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `fdtridfd` recovers the original value for `dfd`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtridfd(dfn, cdf_value, x)\n&quot;</span>
    <span class="s0">&quot;5.0&quot;)</span>
<span class="s0">ufunc_fdtridfd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtridfd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtridfd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_ptr[2*0] = &lt;void*&gt;_func_fdtridfd</span>
<span class="s0">ufunc_fdtridfd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtridfd&quot;)</span>
<span class="s0">ufunc_fdtridfd_ptr[2*1] = &lt;void*&gt;_func_fdtridfd</span>
<span class="s0">ufunc_fdtridfd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtridfd&quot;)</span>
<span class="s0">ufunc_fdtridfd_data[0] = &amp;ufunc_fdtridfd_ptr[2*0]</span>
<span class="s0">ufunc_fdtridfd_data[1] = &amp;ufunc_fdtridfd_ptr[2*1]</span>
<span class="s0">fdtridfd = np.PyUFunc_FromFuncAndData(ufunc_fdtridfd_loops, ufunc_fdtridfd_data, ufunc_fdtridfd_types, 2, 3, 1, 0, &quot;fdtridfd&quot;, ufunc_fdtridfd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fresnel_loops[4]</span>
<span class="s0">cdef void *ufunc_fresnel_ptr[8]</span>
<span class="s0">cdef void *ufunc_fresnel_data[4]</span>
<span class="s0">cdef char ufunc_fresnel_types[12]</span>
<span class="s0">cdef char *ufunc_fresnel_doc = (</span>
    <span class="s0">&quot;fresnel(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Fresnel integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Fresnel integrals are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   S(z) &amp;= \\int_0^z \\sin(\\pi t^2 /2) dt \\\\\n&quot;</span>
    <span class="s0">&quot;   C(z) &amp;= \\int_0^z \\cos(\\pi t^2 /2) dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : 2-tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;S, C : 2-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Fresnel integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fresnel_zeros : zeros of the Fresnel integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/7.2#iii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;As z goes to infinity along the real axis, S and C converge to 0.5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S, C = sc.fresnel([0.1, 1, 10, 100, np.inf])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S\n&quot;</span>
    <span class="s0">&quot;array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C\n&quot;</span>
    <span class="s0">&quot;array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are related to the error function `erf`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S, C = sc.fresnel(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C + 1j*S\n&quot;</span>
    <span class="s0">&quot;array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n&quot;</span>
    <span class="s0">&quot;       0.60572079+0.496313j  , 0.49842603+0.42051575j])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.5 * (1 + 1j) * sc.erf(zeta)\n&quot;</span>
    <span class="s0">&quot;array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n&quot;</span>
    <span class="s0">&quot;       0.60572079+0.496313j  , 0.49842603+0.42051575j])&quot;)</span>
<span class="s0">ufunc_fresnel_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_fresnel_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_fresnel_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_fresnel_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_fresnel_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_ptr[2*0] = &lt;void*&gt;_func_cephes_fresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*1] = &lt;void*&gt;_func_cephes_fresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*2] = &lt;void*&gt;_func_cfresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*3] = &lt;void*&gt;_func_cfresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_data[0] = &amp;ufunc_fresnel_ptr[2*0]</span>
<span class="s0">ufunc_fresnel_data[1] = &amp;ufunc_fresnel_ptr[2*1]</span>
<span class="s0">ufunc_fresnel_data[2] = &amp;ufunc_fresnel_ptr[2*2]</span>
<span class="s0">ufunc_fresnel_data[3] = &amp;ufunc_fresnel_ptr[2*3]</span>
<span class="s0">fresnel = np.PyUFunc_FromFuncAndData(ufunc_fresnel_loops, ufunc_fresnel_data, ufunc_fresnel_types, 4, 1, 2, 0, &quot;fresnel&quot;, ufunc_fresnel_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammainc_loops[2]</span>
<span class="s0">cdef void *ufunc_gammainc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammainc_data[2]</span>
<span class="s0">cdef char ufunc_gammainc_types[6]</span>
<span class="s0">cdef char *ufunc_gammainc_doc = (</span>
    <span class="s0">&quot;gammainc(a, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P(a, x) = \\frac{1}{\\Gamma(a)} \\int_0^x t^{a - 1}e^{-t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`a &gt; 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The function satisfies the relation ``gammainc(a, x) +\n&quot;</span>
    <span class="s0">&quot;gammaincc(a, x) = 1`` where `gammaincc` is the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation largely follows that of [boost]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;.. [boost] Maddock et. al., \&quot;Incomplete Gamma Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the CDF of the gamma distribution, so it starts at 0 and\n&quot;</span>
    <span class="s0">&quot;monotonically increases to 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(0.5, [0, 1, 10, 100])\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.84270079, 0.99999226, 1.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is equal to one minus the upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.6289066304773024\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.gammaincc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.6289066304773024&quot;)</span>
<span class="s0">ufunc_gammainc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammainc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammainc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_ptr[2*0] = &lt;void*&gt;_func_cephes_igam</span>
<span class="s0">ufunc_gammainc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainc&quot;)</span>
<span class="s0">ufunc_gammainc_ptr[2*1] = &lt;void*&gt;_func_cephes_igam</span>
<span class="s0">ufunc_gammainc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainc&quot;)</span>
<span class="s0">ufunc_gammainc_data[0] = &amp;ufunc_gammainc_ptr[2*0]</span>
<span class="s0">ufunc_gammainc_data[1] = &amp;ufunc_gammainc_ptr[2*1]</span>
<span class="s0">gammainc = np.PyUFunc_FromFuncAndData(ufunc_gammainc_loops, ufunc_gammainc_data, ufunc_gammainc_types, 2, 2, 1, 0, &quot;gammainc&quot;, ufunc_gammainc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammaincc_loops[2]</span>
<span class="s0">cdef void *ufunc_gammaincc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammaincc_data[2]</span>
<span class="s0">cdef char ufunc_gammaincc_types[6]</span>
<span class="s0">cdef char *ufunc_gammaincc_doc = (</span>
    <span class="s0">&quot;gammaincc(a, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Q(a, x) = \\frac{1}{\\Gamma(a)} \\int_x^\\infty t^{a - 1}e^{-t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`a &gt; 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The function satisfies the relation ``gammainc(a, x) +\n&quot;</span>
    <span class="s0">&quot;gammaincc(a, x) = 1`` where `gammainc` is the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation largely follows that of [boost]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;.. [boost] Maddock et. al., \&quot;Incomplete Gamma Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the survival function of the gamma distribution, so it\n&quot;</span>
    <span class="s0">&quot;starts at 1 and monotonically decreases to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(0.5, [0, 1, 10, 100, 1000])\n&quot;</span>
    <span class="s0">&quot;array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45,\n&quot;</span>
    <span class="s0">&quot;       0.00000000e+00])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is equal to one minus the lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.37109336952269756\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.gammainc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.37109336952269756&quot;)</span>
<span class="s0">ufunc_gammaincc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammaincc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammaincc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_ptr[2*0] = &lt;void*&gt;_func_cephes_igamc</span>
<span class="s0">ufunc_gammaincc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincc&quot;)</span>
<span class="s0">ufunc_gammaincc_ptr[2*1] = &lt;void*&gt;_func_cephes_igamc</span>
<span class="s0">ufunc_gammaincc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincc&quot;)</span>
<span class="s0">ufunc_gammaincc_data[0] = &amp;ufunc_gammaincc_ptr[2*0]</span>
<span class="s0">ufunc_gammaincc_data[1] = &amp;ufunc_gammaincc_ptr[2*1]</span>
<span class="s0">gammaincc = np.PyUFunc_FromFuncAndData(ufunc_gammaincc_loops, ufunc_gammaincc_data, ufunc_gammaincc_types, 2, 2, 1, 0, &quot;gammaincc&quot;, ufunc_gammaincc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammainccinv_loops[2]</span>
<span class="s0">cdef void *ufunc_gammainccinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammainccinv_data[2]</span>
<span class="s0">cdef char ufunc_gammainccinv_types[6]</span>
<span class="s0">cdef char *ufunc_gammainccinv_doc = (</span>
    <span class="s0">&quot;gammainccinv(a, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the regularized upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Given an input :math:`y` between 0 and 1, returns :math:`x` such\n&quot;</span>
    <span class="s0">&quot;that :math:`y = Q(a, x)`. Here :math:`Q` is the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function; see `gammaincc`. This is well-defined\n&quot;</span>
    <span class="s0">&quot;because the upper incomplete gamma function is monotonic as can\n&quot;</span>
    <span class="s0">&quot;be seen from its definition in [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument between 0 and 1, inclusive\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inverse of the upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It starts at infinity and monotonically decreases to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainccinv(0.5, [0, 0.1, 0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([       inf, 1.35277173, 0.22746821, 0.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts the upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(a, sc.gammainccinv(a, x))\n&quot;</span>
    <span class="s0">&quot;array([0. , 0.1, 0.5, 1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainccinv(a, sc.gammaincc(a, x))\n&quot;</span>
    <span class="s0">&quot;array([ 0., 10., 50.])&quot;)</span>
<span class="s0">ufunc_gammainccinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammainccinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammainccinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_ptr[2*0] = &lt;void*&gt;_func_cephes_igamci</span>
<span class="s0">ufunc_gammainccinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainccinv&quot;)</span>
<span class="s0">ufunc_gammainccinv_ptr[2*1] = &lt;void*&gt;_func_cephes_igamci</span>
<span class="s0">ufunc_gammainccinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainccinv&quot;)</span>
<span class="s0">ufunc_gammainccinv_data[0] = &amp;ufunc_gammainccinv_ptr[2*0]</span>
<span class="s0">ufunc_gammainccinv_data[1] = &amp;ufunc_gammainccinv_ptr[2*1]</span>
<span class="s0">gammainccinv = np.PyUFunc_FromFuncAndData(ufunc_gammainccinv_loops, ufunc_gammainccinv_data, ufunc_gammainccinv_types, 2, 2, 1, 0, &quot;gammainccinv&quot;, ufunc_gammainccinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammaincinv_loops[2]</span>
<span class="s0">cdef void *ufunc_gammaincinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammaincinv_data[2]</span>
<span class="s0">cdef char ufunc_gammaincinv_types[6]</span>
<span class="s0">cdef char *ufunc_gammaincinv_doc = (</span>
    <span class="s0">&quot;gammaincinv(a, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to the regularized lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Given an input :math:`y` between 0 and 1, returns :math:`x` such\n&quot;</span>
    <span class="s0">&quot;that :math:`y = P(a, x)`. Here :math:`P` is the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function; see `gammainc`. This is well-defined\n&quot;</span>
    <span class="s0">&quot;because the lower incomplete gamma function is monotonic as can be\n&quot;</span>
    <span class="s0">&quot;seen from its definition in [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter between 0 and 1, inclusive\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inverse of the lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It starts at 0 and monotonically increases to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.00789539, 0.22746821,        inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts the lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(a, sc.gammaincinv(a, x))\n&quot;</span>
    <span class="s0">&quot;array([0. , 0.1, 0.5, 1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 10, 25]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincinv(a, sc.gammainc(a, x))\n&quot;</span>
    <span class="s0">&quot;array([ 0.        , 10.        , 25.00001465])&quot;)</span>
<span class="s0">ufunc_gammaincinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammaincinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammaincinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_ptr[2*0] = &lt;void*&gt;_func_cephes_igami</span>
<span class="s0">ufunc_gammaincinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincinv&quot;)</span>
<span class="s0">ufunc_gammaincinv_ptr[2*1] = &lt;void*&gt;_func_cephes_igami</span>
<span class="s0">ufunc_gammaincinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincinv&quot;)</span>
<span class="s0">ufunc_gammaincinv_data[0] = &amp;ufunc_gammaincinv_ptr[2*0]</span>
<span class="s0">ufunc_gammaincinv_data[1] = &amp;ufunc_gammaincinv_ptr[2*1]</span>
<span class="s0">gammaincinv = np.PyUFunc_FromFuncAndData(ufunc_gammaincinv_loops, ufunc_gammaincinv_data, ufunc_gammaincinv_types, 2, 2, 1, 0, &quot;gammaincinv&quot;, ufunc_gammaincinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammasgn_loops[2]</span>
<span class="s0">cdef void *ufunc_gammasgn_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammasgn_data[2]</span>
<span class="s0">cdef char ufunc_gammasgn_types[4]</span>
<span class="s0">cdef char *ufunc_gammasgn_doc = (</span>
    <span class="s0">&quot;gammasgn(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sign of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\text{gammasgn}(x) =\n&quot;</span>
    <span class="s0">&quot;   \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;     +1 &amp; \\Gamma(x) &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;     -1 &amp; \\Gamma(x) &lt; 0\n&quot;</span>
    <span class="s0">&quot;   \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;definition is complete since the gamma function is never zero;\n&quot;</span>
    <span class="s0">&quot;see the discussion after [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sign of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;gammaln : log of the absolute value of the gamma function\n&quot;</span>
    <span class="s0">&quot;loggamma : analytic continuation of the log of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The gamma function can be computed as ``gammasgn(x) *\n&quot;</span>
    <span class="s0">&quot;np.exp(gammaln(x))``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/5.2#E1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is 1 for `x &gt; 0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([1., 1., 1., 1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It alternates between -1 and 1 for negative integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn([-0.5, -1.5, -2.5, -3.5])\n&quot;</span>
    <span class="s0">&quot;array([-1.,  1., -1.,  1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be used to compute the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = [1.5, 0.5, -0.5, -1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn(x) * np.exp(sc.gammaln(x))\n&quot;</span>
    <span class="s0">&quot;array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])&quot;)</span>
<span class="s0">ufunc_gammasgn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_gammasgn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_gammasgn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammasgn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammasgn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammasgn_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammasgn_ptr[2*0] = &lt;void*&gt;_func_cephes_gammasgn</span>
<span class="s0">ufunc_gammasgn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammasgn&quot;)</span>
<span class="s0">ufunc_gammasgn_ptr[2*1] = &lt;void*&gt;_func_cephes_gammasgn</span>
<span class="s0">ufunc_gammasgn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammasgn&quot;)</span>
<span class="s0">ufunc_gammasgn_data[0] = &amp;ufunc_gammasgn_ptr[2*0]</span>
<span class="s0">ufunc_gammasgn_data[1] = &amp;ufunc_gammasgn_ptr[2*1]</span>
<span class="s0">gammasgn = np.PyUFunc_FromFuncAndData(ufunc_gammasgn_loops, ufunc_gammasgn_data, ufunc_gammasgn_types, 2, 1, 1, 0, &quot;gammasgn&quot;, ufunc_gammasgn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtr_data[2]</span>
<span class="s0">cdef char ufunc_gdtr_types[8]</span>
<span class="s0">cdef char *ufunc_gdtr_doc = (</span>
    <span class="s0">&quot;gdtr(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Gamma distribution cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral from zero to `x` of the gamma probability density\n&quot;</span>
    <span class="s0">&quot;function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\int_0^x \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    The rate parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\beta` (float).  It is also the reciprocal of the scale\n&quot;</span>
    <span class="s0">&quot;    parameter :math:`\\theta`.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    The shape parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\alpha` (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile (upper limit of integration; float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The CDF of the gamma distribution with parameters `a` and `b`\n&quot;</span>
    <span class="s0">&quot;    evaluated at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtrc : 1 - CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.gamma: Gamma distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The evaluation is carried out using the relation to the incomplete gamma\n&quot;</span>
    <span class="s0">&quot;integral (regularized gamma function).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `gdtr`. Calling `gdtr` directly can\n&quot;</span>
    <span class="s0">&quot;improve performance compared to the ``cdf`` method of `scipy.stats.gamma`\n&quot;</span>
    <span class="s0">&quot;(see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1``, ``b=2`` at ``x=5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(1., 2., 5.)\n&quot;</span>
    <span class="s0">&quot;0.9595723180054873\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1`` and ``b=2`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(1., 1., xvalues)\n&quot;</span>
    <span class="s0">&quot;array([0.63212056, 0.86466472, 0.95021293, 0.98168436])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`gdtr` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n&quot;</span>
    <span class="s0">&quot;function for three different `a` at four positions `x` and ``b=3``,\n&quot;</span>
    <span class="s0">&quot;resulting in a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a.shape, x.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(a, 3., x)\n&quot;</span>
    <span class="s0">&quot;array([[0.01438768, 0.0803014 , 0.19115317, 0.32332358],\n&quot;</span>
    <span class="s0">&quot;       [0.19115317, 0.57680992, 0.82642193, 0.9380312 ],\n&quot;</span>
    <span class="s0">&quot;       [0.45618688, 0.87534798, 0.97974328, 0.9972306 ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b_parameters = [2, 10, 15, 20]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     a, b, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     gdtr_vals = gdtr(a, b, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, gdtr_vals, label=fr\&quot;$a= {a},\\, b={b}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Gamma distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The gamma distribution is also available as `scipy.stats.gamma`. Using\n&quot;</span>
    <span class="s0">&quot;`gdtr` directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.gamma`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.gamma(b, scale=1/a).cdf(x)=gdtr(a, b, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 2.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr_result = gdtr(a, b, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr_result == gamma_dist_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_gdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_gdtr</span>
<span class="s0">ufunc_gdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtr&quot;)</span>
<span class="s0">ufunc_gdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_gdtr</span>
<span class="s0">ufunc_gdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtr&quot;)</span>
<span class="s0">ufunc_gdtr_data[0] = &amp;ufunc_gdtr_ptr[2*0]</span>
<span class="s0">ufunc_gdtr_data[1] = &amp;ufunc_gdtr_ptr[2*1]</span>
<span class="s0">gdtr = np.PyUFunc_FromFuncAndData(ufunc_gdtr_loops, ufunc_gdtr_data, ufunc_gdtr_types, 2, 3, 1, 0, &quot;gdtr&quot;, ufunc_gdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrc_data[2]</span>
<span class="s0">cdef char ufunc_gdtrc_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrc_doc = (</span>
    <span class="s0">&quot;gdtrc(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Gamma distribution survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integral from `x` to infinity of the gamma probability density function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\int_x^\\infty \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    The rate parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\beta` (float). It is also the reciprocal of the scale\n&quot;</span>
    <span class="s0">&quot;    parameter :math:`\\theta`.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    The shape parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\alpha` (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile (lower limit of integration; float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The survival function of the gamma distribution with parameters `a`\n&quot;</span>
    <span class="s0">&quot;    and `b` evaluated at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr: Gamma distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.gamma: Gamma distribution\n&quot;</span>
    <span class="s0">&quot;gdtrix\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The evaluation is carried out using the relation to the incomplete gamma\n&quot;</span>
    <span class="s0">&quot;integral (regularized gamma function).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `gdtrc`. Calling `gdtrc` directly can\n&quot;</span>
    <span class="s0">&quot;improve performance compared to the ``sf`` method of `scipy.stats.gamma`\n&quot;</span>
    <span class="s0">&quot;(see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1`` and ``b=2`` at ``x=5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(1., 2., 5.)\n&quot;</span>
    <span class="s0">&quot;0.04042768199451279\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1``, ``b=2`` at several points by providing\n&quot;</span>
    <span class="s0">&quot;a NumPy array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(1., 1., xvalues)\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.13533528, 0.04978707, 0.01831564])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`gdtrc` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n&quot;</span>
    <span class="s0">&quot;function for three different `a` at four positions `x` and ``b=3``,\n&quot;</span>
    <span class="s0">&quot;resulting in a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a.shape, x.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(a, 3., x)\n&quot;</span>
    <span class="s0">&quot;array([[0.98561232, 0.9196986 , 0.80884683, 0.67667642],\n&quot;</span>
    <span class="s0">&quot;       [0.80884683, 0.42319008, 0.17357807, 0.0619688 ],\n&quot;</span>
    <span class="s0">&quot;       [0.54381312, 0.12465202, 0.02025672, 0.0027694 ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b_parameters = [2, 10, 15, 20]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     a, b, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     gdtrc_vals = gdtrc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, gdtrc_vals, label=fr\&quot;$a= {a},\\, b={b}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Gamma distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The gamma distribution is also available as `scipy.stats.gamma`.\n&quot;</span>
    <span class="s0">&quot;Using `gdtrc` directly can be much faster than calling the ``sf`` method\n&quot;</span>
    <span class="s0">&quot;of `scipy.stats.gamma`, especially for small arrays or individual\n&quot;</span>
    <span class="s0">&quot;values. To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.gamma(b, scale=1/a).sf(x)=gdtrc(a, b, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc_result = gdtrc(a, b, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).sf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc_result == gamma_dist_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_gdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_ptr[2*0] = &lt;void*&gt;_func_cephes_gdtrc</span>
<span class="s0">ufunc_gdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrc&quot;)</span>
<span class="s0">ufunc_gdtrc_ptr[2*1] = &lt;void*&gt;_func_cephes_gdtrc</span>
<span class="s0">ufunc_gdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrc&quot;)</span>
<span class="s0">ufunc_gdtrc_data[0] = &amp;ufunc_gdtrc_ptr[2*0]</span>
<span class="s0">ufunc_gdtrc_data[1] = &amp;ufunc_gdtrc_ptr[2*1]</span>
<span class="s0">gdtrc = np.PyUFunc_FromFuncAndData(ufunc_gdtrc_loops, ufunc_gdtrc_data, ufunc_gdtrc_types, 2, 3, 1, 0, &quot;gdtrc&quot;, ufunc_gdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtria_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtria_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtria_data[2]</span>
<span class="s0">cdef char ufunc_gdtria_types[8]</span>
<span class="s0">cdef char *ufunc_gdtria_doc = (</span>
    <span class="s0">&quot;gdtria(p, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs a.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `a` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    `b` parameter values of `gdtr(a, b, x)`. `b` is the \&quot;shape\&quot; parameter\n&quot;</span>
    <span class="s0">&quot;    of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative real values, from the domain of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;a : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `a` parameter such that `p = gdtr(a, b, x)`.  `1/a`\n&quot;</span>
    <span class="s0">&quot;    is the \&quot;scale\&quot; parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtria\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtria(p, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;1.2&quot;)</span>
<span class="s0">ufunc_gdtria_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtria_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtria_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_ptr[2*0] = &lt;void*&gt;_func_gdtria</span>
<span class="s0">ufunc_gdtria_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtria&quot;)</span>
<span class="s0">ufunc_gdtria_ptr[2*1] = &lt;void*&gt;_func_gdtria</span>
<span class="s0">ufunc_gdtria_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtria&quot;)</span>
<span class="s0">ufunc_gdtria_data[0] = &amp;ufunc_gdtria_ptr[2*0]</span>
<span class="s0">ufunc_gdtria_data[1] = &amp;ufunc_gdtria_ptr[2*1]</span>
<span class="s0">gdtria = np.PyUFunc_FromFuncAndData(ufunc_gdtria_loops, ufunc_gdtria_data, ufunc_gdtria_types, 2, 3, 1, 0, &quot;gdtria&quot;, ufunc_gdtria_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrib_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrib_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrib_data[2]</span>
<span class="s0">cdef char ufunc_gdtrib_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrib_doc = (</span>
    <span class="s0">&quot;gdtrib(a, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs b.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `b` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \&quot;scale\&quot;\n&quot;</span>
    <span class="s0">&quot;    parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative real values, from the domain of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;b : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is\n&quot;</span>
    <span class="s0">&quot;    the \&quot;shape\&quot; parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtrib\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrib(1.2, p, 5.6)\n&quot;</span>
    <span class="s0">&quot;3.3999999999723882&quot;)</span>
<span class="s0">ufunc_gdtrib_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrib_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrib_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_ptr[2*0] = &lt;void*&gt;_func_gdtrib</span>
<span class="s0">ufunc_gdtrib_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrib&quot;)</span>
<span class="s0">ufunc_gdtrib_ptr[2*1] = &lt;void*&gt;_func_gdtrib</span>
<span class="s0">ufunc_gdtrib_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrib&quot;)</span>
<span class="s0">ufunc_gdtrib_data[0] = &amp;ufunc_gdtrib_ptr[2*0]</span>
<span class="s0">ufunc_gdtrib_data[1] = &amp;ufunc_gdtrib_ptr[2*1]</span>
<span class="s0">gdtrib = np.PyUFunc_FromFuncAndData(ufunc_gdtrib_loops, ufunc_gdtrib_data, ufunc_gdtrib_types, 2, 3, 1, 0, &quot;gdtrib&quot;, ufunc_gdtrib_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrix_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrix_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrix_data[2]</span>
<span class="s0">cdef char ufunc_gdtrix_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrix_doc = (</span>
    <span class="s0">&quot;gdtrix(a, b, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `x` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution. This is also known as the pth quantile of the\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \&quot;scale\&quot;\n&quot;</span>
    <span class="s0">&quot;    parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    `b` parameter values of `gdtr(a, b, x)`. `b` is the \&quot;shape\&quot; parameter\n&quot;</span>
    <span class="s0">&quot;    of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`. `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `x` parameter such that `p = gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `x` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtrix\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrix(1.2, 3.4, p)\n&quot;</span>
    <span class="s0">&quot;5.5999999999999996&quot;)</span>
<span class="s0">ufunc_gdtrix_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrix_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrix_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_ptr[2*0] = &lt;void*&gt;_func_gdtrix</span>
<span class="s0">ufunc_gdtrix_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrix&quot;)</span>
<span class="s0">ufunc_gdtrix_ptr[2*1] = &lt;void*&gt;_func_gdtrix</span>
<span class="s0">ufunc_gdtrix_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrix&quot;)</span>
<span class="s0">ufunc_gdtrix_data[0] = &amp;ufunc_gdtrix_ptr[2*0]</span>
<span class="s0">ufunc_gdtrix_data[1] = &amp;ufunc_gdtrix_ptr[2*1]</span>
<span class="s0">gdtrix = np.PyUFunc_FromFuncAndData(ufunc_gdtrix_loops, ufunc_gdtrix_data, ufunc_gdtrix_types, 2, 3, 1, 0, &quot;gdtrix&quot;, ufunc_gdtrix_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_huber_loops[2]</span>
<span class="s0">cdef void *ufunc_huber_ptr[4]</span>
<span class="s0">cdef void *ufunc_huber_data[2]</span>
<span class="s0">cdef char ufunc_huber_types[6]</span>
<span class="s0">cdef char *ufunc_huber_doc = (</span>
    <span class="s0">&quot;huber(delta, r, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Huber loss function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\text{huber}(\\delta, r) = \\begin{cases} \\infty &amp; \\delta &lt; 0  \\\\\n&quot;</span>
    <span class="s0">&quot;          \\frac{1}{2}r^2 &amp; 0 \\le \\delta, | r | \\le \\delta \\\\\n&quot;</span>
    <span class="s0">&quot;          \\delta ( |r| - \\frac{1}{2}\\delta ) &amp; \\text{otherwise} \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;delta : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array, indicating the quadratic vs. linear loss changepoint.\n&quot;</span>
    <span class="s0">&quot;r : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array, possibly representing residuals.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The computed Huber loss function values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pseudo_huber : smooth approximation of this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`huber` is useful as a loss function in robust statistics or machine\n&quot;</span>
    <span class="s0">&quot;learning to reduce the influence of outliers as compared to the common\n&quot;</span>
    <span class="s0">&quot;squared error loss, residuals with a magnitude higher than `delta` are\n&quot;</span>
    <span class="s0">&quot;not squared [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Typically, `r` represents residuals, the difference\n&quot;</span>
    <span class="s0">&quot;between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n&quot;</span>
    <span class="s0">&quot;`huber` resembles the squared error and for :math:`|r|&gt;\\delta` the\n&quot;</span>
    <span class="s0">&quot;absolute error. This way, the Huber loss often achieves\n&quot;</span>
    <span class="s0">&quot;a fast convergence in model fitting for small residuals like the squared\n&quot;</span>
    <span class="s0">&quot;error loss function and still reduces the influence of outliers\n&quot;</span>
    <span class="s0">&quot;(:math:`|r|&gt;\\delta`) like the absolute error loss. As :math:`\\delta` is\n&quot;</span>
    <span class="s0">&quot;the cutoff between squared and absolute error regimes, it has\n&quot;</span>
    <span class="s0">&quot;to be tuned carefully for each problem. `huber` is also\n&quot;</span>
    <span class="s0">&quot;convex, making it suitable for gradient based optimization.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Peter Huber. \&quot;Robust Estimation of a Location Parameter\&quot;,\n&quot;</span>
    <span class="s0">&quot;       1964. Annals of Statistics. 53 (1): 73 - 101.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Import all necessary modules.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import huber\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``delta=1`` at ``r=2``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(1., 2.)\n&quot;</span>
    <span class="s0">&quot;1.5\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for different `delta` by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber([1., 3., 5.], 4.)\n&quot;</span>
    <span class="s0">&quot;array([3.5, 7.5, 8. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function at different points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `r`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(2., np.array([1., 1.5, 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.5  , 1.125, 4.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be calculated for different `delta` and `r` by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both with compatible shapes for broadcasting.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(r.shape, deltas.shape)\n&quot;</span>
    <span class="s0">&quot;(4,) (3, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(deltas, r)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.5  ,  2.   ,  7.5  ,  9.5  ],\n&quot;</span>
    <span class="s0">&quot;       [ 0.5  ,  3.125, 27.5  , 37.5  ],\n&quot;</span>
    <span class="s0">&quot;       [ 0.5  ,  3.125, 32.   , 49.5  ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4, 4, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = [\&quot;dashed\&quot;, \&quot;dotted\&quot;, \&quot;dashdot\&quot;]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for delta, style in combined_plot_parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, huber(delta, x), label=fr\&quot;$\\delta={delta}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Huber loss function $h_{\\delta}(x)$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-4, 4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 8)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_huber_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_huber_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_huber_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_ptr[2*0] = &lt;void*&gt;_func_huber</span>
<span class="s0">ufunc_huber_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;huber&quot;)</span>
<span class="s0">ufunc_huber_ptr[2*1] = &lt;void*&gt;_func_huber</span>
<span class="s0">ufunc_huber_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;huber&quot;)</span>
<span class="s0">ufunc_huber_data[0] = &amp;ufunc_huber_ptr[2*0]</span>
<span class="s0">ufunc_huber_data[1] = &amp;ufunc_huber_ptr[2*1]</span>
<span class="s0">huber = np.PyUFunc_FromFuncAndData(ufunc_huber_loops, ufunc_huber_data, ufunc_huber_types, 2, 2, 1, 0, &quot;huber&quot;, ufunc_huber_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyp0f1_loops[4]</span>
<span class="s0">cdef void *ufunc_hyp0f1_ptr[8]</span>
<span class="s0">cdef void *ufunc_hyp0f1_data[4]</span>
<span class="s0">cdef char ufunc_hyp0f1_types[12]</span>
<span class="s0">cdef char *ufunc_hyp0f1_doc = (</span>
    <span class="s0">&quot;hyp0f1(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric limit function 0F1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameter\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real- or complex-valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The confluent hypergeometric limit function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This function is defined as:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: _0F_1(v, z) = \\sum_{k=0}^{\\infty}\\frac{z^k}{(v)_k k!}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It's also the limit as :math:`q \\to \\infty` of :math:`_1F_1(q; v; z/q)`,\n&quot;</span>
    <span class="s0">&quot;and satisfies the differential equation :math:`f''(z) + vf'(z) =\n&quot;</span>
    <span class="s0">&quot;f(z)`. See [1]_ for more information.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Wolfram MathWorld, \&quot;Confluent Hypergeometric Limit Function\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is one when `z` is zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp0f1(1, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the limit of the confluent hypergeometric function as `q`\n&quot;</span>
    <span class="s0">&quot;goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; q = np.array([1, 10, 100, 1000])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(q, v, z / q)\n&quot;</span>
    <span class="s0">&quot;array([2.71828183, 2.31481985, 2.28303778, 2.27992985])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp0f1(v, z)\n&quot;</span>
    <span class="s0">&quot;2.2795853023360673\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.jv(n, x)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (0.5 * x)**n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x**2)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])&quot;)</span>
<span class="s0">ufunc_hyp0f1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_hyp0f1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hyp0f1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_hyp0f1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hyp0f1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp0f1_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp0f1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp0f1_ptr[2*0] = &lt;void*&gt;_func__hyp0f1_real</span>
<span class="s0">ufunc_hyp0f1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*1] = &lt;void*&gt;_func__hyp0f1_cmplx</span>
<span class="s0">ufunc_hyp0f1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*2] = &lt;void*&gt;_func__hyp0f1_real</span>
<span class="s0">ufunc_hyp0f1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*3] = &lt;void*&gt;_func__hyp0f1_cmplx</span>
<span class="s0">ufunc_hyp0f1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_data[0] = &amp;ufunc_hyp0f1_ptr[2*0]</span>
<span class="s0">ufunc_hyp0f1_data[1] = &amp;ufunc_hyp0f1_ptr[2*1]</span>
<span class="s0">ufunc_hyp0f1_data[2] = &amp;ufunc_hyp0f1_ptr[2*2]</span>
<span class="s0">ufunc_hyp0f1_data[3] = &amp;ufunc_hyp0f1_ptr[2*3]</span>
<span class="s0">hyp0f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp0f1_loops, ufunc_hyp0f1_data, ufunc_hyp0f1_types, 4, 2, 1, 0, &quot;hyp0f1&quot;, ufunc_hyp0f1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyp1f1_loops[4]</span>
<span class="s0">cdef void *ufunc_hyp1f1_ptr[8]</span>
<span class="s0">cdef void *ufunc_hyp1f1_data[4]</span>
<span class="s0">cdef char ufunc_hyp1f1_types[16]</span>
<span class="s0">cdef char *ufunc_hyp1f1_doc = (</span>
    <span class="s0">&quot;hyp1f1(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric function 1F1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The confluent hypergeometric function is defined by the series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   {}_1F_1(a; b; x) = \\sum_{k = 0}^\\infty \\frac{(a)_k}{(b)_k k!} x^k.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for more details. Here :math:`(\\cdot)_k` is the\n&quot;</span>
    <span class="s0">&quot;Pochhammer symbol; see `poch`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;hyperu : another confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;hyp0f1 : confluent hypergeometric limit function\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gaussian hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/13.2#E2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is one when `x` is zero:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(0.5, 0.5, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is singular when `b` is a nonpositive integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(0.5, -1, 0)\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a polynomial when `a` is a nonpositive integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(a, b, x)\n&quot;</span>
    <span class="s0">&quot;array([-1., -3., -5., -7.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 + (a / b) * x\n&quot;</span>
    <span class="s0">&quot;array([-1., -3., -5., -7.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It reduces to the exponential function when `a = b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(2, 2, [1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])&quot;)</span>
<span class="s0">ufunc_hyp1f1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_hyp1f1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_hyp1f1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_hyp1f1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_hyp1f1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp1f1_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp1f1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp1f1_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hyp1f1_double</span>
<span class="s0">ufunc_hyp1f1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*1] = &lt;void*&gt;_func_chyp1f1_wrap</span>
<span class="s0">ufunc_hyp1f1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hyp1f1_double</span>
<span class="s0">ufunc_hyp1f1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*3] = &lt;void*&gt;_func_chyp1f1_wrap</span>
<span class="s0">ufunc_hyp1f1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_data[0] = &amp;ufunc_hyp1f1_ptr[2*0]</span>
<span class="s0">ufunc_hyp1f1_data[1] = &amp;ufunc_hyp1f1_ptr[2*1]</span>
<span class="s0">ufunc_hyp1f1_data[2] = &amp;ufunc_hyp1f1_ptr[2*2]</span>
<span class="s0">ufunc_hyp1f1_data[3] = &amp;ufunc_hyp1f1_ptr[2*3]</span>
<span class="s0">hyp1f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f1_loops, ufunc_hyp1f1_data, ufunc_hyp1f1_types, 4, 3, 1, 0, &quot;hyp1f1&quot;, ufunc_hyp1f1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyperu_loops[2]</span>
<span class="s0">cdef void *ufunc_hyperu_ptr[4]</span>
<span class="s0">cdef void *ufunc_hyperu_data[2]</span>
<span class="s0">cdef char ufunc_hyperu_types[8]</span>
<span class="s0">cdef char *ufunc_hyperu_doc = (</span>
    <span class="s0">&quot;hyperu(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric function U\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as the solution to the equation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   x \\frac{d^2w}{dx^2} + (b - x) \\frac{dw}{dx} - aw = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;which satisfies the property\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   U(a, b, x) \\sim x^{-a}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;as :math:`x \\to \\infty`. See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of `U`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematics Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/13.2#E6\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a branch cut along the negative `x` axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-0.1, -10, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(1, 1, x)\n&quot;</span>
    <span class="s0">&quot;array([nan, nan, nan, nan, nan])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It approaches zero as `x` goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 10, 100])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(1, 1, x)\n&quot;</span>
    <span class="s0">&quot;array([0.59634736, 0.09156333, 0.00990194])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It satisfies Kummer's transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = 2, 1, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.1926947246463881\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)\n&quot;</span>
    <span class="s0">&quot;0.1926947246463881&quot;)</span>
<span class="s0">ufunc_hyperu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_hyperu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_hyperu_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_ptr[2*0] = &lt;void*&gt;_func_hyperu</span>
<span class="s0">ufunc_hyperu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyperu&quot;)</span>
<span class="s0">ufunc_hyperu_ptr[2*1] = &lt;void*&gt;_func_hyperu</span>
<span class="s0">ufunc_hyperu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyperu&quot;)</span>
<span class="s0">ufunc_hyperu_data[0] = &amp;ufunc_hyperu_ptr[2*0]</span>
<span class="s0">ufunc_hyperu_data[1] = &amp;ufunc_hyperu_ptr[2*1]</span>
<span class="s0">hyperu = np.PyUFunc_FromFuncAndData(ufunc_hyperu_loops, ufunc_hyperu_data, ufunc_hyperu_types, 2, 3, 1, 0, &quot;hyperu&quot;, ufunc_hyperu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i0_loops[2]</span>
<span class="s0">cdef void *ufunc_i0_ptr[4]</span>
<span class="s0">cdef void *ufunc_i0_data[2]</span>
<span class="s0">cdef char ufunc_i0_types[4]</span>
<span class="s0">cdef char *ufunc_i0_doc = (</span>
    <span class="s0">&quot;i0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I_0(x) = \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{(k!)^2} = J_0(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of any order\n&quot;</span>
    <span class="s0">&quot;i0e: Exponentially scaled modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(1.)\n&quot;</span>
    <span class="s0">&quot;1.2660658777520082\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(np.array([-2., 0., 3.5]))\n&quot;</span>
    <span class="s0">&quot;array([2.2795853 , 1.        , 7.37820343])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0_ptr[2*0] = &lt;void*&gt;_func_cephes_i0</span>
<span class="s0">ufunc_i0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0&quot;)</span>
<span class="s0">ufunc_i0_ptr[2*1] = &lt;void*&gt;_func_cephes_i0</span>
<span class="s0">ufunc_i0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0&quot;)</span>
<span class="s0">ufunc_i0_data[0] = &amp;ufunc_i0_ptr[2*0]</span>
<span class="s0">ufunc_i0_data[1] = &amp;ufunc_i0_ptr[2*1]</span>
<span class="s0">i0 = np.PyUFunc_FromFuncAndData(ufunc_i0_loops, ufunc_i0_data, ufunc_i0_types, 2, 1, 1, 0, &quot;i0&quot;, ufunc_i0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i0e_loops[2]</span>
<span class="s0">cdef void *ufunc_i0e_ptr[4]</span>
<span class="s0">cdef void *ufunc_i0e_data[2]</span>
<span class="s0">cdef char ufunc_i0e_types[4]</span>
<span class="s0">cdef char *ufunc_i0e_doc = (</span>
    <span class="s0">&quot;i0e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    i0e(x) = exp(-abs(x)) * i0(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;    at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i0: Modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval. The\n&quot;</span>
    <span class="s0">&quot;polynomial expansions used are the same as those in `i0`, but\n&quot;</span>
    <span class="s0">&quot;they are not multiplied by the dominant exponential factor.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i0e`. `i0e`\n&quot;</span>
    <span class="s0">&quot;is useful for large arguments `x`: for these, `i0` quickly overflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `i0` returns infinity whereas `i0e` still returns\n&quot;</span>
    <span class="s0">&quot;a finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i0, i0e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(1000.), i0e(1000.)\n&quot;</span>
    <span class="s0">&quot;(inf, 0.012617240455891257)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0e(np.array([-2., 0., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.30850832, 1.        , 0.24300035])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i0e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i0e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i0e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i0e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0e_ptr[2*0] = &lt;void*&gt;_func_cephes_i0e</span>
<span class="s0">ufunc_i0e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0e&quot;)</span>
<span class="s0">ufunc_i0e_ptr[2*1] = &lt;void*&gt;_func_cephes_i0e</span>
<span class="s0">ufunc_i0e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0e&quot;)</span>
<span class="s0">ufunc_i0e_data[0] = &amp;ufunc_i0e_ptr[2*0]</span>
<span class="s0">ufunc_i0e_data[1] = &amp;ufunc_i0e_ptr[2*1]</span>
<span class="s0">i0e = np.PyUFunc_FromFuncAndData(ufunc_i0e_loops, ufunc_i0e_data, ufunc_i0e_types, 2, 1, 1, 0, &quot;i0e&quot;, ufunc_i0e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i1_loops[2]</span>
<span class="s0">cdef void *ufunc_i1_ptr[4]</span>
<span class="s0">cdef void *ufunc_i1_data[2]</span>
<span class="s0">cdef char ufunc_i1_types[4]</span>
<span class="s0">cdef char *ufunc_i1_doc = (</span>
    <span class="s0">&quot;i1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I_1(x) = \\frac{1}{2}x \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{k! (k + 1)!}\n&quot;</span>
    <span class="s0">&quot;           = -\\imath J_1(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_1` is the Bessel function of the first kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i1e: Exponentially scaled modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(1.)\n&quot;</span>
    <span class="s0">&quot;0.5651591039924851\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(np.array([-2., 0., 6.]))\n&quot;</span>
    <span class="s0">&quot;array([-1.59063685,  0.        , 61.34193678])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function between -10 and 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1_ptr[2*0] = &lt;void*&gt;_func_cephes_i1</span>
<span class="s0">ufunc_i1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1&quot;)</span>
<span class="s0">ufunc_i1_ptr[2*1] = &lt;void*&gt;_func_cephes_i1</span>
<span class="s0">ufunc_i1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1&quot;)</span>
<span class="s0">ufunc_i1_data[0] = &amp;ufunc_i1_ptr[2*0]</span>
<span class="s0">ufunc_i1_data[1] = &amp;ufunc_i1_ptr[2*1]</span>
<span class="s0">i1 = np.PyUFunc_FromFuncAndData(ufunc_i1_loops, ufunc_i1_data, ufunc_i1_types, 2, 1, 1, 0, &quot;i1&quot;, ufunc_i1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i1e_loops[2]</span>
<span class="s0">cdef void *ufunc_i1e_ptr[4]</span>
<span class="s0">cdef void *ufunc_i1e_data[2]</span>
<span class="s0">cdef char ufunc_i1e_types[4]</span>
<span class="s0">cdef char *ufunc_i1e_doc = (</span>
    <span class="s0">&quot;i1e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    i1e(x) = exp(-abs(x)) * i1(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;    at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i1: Modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval. The\n&quot;</span>
    <span class="s0">&quot;polynomial expansions used are the same as those in `i1`, but\n&quot;</span>
    <span class="s0">&quot;they are not multiplied by the dominant exponential factor.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i1e`. `i1e`\n&quot;</span>
    <span class="s0">&quot;is useful for large arguments `x`: for these, `i1` quickly overflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `i1` returns infinity whereas `i1e` still returns\n&quot;</span>
    <span class="s0">&quot;a finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i1, i1e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(1000.), i1e(1000.)\n&quot;</span>
    <span class="s0">&quot;(inf, 0.01261093025692863)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1e(np.array([-2., 0., 6.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.21526929,  0.        ,  0.15205146])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function between -10 and 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i1e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i1e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i1e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i1e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1e_ptr[2*0] = &lt;void*&gt;_func_cephes_i1e</span>
<span class="s0">ufunc_i1e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1e&quot;)</span>
<span class="s0">ufunc_i1e_ptr[2*1] = &lt;void*&gt;_func_cephes_i1e</span>
<span class="s0">ufunc_i1e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1e&quot;)</span>
<span class="s0">ufunc_i1e_data[0] = &amp;ufunc_i1e_ptr[2*0]</span>
<span class="s0">ufunc_i1e_data[1] = &amp;ufunc_i1e_ptr[2*1]</span>
<span class="s0">i1e = np.PyUFunc_FromFuncAndData(ufunc_i1e_loops, ufunc_i1e_data, ufunc_i1e_types, 2, 1, 1, 0, &quot;i1e&quot;, ufunc_i1e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_inv_boxcox_loops[2]</span>
<span class="s0">cdef void *ufunc_inv_boxcox_ptr[4]</span>
<span class="s0">cdef void *ufunc_inv_boxcox_data[2]</span>
<span class="s0">cdef char ufunc_inv_boxcox_types[6]</span>
<span class="s0">cdef char *ufunc_inv_boxcox_doc = (</span>
    <span class="s0">&quot;inv_boxcox(y, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse of the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Find ``x`` such that::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(x)                  if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.16.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox, inv_boxcox\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = boxcox([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; inv_boxcox(y, 2.5)\n&quot;</span>
    <span class="s0">&quot;array([1., 4., 10.])&quot;)</span>
<span class="s0">ufunc_inv_boxcox_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_inv_boxcox_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_inv_boxcox_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*0] = &lt;void*&gt;_func_inv_boxcox</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox&quot;)</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*1] = &lt;void*&gt;_func_inv_boxcox</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox&quot;)</span>
<span class="s0">ufunc_inv_boxcox_data[0] = &amp;ufunc_inv_boxcox_ptr[2*0]</span>
<span class="s0">ufunc_inv_boxcox_data[1] = &amp;ufunc_inv_boxcox_ptr[2*1]</span>
<span class="s0">inv_boxcox = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox_loops, ufunc_inv_boxcox_data, ufunc_inv_boxcox_types, 2, 2, 1, 0, &quot;inv_boxcox&quot;, ufunc_inv_boxcox_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_inv_boxcox1p_loops[2]</span>
<span class="s0">cdef void *ufunc_inv_boxcox1p_ptr[4]</span>
<span class="s0">cdef void *ufunc_inv_boxcox1p_data[2]</span>
<span class="s0">cdef char ufunc_inv_boxcox1p_types[6]</span>
<span class="s0">cdef char *ufunc_inv_boxcox1p_doc = (</span>
    <span class="s0">&quot;inv_boxcox1p(y, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse of the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Find ``x`` such that::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(1+x)                    if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.16.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox1p, inv_boxcox1p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = boxcox1p([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; inv_boxcox1p(y, 2.5)\n&quot;</span>
    <span class="s0">&quot;array([1., 4., 10.])&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_inv_boxcox1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_inv_boxcox1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*0] = &lt;void*&gt;_func_inv_boxcox1p</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox1p&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*1] = &lt;void*&gt;_func_inv_boxcox1p</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox1p&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_data[0] = &amp;ufunc_inv_boxcox1p_ptr[2*0]</span>
<span class="s0">ufunc_inv_boxcox1p_data[1] = &amp;ufunc_inv_boxcox1p_ptr[2*1]</span>
<span class="s0">inv_boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox1p_loops, ufunc_inv_boxcox1p_data, ufunc_inv_boxcox1p_types, 2, 2, 1, 0, &quot;inv_boxcox1p&quot;, ufunc_inv_boxcox1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_j0_loops[2]</span>
<span class="s0">cdef void *ufunc_j0_ptr[4]</span>
<span class="s0">cdef void *ufunc_j0_data[2]</span>
<span class="s0">cdef char ufunc_j0_types[4]</span>
<span class="s0">cdef char *ufunc_j0_doc = (</span>
    <span class="s0">&quot;j0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the first kind of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jv : Bessel function of real order and complex argument.\n&quot;</span>
    <span class="s0">&quot;spherical_jn : spherical Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 5] and (5, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval the following rational approximation is used:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    J_0(x) \\approx (w - r_1^2)(w - r_2^2) \\frac{P_3(w)}{Q_8(w)},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`w = x^2` and :math:`r_1`, :math:`r_2` are the zeros of\n&quot;</span>
    <span class="s0">&quot;:math:`J_0`, and :math:`P_3` and :math:`Q_8` are polynomials of degrees 3\n&quot;</span>
    <span class="s0">&quot;and 8, respectively.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the second interval, the Hankel asymptotic expansion is employed with\n&quot;</span>
    <span class="s0">&quot;two rational functions of degree 6/6 and 7/7.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `j0`.\n&quot;</span>
    <span class="s0">&quot;It should not be confused with the spherical Bessel functions (see\n&quot;</span>
    <span class="s0">&quot;`spherical_jn`).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import j0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j0(1.)\n&quot;</span>
    <span class="s0">&quot;0.7651976865579665\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j0(np.array([-2., 0., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([ 0.22389078,  1.        , -0.39714981])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -20 to 20.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-20., 20., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = j0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_j0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_j0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_j0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j0_ptr[2*0] = &lt;void*&gt;_func_cephes_j0</span>
<span class="s0">ufunc_j0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j0&quot;)</span>
<span class="s0">ufunc_j0_ptr[2*1] = &lt;void*&gt;_func_cephes_j0</span>
<span class="s0">ufunc_j0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j0&quot;)</span>
<span class="s0">ufunc_j0_data[0] = &amp;ufunc_j0_ptr[2*0]</span>
<span class="s0">ufunc_j0_data[1] = &amp;ufunc_j0_ptr[2*1]</span>
<span class="s0">j0 = np.PyUFunc_FromFuncAndData(ufunc_j0_loops, ufunc_j0_data, ufunc_j0_types, 2, 1, 1, 0, &quot;j0&quot;, ufunc_j0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_j1_loops[2]</span>
<span class="s0">cdef void *ufunc_j1_ptr[4]</span>
<span class="s0">cdef void *ufunc_j1_data[2]</span>
<span class="s0">cdef char ufunc_j1_types[4]</span>
<span class="s0">cdef char *ufunc_j1_doc = (</span>
    <span class="s0">&quot;j1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the first kind of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jv: Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;spherical_jn: spherical Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 8] and (8, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a 24 term Chebyshev expansion is used. In the second, the\n&quot;</span>
    <span class="s0">&quot;asymptotic trigonometric representation is employed using two rational\n&quot;</span>
    <span class="s0">&quot;functions of degree 5/5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `j1`.\n&quot;</span>
    <span class="s0">&quot;It should not be confused with the spherical Bessel functions (see\n&quot;</span>
    <span class="s0">&quot;`spherical_jn`).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import j1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j1(1.)\n&quot;</span>
    <span class="s0">&quot;0.44005058574493355\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j1(np.array([-2., 0., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.57672481,  0.        , -0.06604333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -20 to 20.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-20., 20., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = j1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_j1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_j1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_j1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j1_ptr[2*0] = &lt;void*&gt;_func_cephes_j1</span>
<span class="s0">ufunc_j1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j1&quot;)</span>
<span class="s0">ufunc_j1_ptr[2*1] = &lt;void*&gt;_func_cephes_j1</span>
<span class="s0">ufunc_j1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j1&quot;)</span>
<span class="s0">ufunc_j1_data[0] = &amp;ufunc_j1_ptr[2*0]</span>
<span class="s0">ufunc_j1_data[1] = &amp;ufunc_j1_ptr[2*1]</span>
<span class="s0">j1 = np.PyUFunc_FromFuncAndData(ufunc_j1_loops, ufunc_j1_data, ufunc_j1_types, 2, 1, 1, 0, &quot;j1&quot;, ufunc_j1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k0_loops[2]</span>
<span class="s0">cdef void *ufunc_k0_ptr[4]</span>
<span class="s0">cdef void *ufunc_k0_data[2]</span>
<span class="s0">cdef char ufunc_k0_types[4]</span>
<span class="s0">cdef char *ufunc_k0_doc = (</span>
    <span class="s0">&quot;k0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of order 0, :math:`K_0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is also sometimes referred to as the modified Bessel\n&quot;</span>
    <span class="s0">&quot;function of the third kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function :math:`K_0` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k0e: Exponentially scaled modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(1.)\n&quot;</span>
    <span class="s0">&quot;0.42102443824070823\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.92441907, 0.11389387, 0.0347395 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0_ptr[2*0] = &lt;void*&gt;_func_cephes_k0</span>
<span class="s0">ufunc_k0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0&quot;)</span>
<span class="s0">ufunc_k0_ptr[2*1] = &lt;void*&gt;_func_cephes_k0</span>
<span class="s0">ufunc_k0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0&quot;)</span>
<span class="s0">ufunc_k0_data[0] = &amp;ufunc_k0_ptr[2*0]</span>
<span class="s0">ufunc_k0_data[1] = &amp;ufunc_k0_ptr[2*1]</span>
<span class="s0">k0 = np.PyUFunc_FromFuncAndData(ufunc_k0_loops, ufunc_k0_data, ufunc_k0_types, 2, 1, 1, 0, &quot;k0&quot;, ufunc_k0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k0e_loops[2]</span>
<span class="s0">cdef void *ufunc_k0e_ptr[4]</span>
<span class="s0">cdef void *ufunc_k0e_data[2]</span>
<span class="s0">cdef char ufunc_k0e_types[4]</span>
<span class="s0">cdef char *ufunc_k0e_doc = (</span>
    <span class="s0">&quot;k0e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function K of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    k0e(x) = exp(x) * k0(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function K of order\n&quot;</span>
    <span class="s0">&quot;    0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k0: Modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k0e`. `k0e` is\n&quot;</span>
    <span class="s0">&quot;useful for large arguments: for these, `k0` easily underflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `k0` returns 0 whereas `k0e` still returns a\n&quot;</span>
    <span class="s0">&quot;useful finite number:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k0, k0e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(1000.), k0e(1000)\n&quot;</span>
    <span class="s0">&quot;(0., 0.03962832160075422)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0e(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([1.52410939, 0.84156822, 0.6977616 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k0e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k0e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k0e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k0e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0e_ptr[2*0] = &lt;void*&gt;_func_cephes_k0e</span>
<span class="s0">ufunc_k0e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0e&quot;)</span>
<span class="s0">ufunc_k0e_ptr[2*1] = &lt;void*&gt;_func_cephes_k0e</span>
<span class="s0">ufunc_k0e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0e&quot;)</span>
<span class="s0">ufunc_k0e_data[0] = &amp;ufunc_k0e_ptr[2*0]</span>
<span class="s0">ufunc_k0e_data[1] = &amp;ufunc_k0e_ptr[2*1]</span>
<span class="s0">k0e = np.PyUFunc_FromFuncAndData(ufunc_k0e_loops, ufunc_k0e_data, ufunc_k0e_types, 2, 1, 1, 0, &quot;k0e&quot;, ufunc_k0e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k1_loops[2]</span>
<span class="s0">cdef void *ufunc_k1_ptr[4]</span>
<span class="s0">cdef void *ufunc_k1_data[2]</span>
<span class="s0">cdef char ufunc_k1_types[4]</span>
<span class="s0">cdef char *ufunc_k1_doc = (</span>
    <span class="s0">&quot;k1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of order 1, :math:`K_1(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function K of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k1e: Exponentially scaled modified Bessel function K of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(1.)\n&quot;</span>
    <span class="s0">&quot;0.6019072301972346\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([1.65644112, 0.13986588, 0.04015643])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1_ptr[2*0] = &lt;void*&gt;_func_cephes_k1</span>
<span class="s0">ufunc_k1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1&quot;)</span>
<span class="s0">ufunc_k1_ptr[2*1] = &lt;void*&gt;_func_cephes_k1</span>
<span class="s0">ufunc_k1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1&quot;)</span>
<span class="s0">ufunc_k1_data[0] = &amp;ufunc_k1_ptr[2*0]</span>
<span class="s0">ufunc_k1_data[1] = &amp;ufunc_k1_ptr[2*1]</span>
<span class="s0">k1 = np.PyUFunc_FromFuncAndData(ufunc_k1_loops, ufunc_k1_data, ufunc_k1_types, 2, 1, 1, 0, &quot;k1&quot;, ufunc_k1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k1e_loops[2]</span>
<span class="s0">cdef void *ufunc_k1e_ptr[4]</span>
<span class="s0">cdef void *ufunc_k1e_data[2]</span>
<span class="s0">cdef char ufunc_k1e_types[4]</span>
<span class="s0">cdef char *ufunc_k1e_doc = (</span>
    <span class="s0">&quot;k1e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function K of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    k1e(x) = exp(x) * k1(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function K of order\n&quot;</span>
    <span class="s0">&quot;    1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k1: Modified Bessel function of the second kind of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k1e`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `k1` returns 0 whereas `k1e` still returns a\n&quot;</span>
    <span class="s0">&quot;useful floating point number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k1, k1e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(1000.), k1e(1000.)\n&quot;</span>
    <span class="s0">&quot;(0., 0.03964813081296021)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1e(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([2.73100971, 1.03347685, 0.80656348])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k1e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k1e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k1e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k1e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1e_ptr[2*0] = &lt;void*&gt;_func_cephes_k1e</span>
<span class="s0">ufunc_k1e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1e&quot;)</span>
<span class="s0">ufunc_k1e_ptr[2*1] = &lt;void*&gt;_func_cephes_k1e</span>
<span class="s0">ufunc_k1e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1e&quot;)</span>
<span class="s0">ufunc_k1e_data[0] = &amp;ufunc_k1e_ptr[2*0]</span>
<span class="s0">ufunc_k1e_data[1] = &amp;ufunc_k1e_ptr[2*1]</span>
<span class="s0">k1e = np.PyUFunc_FromFuncAndData(ufunc_k1e_loops, ufunc_k1e_data, ufunc_k1e_types, 2, 1, 1, 0, &quot;k1e&quot;, ufunc_k1e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kl_div_loops[2]</span>
<span class="s0">cdef void *ufunc_kl_div_ptr[4]</span>
<span class="s0">cdef void *ufunc_kl_div_data[2]</span>
<span class="s0">cdef char ufunc_kl_div_types[6]</span>
<span class="s0">cdef char *ufunc_kl_div_doc = (</span>
    <span class="s0">&quot;kl_div(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing Kullback-Leibler divergence.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{kl\\_div}(x, y) =\n&quot;</span>
    <span class="s0">&quot;      \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;        x \\log(x / y) - x + y &amp; x &gt; 0, y &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;        y &amp; x = 0, y \\ge 0 \\\\\n&quot;</span>
    <span class="s0">&quot;        \\infty &amp; \\text{otherwise}\n&quot;</span>
    <span class="s0">&quot;      \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real arguments\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kullback-Liebler divergence.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;entr, rel_entr, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is non-negative and is jointly convex in `x` and `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see [1]_ for\n&quot;</span>
    <span class="s0">&quot;details. This is why the function contains the extra :math:`-x\n&quot;</span>
    <span class="s0">&quot;+ y` terms over what might be expected from the Kullback-Leibler\n&quot;</span>
    <span class="s0">&quot;divergence. For a version of the function without the extra terms,\n&quot;</span>
    <span class="s0">&quot;see `rel_entr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`&quot;)</span>
<span class="s0">ufunc_kl_div_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kl_div_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kl_div_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_ptr[2*0] = &lt;void*&gt;_func_kl_div</span>
<span class="s0">ufunc_kl_div_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kl_div&quot;)</span>
<span class="s0">ufunc_kl_div_ptr[2*1] = &lt;void*&gt;_func_kl_div</span>
<span class="s0">ufunc_kl_div_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kl_div&quot;)</span>
<span class="s0">ufunc_kl_div_data[0] = &amp;ufunc_kl_div_ptr[2*0]</span>
<span class="s0">ufunc_kl_div_data[1] = &amp;ufunc_kl_div_ptr[2*1]</span>
<span class="s0">kl_div = np.PyUFunc_FromFuncAndData(ufunc_kl_div_loops, ufunc_kl_div_data, ufunc_kl_div_types, 2, 2, 1, 0, &quot;kl_div&quot;, ufunc_kl_div_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kn_loops[3]</span>
<span class="s0">cdef void *ufunc_kn_ptr[6]</span>
<span class="s0">cdef void *ufunc_kn_data[3]</span>
<span class="s0">cdef char ufunc_kn_types[9]</span>
<span class="s0">cdef char *ufunc_kn_doc = (</span>
    <span class="s0">&quot;kn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of integer order `n`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the modified Bessel function of the second kind for integer order\n&quot;</span>
    <span class="s0">&quot;`n` at real `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These are also sometimes called functions of the third kind, Basset\n&quot;</span>
    <span class="s0">&quot;functions, or Macdonald functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like of int\n&quot;</span>
    <span class="s0">&quot;    Order of Bessel functions (floats will truncate with a warning)\n&quot;</span>
    <span class="s0">&quot;x : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate the Bessel functions\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Modified Bessel function of the second kind,\n&quot;</span>
    <span class="s0">&quot;    :math:`K_n(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv : Same function, but accepts real order and complex argument\n&quot;</span>
    <span class="s0">&quot;kvp : Derivative of this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n&quot;</span>
    <span class="s0">&quot;algorithm used, see [2]_ and the references therein.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;Algorithm 644: A portable package for Bessel\n&quot;</span>
    <span class="s0">&quot;       functions of a complex argument and nonnegative order\&quot;, ACM\n&quot;</span>
    <span class="s0">&quot;       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Plot the function of several orders for real input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for N in range(6):\n&quot;</span>
    <span class="s0">&quot;...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(0, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate for a single value at multiple orders:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kn([4, 5, 6], 1)\n&quot;</span>
    <span class="s0">&quot;array([   44.23241585,   360.9605896 ,  3653.83831186])&quot;)</span>
<span class="s0">ufunc_kn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_kn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kn_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_kn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_ptr[2*0] = &lt;void*&gt;_func_special_cyl_bessel_k_int</span>
<span class="s0">ufunc_kn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_ptr[2*1] = &lt;void*&gt;_func_kn_unsafe</span>
<span class="s0">ufunc_kn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_ptr[2*2] = &lt;void*&gt;_func_kn_unsafe</span>
<span class="s0">ufunc_kn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_data[0] = &amp;ufunc_kn_ptr[2*0]</span>
<span class="s0">ufunc_kn_data[1] = &amp;ufunc_kn_ptr[2*1]</span>
<span class="s0">ufunc_kn_data[2] = &amp;ufunc_kn_ptr[2*2]</span>
<span class="s0">kn = np.PyUFunc_FromFuncAndData(ufunc_kn_loops, ufunc_kn_data, ufunc_kn_types, 3, 2, 1, 0, &quot;kn&quot;, ufunc_kn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kolmogi_loops[2]</span>
<span class="s0">cdef void *ufunc_kolmogi_ptr[4]</span>
<span class="s0">cdef void *ufunc_kolmogi_data[2]</span>
<span class="s0">cdef char ufunc_kolmogi_types[4]</span>
<span class="s0">cdef char *ufunc_kolmogi_doc = (</span>
    <span class="s0">&quot;kolmogi(p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse Survival Function of Kolmogorov distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the inverse function to `kolmogorov`.\n&quot;</span>
    <span class="s0">&quot;Returns y such that ``kolmogorov(y) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : float array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of kolmogi(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kolmogorov : The Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;smirnov, smirnovi : Functions for the one-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`kolmogorov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.kstwobign` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kolmogi\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,\n&quot;</span>
    <span class="s0">&quot;        0.57117327,  0.        ])&quot;)</span>
<span class="s0">ufunc_kolmogi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kolmogi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kolmogi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogi_ptr[2*0] = &lt;void*&gt;_func_cephes_kolmogi</span>
<span class="s0">ufunc_kolmogi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogi&quot;)</span>
<span class="s0">ufunc_kolmogi_ptr[2*1] = &lt;void*&gt;_func_cephes_kolmogi</span>
<span class="s0">ufunc_kolmogi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogi&quot;)</span>
<span class="s0">ufunc_kolmogi_data[0] = &amp;ufunc_kolmogi_ptr[2*0]</span>
<span class="s0">ufunc_kolmogi_data[1] = &amp;ufunc_kolmogi_ptr[2*1]</span>
<span class="s0">kolmogi = np.PyUFunc_FromFuncAndData(ufunc_kolmogi_loops, ufunc_kolmogi_data, ufunc_kolmogi_types, 2, 1, 1, 0, &quot;kolmogi&quot;, ufunc_kolmogi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kolmogorov_loops[2]</span>
<span class="s0">cdef void *ufunc_kolmogorov_ptr[4]</span>
<span class="s0">cdef void *ufunc_kolmogorov_data[2]</span>
<span class="s0">cdef char ufunc_kolmogorov_types[4]</span>
<span class="s0">cdef char *ufunc_kolmogorov_doc = (</span>
    <span class="s0">&quot;kolmogorov(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complementary cumulative distribution (Survival Function) function of\n&quot;</span>
    <span class="s0">&quot;Kolmogorov distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the complementary cumulative distribution function of\n&quot;</span>
    <span class="s0">&quot;Kolmogorov's limiting distribution (``D_n*\\sqrt(n)`` as n goes to infinity)\n&quot;</span>
    <span class="s0">&quot;of a two-sided test for equality between an empirical and a theoretical\n&quot;</span>
    <span class="s0">&quot;distribution. It is equal to the (limit as n-&gt;infinity of the)\n&quot;</span>
    <span class="s0">&quot;probability that ``sqrt(n) * max absolute deviation &gt; y``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : float array_like\n&quot;</span>
    <span class="s0">&quot;  Absolute deviation between the Empirical CDF (ECDF) and the target CDF,\n&quot;</span>
    <span class="s0">&quot;  multiplied by sqrt(n).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of kolmogorov(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kolmogi : The Inverse Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;smirnov, smirnovi : Functions for the one-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`kolmogorov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.kstwobign` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Show the probability of a gap at least as big as 0, 0.5 and 1.0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kolmogorov\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import kstwobign\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kolmogorov([0, 0.5, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([ 1.        ,  0.96394524,  0.26999967])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against\n&quot;</span>
    <span class="s0">&quot;the target distribution, a Normal(0, 1) distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm, laplace\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; rng = np.random.default_rng()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 1000\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lap01 = laplace(0, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.sort(lap01.rvs(n, random_state=rng))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.mean(x), np.std(x)\n&quot;</span>
    <span class="s0">&quot;(-0.05841730131499543, 1.3968109101997568)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Construct the Empirical CDF and the K-S statistic Dn.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; target = norm(0,1)  # Normal mean 0, stddev 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs = target.cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Dn = np.max(gaps)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Kn = np.sqrt(n) * Dn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print('Dn=%f, sqrt(n)*Dn=%f' % (Dn, Kn))\n&quot;</span>
    <span class="s0">&quot;Dn=0.043363, sqrt(n)*Dn=1.371265\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',\n&quot;</span>
    <span class="s0">&quot;...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=%f is %f' %\n&quot;</span>
    <span class="s0">&quot;...    (Kn, kolmogorov(Kn)),\n&quot;</span>
    <span class="s0">&quot;...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=%f is %f' %\n&quot;</span>
    <span class="s0">&quot;...    (Kn, kstwobign.cdf(Kn))]))\n&quot;</span>
    <span class="s0">&quot;For a sample of size n drawn from a N(0, 1) distribution:\n&quot;</span>
    <span class="s0">&quot; the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=1.371265 is 0.046533\n&quot;</span>
    <span class="s0">&quot; the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=1.371265 is 0.953467\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the Empirical CDF against the target N(0, 1) CDF.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x3 = np.linspace(-3, 3, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim([0, 1]); plt.grid(True); plt.legend();\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; # Add vertical lines marking Dn+ and Dn-\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus],\n&quot;</span>
    <span class="s0">&quot;...            color='r', linestyle='dashed', lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1],\n&quot;</span>
    <span class="s0">&quot;...            color='r', linestyle='dashed', lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_kolmogorov_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kolmogorov_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kolmogorov_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogorov_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogorov_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogorov_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogorov_ptr[2*0] = &lt;void*&gt;_func_cephes_kolmogorov</span>
<span class="s0">ufunc_kolmogorov_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogorov&quot;)</span>
<span class="s0">ufunc_kolmogorov_ptr[2*1] = &lt;void*&gt;_func_cephes_kolmogorov</span>
<span class="s0">ufunc_kolmogorov_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogorov&quot;)</span>
<span class="s0">ufunc_kolmogorov_data[0] = &amp;ufunc_kolmogorov_ptr[2*0]</span>
<span class="s0">ufunc_kolmogorov_data[1] = &amp;ufunc_kolmogorov_ptr[2*1]</span>
<span class="s0">kolmogorov = np.PyUFunc_FromFuncAndData(ufunc_kolmogorov_loops, ufunc_kolmogorov_data, ufunc_kolmogorov_types, 2, 1, 1, 0, &quot;kolmogorov&quot;, ufunc_kolmogorov_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_log1p_loops[4]</span>
<span class="s0">cdef void *ufunc_log1p_ptr[8]</span>
<span class="s0">cdef void *ufunc_log1p_data[4]</span>
<span class="s0">cdef char ufunc_log1p_types[8]</span>
<span class="s0">cdef char *ufunc_log1p_doc = (</span>
    <span class="s0">&quot;log1p(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculates log(1 + x) for use when `x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of ``log(1 + x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expm1, cosm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using ``log(1 + x)`` directly for ``x``\n&quot;</span>
    <span class="s0">&quot;near 0. Note that in the below example ``1 + 1e-17 == 1`` to\n&quot;</span>
    <span class="s0">&quot;double precision.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.log1p(1e-17)\n&quot;</span>
    <span class="s0">&quot;1e-17\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(1 + 1e-17)\n&quot;</span>
    <span class="s0">&quot;0.0&quot;)</span>
<span class="s0">ufunc_log1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_log1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_log1p_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_log1p_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_log1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log1p_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log1p_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log1p_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log1p_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log1p_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log1p_ptr[2*0] = &lt;void*&gt;_func_cephes_log1p</span>
<span class="s0">ufunc_log1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*1] = &lt;void*&gt;_func_cephes_log1p</span>
<span class="s0">ufunc_log1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*2] = &lt;void*&gt;_func_clog1p</span>
<span class="s0">ufunc_log1p_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*3] = &lt;void*&gt;_func_clog1p</span>
<span class="s0">ufunc_log1p_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_data[0] = &amp;ufunc_log1p_ptr[2*0]</span>
<span class="s0">ufunc_log1p_data[1] = &amp;ufunc_log1p_ptr[2*1]</span>
<span class="s0">ufunc_log1p_data[2] = &amp;ufunc_log1p_ptr[2*2]</span>
<span class="s0">ufunc_log1p_data[3] = &amp;ufunc_log1p_ptr[2*3]</span>
<span class="s0">log1p = np.PyUFunc_FromFuncAndData(ufunc_log1p_loops, ufunc_log1p_data, ufunc_log1p_types, 4, 1, 1, 0, &quot;log1p&quot;, ufunc_log1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_log_ndtr_loops[4]</span>
<span class="s0">cdef void *ufunc_log_ndtr_ptr[8]</span>
<span class="s0">cdef void *ufunc_log_ndtr_data[4]</span>
<span class="s0">cdef char ufunc_log_ndtr_types[8]</span>
<span class="s0">cdef char *ufunc_log_ndtr_doc = (</span>
    <span class="s0">&quot;log_ndtr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Logarithm of Gaussian cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the log of the area under the standard Gaussian probability\n&quot;</span>
    <span class="s0">&quot;density function, integrated from minus infinity to `x`::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like, real or complex\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the log of the normal CDF evaluated at `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf\n&quot;</span>
    <span class="s0">&quot;erfc\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm\n&quot;</span>
    <span class="s0">&quot;ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import log_ndtr, ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The benefit of ``log_ndtr(x)`` over the naive implementation\n&quot;</span>
    <span class="s0">&quot;``np.log(ndtr(x))`` is most evident with moderate to large positive\n&quot;</span>
    <span class="s0">&quot;values of ``x``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([6, 7, 9, 12, 15, 25])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; log_ndtr(x)\n&quot;</span>
    <span class="s0">&quot;array([-9.86587646e-010, -1.27981254e-012, -1.12858841e-019,\n&quot;</span>
    <span class="s0">&quot;       -1.77648211e-033, -3.67096620e-051, -3.05669671e-138])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The results of the naive calculation for the moderate ``x`` values\n&quot;</span>
    <span class="s0">&quot;have only 5 or 6 correct significant digits. For values of ``x``\n&quot;</span>
    <span class="s0">&quot;greater than approximately 8.3, the naive expression returns 0:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(ndtr(x))\n&quot;</span>
    <span class="s0">&quot;array([-9.86587701e-10, -1.27986510e-12,  0.00000000e+00,\n&quot;</span>
    <span class="s0">&quot;        0.00000000e+00,  0.00000000e+00,  0.00000000e+00])&quot;)</span>
<span class="s0">ufunc_log_ndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_log_ndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_log_ndtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_log_ndtr_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_log_ndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_ndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_ndtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log_ndtr_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log_ndtr_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log_ndtr_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr</span>
<span class="s0">ufunc_log_ndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr</span>
<span class="s0">ufunc_log_ndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex</span>
<span class="s0">ufunc_log_ndtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex</span>
<span class="s0">ufunc_log_ndtr_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_data[0] = &amp;ufunc_log_ndtr_ptr[2*0]</span>
<span class="s0">ufunc_log_ndtr_data[1] = &amp;ufunc_log_ndtr_ptr[2*1]</span>
<span class="s0">ufunc_log_ndtr_data[2] = &amp;ufunc_log_ndtr_ptr[2*2]</span>
<span class="s0">ufunc_log_ndtr_data[3] = &amp;ufunc_log_ndtr_ptr[2*3]</span>
<span class="s0">log_ndtr = np.PyUFunc_FromFuncAndData(ufunc_log_ndtr_loops, ufunc_log_ndtr_data, ufunc_log_ndtr_types, 4, 1, 1, 0, &quot;log_ndtr&quot;, ufunc_log_ndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_lpmv_loops[2]</span>
<span class="s0">cdef void *ufunc_lpmv_ptr[4]</span>
<span class="s0">cdef void *ufunc_lpmv_data[2]</span>
<span class="s0">cdef char ufunc_lpmv_types[8]</span>
<span class="s0">cdef char *ufunc_lpmv_doc = (</span>
    <span class="s0">&quot;lpmv(m, v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Associated Legendre function of integer order and real degree.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_v^m = (-1)^m (1 - x^2)^{m/2} \\frac{d^m}{dx^m} P_v(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_v = \\sum_{k = 0}^\\infty \\frac{(-v)_k (v + 1)_k}{(k!)^2}\n&quot;</span>
    <span class="s0">&quot;            \\left(\\frac{1 - x}{2}\\right)^k\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is the Legendre function of the first kind. Here :math:`(\\cdot)_k`\n&quot;</span>
    <span class="s0">&quot;is the Pochhammer symbol; see `poch`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (int or float). If passed a float not equal to an\n&quot;</span>
    <span class="s0">&quot;    integer the function returns NaN.\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float). Must have ``|x| &lt;= 1``.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;pmv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the associated Legendre function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;lpmn : Compute the associated Legendre function for all orders\n&quot;</span>
    <span class="s0">&quot;       ``0, ..., m`` and degrees ``0, ..., n``.\n&quot;</span>
    <span class="s0">&quot;clpmn : Compute the associated Legendre function at complex\n&quot;</span>
    <span class="s0">&quot;        arguments.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Note that this implementation includes the Condon-Shortley phase.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Jin, \&quot;Computation of Special Functions\&quot;, John Wiley\n&quot;</span>
    <span class="s0">&quot;       and Sons, Inc, 1996.&quot;)</span>
<span class="s0">ufunc_lpmv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_lpmv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_lpmv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_ptr[2*0] = &lt;void*&gt;_func_pmv_wrap</span>
<span class="s0">ufunc_lpmv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;lpmv&quot;)</span>
<span class="s0">ufunc_lpmv_ptr[2*1] = &lt;void*&gt;_func_pmv_wrap</span>
<span class="s0">ufunc_lpmv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;lpmv&quot;)</span>
<span class="s0">ufunc_lpmv_data[0] = &amp;ufunc_lpmv_ptr[2*0]</span>
<span class="s0">ufunc_lpmv_data[1] = &amp;ufunc_lpmv_ptr[2*1]</span>
<span class="s0">lpmv = np.PyUFunc_FromFuncAndData(ufunc_lpmv_loops, ufunc_lpmv_data, ufunc_lpmv_types, 2, 3, 1, 0, &quot;lpmv&quot;, ufunc_lpmv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_modstruve_loops[2]</span>
<span class="s0">cdef void *ufunc_modstruve_ptr[4]</span>
<span class="s0">cdef void *ufunc_modstruve_data[2]</span>
<span class="s0">cdef char ufunc_modstruve_types[6]</span>
<span class="s0">cdef char *ufunc_modstruve_doc = (</span>
    <span class="s0">&quot;modstruve(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Return the value of the modified Struve function of order `v` at `x`.  The\n&quot;</span>
    <span class="s0">&quot;modified Struve function is defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    L_v(x) = -\\imath \\exp(-\\pi\\imath v/2) H_v(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`H_v` is the Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the modified Struve function (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the Struve function (float; must be positive unless `v` is\n&quot;</span>
    <span class="s0">&quot;    an integer).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Struve function of order `v` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;struve\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Three methods discussed in [1]_ are used to evaluate the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;- power series\n&quot;</span>
    <span class="s0">&quot;- expansion in Bessel functions (if :math:`|x| &lt; |v| + 20`)\n&quot;</span>
    <span class="s0">&quot;- asymptotic large-x expansion (if :math:`x \\geq 0.7v + 12`)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Rounding errors are estimated based on the largest terms in the sums, and\n&quot;</span>
    <span class="s0">&quot;the result associated with the smallest error is returned.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/11\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function of order 1 at 2.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import modstruve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(1, 2.)\n&quot;</span>
    <span class="s0">&quot;1.102759787367716\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function at 2 for orders 1, 2 and 3 by\n&quot;</span>
    <span class="s0">&quot;providing a list for the order parameter `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve([1, 2, 3], 2.)\n&quot;</span>
    <span class="s0">&quot;array([1.10275979, 0.41026079, 0.11247294])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function of order 1 for several points\n&quot;</span>
    <span class="s0">&quot;by providing an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([2., 5., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(1, points)\n&quot;</span>
    <span class="s0">&quot;array([  1.10275979,  23.72821578, 399.24709139])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the modified Struve function for several orders at several\n&quot;</span>
    <span class="s0">&quot;points by providing arrays for `v` and `z`. The arrays have to be\n&quot;</span>
    <span class="s0">&quot;broadcastable to the correct shapes.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points.shape, orders.shape\n&quot;</span>
    <span class="s0">&quot;((3,), (3, 1))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[1.10275979e+00, 2.37282158e+01, 3.99247091e+02],\n&quot;</span>
    <span class="s0">&quot;       [4.10260789e-01, 1.65535979e+01, 3.25973609e+02],\n&quot;</span>
    <span class="s0">&quot;       [1.12472937e-01, 9.42430454e+00, 2.33544042e+02]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the modified Struve functions of order 0 to 3 from -5 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, modstruve(i, x), label=f'$L_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(ncol=2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-5, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Modified Struve functions $L_{\\nu}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_modstruve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_modstruve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_modstruve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_ptr[2*0] = &lt;void*&gt;_func_cephes_struve_l</span>
<span class="s0">ufunc_modstruve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modstruve&quot;)</span>
<span class="s0">ufunc_modstruve_ptr[2*1] = &lt;void*&gt;_func_cephes_struve_l</span>
<span class="s0">ufunc_modstruve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modstruve&quot;)</span>
<span class="s0">ufunc_modstruve_data[0] = &amp;ufunc_modstruve_ptr[2*0]</span>
<span class="s0">ufunc_modstruve_data[1] = &amp;ufunc_modstruve_ptr[2*1]</span>
<span class="s0">modstruve = np.PyUFunc_FromFuncAndData(ufunc_modstruve_loops, ufunc_modstruve_data, ufunc_modstruve_types, 2, 2, 1, 0, &quot;modstruve&quot;, ufunc_modstruve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtr_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtr_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtr_data[3]</span>
<span class="s0">cdef char ufunc_nbdtr_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtr_doc = (</span>
    <span class="s0">&quot;nbdtr(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms 0 through `k` of the negative binomial\n&quot;</span>
    <span class="s0">&quot;distribution probability mass function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\sum_{j=0}^k {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In a sequence of Bernoulli trials with individual success probabilities\n&quot;</span>
    <span class="s0">&quot;`p`, this is the probability that `k` or fewer failures precede the nth\n&quot;</span>
    <span class="s0">&quot;success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes in a\n&quot;</span>
    <span class="s0">&quot;    sequence of events with individual success probability `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Negative binomial survival function\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Negative binomial quantile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;If floating point values are passed for `k` or `n`, they will be truncated\n&quot;</span>
    <span class="s0">&quot;to integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtr` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``cdf`` method of `scipy.stats.nbinom` (see last example).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr(10, 5, 0.5)\n&quot;</span>
    <span class="s0">&quot;0.940765380859375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``n=10`` and ``p=0.5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr([5, 10, 15], 10, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.15087891, 0.58809853, 0.88523853])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.arange(130)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [20, 20, 20, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtr_vals = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(k, nbdtr_vals, label=rf\&quot;$n={n},\\, p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtr` directly can be much faster than\n&quot;</span>
    <span class="s0">&quot;calling the ``cdf`` method of `scipy.stats.nbinom`, especially for small\n&quot;</span>
    <span class="s0">&quot;arrays or individual values. To get the same results one must use the\n&quot;</span>
    <span class="s0">&quot;following parametrization: ``nbinom(n, p).cdf(k)=nbdtr(k, n, p)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 3, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr_res = nbdtr(k, n, p)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res = nbinom(n, p).cdf(k)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;(0.85546875, 0.85546875)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtr` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr(k, 5, p)\n&quot;</span>
    <span class="s0">&quot;array([[0.15026833, 0.62304687, 0.95265101, 0.9998531 ],\n&quot;</span>
    <span class="s0">&quot;       [0.48450894, 0.94076538, 0.99932777, 0.99999999],\n&quot;</span>
    <span class="s0">&quot;       [0.76249222, 0.99409103, 0.99999445, 1.        ]])&quot;)</span>
<span class="s0">ufunc_nbdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ppd__As_ppd_d</span>
<span class="s0">ufunc_nbdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtr_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtr_types[1] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_nbdtr_wrap</span>
<span class="s0">ufunc_nbdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_ptr[2*1] = &lt;void*&gt;_func_nbdtr_unsafe</span>
<span class="s0">ufunc_nbdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_ptr[2*2] = &lt;void*&gt;_func_nbdtr_unsafe</span>
<span class="s0">ufunc_nbdtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_data[0] = &amp;ufunc_nbdtr_ptr[2*0]</span>
<span class="s0">ufunc_nbdtr_data[1] = &amp;ufunc_nbdtr_ptr[2*1]</span>
<span class="s0">ufunc_nbdtr_data[2] = &amp;ufunc_nbdtr_ptr[2*2]</span>
<span class="s0">nbdtr = np.PyUFunc_FromFuncAndData(ufunc_nbdtr_loops, ufunc_nbdtr_data, ufunc_nbdtr_types, 3, 3, 1, 0, &quot;nbdtr&quot;, ufunc_nbdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrc_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtrc_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtrc_data[3]</span>
<span class="s0">cdef char ufunc_nbdtrc_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtrc_doc = (</span>
    <span class="s0">&quot;nbdtrc(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms `k + 1` to infinity of the negative binomial\n&quot;</span>
    <span class="s0">&quot;distribution probability mass function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In a sequence of Bernoulli trials with individual success probabilities\n&quot;</span>
    <span class="s0">&quot;`p`, this is the probability that more than `k` failures precede the nth\n&quot;</span>
    <span class="s0">&quot;success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The probability of `k + 1` or more failures before `n` successes in a\n&quot;</span>
    <span class="s0">&quot;    sequence of events with individual success probability `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Negative binomial cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Negative binomial percentile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;If floating point values are passed for `k` or `n`, they will be truncated\n&quot;</span>
    <span class="s0">&quot;to integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtrc` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``sf`` method of `scipy.stats.nbinom` (see last example).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc(10, 5, 0.5)\n&quot;</span>
    <span class="s0">&quot;0.059234619140624986\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``n=10`` and ``p=0.5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc([5, 10, 15], 10, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.84912109, 0.41190147, 0.11476147])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.arange(130)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [20, 20, 20, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtrc_vals = nbdtrc(k, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(k, nbdtrc_vals, label=rf\&quot;$n={n},\\, p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtrc` directly can be much faster than\n&quot;</span>
    <span class="s0">&quot;calling the ``sf`` method of `scipy.stats.nbinom`, especially for small\n&quot;</span>
    <span class="s0">&quot;arrays or individual values. To get the same results one must use the\n&quot;</span>
    <span class="s0">&quot;following parametrization: ``nbinom(n, p).sf(k)=nbdtrc(k, n, p)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 3, 5, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr_res = nbdtrc(k, n, p)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res = nbinom(n, p).sf(k)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;(0.6367187499999999, 0.6367187499999999)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtrc` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc(k, 5, p)\n&quot;</span>
    <span class="s0">&quot;array([[8.49731667e-01, 3.76953125e-01, 4.73489874e-02, 1.46902600e-04],\n&quot;</span>
    <span class="s0">&quot;       [5.15491059e-01, 5.92346191e-02, 6.72234070e-04, 9.29610100e-09],\n&quot;</span>
    <span class="s0">&quot;       [2.37507779e-01, 5.90896606e-03, 5.55025308e-06, 3.26346760e-13]])&quot;)</span>
<span class="s0">ufunc_nbdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ppd__As_ppd_d</span>
<span class="s0">ufunc_nbdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrc_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtrc_types[1] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtrc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_ptr[2*0] = &lt;void*&gt;_func_cephes_nbdtrc_wrap</span>
<span class="s0">ufunc_nbdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_ptr[2*1] = &lt;void*&gt;_func_nbdtrc_unsafe</span>
<span class="s0">ufunc_nbdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_ptr[2*2] = &lt;void*&gt;_func_nbdtrc_unsafe</span>
<span class="s0">ufunc_nbdtrc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_data[0] = &amp;ufunc_nbdtrc_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrc_data[1] = &amp;ufunc_nbdtrc_ptr[2*1]</span>
<span class="s0">ufunc_nbdtrc_data[2] = &amp;ufunc_nbdtrc_ptr[2*2]</span>
<span class="s0">nbdtrc = np.PyUFunc_FromFuncAndData(ufunc_nbdtrc_loops, ufunc_nbdtrc_data, ufunc_nbdtrc_types, 3, 3, 1, 0, &quot;nbdtrc&quot;, ufunc_nbdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtri_data[3]</span>
<span class="s0">cdef char ufunc_nbdtri_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtri_doc = (</span>
    <span class="s0">&quot;nbdtri(k, n, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `p` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;p : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float) such that\n&quot;</span>
    <span class="s0">&quot;    `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Negative binomial survival function.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtri` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``ppf`` method of `scipy.stats.nbinom`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`nbdtri` is the inverse of `nbdtr` with respect to `p`.\n&quot;</span>
    <span class="s0">&quot;Up to floating point errors the following holds:\n&quot;</span>
    <span class="s0">&quot;``nbdtri(k, n, nbdtr(k, n, p))=p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtri, nbdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, y = 5, 10, 0.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val = nbdtr(k, n, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(k, n, cdf_val)\n&quot;</span>
    <span class="s0">&quot;0.20000000000000004\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0.1, 0.4, 0.8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(3, 5, y)\n&quot;</span>
    <span class="s0">&quot;array([0.34462319, 0.51653095, 0.69677416])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [5, 20, 30, 30]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k_parameters = [20, 20, 60, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(n_parameters, k_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     n, k, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtri_vals = nbdtri(k, n, cdf_vals)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(cdf_vals, nbdtri_vals, label=rf\&quot;$k={k},\\ n={n}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(\&quot;$p$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$CDF$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; title = \&quot;nbdtri: inverse of negative binomial CDF with respect to $p$\&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(title)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtri` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, y.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(k, 5, y)\n&quot;</span>
    <span class="s0">&quot;array([[0.37258157, 0.45169416, 0.53249956, 0.64578407],\n&quot;</span>
    <span class="s0">&quot;       [0.24588501, 0.30451981, 0.36778453, 0.46397088],\n&quot;</span>
    <span class="s0">&quot;       [0.18362101, 0.22966758, 0.28054743, 0.36066188]])&quot;)</span>
<span class="s0">ufunc_nbdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ppd__As_ppd_d</span>
<span class="s0">ufunc_nbdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtri_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtri_types[1] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_nbdtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_ptr[2*0] = &lt;void*&gt;_func_cephes_nbdtri_wrap</span>
<span class="s0">ufunc_nbdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_ptr[2*1] = &lt;void*&gt;_func_nbdtri_unsafe</span>
<span class="s0">ufunc_nbdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_ptr[2*2] = &lt;void*&gt;_func_nbdtri_unsafe</span>
<span class="s0">ufunc_nbdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_data[0] = &amp;ufunc_nbdtri_ptr[2*0]</span>
<span class="s0">ufunc_nbdtri_data[1] = &amp;ufunc_nbdtri_ptr[2*1]</span>
<span class="s0">ufunc_nbdtri_data[2] = &amp;ufunc_nbdtri_ptr[2*2]</span>
<span class="s0">nbdtri = np.PyUFunc_FromFuncAndData(ufunc_nbdtri_loops, ufunc_nbdtri_data, ufunc_nbdtri_types, 3, 3, 1, 0, &quot;nbdtri&quot;, ufunc_nbdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_nbdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_nbdtrik_data[2]</span>
<span class="s0">cdef char ufunc_nbdtrik_types[8]</span>
<span class="s0">cdef char *ufunc_nbdtrik_doc = (</span>
    <span class="s0">&quot;nbdtrik(y, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial percentile function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `k` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;k : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures such that `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Survival function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.26 of [2]_,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n&quot;</span>
    <span class="s0">&quot;    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used to reduce calculation of the cumulative distribution function to\n&quot;</span>
    <span class="s0">&quot;that of a regularized incomplete beta :math:`I`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `k` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`.  The search relies on the monotonicity of `y` with `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the negative binomial cumulative distribution function for an\n&quot;</span>
    <span class="s0">&quot;exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr, nbdtrik\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 2, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nbdtrik` recovers the original value for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrik(cdf_value, n, p)\n&quot;</span>
    <span class="s0">&quot;5.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.7, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [30, 30, 30, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtrik_vals = nbdtrik(cdf_vals, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(cdf_vals, nbdtrik_vals, label=rf\&quot;$n={n},\\ p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$CDF$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial percentile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. The percentile function  method ``ppf``\n&quot;</span>
    <span class="s0">&quot;returns the result of `nbdtrik` rounded up to integers:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; q, n, p = 0.6, 5, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbinom.ppf(q, n, p), nbdtrik(q, n, p)\n&quot;</span>
    <span class="s0">&quot;(5.0, 4.800428460273882)&quot;)</span>
<span class="s0">ufunc_nbdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_ptr[2*0] = &lt;void*&gt;_func_nbdtrik</span>
<span class="s0">ufunc_nbdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrik&quot;)</span>
<span class="s0">ufunc_nbdtrik_ptr[2*1] = &lt;void*&gt;_func_nbdtrik</span>
<span class="s0">ufunc_nbdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrik&quot;)</span>
<span class="s0">ufunc_nbdtrik_data[0] = &amp;ufunc_nbdtrik_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrik_data[1] = &amp;ufunc_nbdtrik_ptr[2*1]</span>
<span class="s0">nbdtrik = np.PyUFunc_FromFuncAndData(ufunc_nbdtrik_loops, ufunc_nbdtrik_data, ufunc_nbdtrik_types, 2, 3, 1, 0, &quot;nbdtrik&quot;, ufunc_nbdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrin_loops[2]</span>
<span class="s0">cdef void *ufunc_nbdtrin_ptr[4]</span>
<span class="s0">cdef void *ufunc_nbdtrin_data[2]</span>
<span class="s0">cdef char ufunc_nbdtrin_types[8]</span>
<span class="s0">cdef char *ufunc_nbdtrin_doc = (</span>
    <span class="s0">&quot;nbdtrin(k, y, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `nbdtr` vs `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `n` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;n : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of successes `n` such that `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.26 of [2]_,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n&quot;</span>
    <span class="s0">&quot;    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used to reduce calculation of the cumulative distribution function to\n&quot;</span>
    <span class="s0">&quot;that of a regularized incomplete beta :math:`I`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `n` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`.  The search relies on the monotonicity of `y` with `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the negative binomial cumulative distribution function for an\n&quot;</span>
    <span class="s0">&quot;exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr, nbdtrin\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 2, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nbdtrin` recovers the original value for `n` up to floating\n&quot;</span>
    <span class="s0">&quot;point accuracy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrin(k, cdf_value, p)\n&quot;</span>
    <span class="s0">&quot;1.999999999998137&quot;)</span>
<span class="s0">ufunc_nbdtrin_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrin_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrin_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_ptr[2*0] = &lt;void*&gt;_func_nbdtrin</span>
<span class="s0">ufunc_nbdtrin_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrin&quot;)</span>
<span class="s0">ufunc_nbdtrin_ptr[2*1] = &lt;void*&gt;_func_nbdtrin</span>
<span class="s0">ufunc_nbdtrin_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrin&quot;)</span>
<span class="s0">ufunc_nbdtrin_data[0] = &amp;ufunc_nbdtrin_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrin_data[1] = &amp;ufunc_nbdtrin_ptr[2*1]</span>
<span class="s0">nbdtrin = np.PyUFunc_FromFuncAndData(ufunc_nbdtrin_loops, ufunc_nbdtrin_data, ufunc_nbdtrin_types, 2, 3, 1, 0, &quot;nbdtrin&quot;, ufunc_nbdtrin_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtr_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtr_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtr_doc = (</span>
    <span class="s0">&quot;ncfdtr(dfn, dfd, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The non-central F describes the distribution of,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    Z = \\frac{X/d_n}{Y/d_d}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`X` and :math:`Y` are independently distributed, with\n&quot;</span>
    <span class="s0">&quot;:math:`X` distributed non-central :math:`\\chi^2` with noncentrality\n&quot;</span>
    <span class="s0">&quot;parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y`\n&quot;</span>
    <span class="s0">&quot;distributed :math:`\\chi^2` with :math:`d_d` degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The calculated CDF.  If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float.  Otherwise it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdffnc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function is computed using Formula 26.6.20 of\n&quot;</span>
    <span class="s0">&quot;[2]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d, n_c, f) = \\sum_{j=0}^\\infty e^{-n_c/2}\n&quot;</span>
    <span class="s0">&quot;    \\frac{(n_c/2)^j}{j!} I_{x}(\\frac{d_n}{2} + j, \\frac{d_d}{2}),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`I` is the regularized incomplete beta function, and\n&quot;</span>
    <span class="s0">&quot;:math:`x = f d_n/(f d_n + d_d)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The computation time required for this routine is proportional to the\n&quot;</span>
    <span class="s0">&quot;noncentrality parameter `nc`.  Very large values of this parameter can\n&quot;</span>
    <span class="s0">&quot;consume immense computer resources.  This is why the search range is\n&quot;</span>
    <span class="s0">&quot;bounded by 10,000.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import stats\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the CDF of the non-central F distribution, for nc=0.  Compare with the\n&quot;</span>
    <span class="s0">&quot;F-distribution from scipy.stats:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-1, 8, num=500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncf_stats = stats.f.cdf(x, dfn, dfd)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncf_special = special.ncfdtr(dfn, dfd, 0, x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig = plt.figure()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax = fig.add_subplot(111)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ncf_stats, 'b-', lw=3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ncf_special, 'r-')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ncfdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_ptr[2*0] = &lt;void*&gt;_func_ncfdtr</span>
<span class="s0">ufunc_ncfdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtr&quot;)</span>
<span class="s0">ufunc_ncfdtr_ptr[2*1] = &lt;void*&gt;_func_ncfdtr</span>
<span class="s0">ufunc_ncfdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtr&quot;)</span>
<span class="s0">ufunc_ncfdtr_data[0] = &amp;ufunc_ncfdtr_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtr_data[1] = &amp;ufunc_ncfdtr_ptr[2*1]</span>
<span class="s0">ncfdtr = np.PyUFunc_FromFuncAndData(ufunc_ncfdtr_loops, ufunc_ncfdtr_data, ufunc_ncfdtr_types, 2, 4, 1, 0, &quot;ncfdtr&quot;, ufunc_ncfdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtri_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtri_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtri_doc = (</span>
    <span class="s0">&quot;ncfdtri(dfn, dfd, nc, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse with respect to `f` of the CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function.  Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;f : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtri\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `f`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f = [0.5, 1, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, 3, 1.5, f)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.20782291,  0.36107392,  0.47345752])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse.  We recover the values of `f`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtri(2, 3, 1.5, p)\n&quot;</span>
    <span class="s0">&quot;array([ 0.5,  1. ,  1.5])&quot;)</span>
<span class="s0">ufunc_ncfdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_ptr[2*0] = &lt;void*&gt;_func_ncfdtri</span>
<span class="s0">ufunc_ncfdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtri&quot;)</span>
<span class="s0">ufunc_ncfdtri_ptr[2*1] = &lt;void*&gt;_func_ncfdtri</span>
<span class="s0">ufunc_ncfdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtri&quot;)</span>
<span class="s0">ufunc_ncfdtri_data[0] = &amp;ufunc_ncfdtri_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtri_data[1] = &amp;ufunc_ncfdtri_ptr[2*1]</span>
<span class="s0">ncfdtri = np.PyUFunc_FromFuncAndData(ufunc_ncfdtri_loops, ufunc_ncfdtri_data, ufunc_ncfdtri_types, 2, 4, 1, 0, &quot;ncfdtri&quot;, ufunc_ncfdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtridfd_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtridfd_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtridfd_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtridfd_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtridfd_doc = (</span>
    <span class="s0">&quot;ncfdtridfd(dfn, p, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom (denominator) for the noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `dfd` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function.  Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfd : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of the cumulative noncentral F distribution is not necessarily\n&quot;</span>
    <span class="s0">&quot;monotone in either degrees of freedom. There thus may be two values that\n&quot;</span>
    <span class="s0">&quot;provide a given CDF value. This routine assumes monotonicity and will\n&quot;</span>
    <span class="s0">&quot;find an arbitrary one of the two values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `dfd`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, dfd, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.8097138 ,  0.93020416,  0.96787852])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse.  We recover the values of `dfd`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtridfd(2, p, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 1.,  2.,  3.])&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtridfd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtridfd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*0] = &lt;void*&gt;_func_ncfdtridfd</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfd&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*1] = &lt;void*&gt;_func_ncfdtridfd</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfd&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_data[0] = &amp;ufunc_ncfdtridfd_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtridfd_data[1] = &amp;ufunc_ncfdtridfd_ptr[2*1]</span>
<span class="s0">ncfdtridfd = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfd_loops, ufunc_ncfdtridfd_data, ufunc_ncfdtridfd_types, 2, 4, 1, 0, &quot;ncfdtridfd&quot;, ufunc_ncfdtridfd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtridfn_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtridfn_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtridfn_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtridfn_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtridfn_doc = (</span>
    <span class="s0">&quot;ncfdtridfn(p, dfd, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom (numerator) for the noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `dfn` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function. Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : float\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of the cumulative noncentral F distribution is not necessarily\n&quot;</span>
    <span class="s0">&quot;monotone in either degrees of freedom. There thus may be two values that\n&quot;</span>
    <span class="s0">&quot;provide a given CDF value. This routine assumes monotonicity and will\n&quot;</span>
    <span class="s0">&quot;find an arbitrary one of the two values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfn\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `dfn`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(dfn, 2, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.92562363,  0.93020416,  0.93188394])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `dfn`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtridfn(p, 2, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 1.,  2.,  3.])&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtridfn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtridfn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*0] = &lt;void*&gt;_func_ncfdtridfn</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfn&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*1] = &lt;void*&gt;_func_ncfdtridfn</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfn&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_data[0] = &amp;ufunc_ncfdtridfn_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtridfn_data[1] = &amp;ufunc_ncfdtridfn_ptr[2*1]</span>
<span class="s0">ncfdtridfn = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfn_loops, ufunc_ncfdtridfn_data, ufunc_ncfdtridfn_types, 2, 4, 1, 0, &quot;ncfdtridfn&quot;, ufunc_ncfdtridfn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtrinc_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtrinc_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtrinc_doc = (</span>
    <span class="s0">&quot;ncfdtrinc(dfn, dfd, p, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate non-centrality parameter for non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `nc` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function. Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtrinc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `nc`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nc = [0.5, 1.5, 2.0]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, 3, nc, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.96309246,  0.94327955,  0.93304098])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `nc`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtrinc(2, 3, p, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 0.5,  1.5,  2. ])&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*0] = &lt;void*&gt;_func_ncfdtrinc</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtrinc&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*1] = &lt;void*&gt;_func_ncfdtrinc</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtrinc&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_data[0] = &amp;ufunc_ncfdtrinc_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtrinc_data[1] = &amp;ufunc_ncfdtrinc_ptr[2*1]</span>
<span class="s0">ncfdtrinc = np.PyUFunc_FromFuncAndData(ufunc_ncfdtrinc_loops, ufunc_ncfdtrinc_data, ufunc_ncfdtrinc_types, 2, 4, 1, 0, &quot;ncfdtrinc&quot;, ufunc_ncfdtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtr_data[2]</span>
<span class="s0">cdef char ufunc_nctdtr_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtr_doc = (</span>
    <span class="s0">&quot;nctdtr(df, nc, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The calculated CDF. If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float. Otherwise, it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import stats\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the CDF of the non-central t distribution, for nc=0. Compare with the\n&quot;</span>
    <span class="s0">&quot;t-distribution from scipy.stats:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5, 5, num=500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nct_stats = stats.t.cdf(x, df)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nct_special = special.nctdtr(df, 0, x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig = plt.figure()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax = fig.add_subplot(111)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, nct_stats, 'b-', lw=3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, nct_special, 'r-')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_nctdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_ptr[2*0] = &lt;void*&gt;_func_nctdtr</span>
<span class="s0">ufunc_nctdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtr&quot;)</span>
<span class="s0">ufunc_nctdtr_ptr[2*1] = &lt;void*&gt;_func_nctdtr</span>
<span class="s0">ufunc_nctdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtr&quot;)</span>
<span class="s0">ufunc_nctdtr_data[0] = &amp;ufunc_nctdtr_ptr[2*0]</span>
<span class="s0">ufunc_nctdtr_data[1] = &amp;ufunc_nctdtr_ptr[2*1]</span>
<span class="s0">nctdtr = np.PyUFunc_FromFuncAndData(ufunc_nctdtr_loops, ufunc_nctdtr_data, ufunc_nctdtr_types, 2, 3, 1, 0, &quot;nctdtr&quot;, ufunc_nctdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtridf_data[2]</span>
<span class="s0">cdef char ufunc_nctdtridf_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtridf_doc = (</span>
    <span class="s0">&quot;nctdtridf(p, nc, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom for non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;df : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The degrees of freedom. If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float. Otherwise, it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nctdtr, nctdtridf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `df`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = nctdtr(df, 0.25, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.67491974, 0.716464  , 0.73349456])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `df`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nctdtridf(p, 0.25, 1)\n&quot;</span>
    <span class="s0">&quot;array([1., 2., 3.])&quot;)</span>
<span class="s0">ufunc_nctdtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_ptr[2*0] = &lt;void*&gt;_func_nctdtridf</span>
<span class="s0">ufunc_nctdtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtridf&quot;)</span>
<span class="s0">ufunc_nctdtridf_ptr[2*1] = &lt;void*&gt;_func_nctdtridf</span>
<span class="s0">ufunc_nctdtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtridf&quot;)</span>
<span class="s0">ufunc_nctdtridf_data[0] = &amp;ufunc_nctdtridf_ptr[2*0]</span>
<span class="s0">ufunc_nctdtridf_data[1] = &amp;ufunc_nctdtridf_ptr[2*1]</span>
<span class="s0">nctdtridf = np.PyUFunc_FromFuncAndData(ufunc_nctdtridf_loops, ufunc_nctdtridf_data, ufunc_nctdtridf_types, 2, 3, 1, 0, &quot;nctdtridf&quot;, ufunc_nctdtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtrinc_data[2]</span>
<span class="s0">cdef char ufunc_nctdtrinc_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtrinc_doc = (</span>
    <span class="s0">&quot;nctdtrinc(df, p, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate non-centrality parameter for non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nctdtr, nctdtrinc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `nc`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nc = [0.5, 1.5, 2.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = nctdtr(3, nc, 1.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.77569497, 0.45524533, 0.1668691 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `nc`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nctdtrinc(3, p, 1.5)\n&quot;</span>
    <span class="s0">&quot;array([0.5, 1.5, 2.5])&quot;)</span>
<span class="s0">ufunc_nctdtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*0] = &lt;void*&gt;_func_nctdtrinc</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrinc&quot;)</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*1] = &lt;void*&gt;_func_nctdtrinc</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrinc&quot;)</span>
<span class="s0">ufunc_nctdtrinc_data[0] = &amp;ufunc_nctdtrinc_ptr[2*0]</span>
<span class="s0">ufunc_nctdtrinc_data[1] = &amp;ufunc_nctdtrinc_ptr[2*1]</span>
<span class="s0">nctdtrinc = np.PyUFunc_FromFuncAndData(ufunc_nctdtrinc_loops, ufunc_nctdtrinc_data, ufunc_nctdtrinc_types, 2, 3, 1, 0, &quot;nctdtrinc&quot;, ufunc_nctdtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtrit_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtrit_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtrit_data[2]</span>
<span class="s0">cdef char ufunc_nctdtrit_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtrit_doc = (</span>
    <span class="s0">&quot;nctdtrit(df, nc, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse cumulative distribution function of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Quantiles\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nctdtr, nctdtrit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `t`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; t = [0.5, 1, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = nctdtr(3, 1, t)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.29811049, 0.46922687, 0.6257559 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `t`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nctdtrit(3, 1, p)\n&quot;</span>
    <span class="s0">&quot;array([0.5, 1. , 1.5])&quot;)</span>
<span class="s0">ufunc_nctdtrit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtrit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtrit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_ptr[2*0] = &lt;void*&gt;_func_nctdtrit</span>
<span class="s0">ufunc_nctdtrit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrit&quot;)</span>
<span class="s0">ufunc_nctdtrit_ptr[2*1] = &lt;void*&gt;_func_nctdtrit</span>
<span class="s0">ufunc_nctdtrit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrit&quot;)</span>
<span class="s0">ufunc_nctdtrit_data[0] = &amp;ufunc_nctdtrit_ptr[2*0]</span>
<span class="s0">ufunc_nctdtrit_data[1] = &amp;ufunc_nctdtrit_ptr[2*1]</span>
<span class="s0">nctdtrit = np.PyUFunc_FromFuncAndData(ufunc_nctdtrit_loops, ufunc_nctdtrit_data, ufunc_nctdtrit_types, 2, 3, 1, 0, &quot;nctdtrit&quot;, ufunc_nctdtrit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtr_loops[4]</span>
<span class="s0">cdef void *ufunc_ndtr_ptr[8]</span>
<span class="s0">cdef void *ufunc_ndtr_data[4]</span>
<span class="s0">cdef char ufunc_ndtr_types[8]</span>
<span class="s0">cdef char *ufunc_ndtr_doc = (</span>
    <span class="s0">&quot;ndtr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution of the standard normal distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the standard Gaussian probability\n&quot;</span>
    <span class="s0">&quot;density function, integrated from minus infinity to `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like, real or complex\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the normal CDF evaluated at `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;log_ndtr : Logarithm of ndtr\n&quot;</span>
    <span class="s0">&quot;ndtri : Inverse of ndtr, standard normal percentile function\n&quot;</span>
    <span class="s0">&quot;erf : Error function\n&quot;</span>
    <span class="s0">&quot;erfc : 1 - erf\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm : Normal distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate `ndtr` at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ndtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtr(0.5)\n&quot;</span>
    <span class="s0">&quot;0.6914624612740131\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points by providing a NumPy array\n&quot;</span>
    <span class="s0">&quot;or list for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtr([0, 0.5, 2])\n&quot;</span>
    <span class="s0">&quot;array([0.5       , 0.69146246, 0.97724987])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ndtr(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Standard normal cumulative distribution function $\\Phi$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_ndtr_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_ndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtr_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ndtr_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ndtr_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ndtr_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ndtr_ptr[2*0] = &lt;void*&gt;_func_cephes_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*1] = &lt;void*&gt;_func_cephes_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_data[0] = &amp;ufunc_ndtr_ptr[2*0]</span>
<span class="s0">ufunc_ndtr_data[1] = &amp;ufunc_ndtr_ptr[2*1]</span>
<span class="s0">ufunc_ndtr_data[2] = &amp;ufunc_ndtr_ptr[2*2]</span>
<span class="s0">ufunc_ndtr_data[3] = &amp;ufunc_ndtr_ptr[2*3]</span>
<span class="s0">ndtr = np.PyUFunc_FromFuncAndData(ufunc_ndtr_loops, ufunc_ndtr_data, ufunc_ndtr_types, 4, 1, 1, 0, &quot;ndtr&quot;, ufunc_ndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtri_loops[2]</span>
<span class="s0">cdef void *ufunc_ndtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_ndtri_data[2]</span>
<span class="s0">cdef char ufunc_ndtri_types[4]</span>
<span class="s0">cdef char *ufunc_ndtri_doc = (</span>
    <span class="s0">&quot;ndtri(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `ndtr` vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument x for which the area under the standard normal\n&quot;</span>
    <span class="s0">&quot;probability density function (integrated from minus infinity to `x`)\n&quot;</span>
    <span class="s0">&quot;is equal to y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of x such that ``ndtr(x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ndtr : Standard normal cumulative probability distribution\n&quot;</span>
    <span class="s0">&quot;ndtri_exp : Inverse of log_ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`ndtri` is the percentile function of the standard normal distribution.\n&quot;</span>
    <span class="s0">&quot;This means it returns the inverse of the cumulative density `ndtr`. First,\n&quot;</span>
    <span class="s0">&quot;let us compute a cumulative density value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ndtri, ndtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val = ndtr(2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val\n&quot;</span>
    <span class="s0">&quot;0.9772498680518208\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `ndtri` yields the original value for `x` up to floating point\n&quot;</span>
    <span class="s0">&quot;errors.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtri(cdf_val)\n&quot;</span>
    <span class="s0">&quot;2.0000000000000004\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function. For that purpose, we provide a NumPy array as argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0.01, 1, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ndtri(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Standard normal percentile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ndtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_ptr[2*0] = &lt;void*&gt;_func_cephes_ndtri</span>
<span class="s0">ufunc_ndtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri&quot;)</span>
<span class="s0">ufunc_ndtri_ptr[2*1] = &lt;void*&gt;_func_cephes_ndtri</span>
<span class="s0">ufunc_ndtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri&quot;)</span>
<span class="s0">ufunc_ndtri_data[0] = &amp;ufunc_ndtri_ptr[2*0]</span>
<span class="s0">ufunc_ndtri_data[1] = &amp;ufunc_ndtri_ptr[2*1]</span>
<span class="s0">ndtri = np.PyUFunc_FromFuncAndData(ufunc_ndtri_loops, ufunc_ndtri_data, ufunc_ndtri_types, 2, 1, 1, 0, &quot;ndtri&quot;, ufunc_ndtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtri_exp_loops[2]</span>
<span class="s0">cdef void *ufunc_ndtri_exp_ptr[4]</span>
<span class="s0">cdef void *ufunc_ndtri_exp_data[2]</span>
<span class="s0">cdef char ufunc_ndtri_exp_types[4]</span>
<span class="s0">cdef char *ufunc_ndtri_exp_doc = (</span>
    <span class="s0">&quot;ndtri_exp(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `log_ndtr` vs x. Allows for greater precision than\n&quot;</span>
    <span class="s0">&quot;`ndtri` composed with `numpy.exp` for very small values of y and for\n&quot;</span>
    <span class="s0">&quot;y close to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Function argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Inverse of the log CDF of the standard normal distribution, evaluated\n&quot;</span>
    <span class="s0">&quot;    at y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;log_ndtr : log of the standard normal cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;ndtr : standard normal cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;ndtri : standard normal percentile function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`ndtri_exp` agrees with the naive implementation when the latter does\n&quot;</span>
    <span class="s0">&quot;not suffer from underflow.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-1)\n&quot;</span>
    <span class="s0">&quot;-0.33747496376420244\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-1))\n&quot;</span>
    <span class="s0">&quot;-0.33747496376420244\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For extreme values of y, the naive approach fails\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-800))\n&quot;</span>
    <span class="s0">&quot;-inf\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-1e-20))\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;whereas `ndtri_exp` is still able to compute the result to high precision.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-800)\n&quot;</span>
    <span class="s0">&quot;-39.88469483825668\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-1e-20)\n&quot;</span>
    <span class="s0">&quot;9.262340089798409&quot;)</span>
<span class="s0">ufunc_ndtri_exp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtri_exp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtri_exp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_exp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_exp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_exp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*0] = &lt;void*&gt;_func_ndtri_exp</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri_exp&quot;)</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*1] = &lt;void*&gt;_func_ndtri_exp</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri_exp&quot;)</span>
<span class="s0">ufunc_ndtri_exp_data[0] = &amp;ufunc_ndtri_exp_ptr[2*0]</span>
<span class="s0">ufunc_ndtri_exp_data[1] = &amp;ufunc_ndtri_exp_ptr[2*1]</span>
<span class="s0">ndtri_exp = np.PyUFunc_FromFuncAndData(ufunc_ndtri_exp_loops, ufunc_ndtri_exp_data, ufunc_ndtri_exp_types, 2, 1, 1, 0, &quot;ndtri_exp&quot;, ufunc_ndtri_exp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nrdtrimn_loops[2]</span>
<span class="s0">cdef void *ufunc_nrdtrimn_ptr[4]</span>
<span class="s0">cdef void *ufunc_nrdtrimn_data[2]</span>
<span class="s0">cdef char ufunc_nrdtrimn_types[8]</span>
<span class="s0">cdef char *ufunc_nrdtrimn_doc = (</span>
    <span class="s0">&quot;nrdtrimn(p, std, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate mean of normal distribution given other params.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;std : array_like\n&quot;</span>
    <span class="s0">&quot;    Standard deviation.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;mn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The mean of the normal distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm : Normal distribution\n&quot;</span>
    <span class="s0">&quot;ndtr : Standard normal cumulative probability distribution\n&quot;</span>
    <span class="s0">&quot;ndtri : Inverse of standard normal CDF with respect to quantile\n&quot;</span>
    <span class="s0">&quot;nrdtrisd : Inverse of normal distribution CDF with respect to\n&quot;</span>
    <span class="s0">&quot;           standard deviation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`nrdtrimn` can be used to recover the mean of a normal distribution\n&quot;</span>
    <span class="s0">&quot;if we know the CDF value `p` for a given quantile `x` and the\n&quot;</span>
    <span class="s0">&quot;standard deviation `std`. First, we calculate\n&quot;</span>
    <span class="s0">&quot;the normal distribution CDF for an exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; mean = 3.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; std = 2.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = norm.cdf(x, loc=mean, scale=std)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;0.9331927987311419\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nrdtrimn` returns the original value for `mean`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nrdtrimn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nrdtrimn(p, std, x)\n&quot;</span>
    <span class="s0">&quot;3.0000000000000004&quot;)</span>
<span class="s0">ufunc_nrdtrimn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nrdtrimn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nrdtrimn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*0] = &lt;void*&gt;_func_nrdtrimn</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrimn&quot;)</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*1] = &lt;void*&gt;_func_nrdtrimn</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrimn&quot;)</span>
<span class="s0">ufunc_nrdtrimn_data[0] = &amp;ufunc_nrdtrimn_ptr[2*0]</span>
<span class="s0">ufunc_nrdtrimn_data[1] = &amp;ufunc_nrdtrimn_ptr[2*1]</span>
<span class="s0">nrdtrimn = np.PyUFunc_FromFuncAndData(ufunc_nrdtrimn_loops, ufunc_nrdtrimn_data, ufunc_nrdtrimn_types, 2, 3, 1, 0, &quot;nrdtrimn&quot;, ufunc_nrdtrimn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nrdtrisd_loops[2]</span>
<span class="s0">cdef void *ufunc_nrdtrisd_ptr[4]</span>
<span class="s0">cdef void *ufunc_nrdtrisd_data[2]</span>
<span class="s0">cdef char ufunc_nrdtrisd_types[8]</span>
<span class="s0">cdef char *ufunc_nrdtrisd_doc = (</span>
    <span class="s0">&quot;nrdtrisd(mn, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate standard deviation of normal distribution given other params.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;mn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The mean of the normal distribution.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;std : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Standard deviation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm : Normal distribution\n&quot;</span>
    <span class="s0">&quot;ndtr : Standard normal cumulative probability distribution\n&quot;</span>
    <span class="s0">&quot;ndtri : Inverse of standard normal CDF with respect to quantile\n&quot;</span>
    <span class="s0">&quot;nrdtrimn : Inverse of normal distribution CDF with respect to\n&quot;</span>
    <span class="s0">&quot;           mean\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`nrdtrisd` can be used to recover the standard deviation of a normal\n&quot;</span>
    <span class="s0">&quot;distribution if we know the CDF value `p` for a given quantile `x` and\n&quot;</span>
    <span class="s0">&quot;the mean `mn`. First, we calculate the normal distribution CDF for an\n&quot;</span>
    <span class="s0">&quot;exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; mean = 3.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; std = 2.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = norm.cdf(x, loc=mean, scale=std)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;0.9331927987311419\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nrdtrisd` returns the original value for `std`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nrdtrisd\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nrdtrisd(mean, p, x)\n&quot;</span>
    <span class="s0">&quot;2.0000000000000004&quot;)</span>
<span class="s0">ufunc_nrdtrisd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nrdtrisd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nrdtrisd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*0] = &lt;void*&gt;_func_nrdtrisd</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrisd&quot;)</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*1] = &lt;void*&gt;_func_nrdtrisd</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrisd&quot;)</span>
<span class="s0">ufunc_nrdtrisd_data[0] = &amp;ufunc_nrdtrisd_ptr[2*0]</span>
<span class="s0">ufunc_nrdtrisd_data[1] = &amp;ufunc_nrdtrisd_ptr[2*1]</span>
<span class="s0">nrdtrisd = np.PyUFunc_FromFuncAndData(ufunc_nrdtrisd_loops, ufunc_nrdtrisd_data, ufunc_nrdtrisd_types, 2, 3, 1, 0, &quot;nrdtrisd&quot;, ufunc_nrdtrisd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_owens_t_loops[2]</span>
<span class="s0">cdef void *ufunc_owens_t_ptr[4]</span>
<span class="s0">cdef void *ufunc_owens_t_data[2]</span>
<span class="s0">cdef char ufunc_owens_t_types[6]</span>
<span class="s0">cdef char *ufunc_owens_t_doc = (</span>
    <span class="s0">&quot;owens_t(h, a, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Owen's T Function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function T(h, a) gives the probability of the event\n&quot;</span>
    <span class="s0">&quot;(X &gt; h and 0 &lt; Y &lt; a * X) where X and Y are independent\n&quot;</span>
    <span class="s0">&quot;standard normal random variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;h: array_like\n&quot;</span>
    <span class="s0">&quot;    Input value.\n&quot;</span>
    <span class="s0">&quot;a: array_like\n&quot;</span>
    <span class="s0">&quot;    Input value.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t: scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of the event (X &gt; h and 0 &lt; Y &lt; a * X),\n&quot;</span>
    <span class="s0">&quot;    where X and Y are independent standard normal random variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] M. Patefield and D. Tandy, \&quot;Fast and accurate calculation of\n&quot;</span>
    <span class="s0">&quot;       Owen's T Function\&quot;, Statistical Software vol. 5, pp. 1-25, 2000.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 3.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; h = 0.78\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; special.owens_t(h, a)\n&quot;</span>
    <span class="s0">&quot;0.10877216734852274&quot;)</span>
<span class="s0">ufunc_owens_t_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_owens_t_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_owens_t_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_ptr[2*0] = &lt;void*&gt;_func_cephes_owens_t</span>
<span class="s0">ufunc_owens_t_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;owens_t&quot;)</span>
<span class="s0">ufunc_owens_t_ptr[2*1] = &lt;void*&gt;_func_cephes_owens_t</span>
<span class="s0">ufunc_owens_t_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;owens_t&quot;)</span>
<span class="s0">ufunc_owens_t_data[0] = &amp;ufunc_owens_t_ptr[2*0]</span>
<span class="s0">ufunc_owens_t_data[1] = &amp;ufunc_owens_t_ptr[2*1]</span>
<span class="s0">owens_t = np.PyUFunc_FromFuncAndData(ufunc_owens_t_loops, ufunc_owens_t_data, ufunc_owens_t_types, 2, 2, 1, 0, &quot;owens_t&quot;, ufunc_owens_t_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtr_data[2]</span>
<span class="s0">cdef char ufunc_pdtr_types[6]</span>
<span class="s0">cdef char *ufunc_pdtr_doc = (</span>
    <span class="s0">&quot;pdtr(k, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Poisson cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as the probability that a Poisson-distributed random\n&quot;</span>
    <span class="s0">&quot;variable with event rate :math:`m` is less than or equal to\n&quot;</span>
    <span class="s0">&quot;:math:`k`. More concretely, this works out to be [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\exp(-m) \\sum_{j = 0}^{\\lfloor{k}\\rfloor} \\frac{m^j}{j!}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a cumulative distribution function, so it converges to 1\n&quot;</span>
    <span class="s0">&quot;monotonically as `k` goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtr([1, 10, 100, np.inf], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.73575888, 0.99999999, 1.        , 1.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is discontinuous at integers and constant between integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtr([1, 1.5, 1.9, 2], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])&quot;)</span>
<span class="s0">ufunc_pdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_ptr[2*0] = &lt;void*&gt;_func_cephes_pdtr</span>
<span class="s0">ufunc_pdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtr&quot;)</span>
<span class="s0">ufunc_pdtr_ptr[2*1] = &lt;void*&gt;_func_cephes_pdtr</span>
<span class="s0">ufunc_pdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtr&quot;)</span>
<span class="s0">ufunc_pdtr_data[0] = &amp;ufunc_pdtr_ptr[2*0]</span>
<span class="s0">ufunc_pdtr_data[1] = &amp;ufunc_pdtr_ptr[2*1]</span>
<span class="s0">pdtr = np.PyUFunc_FromFuncAndData(ufunc_pdtr_loops, ufunc_pdtr_data, ufunc_pdtr_types, 2, 2, 1, 0, &quot;pdtr&quot;, ufunc_pdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtrc_data[2]</span>
<span class="s0">cdef char ufunc_pdtrc_types[6]</span>
<span class="s0">cdef char *ufunc_pdtrc_doc = (</span>
    <span class="s0">&quot;pdtrc(k, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Poisson survival function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms from k+1 to infinity of the Poisson\n&quot;</span>
    <span class="s0">&quot;distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(\n&quot;</span>
    <span class="s0">&quot;k+1, m). Arguments must both be non-negative doubles.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Poisson survival function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a survival function, so it decreases to 0\n&quot;</span>
    <span class="s0">&quot;monotonically as `k` goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([1, 10, 100, np.inf])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtrc(k, 1)\n&quot;</span>
    <span class="s0">&quot;array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the lower incomplete gamma\n&quot;</span>
    <span class="s0">&quot;function `gammainc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(k + 1, 1)\n&quot;</span>
    <span class="s0">&quot;array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000])&quot;)</span>
<span class="s0">ufunc_pdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_ptr[2*0] = &lt;void*&gt;_func_cephes_pdtrc</span>
<span class="s0">ufunc_pdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrc&quot;)</span>
<span class="s0">ufunc_pdtrc_ptr[2*1] = &lt;void*&gt;_func_cephes_pdtrc</span>
<span class="s0">ufunc_pdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrc&quot;)</span>
<span class="s0">ufunc_pdtrc_data[0] = &amp;ufunc_pdtrc_ptr[2*0]</span>
<span class="s0">ufunc_pdtrc_data[1] = &amp;ufunc_pdtrc_ptr[2*1]</span>
<span class="s0">pdtrc = np.PyUFunc_FromFuncAndData(ufunc_pdtrc_loops, ufunc_pdtrc_data, ufunc_pdtrc_types, 2, 2, 1, 0, &quot;pdtrc&quot;, ufunc_pdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_pdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_pdtri_data[3]</span>
<span class="s0">cdef char ufunc_pdtri_types[9]</span>
<span class="s0">cdef char *ufunc_pdtri_doc = (</span>
    <span class="s0">&quot;pdtri(k, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `pdtr` vs m\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the Poisson variable `m` such that the sum from 0 to `k` of\n&quot;</span>
    <span class="s0">&quot;the Poisson density is equal to the given probability `y`:\n&quot;</span>
    <span class="s0">&quot;calculated by ``gammaincinv(k + 1, y)``. `k` must be a nonnegative\n&quot;</span>
    <span class="s0">&quot;integer and `y` between 0 and 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shape parameter `m` such that ``pdtr(k, m) = p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `m`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; m = [0.5, 1, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = sc.pdtr(1, m)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.90979599, 0.73575888, 0.5578254 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `m`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtri(1, p)\n&quot;</span>
    <span class="s0">&quot;array([0.5, 1. , 1.5])&quot;)</span>
<span class="s0">ufunc_pdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_pdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtri_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_pdtri_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_ptr[2*0] = &lt;void*&gt;_func_cephes_pdtri_wrap</span>
<span class="s0">ufunc_pdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_ptr[2*1] = &lt;void*&gt;_func_pdtri_unsafe</span>
<span class="s0">ufunc_pdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_ptr[2*2] = &lt;void*&gt;_func_pdtri_unsafe</span>
<span class="s0">ufunc_pdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_data[0] = &amp;ufunc_pdtri_ptr[2*0]</span>
<span class="s0">ufunc_pdtri_data[1] = &amp;ufunc_pdtri_ptr[2*1]</span>
<span class="s0">ufunc_pdtri_data[2] = &amp;ufunc_pdtri_ptr[2*2]</span>
<span class="s0">pdtri = np.PyUFunc_FromFuncAndData(ufunc_pdtri_loops, ufunc_pdtri_data, ufunc_pdtri_types, 3, 2, 1, 0, &quot;pdtri&quot;, ufunc_pdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtrik_data[2]</span>
<span class="s0">cdef char ufunc_pdtrik_types[6]</span>
<span class="s0">cdef char *ufunc_pdtrik_doc = (</span>
    <span class="s0">&quot;pdtrik(p, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `pdtr` vs `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of occurrences `k` such that ``pdtr(k, m) = p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `k`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = sc.pdtr(k, 2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.40600585, 0.67667642, 0.85712346])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `k`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtrik(p, 2)\n&quot;</span>
    <span class="s0">&quot;array([1., 2., 3.])&quot;)</span>
<span class="s0">ufunc_pdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_ptr[2*0] = &lt;void*&gt;_func_pdtrik</span>
<span class="s0">ufunc_pdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrik&quot;)</span>
<span class="s0">ufunc_pdtrik_ptr[2*1] = &lt;void*&gt;_func_pdtrik</span>
<span class="s0">ufunc_pdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrik&quot;)</span>
<span class="s0">ufunc_pdtrik_data[0] = &amp;ufunc_pdtrik_ptr[2*0]</span>
<span class="s0">ufunc_pdtrik_data[1] = &amp;ufunc_pdtrik_ptr[2*1]</span>
<span class="s0">pdtrik = np.PyUFunc_FromFuncAndData(ufunc_pdtrik_loops, ufunc_pdtrik_data, ufunc_pdtrik_types, 2, 2, 1, 0, &quot;pdtrik&quot;, ufunc_pdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_poch_loops[2]</span>
<span class="s0">cdef void *ufunc_poch_ptr[4]</span>
<span class="s0">cdef void *ufunc_poch_data[2]</span>
<span class="s0">cdef char ufunc_poch_types[6]</span>
<span class="s0">cdef char *ufunc_poch_doc = (</span>
    <span class="s0">&quot;poch(z, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Pochhammer symbol.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Pochhammer symbol (rising factorial) is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    (z)_m = \\frac{\\Gamma(z + m)}{\\Gamma(z)}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For positive integer `m` it reads\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    (z)_m = z (z + 1) ... (z + m - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z, m : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued arguments.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] Nist, Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/5.2#iii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is 1 when m is 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch([1, 2, 3, 4], 0)\n&quot;</span>
    <span class="s0">&quot;array([1., 1., 1., 1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For z equal to 1 it reduces to the factorial function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch(1, 5)\n&quot;</span>
    <span class="s0">&quot;120.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 * 2 * 3 * 4 * 5\n&quot;</span>
    <span class="s0">&quot;120\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z, m = 3.7, 2.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch(z, m)\n&quot;</span>
    <span class="s0">&quot;20.529581933776953\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(z + m) / sc.gamma(z)\n&quot;</span>
    <span class="s0">&quot;20.52958193377696&quot;)</span>
<span class="s0">ufunc_poch_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_poch_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_poch_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_ptr[2*0] = &lt;void*&gt;_func_cephes_poch</span>
<span class="s0">ufunc_poch_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;poch&quot;)</span>
<span class="s0">ufunc_poch_ptr[2*1] = &lt;void*&gt;_func_cephes_poch</span>
<span class="s0">ufunc_poch_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;poch&quot;)</span>
<span class="s0">ufunc_poch_data[0] = &amp;ufunc_poch_ptr[2*0]</span>
<span class="s0">ufunc_poch_data[1] = &amp;ufunc_poch_ptr[2*1]</span>
<span class="s0">poch = np.PyUFunc_FromFuncAndData(ufunc_poch_loops, ufunc_poch_data, ufunc_poch_types, 2, 2, 1, 0, &quot;poch&quot;, ufunc_poch_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_powm1_loops[2]</span>
<span class="s0">cdef void *ufunc_powm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_powm1_data[2]</span>
<span class="s0">cdef char ufunc_powm1_types[6]</span>
<span class="s0">cdef char *ufunc_powm1_doc = (</span>
    <span class="s0">&quot;powm1(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes ``x**y - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is useful when `y` is near 0, or when `x` is near 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is implemented for real types only (unlike ``numpy.power``,\n&quot;</span>
    <span class="s0">&quot;which accepts complex inputs).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The base. Must be a real type (i.e. integer or float, not complex).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The exponent. Must be a real type (i.e. integer or float, not complex).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;array_like\n&quot;</span>
    <span class="s0">&quot;    Result of the calculation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.10.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The underlying code is implemented for single precision and double\n&quot;</span>
    <span class="s0">&quot;precision floats only.  Unlike `numpy.power`, integer inputs to\n&quot;</span>
    <span class="s0">&quot;`powm1` are converted to floating point, and complex inputs are\n&quot;</span>
    <span class="s0">&quot;not accepted.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Note the following edge cases:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* ``powm1(x, 0)`` returns 0 for any ``x``, including 0, ``inf``\n&quot;</span>
    <span class="s0">&quot;  and ``nan``.\n&quot;</span>
    <span class="s0">&quot;* ``powm1(1, y)`` returns 0 for any ``y``, including ``nan``\n&quot;</span>
    <span class="s0">&quot;  and ``inf``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import powm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.2, 10.0, 0.9999999975])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([1e-9, 1e-11, 0.1875])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; powm1(x, y)\n&quot;</span>
    <span class="s0">&quot;array([ 1.82321557e-10,  2.30258509e-11, -4.68749998e-10])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be verified that the relative errors in those results\n&quot;</span>
    <span class="s0">&quot;are less than 2.5e-16.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that to the result of ``x**y - 1``, where the\n&quot;</span>
    <span class="s0">&quot;relative errors are all larger than 8e-8:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**y - 1\n&quot;</span>
    <span class="s0">&quot;array([ 1.82321491e-10,  2.30258035e-11, -4.68750039e-10])&quot;)</span>
<span class="s0">ufunc_powm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc_powm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_powm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_powm1_float</span>
<span class="s0">ufunc_powm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;powm1&quot;)</span>
<span class="s0">ufunc_powm1_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_powm1_double</span>
<span class="s0">ufunc_powm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;powm1&quot;)</span>
<span class="s0">ufunc_powm1_data[0] = &amp;ufunc_powm1_ptr[2*0]</span>
<span class="s0">ufunc_powm1_data[1] = &amp;ufunc_powm1_ptr[2*1]</span>
<span class="s0">powm1 = np.PyUFunc_FromFuncAndData(ufunc_powm1_loops, ufunc_powm1_data, ufunc_powm1_types, 2, 2, 1, 0, &quot;powm1&quot;, ufunc_powm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pseudo_huber_loops[2]</span>
<span class="s0">cdef void *ufunc_pseudo_huber_ptr[4]</span>
<span class="s0">cdef void *ufunc_pseudo_huber_data[2]</span>
<span class="s0">cdef char ufunc_pseudo_huber_types[6]</span>
<span class="s0">cdef char *ufunc_pseudo_huber_doc = (</span>
    <span class="s0">&quot;pseudo_huber(delta, r, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Pseudo-Huber loss function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\mathrm{pseudo\\_huber}(\\delta, r) =\n&quot;</span>
    <span class="s0">&quot;          \\delta^2 \\left( \\sqrt{ 1 + \\left( \\frac{r}{\\delta} \\right)^2 } - 1 \\right)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;delta : array_like\n&quot;</span>
    <span class="s0">&quot;    Input array, indicating the soft quadratic vs. linear loss changepoint.\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Input array, possibly representing residuals.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The computed Pseudo-Huber loss function values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;huber: Similar function which this function approximates\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Like `huber`, `pseudo_huber` often serves as a robust loss function\n&quot;</span>
    <span class="s0">&quot;in statistics or machine learning to reduce the influence of outliers.\n&quot;</span>
    <span class="s0">&quot;Unlike `huber`, `pseudo_huber` is smooth.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Typically, `r` represents residuals, the difference\n&quot;</span>
    <span class="s0">&quot;between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n&quot;</span>
    <span class="s0">&quot;`pseudo_huber` resembles the squared error and for :math:`|r|&gt;\\delta` the\n&quot;</span>
    <span class="s0">&quot;absolute error. This way, the Pseudo-Huber loss often achieves\n&quot;</span>
    <span class="s0">&quot;a fast convergence in model fitting for small residuals like the squared\n&quot;</span>
    <span class="s0">&quot;error loss function and still reduces the influence of outliers\n&quot;</span>
    <span class="s0">&quot;(:math:`|r|&gt;\\delta`) like the absolute error loss. As :math:`\\delta` is\n&quot;</span>
    <span class="s0">&quot;the cutoff between squared and absolute error regimes, it has\n&quot;</span>
    <span class="s0">&quot;to be tuned carefully for each problem. `pseudo_huber` is also\n&quot;</span>
    <span class="s0">&quot;convex, making it suitable for gradient based optimization. [1]_ [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Hartley, Zisserman, \&quot;Multiple View Geometry in Computer Vision\&quot;.\n&quot;</span>
    <span class="s0">&quot;       2003. Cambridge University Press. p. 619\n&quot;</span>
    <span class="s0">&quot;.. [2] Charbonnier et al. \&quot;Deterministic edge-preserving regularization\n&quot;</span>
    <span class="s0">&quot;       in computed imaging\&quot;. 1997. IEEE Trans. Image Processing.\n&quot;</span>
    <span class="s0">&quot;       6 (2): 298 - 311.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Import all necessary modules.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import pseudo_huber, huber\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``delta=1`` at ``r=2``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(1., 2.)\n&quot;</span>
    <span class="s0">&quot;1.2360679774997898\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at ``r=2`` for different `delta` by providing\n&quot;</span>
    <span class="s0">&quot;a list or NumPy array for `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber([1., 2., 4.], 3.)\n&quot;</span>
    <span class="s0">&quot;array([2.16227766, 3.21110255, 4.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``delta=1`` at several points by providing\n&quot;</span>
    <span class="s0">&quot;a list or NumPy array for `r`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(2., np.array([1., 1.5, 3., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([0.47213595, 1.        , 3.21110255, 4.94427191])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be calculated for different `delta` and `r` by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both with compatible shapes for broadcasting.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(r.shape, deltas.shape)\n&quot;</span>
    <span class="s0">&quot;(4,) (3, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(deltas, r)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.41421356,  1.6925824 ,  7.06225775,  9.04987562],\n&quot;</span>
    <span class="s0">&quot;       [ 0.49509757,  2.95084972, 22.16990566, 30.90169944],\n&quot;</span>
    <span class="s0">&quot;       [ 0.49846624,  3.06693762, 27.37435121, 40.08261642]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4, 4, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = [\&quot;dashed\&quot;, \&quot;dotted\&quot;, \&quot;dashdot\&quot;]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for delta, style in combined_plot_parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, pseudo_huber(delta, x), label=rf\&quot;$\\delta={delta}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Pseudo-Huber loss function $h_{\\delta}(x)$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-4, 4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 8)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finally, illustrate the difference between `huber` and `pseudo_huber` by\n&quot;</span>
    <span class="s0">&quot;plotting them and their gradients with respect to `r`. The plot shows\n&quot;</span>
    <span class="s0">&quot;that `pseudo_huber` is continuously differentiable while `huber` is not\n&quot;</span>
    <span class="s0">&quot;at the points :math:`\\pm\\delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def huber_grad(delta, x):\n&quot;</span>
    <span class="s0">&quot;...     grad = np.copy(x)\n&quot;</span>
    <span class="s0">&quot;...     linear_area = np.argwhere(np.abs(x) &gt; delta)\n&quot;</span>
    <span class="s0">&quot;...     grad[linear_area]=delta*np.sign(x[linear_area])\n&quot;</span>
    <span class="s0">&quot;...     return grad\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def pseudo_huber_grad(delta, x):\n&quot;</span>
    <span class="s0">&quot;...     return x* (1+(x/delta)**2)**(-0.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x=np.linspace(-3, 3, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; delta = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(7, 7))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, huber(delta, x), label=\&quot;Huber\&quot;, ls=\&quot;dashed\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, huber_grad(delta, x), label=\&quot;Huber Gradient\&quot;, ls=\&quot;dashdot\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, pseudo_huber(delta, x), label=\&quot;Pseudo-Huber\&quot;, ls=\&quot;dotted\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, pseudo_huber_grad(delta, x), label=\&quot;Pseudo-Huber Gradient\&quot;,\n&quot;</span>
    <span class="s0">&quot;...         ls=\&quot;solid\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_pseudo_huber_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pseudo_huber_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pseudo_huber_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*0] = &lt;void*&gt;_func_pseudo_huber</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pseudo_huber&quot;)</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*1] = &lt;void*&gt;_func_pseudo_huber</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pseudo_huber&quot;)</span>
<span class="s0">ufunc_pseudo_huber_data[0] = &amp;ufunc_pseudo_huber_ptr[2*0]</span>
<span class="s0">ufunc_pseudo_huber_data[1] = &amp;ufunc_pseudo_huber_ptr[2*1]</span>
<span class="s0">pseudo_huber = np.PyUFunc_FromFuncAndData(ufunc_pseudo_huber_loops, ufunc_pseudo_huber_data, ufunc_pseudo_huber_types, 2, 2, 1, 0, &quot;pseudo_huber&quot;, ufunc_pseudo_huber_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_radian_loops[2]</span>
<span class="s0">cdef void *ufunc_radian_ptr[4]</span>
<span class="s0">cdef void *ufunc_radian_data[2]</span>
<span class="s0">cdef char ufunc_radian_types[8]</span>
<span class="s0">cdef char *ufunc_radian_doc = (</span>
    <span class="s0">&quot;radian(d, m, s, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Convert from degrees to radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the angle given in (d)egrees, (m)inutes, and (s)econds in\n&quot;</span>
    <span class="s0">&quot;radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;d : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Minutes, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;s : array_like\n&quot;</span>
    <span class="s0">&quot;    Seconds, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inputs in radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;There are many ways to specify an angle.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(90, 0, 0)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(0, 60 * 90, 0)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(0, 0, 60**2 * 90)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The inputs can be real-valued.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(1.5, 0, 0)\n&quot;</span>
    <span class="s0">&quot;0.02617993877991494\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(1, 30, 0)\n&quot;</span>
    <span class="s0">&quot;0.02617993877991494&quot;)</span>
<span class="s0">ufunc_radian_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_radian_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_radian_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_ptr[2*0] = &lt;void*&gt;_func_cephes_radian</span>
<span class="s0">ufunc_radian_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;radian&quot;)</span>
<span class="s0">ufunc_radian_ptr[2*1] = &lt;void*&gt;_func_cephes_radian</span>
<span class="s0">ufunc_radian_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;radian&quot;)</span>
<span class="s0">ufunc_radian_data[0] = &amp;ufunc_radian_ptr[2*0]</span>
<span class="s0">ufunc_radian_data[1] = &amp;ufunc_radian_ptr[2*1]</span>
<span class="s0">radian = np.PyUFunc_FromFuncAndData(ufunc_radian_loops, ufunc_radian_data, ufunc_radian_types, 2, 3, 1, 0, &quot;radian&quot;, ufunc_radian_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_rel_entr_loops[2]</span>
<span class="s0">cdef void *ufunc_rel_entr_ptr[4]</span>
<span class="s0">cdef void *ufunc_rel_entr_data[2]</span>
<span class="s0">cdef char ufunc_rel_entr_types[6]</span>
<span class="s0">cdef char *ufunc_rel_entr_doc = (</span>
    <span class="s0">&quot;rel_entr(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing relative entropy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{rel\\_entr}(x, y) =\n&quot;</span>
    <span class="s0">&quot;        \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;            x \\log(x / y) &amp; x &gt; 0, y &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;            0 &amp; x = 0, y \\ge 0 \\\\\n&quot;</span>
    <span class="s0">&quot;            \\infty &amp; \\text{otherwise}\n&quot;</span>
    <span class="s0">&quot;        \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Input arrays\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Relative entropy of the inputs\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;entr, kl_div, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is jointly convex in x and y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see\n&quot;</span>
    <span class="s0">&quot;[1]_. Given two discrete probability distributions :math:`p_1,\n&quot;</span>
    <span class="s0">&quot;\\ldots, p_n` and :math:`q_1, \\ldots, q_n`, the definition of relative\n&quot;</span>
    <span class="s0">&quot;entropy in the context of *information theory* is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\sum_{i = 1}^n \\mathrm{rel\\_entr}(p_i, q_i).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;To compute the latter quantity, use `scipy.stats.entropy`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [2]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`\n&quot;</span>
    <span class="s0">&quot;.. [2] Kullback-Leibler divergence,\n&quot;</span>
    <span class="s0">&quot;       https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;)</span>
<span class="s0">ufunc_rel_entr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_rel_entr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_rel_entr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_ptr[2*0] = &lt;void*&gt;_func_rel_entr</span>
<span class="s0">ufunc_rel_entr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rel_entr&quot;)</span>
<span class="s0">ufunc_rel_entr_ptr[2*1] = &lt;void*&gt;_func_rel_entr</span>
<span class="s0">ufunc_rel_entr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rel_entr&quot;)</span>
<span class="s0">ufunc_rel_entr_data[0] = &amp;ufunc_rel_entr_ptr[2*0]</span>
<span class="s0">ufunc_rel_entr_data[1] = &amp;ufunc_rel_entr_ptr[2*1]</span>
<span class="s0">rel_entr = np.PyUFunc_FromFuncAndData(ufunc_rel_entr_loops, ufunc_rel_entr_data, ufunc_rel_entr_types, 2, 2, 1, 0, &quot;rel_entr&quot;, ufunc_rel_entr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_round_loops[2]</span>
<span class="s0">cdef void *ufunc_round_ptr[4]</span>
<span class="s0">cdef void *ufunc_round_data[2]</span>
<span class="s0">cdef char ufunc_round_types[4]</span>
<span class="s0">cdef char *ufunc_round_doc = (</span>
    <span class="s0">&quot;round(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Round to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the nearest integer to `x`.  If `x` ends in 0.5 exactly,\n&quot;</span>
    <span class="s0">&quot;the nearest even integer is chosen.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real valued input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The nearest integers to the elements of `x`. The result is of\n&quot;</span>
    <span class="s0">&quot;    floating type, not integer type.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It rounds to even.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.round([0.5, 1.5])\n&quot;</span>
    <span class="s0">&quot;array([0., 2.])&quot;)</span>
<span class="s0">ufunc_round_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_round_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_round_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_round_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_round_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_round_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_round_ptr[2*0] = &lt;void*&gt;_func_cephes_round</span>
<span class="s0">ufunc_round_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;round&quot;)</span>
<span class="s0">ufunc_round_ptr[2*1] = &lt;void*&gt;_func_cephes_round</span>
<span class="s0">ufunc_round_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;round&quot;)</span>
<span class="s0">ufunc_round_data[0] = &amp;ufunc_round_ptr[2*0]</span>
<span class="s0">ufunc_round_data[1] = &amp;ufunc_round_ptr[2*1]</span>
<span class="s0">round = np.PyUFunc_FromFuncAndData(ufunc_round_loops, ufunc_round_data, ufunc_round_types, 2, 1, 1, 0, &quot;round&quot;, ufunc_round_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_shichi_loops[4]</span>
<span class="s0">cdef void *ufunc_shichi_ptr[8]</span>
<span class="s0">cdef void *ufunc_shichi_data[4]</span>
<span class="s0">cdef char ufunc_shichi_types[12]</span>
<span class="s0">cdef char *ufunc_shichi_doc = (</span>
    <span class="s0">&quot;shichi(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Hyperbolic sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The hyperbolic sine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\int_0^x \\frac{\\sinh{t}}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the hyperbolic cosine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\gamma + \\log(x) + \\int_0^x \\frac{\\cosh{t} - 1}{t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n&quot;</span>
    <span class="s0">&quot;principal branch of the logarithm [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex points at which to compute the hyperbolic sine\n&quot;</span>
    <span class="s0">&quot;    and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;si : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Hyperbolic sine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;ci : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Hyperbolic cosine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sici : Sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;exp1 : Exponential integral E1.\n&quot;</span>
    <span class="s0">&quot;expi : Exponential integral Ei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For real arguments with ``x &lt; 0``, ``chi`` is the real part of the\n&quot;</span>
    <span class="s0">&quot;hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x\n&quot;</span>
    <span class="s0">&quot;+ 0j)`` differ by a factor of ``1j*pi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments the function is computed by calling Cephes'\n&quot;</span>
    <span class="s0">&quot;[2]_ *shichi* routine. For complex arguments the algorithm is based\n&quot;</span>
    <span class="s0">&quot;on Mpmath's [3]_ *shi* and *chi* routines.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;       (See Section 5.2.)\n&quot;</span>
    <span class="s0">&quot;.. [2] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [3] Fredrik Johansson and others.\n&quot;</span>
    <span class="s0">&quot;       \&quot;mpmath: a Python library for arbitrary-precision floating-point\n&quot;</span>
    <span class="s0">&quot;       arithmetic\&quot; (Version 0.19) http://mpmath.org/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import shichi, sici\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`shichi` accepts real or complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shichi(0.5)\n&quot;</span>
    <span class="s0">&quot;(0.5069967498196671, -0.05277684495649357)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shichi(0.5 + 2.5j)\n&quot;</span>
    <span class="s0">&quot;((0.11772029666668238+1.831091777729851j),\n&quot;</span>
    <span class="s0">&quot; (0.29912435887648825+1.7395351121166562j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The hyperbolic sine and cosine integrals Shi(z) and Chi(z) are\n&quot;</span>
    <span class="s0">&quot;related to the sine and cosine integrals Si(z) and Ci(z) by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* Shi(z) = -i*Si(i*z)\n&quot;</span>
    <span class="s0">&quot;* Chi(z) = Ci(-i*z) + i*pi/2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.25 + 5j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, chi = shichi(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, -1j*sici(1j*z)[0]            # Should be the same.\n&quot;</span>
    <span class="s0">&quot;((-0.04834719325101729+1.5469354086921228j),\n&quot;</span>
    <span class="s0">&quot; (-0.04834719325101729+1.5469354086921228j))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; chi, sici(-1j*z)[1] + 1j*np.pi/2  # Should be the same.\n&quot;</span>
    <span class="s0">&quot;((-0.19568708973868087+1.556276312103824j),\n&quot;</span>
    <span class="s0">&quot; (-0.19568708973868087+1.556276312103824j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions evaluated on the real axis:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xp = np.geomspace(1e-8, 4.0, 250)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.concatenate((-xp[::-1], xp))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, chi = shichi(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, shi, label='Shi(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, chi, '--', label='Chi(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('Hyperbolic Sine and Cosine Integrals')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='lower right')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_shichi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_shichi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_shichi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_shichi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_shichi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_ptr[2*0] = &lt;void*&gt;_func_cephes_shichi_wrap</span>
<span class="s0">ufunc_shichi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*1] = &lt;void*&gt;_func_cephes_shichi_wrap</span>
<span class="s0">ufunc_shichi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*2] = &lt;void*&gt;_func_cshichi</span>
<span class="s0">ufunc_shichi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*3] = &lt;void*&gt;_func_cshichi</span>
<span class="s0">ufunc_shichi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_data[0] = &amp;ufunc_shichi_ptr[2*0]</span>
<span class="s0">ufunc_shichi_data[1] = &amp;ufunc_shichi_ptr[2*1]</span>
<span class="s0">ufunc_shichi_data[2] = &amp;ufunc_shichi_ptr[2*2]</span>
<span class="s0">ufunc_shichi_data[3] = &amp;ufunc_shichi_ptr[2*3]</span>
<span class="s0">shichi = np.PyUFunc_FromFuncAndData(ufunc_shichi_loops, ufunc_shichi_data, ufunc_shichi_types, 4, 1, 2, 0, &quot;shichi&quot;, ufunc_shichi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_sici_loops[4]</span>
<span class="s0">cdef void *ufunc_sici_ptr[8]</span>
<span class="s0">cdef void *ufunc_sici_data[4]</span>
<span class="s0">cdef char ufunc_sici_types[12]</span>
<span class="s0">cdef char *ufunc_sici_doc = (</span>
    <span class="s0">&quot;sici(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The sine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\int_0^x \\frac{\\sin{t}}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the cosine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\gamma + \\log(x) + \\int_0^x \\frac{\\cos{t} - 1}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n&quot;</span>
    <span class="s0">&quot;principal branch of the logarithm [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex points at which to compute the sine and cosine\n&quot;</span>
    <span class="s0">&quot;    integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;si : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;ci : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cosine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;shichi : Hyperbolic sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;exp1 : Exponential integral E1.\n&quot;</span>
    <span class="s0">&quot;expi : Exponential integral Ei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For real arguments with ``x &lt; 0``, ``ci`` is the real part of the\n&quot;</span>
    <span class="s0">&quot;cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)``\n&quot;</span>
    <span class="s0">&quot;differ by a factor of ``1j*pi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments the function is computed by calling Cephes'\n&quot;</span>
    <span class="s0">&quot;[2]_ *sici* routine. For complex arguments the algorithm is based\n&quot;</span>
    <span class="s0">&quot;on Mpmath's [3]_ *si* and *ci* routines.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;       (See Section 5.2.)\n&quot;</span>
    <span class="s0">&quot;.. [2] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [3] Fredrik Johansson and others.\n&quot;</span>
    <span class="s0">&quot;       \&quot;mpmath: a Python library for arbitrary-precision floating-point\n&quot;</span>
    <span class="s0">&quot;       arithmetic\&quot; (Version 0.19) http://mpmath.org/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import sici, exp1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`sici` accepts real or complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(2.5)\n&quot;</span>
    <span class="s0">&quot;(1.7785201734438267, 0.2858711963653835)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(2.5 + 3j)\n&quot;</span>
    <span class="s0">&quot;((4.505735874563953+0.06863305018999577j),\n&quot;</span>
    <span class="s0">&quot;(0.0793644206906966-2.935510262937543j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For z in the right half plane, the sine and cosine integrals are\n&quot;</span>
    <span class="s0">&quot;related to the exponential integral E1 (implemented in SciPy as\n&quot;</span>
    <span class="s0">&quot;`scipy.special.exp1`) by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* Si(z) = (E1(i*z) - E1(-i*z))/2i + pi/2\n&quot;</span>
    <span class="s0">&quot;* Ci(z) = -(E1(i*z) + E1(-i*z))/2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [1]_ (equations 5.2.21 and 5.2.23).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can verify these relations:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 2 - 3j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(z)\n&quot;</span>
    <span class="s0">&quot;((4.54751388956229-1.3991965806460565j),\n&quot;</span>
    <span class="s0">&quot;(1.408292501520851+2.9836177420296055j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (exp1(1j*z) - exp1(-1j*z))/2j + np.pi/2  # Same as sine integral\n&quot;</span>
    <span class="s0">&quot;(4.54751388956229-1.3991965806460565j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; -(exp1(1j*z) + exp1(-1j*z))/2            # Same as cosine integral\n&quot;</span>
    <span class="s0">&quot;(1.408292501520851+2.9836177420296055j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions evaluated on the real axis; the dotted horizontal\n&quot;</span>
    <span class="s0">&quot;lines are at pi/2 and -pi/2:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-16, 16, 150)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; si, ci = sici(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, si, label='Si(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ci, '--', label='Ci(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='upper left')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('Sine and Cosine Integrals')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.axhline(np.pi/2, linestyle=':', alpha=0.5, color='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.axhline(-np.pi/2, linestyle=':', alpha=0.5, color='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_sici_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_sici_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_sici_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_sici_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_sici_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_ptr[2*0] = &lt;void*&gt;_func_cephes_sici_wrap</span>
<span class="s0">ufunc_sici_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*1] = &lt;void*&gt;_func_cephes_sici_wrap</span>
<span class="s0">ufunc_sici_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*2] = &lt;void*&gt;_func_csici</span>
<span class="s0">ufunc_sici_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*3] = &lt;void*&gt;_func_csici</span>
<span class="s0">ufunc_sici_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_data[0] = &amp;ufunc_sici_ptr[2*0]</span>
<span class="s0">ufunc_sici_data[1] = &amp;ufunc_sici_ptr[2*1]</span>
<span class="s0">ufunc_sici_data[2] = &amp;ufunc_sici_ptr[2*2]</span>
<span class="s0">ufunc_sici_data[3] = &amp;ufunc_sici_ptr[2*3]</span>
<span class="s0">sici = np.PyUFunc_FromFuncAndData(ufunc_sici_loops, ufunc_sici_data, ufunc_sici_types, 4, 1, 2, 0, &quot;sici&quot;, ufunc_sici_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_sindg_loops[2]</span>
<span class="s0">cdef void *ufunc_sindg_ptr[4]</span>
<span class="s0">cdef void *ufunc_sindg_data[2]</span>
<span class="s0">cdef char ufunc_sindg_types[4]</span>
<span class="s0">cdef char *ufunc_sindg_doc = (</span>
    <span class="s0">&quot;sindg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sine of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sine at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;cosdg, tandg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using sine directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.sindg(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0., -0.,  0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.sin(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 0.0000000e+00,  1.2246468e-16, -2.4492936e-16])&quot;)</span>
<span class="s0">ufunc_sindg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_sindg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_sindg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sindg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sindg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sindg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sindg_ptr[2*0] = &lt;void*&gt;_func_cephes_sindg</span>
<span class="s0">ufunc_sindg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sindg&quot;)</span>
<span class="s0">ufunc_sindg_ptr[2*1] = &lt;void*&gt;_func_cephes_sindg</span>
<span class="s0">ufunc_sindg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sindg&quot;)</span>
<span class="s0">ufunc_sindg_data[0] = &amp;ufunc_sindg_ptr[2*0]</span>
<span class="s0">ufunc_sindg_data[1] = &amp;ufunc_sindg_ptr[2*1]</span>
<span class="s0">sindg = np.PyUFunc_FromFuncAndData(ufunc_sindg_loops, ufunc_sindg_data, ufunc_sindg_types, 2, 1, 1, 0, &quot;sindg&quot;, ufunc_sindg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_smirnov_loops[3]</span>
<span class="s0">cdef void *ufunc_smirnov_ptr[6]</span>
<span class="s0">cdef void *ufunc_smirnov_data[3]</span>
<span class="s0">cdef char ufunc_smirnov_types[9]</span>
<span class="s0">cdef char *ufunc_smirnov_doc = (</span>
    <span class="s0">&quot;smirnov(n, d, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov complementary cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the exact Kolmogorov-Smirnov complementary cumulative\n&quot;</span>
    <span class="s0">&quot;distribution function,(aka the Survival Function) of Dn+ (or Dn-)\n&quot;</span>
    <span class="s0">&quot;for a one-sided test of equality between an empirical and a\n&quot;</span>
    <span class="s0">&quot;theoretical distribution. It is equal to the probability that the\n&quot;</span>
    <span class="s0">&quot;maximum difference between a theoretical distribution and an empirical\n&quot;</span>
    <span class="s0">&quot;one based on `n` samples is greater than d.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;  Number of samples\n&quot;</span>
    <span class="s0">&quot;d : float array_like\n&quot;</span>
    <span class="s0">&quot;  Deviation between the Empirical CDF (ECDF) and the target CDF.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of smirnov(n, d), Prob(Dn+ &gt;= d) (Also Prob(Dn- &gt;= d))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;smirnovi : The Inverse Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.ksone : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;kolmogorov, kolmogi : Functions for the two-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`smirnov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.ksone` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import smirnov\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a\n&quot;</span>
    <span class="s0">&quot;sample of size 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; smirnov(5, [0, 0.5, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([ 1.   ,  0.056,  0.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare a sample of size 5 against N(0, 1), the standard normal\n&quot;</span>
    <span class="s0">&quot;distribution with mean 0 and standard deviation 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`x` is the sample.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([-1.392, -0.135, 0.114, 0.190, 1.82])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; target = norm(0, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs = target.cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs\n&quot;</span>
    <span class="s0">&quot;array([0.0819612 , 0.44630594, 0.5453811 , 0.57534543, 0.9656205 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Construct the empirical CDF and the K-S statistics (Dn+, Dn-, Dn).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = len(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n],\n&quot;</span>
    <span class="s0">&quot;...                        ecdfs[1:] - cdfs])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; with np.printoptions(precision=3):\n&quot;</span>
    <span class="s0">&quot;...    print(cols)\n&quot;</span>
    <span class="s0">&quot;[[-1.392  0.2    0.082  0.082  0.118]\n&quot;</span>
    <span class="s0">&quot; [-0.135  0.4    0.446  0.246 -0.046]\n&quot;</span>
    <span class="s0">&quot; [ 0.114  0.6    0.545  0.145  0.055]\n&quot;</span>
    <span class="s0">&quot; [ 0.19   0.8    0.575 -0.025  0.225]\n&quot;</span>
    <span class="s0">&quot; [ 1.82   1.     0.966  0.166  0.034]]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gaps = cols[:, -2:]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Dnpm = np.max(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(f'Dn-={Dnpm[0]:f}, Dn+={Dnpm[1]:f}')\n&quot;</span>
    <span class="s0">&quot;Dn-=0.246306, Dn+=0.224655\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; probs = smirnov(n, Dnpm)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(f'For a sample of size {n} drawn from N(0, 1):',\n&quot;</span>
    <span class="s0">&quot;...       f' Smirnov n={n}: Prob(Dn- &gt;= {Dnpm[0]:f}) = {probs[0]:.4f}',\n&quot;</span>
    <span class="s0">&quot;...       f' Smirnov n={n}: Prob(Dn+ &gt;= {Dnpm[1]:f}) = {probs[1]:.4f}',\n&quot;</span>
    <span class="s0">&quot;...       sep='\\n')\n&quot;</span>
    <span class="s0">&quot;For a sample of size 5 drawn from N(0, 1):\n&quot;</span>
    <span class="s0">&quot; Smirnov n=5: Prob(Dn- &gt;= 0.246306) = 0.4711\n&quot;</span>
    <span class="s0">&quot; Smirnov n=5: Prob(Dn+ &gt;= 0.224655) = 0.5245\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the empirical CDF and the standard normal CDF.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.step(np.concatenate(([-2.5], x, [2.5])),\n&quot;</span>
    <span class="s0">&quot;...          np.concatenate((ecdfs, [1])),\n&quot;</span>
    <span class="s0">&quot;...          where='post', label='Empirical CDF')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xx = np.linspace(-2.5, 2.5, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(xx, target.cdf(xx), '--', label='CDF for N(0, 1)')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Add vertical lines marking Dn+ and Dn-.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r',\n&quot;</span>
    <span class="s0">&quot;...            alpha=0.5, lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m',\n&quot;</span>
    <span class="s0">&quot;...            alpha=0.5, lw=4)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_smirnov_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_smirnov_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_smirnov_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_smirnov_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_smirnov_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_ptr[2*0] = &lt;void*&gt;_func_cephes_smirnov_wrap</span>
<span class="s0">ufunc_smirnov_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_ptr[2*1] = &lt;void*&gt;_func_smirnov_unsafe</span>
<span class="s0">ufunc_smirnov_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_ptr[2*2] = &lt;void*&gt;_func_smirnov_unsafe</span>
<span class="s0">ufunc_smirnov_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_data[0] = &amp;ufunc_smirnov_ptr[2*0]</span>
<span class="s0">ufunc_smirnov_data[1] = &amp;ufunc_smirnov_ptr[2*1]</span>
<span class="s0">ufunc_smirnov_data[2] = &amp;ufunc_smirnov_ptr[2*2]</span>
<span class="s0">smirnov = np.PyUFunc_FromFuncAndData(ufunc_smirnov_loops, ufunc_smirnov_data, ufunc_smirnov_types, 3, 2, 1, 0, &quot;smirnov&quot;, ufunc_smirnov_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_smirnovi_loops[3]</span>
<span class="s0">cdef void *ufunc_smirnovi_ptr[6]</span>
<span class="s0">cdef void *ufunc_smirnovi_data[3]</span>
<span class="s0">cdef char ufunc_smirnovi_types[9]</span>
<span class="s0">cdef char *ufunc_smirnovi_doc = (</span>
    <span class="s0">&quot;smirnovi(n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `smirnov`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `d` such that ``smirnov(n, d) == p``, the critical value\n&quot;</span>
    <span class="s0">&quot;corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;  Number of samples\n&quot;</span>
    <span class="s0">&quot;p : float array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of smirnovi(n, p), the critical values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;smirnov : The Survival Function (SF) for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.ksone : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;kolmogorov, kolmogi : Functions for the two-sided distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Two-sided Kolmogorov-Smirnov distribution, large n\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`smirnov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.ksone` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import smirnovi, smirnov\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 24\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deviations = [0.1, 0.2, 0.3]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Use `smirnov` to compute the complementary CDF of the Smirnov\n&quot;</span>
    <span class="s0">&quot;distribution for the given number of samples and deviations.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = smirnov(n, deviations)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.58105083, 0.12826832, 0.01032231])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The inverse function ``smirnovi(n, p)`` returns ``deviations``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; smirnovi(n, p)\n&quot;</span>
    <span class="s0">&quot;array([0.1, 0.2, 0.3])&quot;)</span>
<span class="s0">ufunc_smirnovi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_smirnovi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_smirnovi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_smirnovi_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_smirnovi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_ptr[2*0] = &lt;void*&gt;_func_cephes_smirnovi_wrap</span>
<span class="s0">ufunc_smirnovi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_ptr[2*1] = &lt;void*&gt;_func_smirnovi_unsafe</span>
<span class="s0">ufunc_smirnovi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_ptr[2*2] = &lt;void*&gt;_func_smirnovi_unsafe</span>
<span class="s0">ufunc_smirnovi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_data[0] = &amp;ufunc_smirnovi_ptr[2*0]</span>
<span class="s0">ufunc_smirnovi_data[1] = &amp;ufunc_smirnovi_ptr[2*1]</span>
<span class="s0">ufunc_smirnovi_data[2] = &amp;ufunc_smirnovi_ptr[2*2]</span>
<span class="s0">smirnovi = np.PyUFunc_FromFuncAndData(ufunc_smirnovi_loops, ufunc_smirnovi_data, ufunc_smirnovi_types, 3, 2, 1, 0, &quot;smirnovi&quot;, ufunc_smirnovi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_spence_loops[4]</span>
<span class="s0">cdef void *ufunc_spence_ptr[8]</span>
<span class="s0">cdef void *ufunc_spence_data[4]</span>
<span class="s0">cdef char ufunc_spence_types[8]</span>
<span class="s0">cdef char *ufunc_spence_doc = (</span>
    <span class="s0">&quot;spence(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Spence's function, also known as the dilogarithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined to be\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  \\int_1^z \\frac{\\log(t)}{1 - t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for complex :math:`z`, where the contour of integration is taken\n&quot;</span>
    <span class="s0">&quot;to avoid the branch cut of the logarithm. Spence's function is\n&quot;</span>
    <span class="s0">&quot;analytic everywhere except the negative real axis where it has a\n&quot;</span>
    <span class="s0">&quot;branch cut.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate Spence's function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed values of Spence's function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;There is a different convention which defines Spence's function by\n&quot;</span>
    <span class="s0">&quot;the integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  -\\int_0^z \\frac{\\log(1 - t)}{t}dt;\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;this is our ``spence(1 - z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import spence\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is defined for complex inputs:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([1-1j, 1.5+2j, 3j, -10-5j])\n&quot;</span>
    <span class="s0">&quot;array([-0.20561676+0.91596559j, -0.86766909-1.39560134j,\n&quot;</span>
    <span class="s0">&quot;       -0.59422064-2.49129918j, -1.14044398+6.80075924j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For complex inputs on the branch cut, which is the negative real axis,\n&quot;</span>
    <span class="s0">&quot;the function returns the limit for ``z`` with positive imaginary part.\n&quot;</span>
    <span class="s0">&quot;For example, in the following, note the sign change of the imaginary\n&quot;</span>
    <span class="s0">&quot;part of the output for ``z = -2`` and ``z = -2 - 1e-8j``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([-2 + 1e-8j, -2, -2 - 1e-8j])\n&quot;</span>
    <span class="s0">&quot;array([2.32018041-3.45139229j, 2.32018042-3.4513923j ,\n&quot;</span>
    <span class="s0">&quot;       2.32018041+3.45139229j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function returns ``nan`` for real inputs on the branch cut:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence(-1.5)\n&quot;</span>
    <span class="s0">&quot;nan\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify some particular values: ``spence(0) = pi**2/6``,\n&quot;</span>
    <span class="s0">&quot;``spence(1) = 0`` and ``spence(2) = -pi**2/12``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([ 1.64493407,  0.        , -0.82246703])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi**2/6, -np.pi**2/12\n&quot;</span>
    <span class="s0">&quot;(1.6449340668482264, -0.8224670334241132)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the identity::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    spence(z) + spence(1 - z) = pi**2/6 - log(z)*log(1 - z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 3 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence(z) + spence(1 - z)\n&quot;</span>
    <span class="s0">&quot;(-2.6523186143876067+1.8853470951513935j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi**2/6 - np.log(z)*np.log(1 - z)\n&quot;</span>
    <span class="s0">&quot;(-2.652318614387606+1.885347095151394j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for positive real input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 6, 400)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, spence(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('spence(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_spence_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_spence_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_spence_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_spence_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_spence_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_spence_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_spence_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_spence_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_spence_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_spence_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_spence_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_spence_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_spence_ptr[2*0] = &lt;void*&gt;_func_cephes_spence</span>
<span class="s0">ufunc_spence_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*1] = &lt;void*&gt;_func_cephes_spence</span>
<span class="s0">ufunc_spence_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*2] = &lt;void*&gt;_func_cspence</span>
<span class="s0">ufunc_spence_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*3] = &lt;void*&gt;_func_cspence</span>
<span class="s0">ufunc_spence_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_data[0] = &amp;ufunc_spence_ptr[2*0]</span>
<span class="s0">ufunc_spence_data[1] = &amp;ufunc_spence_ptr[2*1]</span>
<span class="s0">ufunc_spence_data[2] = &amp;ufunc_spence_ptr[2*2]</span>
<span class="s0">ufunc_spence_data[3] = &amp;ufunc_spence_ptr[2*3]</span>
<span class="s0">spence = np.PyUFunc_FromFuncAndData(ufunc_spence_loops, ufunc_spence_data, ufunc_spence_types, 4, 1, 1, 0, &quot;spence&quot;, ufunc_spence_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtr_data[2]</span>
<span class="s0">cdef char ufunc_stdtr_types[6]</span>
<span class="s0">cdef char *ufunc_stdtr_doc = (</span>
    <span class="s0">&quot;stdtr(df, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Student t distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\frac{\\Gamma((df+1)/2)}{\\sqrt{\\pi df} \\Gamma(df/2)}\n&quot;</span>
    <span class="s0">&quot;    \\int_{-\\infty}^t (1+x^2/df)^{-(df+1)/2}\\, dx\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Student t CDF at t\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtridf : inverse of stdtr with respect to `df`\n&quot;</span>
    <span class="s0">&quot;stdtrit : inverse of stdtr with respect to `t`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The student t distribution is also available as `scipy.stats.t`.\n&quot;</span>
    <span class="s0">&quot;Calling `stdtr` directly can improve performance compared to the\n&quot;</span>
    <span class="s0">&quot;``cdf`` method of `scipy.stats.t` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``df=3`` at ``t=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr(3, 1)\n&quot;</span>
    <span class="s0">&quot;0.8044988905221148\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters = [(1, \&quot;solid\&quot;), (3, \&quot;dashed\&quot;), (10, \&quot;dotted\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for (df, linestyle) in parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, stdtr(df, x), ls=linestyle, label=f\&quot;$df={df}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Student t distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be computed for several degrees of freedom at the same\n&quot;</span>
    <span class="s0">&quot;time by providing a NumPy array or list for `df`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr([1, 2, 3], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.75      , 0.78867513, 0.80449889])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is possible to calculate the function at several points for several\n&quot;</span>
    <span class="s0">&quot;different degrees of freedom simultaneously by providing arrays for `df`\n&quot;</span>
    <span class="s0">&quot;and `t` with shapes compatible for broadcasting. Compute `stdtr` at\n&quot;</span>
    <span class="s0">&quot;4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; t = np.array([2, 4, 6, 8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs.shape, t.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr(dfs, t)\n&quot;</span>
    <span class="s0">&quot;array([[0.85241638, 0.92202087, 0.94743154, 0.96041658],\n&quot;</span>
    <span class="s0">&quot;       [0.90824829, 0.97140452, 0.98666426, 0.99236596],\n&quot;</span>
    <span class="s0">&quot;       [0.93033702, 0.98599577, 0.99536364, 0.99796171]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The t distribution is also available as `scipy.stats.t`. Calling `stdtr`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.t`. To get the same results, one must use the following\n&quot;</span>
    <span class="s0">&quot;parametrization: ``scipy.stats.t(df).cdf(x) = stdtr(df, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import t\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 3, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr_result = stdtr(df, x)  # this can be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result = t(df).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result == stdtr_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_stdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_ptr[2*0] = &lt;void*&gt;_func_stdtr</span>
<span class="s0">ufunc_stdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtr&quot;)</span>
<span class="s0">ufunc_stdtr_ptr[2*1] = &lt;void*&gt;_func_stdtr</span>
<span class="s0">ufunc_stdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtr&quot;)</span>
<span class="s0">ufunc_stdtr_data[0] = &amp;ufunc_stdtr_ptr[2*0]</span>
<span class="s0">ufunc_stdtr_data[1] = &amp;ufunc_stdtr_ptr[2*1]</span>
<span class="s0">stdtr = np.PyUFunc_FromFuncAndData(ufunc_stdtr_loops, ufunc_stdtr_data, ufunc_stdtr_types, 2, 2, 1, 0, &quot;stdtr&quot;, ufunc_stdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtridf_data[2]</span>
<span class="s0">cdef char ufunc_stdtridf_types[6]</span>
<span class="s0">cdef char *ufunc_stdtridf_doc = (</span>
    <span class="s0">&quot;stdtridf(p, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `stdtr` vs df\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument df such that stdtr(df, t) is equal to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;df : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of `df` such that ``stdtr(df, t) == p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtr : Student t CDF\n&quot;</span>
    <span class="s0">&quot;stdtrit : inverse of stdtr with respect to `t`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : Student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the student t cumulative distribution function for one\n&quot;</span>
    <span class="s0">&quot;parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr, stdtridf\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 5, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = stdtr(df, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9490302605850709\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `stdtridf` recovers the original value for `df` given\n&quot;</span>
    <span class="s0">&quot;the CDF value and `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtridf(cdf_value, x)\n&quot;</span>
    <span class="s0">&quot;5.0&quot;)</span>
<span class="s0">ufunc_stdtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_ptr[2*0] = &lt;void*&gt;_func_stdtridf</span>
<span class="s0">ufunc_stdtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtridf&quot;)</span>
<span class="s0">ufunc_stdtridf_ptr[2*1] = &lt;void*&gt;_func_stdtridf</span>
<span class="s0">ufunc_stdtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtridf&quot;)</span>
<span class="s0">ufunc_stdtridf_data[0] = &amp;ufunc_stdtridf_ptr[2*0]</span>
<span class="s0">ufunc_stdtridf_data[1] = &amp;ufunc_stdtridf_ptr[2*1]</span>
<span class="s0">stdtridf = np.PyUFunc_FromFuncAndData(ufunc_stdtridf_loops, ufunc_stdtridf_data, ufunc_stdtridf_types, 2, 2, 1, 0, &quot;stdtridf&quot;, ufunc_stdtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtrit_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtrit_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtrit_data[2]</span>
<span class="s0">cdef char ufunc_stdtrit_types[6]</span>
<span class="s0">cdef char *ufunc_stdtrit_doc = (</span>
    <span class="s0">&quot;stdtrit(df, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the student t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the student t distribution cumulative\n&quot;</span>
    <span class="s0">&quot;distribution function (CDF), returning `t` such that `stdtr(df, t) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument `t` such that stdtr(df, t) is equal to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of `t` such that ``stdtr(df, t) == p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtr : Student t CDF\n&quot;</span>
    <span class="s0">&quot;stdtridf : inverse of stdtr with respect to `df`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : Student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The student t distribution is also available as `scipy.stats.t`. Calling\n&quot;</span>
    <span class="s0">&quot;`stdtrit` directly can improve performance compared to the ``ppf``\n&quot;</span>
    <span class="s0">&quot;method of `scipy.stats.t` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`stdtrit` represents the inverse of the student t distribution CDF which\n&quot;</span>
    <span class="s0">&quot;is available as `stdtr`. Here, we calculate the CDF for ``df`` at\n&quot;</span>
    <span class="s0">&quot;``x=1``. `stdtrit` then returns ``1`` up to floating point errors\n&quot;</span>
    <span class="s0">&quot;given the same value for `df` and the computed CDF value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr, stdtrit\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = stdtr(df, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit(df, cdf_value)\n&quot;</span>
    <span class="s0">&quot;0.9999999994418539\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters = [(1, \&quot;solid\&quot;), (2, \&quot;dashed\&quot;), (5, \&quot;dotted\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for (df, linestyle) in parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, stdtrit(df, x), ls=linestyle, label=f\&quot;$df={df}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-10, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Student t distribution quantile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be computed for several degrees of freedom at the same\n&quot;</span>
    <span class="s0">&quot;time by providing a NumPy array or list for `df`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit([1, 2, 3], 0.7)\n&quot;</span>
    <span class="s0">&quot;array([0.72654253, 0.6172134 , 0.58438973])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is possible to calculate the function at several points for several\n&quot;</span>
    <span class="s0">&quot;different degrees of freedom simultaneously by providing arrays for `df`\n&quot;</span>
    <span class="s0">&quot;and `p` with shapes compatible for broadcasting. Compute `stdtrit` at\n&quot;</span>
    <span class="s0">&quot;4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.2, 0.4, 0.7, 0.8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit(dfs, p)\n&quot;</span>
    <span class="s0">&quot;array([[-1.37638192, -0.3249197 ,  0.72654253,  1.37638192],\n&quot;</span>
    <span class="s0">&quot;       [-1.06066017, -0.28867513,  0.6172134 ,  1.06066017],\n&quot;</span>
    <span class="s0">&quot;       [-0.97847231, -0.27667066,  0.58438973,  0.97847231]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The t distribution is also available as `scipy.stats.t`. Calling `stdtrit`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``ppf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.t`. To get the same results, one must use the following\n&quot;</span>
    <span class="s0">&quot;parametrization: ``scipy.stats.t(df).ppf(x) = stdtrit(df, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import t\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 3, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit_result = stdtrit(df, x)  # this can be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result = t(df).ppf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result == stdtrit_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_stdtrit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtrit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtrit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_ptr[2*0] = &lt;void*&gt;_func_stdtrit</span>
<span class="s0">ufunc_stdtrit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtrit&quot;)</span>
<span class="s0">ufunc_stdtrit_ptr[2*1] = &lt;void*&gt;_func_stdtrit</span>
<span class="s0">ufunc_stdtrit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtrit&quot;)</span>
<span class="s0">ufunc_stdtrit_data[0] = &amp;ufunc_stdtrit_ptr[2*0]</span>
<span class="s0">ufunc_stdtrit_data[1] = &amp;ufunc_stdtrit_ptr[2*1]</span>
<span class="s0">stdtrit = np.PyUFunc_FromFuncAndData(ufunc_stdtrit_loops, ufunc_stdtrit_data, ufunc_stdtrit_types, 2, 2, 1, 0, &quot;stdtrit&quot;, ufunc_stdtrit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_struve_loops[2]</span>
<span class="s0">cdef void *ufunc_struve_ptr[4]</span>
<span class="s0">cdef void *ufunc_struve_data[2]</span>
<span class="s0">cdef char ufunc_struve_types[6]</span>
<span class="s0">cdef char *ufunc_struve_doc = (</span>
    <span class="s0">&quot;struve(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Return the value of the Struve function of order `v` at `x`.  The Struve\n&quot;</span>
    <span class="s0">&quot;function is defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    H_v(x) = (z/2)^{v + 1} \\sum_{n=0}^\\infty\n&quot;</span>
    <span class="s0">&quot;    \\frac{(-1)^n (z/2)^{2n}}{\\Gamma(n + \\frac{3}{2}) \\Gamma(n + v + \\frac{3}{2})},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the Struve function (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the Struve function (float; must be positive unless `v` is\n&quot;</span>
    <span class="s0">&quot;    an integer).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;H : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Struve function of order `v` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;modstruve: Modified Struve function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Three methods discussed in [1]_ are used to evaluate the Struve function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;- power series\n&quot;</span>
    <span class="s0">&quot;- expansion in Bessel functions (if :math:`|z| &lt; |v| + 20`)\n&quot;</span>
    <span class="s0">&quot;- asymptotic large-z expansion (if :math:`z \\geq 0.7v + 12`)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Rounding errors are estimated based on the largest terms in the sums, and\n&quot;</span>
    <span class="s0">&quot;the result associated with the smallest error is returned.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/11\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function of order 1 at 2.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import struve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(1, 2.)\n&quot;</span>
    <span class="s0">&quot;0.6467637282835622\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function at 2 for orders 1, 2 and 3 by providing\n&quot;</span>
    <span class="s0">&quot;a list for the order parameter `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve([1, 2, 3], 2.)\n&quot;</span>
    <span class="s0">&quot;array([0.64676373, 0.28031806, 0.08363767])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function of order 1 for several points by providing\n&quot;</span>
    <span class="s0">&quot;an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([2., 5., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(1, points)\n&quot;</span>
    <span class="s0">&quot;array([0.64676373, 0.80781195, 0.48811605])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Struve function for several orders at several points by\n&quot;</span>
    <span class="s0">&quot;providing arrays for `v` and `z`. The arrays have to be broadcastable\n&quot;</span>
    <span class="s0">&quot;to the correct shapes.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points.shape, orders.shape\n&quot;</span>
    <span class="s0">&quot;((3,), (3, 1))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[0.64676373, 0.80781195, 0.48811605],\n&quot;</span>
    <span class="s0">&quot;       [0.28031806, 1.56937455, 1.51769363],\n&quot;</span>
    <span class="s0">&quot;       [0.08363767, 1.50872065, 2.98697513]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the Struve functions of order 0 to 3 from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, struve(i, x), label=f'$H_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(ncol=2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-10, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Struve functions $H_{\\nu}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_struve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_struve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_struve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_ptr[2*0] = &lt;void*&gt;_func_cephes_struve_h</span>
<span class="s0">ufunc_struve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;struve&quot;)</span>
<span class="s0">ufunc_struve_ptr[2*1] = &lt;void*&gt;_func_cephes_struve_h</span>
<span class="s0">ufunc_struve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;struve&quot;)</span>
<span class="s0">ufunc_struve_data[0] = &amp;ufunc_struve_ptr[2*0]</span>
<span class="s0">ufunc_struve_data[1] = &amp;ufunc_struve_ptr[2*1]</span>
<span class="s0">struve = np.PyUFunc_FromFuncAndData(ufunc_struve_loops, ufunc_struve_data, ufunc_struve_types, 2, 2, 1, 0, &quot;struve&quot;, ufunc_struve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_tandg_loops[2]</span>
<span class="s0">cdef void *ufunc_tandg_ptr[4]</span>
<span class="s0">cdef void *ufunc_tandg_data[2]</span>
<span class="s0">cdef char ufunc_tandg_types[4]</span>
<span class="s0">cdef char *ufunc_tandg_doc = (</span>
    <span class="s0">&quot;tandg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Tangent of angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Tangent at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, cosdg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using tangent directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.tandg(x)\n&quot;</span>
    <span class="s0">&quot;array([0., 0., 0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.tan(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 0.0000000e+00, -1.2246468e-16, -2.4492936e-16])&quot;)</span>
<span class="s0">ufunc_tandg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_tandg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_tandg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tandg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tandg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tandg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tandg_ptr[2*0] = &lt;void*&gt;_func_cephes_tandg</span>
<span class="s0">ufunc_tandg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tandg&quot;)</span>
<span class="s0">ufunc_tandg_ptr[2*1] = &lt;void*&gt;_func_cephes_tandg</span>
<span class="s0">ufunc_tandg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tandg&quot;)</span>
<span class="s0">ufunc_tandg_data[0] = &amp;ufunc_tandg_ptr[2*0]</span>
<span class="s0">ufunc_tandg_data[1] = &amp;ufunc_tandg_ptr[2*1]</span>
<span class="s0">tandg = np.PyUFunc_FromFuncAndData(ufunc_tandg_loops, ufunc_tandg_data, ufunc_tandg_types, 2, 1, 1, 0, &quot;tandg&quot;, ufunc_tandg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_tklmbda_loops[2]</span>
<span class="s0">cdef void *ufunc_tklmbda_ptr[4]</span>
<span class="s0">cdef void *ufunc_tklmbda_data[2]</span>
<span class="s0">cdef char ufunc_tklmbda_types[6]</span>
<span class="s0">cdef char *ufunc_tklmbda_doc = (</span>
    <span class="s0">&quot;tklmbda(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the Tukey lambda distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameters\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Tukey lambda CDF\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;scipy.stats.tukeylambda : Tukey lambda distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import tklmbda, expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the cumulative distribution function (CDF) of the Tukey lambda\n&quot;</span>
    <span class="s0">&quot;distribution at several ``x`` values for `lmbda` = -1.5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x\n&quot;</span>
    <span class="s0">&quot;array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;array([0.34688734, 0.3786554 , 0.41528805, 0.45629737, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.54370263, 0.58471195, 0.6213446 , 0.65311266])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `lmbda` is 0, the function is the logistic sigmoid function,\n&quot;</span>
    <span class="s0">&quot;which is implemented in `scipy.special` as `expit`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, 0)\n&quot;</span>
    <span class="s0">&quot;array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expit(x)\n&quot;</span>
    <span class="s0">&quot;array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `lmbda` is 1, the Tukey lambda distribution is uniform on the\n&quot;</span>
    <span class="s0">&quot;interval [-1, 1], so the CDF increases linearly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; t = np.linspace(-1, 1, 9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(t, 1)\n&quot;</span>
    <span class="s0">&quot;array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the following, we generate plots for several values of `lmbda`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The first figure shows graphs for `lmbda` &lt;= 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; styles = ['-', '-.', '--', ':']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-12, 12, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for k, lmbda in enumerate([-1.0, -0.5, 0.0]):\n&quot;</span>
    <span class="s0">&quot;...     y = tklmbda(x, lmbda)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, y, styles[k], label=rf'$\\lambda$ = {lmbda:-4.1f}')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r'tklmbda(x, $\\lambda$)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_label('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The second figure shows graphs for `lmbda` &gt; 0.  The dots in the\n&quot;</span>
    <span class="s0">&quot;graphs show the bounds of the support of the distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4.2, 4.2, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lmbdas = [0.25, 0.5, 1.0, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for k, lmbda in enumerate(lmbdas):\n&quot;</span>
    <span class="s0">&quot;...     y = tklmbda(x, lmbda)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, y, styles[k], label=fr'$\\lambda$ = {lmbda}')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_prop_cycle(None)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for lmbda in lmbdas:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot([-1/lmbda, 1/lmbda], [0, 1], '.', ms=8)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r'tklmbda(x, $\\lambda$)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.tight_layout()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The CDF of the Tukey lambda distribution is also implemented as the\n&quot;</span>
    <span class="s0">&quot;``cdf`` method of `scipy.stats.tukeylambda`.  In the following,\n&quot;</span>
    <span class="s0">&quot;``tukeylambda.cdf(x, -0.5)`` and ``tklmbda(x, -0.5)`` compute the\n&quot;</span>
    <span class="s0">&quot;same values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import tukeylambda\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 9)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tukeylambda.cdf(x, -0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, -0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation in ``tukeylambda`` also provides location and scale\n&quot;</span>
    <span class="s0">&quot;parameters, and other methods such as ``pdf()`` (the probability\n&quot;</span>
    <span class="s0">&quot;density function) and ``ppf()`` (the inverse of the CDF), so for\n&quot;</span>
    <span class="s0">&quot;working with the Tukey lambda distribution, ``tukeylambda`` is more\n&quot;</span>
    <span class="s0">&quot;generally useful.  The primary advantage of ``tklmbda`` is that it is\n&quot;</span>
    <span class="s0">&quot;significantly faster than ``tukeylambda.cdf``.&quot;)</span>
<span class="s0">ufunc_tklmbda_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_tklmbda_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_tklmbda_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_ptr[2*0] = &lt;void*&gt;_func_cephes_tukeylambdacdf</span>
<span class="s0">ufunc_tklmbda_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tklmbda&quot;)</span>
<span class="s0">ufunc_tklmbda_ptr[2*1] = &lt;void*&gt;_func_cephes_tukeylambdacdf</span>
<span class="s0">ufunc_tklmbda_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tklmbda&quot;)</span>
<span class="s0">ufunc_tklmbda_data[0] = &amp;ufunc_tklmbda_ptr[2*0]</span>
<span class="s0">ufunc_tklmbda_data[1] = &amp;ufunc_tklmbda_ptr[2*1]</span>
<span class="s0">tklmbda = np.PyUFunc_FromFuncAndData(ufunc_tklmbda_loops, ufunc_tklmbda_data, ufunc_tklmbda_types, 2, 2, 1, 0, &quot;tklmbda&quot;, ufunc_tklmbda_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_voigt_profile_loops[2]</span>
<span class="s0">cdef void *ufunc_voigt_profile_ptr[4]</span>
<span class="s0">cdef void *ufunc_voigt_profile_data[2]</span>
<span class="s0">cdef char ufunc_voigt_profile_types[8]</span>
<span class="s0">cdef char *ufunc_voigt_profile_doc = (</span>
    <span class="s0">&quot;voigt_profile(x, sigma, gamma, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Voigt profile.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Voigt profile is a convolution of a 1-D Normal distribution with\n&quot;</span>
    <span class="s0">&quot;standard deviation ``sigma`` and a 1-D Cauchy distribution with half-width at\n&quot;</span>
    <span class="s0">&quot;half-maximum ``gamma``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If ``sigma = 0``, PDF of Cauchy distribution is returned.\n&quot;</span>
    <span class="s0">&quot;Conversely, if ``gamma = 0``, PDF of Normal distribution is returned.\n&quot;</span>
    <span class="s0">&quot;If ``sigma = gamma = 0``, the return value is ``Inf`` for ``x = 0``,\n&quot;</span>
    <span class="s0">&quot;and ``0`` for all other ``x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;sigma : array_like\n&quot;</span>
    <span class="s0">&quot;    The standard deviation of the Normal distribution part\n&quot;</span>
    <span class="s0">&quot;gamma : array_like\n&quot;</span>
    <span class="s0">&quot;    The half-width at half-maximum of the Cauchy distribution part\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The Voigt profile at the given arguments\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;wofz : Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: V(x; \\sigma, \\gamma) = \\frac{Re[w(z)]}{\\sigma\\sqrt{2\\pi}},\n&quot;</span>
    <span class="s0">&quot;.. math:: z = \\frac{x + i\\gamma}{\\sqrt{2}\\sigma}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`w(z)` is the Faddeeva function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Voigt_profile\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at point 2 for ``sigma=1`` and ``gamma=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import voigt_profile\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt_profile(2, 1., 1.)\n&quot;</span>
    <span class="s0">&quot;0.09071519942627544\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array\n&quot;</span>
    <span class="s0">&quot;for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; values = np.array([-2., 0., 5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt_profile(values, 1., 1.)\n&quot;</span>
    <span class="s0">&quot;array([0.0907152 , 0.20870928, 0.01388492])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10, 10, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = [(1.5, 0., \&quot;solid\&quot;), (1.3, 0.5, \&quot;dashed\&quot;),\n&quot;</span>
    <span class="s0">&quot;...                    (0., 1.8, \&quot;dotted\&quot;), (1., 1., \&quot;dashdot\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for params in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     sigma, gamma, linestyle = params\n&quot;</span>
    <span class="s0">&quot;...     voigt = voigt_profile(x, sigma, gamma)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, voigt, label=rf\&quot;$\\sigma={sigma},\\, \\gamma={gamma}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=linestyle)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify visually that the Voigt profile indeed arises as the convolution\n&quot;</span>
    <span class="s0">&quot;of a normal and a Cauchy distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.signal import convolve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, dx = np.linspace(-10, 10, 500, retstep=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def gaussian(x, sigma):\n&quot;</span>
    <span class="s0">&quot;...     return np.exp(-0.5 * x**2/sigma**2)/(sigma * np.sqrt(2*np.pi))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def cauchy(x, gamma):\n&quot;</span>
    <span class="s0">&quot;...     return gamma/(np.pi * (np.square(x)+gamma**2))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sigma = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gauss_profile = gaussian(x, sigma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cauchy_profile = cauchy(x, gamma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; convolved = dx * convolve(cauchy_profile, gauss_profile, mode=\&quot;same\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt = voigt_profile(x, sigma, gamma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, gauss_profile, label=\&quot;Gauss: $G$\&quot;, c='b')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, cauchy_profile, label=\&quot;Cauchy: $C$\&quot;, c='y', ls=\&quot;dashed\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xx = 0.5*(x[1:] + x[:-1])  # midpoints\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(xx, convolved[1:], label=\&quot;Convolution: $G * C$\&quot;, ls='dashdot',\n&quot;</span>
    <span class="s0">&quot;...         c='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, voigt, label=\&quot;Voigt\&quot;, ls='dotted', c='r')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_voigt_profile_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_voigt_profile_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_voigt_profile_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile</span>
<span class="s0">ufunc_voigt_profile_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;voigt_profile&quot;)</span>
<span class="s0">ufunc_voigt_profile_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile</span>
<span class="s0">ufunc_voigt_profile_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;voigt_profile&quot;)</span>
<span class="s0">ufunc_voigt_profile_data[0] = &amp;ufunc_voigt_profile_ptr[2*0]</span>
<span class="s0">ufunc_voigt_profile_data[1] = &amp;ufunc_voigt_profile_ptr[2*1]</span>
<span class="s0">voigt_profile = np.PyUFunc_FromFuncAndData(ufunc_voigt_profile_loops, ufunc_voigt_profile_data, ufunc_voigt_profile_types, 2, 3, 1, 0, &quot;voigt_profile&quot;, ufunc_voigt_profile_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_wofz_loops[2]</span>
<span class="s0">cdef void *ufunc_wofz_ptr[4]</span>
<span class="s0">cdef void *ufunc_wofz_data[2]</span>
<span class="s0">cdef char ufunc_wofz_types[4]</span>
<span class="s0">cdef char *ufunc_wofz_doc = (</span>
    <span class="s0">&quot;wofz(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the value of the Faddeeva function for complex argument::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    exp(-z**2) * erfc(-i*z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    complex argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;dawsn, erf, erfc, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = special.wofz(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, z.real, label='wofz(x).real')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, z.imag, label='wofz(x).imag')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid(alpha=0.25)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_wofz_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_wofz_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_wofz_types[0] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wofz_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wofz_types[2] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wofz_types[3] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wofz_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_w</span>
<span class="s0">ufunc_wofz_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wofz&quot;)</span>
<span class="s0">ufunc_wofz_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_w</span>
<span class="s0">ufunc_wofz_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wofz&quot;)</span>
<span class="s0">ufunc_wofz_data[0] = &amp;ufunc_wofz_ptr[2*0]</span>
<span class="s0">ufunc_wofz_data[1] = &amp;ufunc_wofz_ptr[2*1]</span>
<span class="s0">wofz = np.PyUFunc_FromFuncAndData(ufunc_wofz_loops, ufunc_wofz_data, ufunc_wofz_types, 2, 1, 1, 0, &quot;wofz&quot;, ufunc_wofz_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_wrightomega_loops[4]</span>
<span class="s0">cdef void *ufunc_wrightomega_ptr[8]</span>
<span class="s0">cdef void *ufunc_wrightomega_data[4]</span>
<span class="s0">cdef char ufunc_wrightomega_types[8]</span>
<span class="s0">cdef char *ufunc_wrightomega_doc = (</span>
    <span class="s0">&quot;wrightomega(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wright Omega function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as the solution to\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\omega + \\log(\\omega) = z\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\log` is the principal branch of the complex logarithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Wright Omega function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;omega : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Wright Omega function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;lambertw : The Lambert W function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.19.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can also be defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\omega(z) = W_{K(z)}(e^z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K(z) = \\lceil (\\Im(z) - \\pi)/(2\\pi) \\rceil` is the\n&quot;</span>
    <span class="s0">&quot;unwinding number and :math:`W` is the Lambert W function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation here is taken from [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Lawrence, Corless, and Jeffrey, \&quot;Algorithm 917: Complex\n&quot;</span>
    <span class="s0">&quot;       Double-Precision Evaluation of the Wright :math:`\\omega`\n&quot;</span>
    <span class="s0">&quot;       Function.\&quot; ACM Transactions on Mathematical Software,\n&quot;</span>
    <span class="s0">&quot;       2012. :doi:`10.1145/2168773.2168779`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import wrightomega, lambertw\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega([-2, -1, 0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([0.12002824, 0.27846454, 0.56714329, 1.        , 1.5571456 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(3 + 5j)\n&quot;</span>
    <span class="s0">&quot;(1.5804428632097158+3.8213626783287937j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that ``wrightomega(z)`` satisfies ``w + log(w) = z``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; w = -5 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(w + np.log(w))\n&quot;</span>
    <span class="s0">&quot;(-5+4j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the connection to ``lambertw``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.5 + 3j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(z)\n&quot;</span>
    <span class="s0">&quot;(0.0966015889280649+1.4937828458191993j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lambertw(np.exp(z))\n&quot;</span>
    <span class="s0">&quot;(0.09660158892806493+1.4937828458191993j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.5 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(z)\n&quot;</span>
    <span class="s0">&quot;(-0.3362123489037213+2.282986001579032j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lambertw(np.exp(z), k=1)\n&quot;</span>
    <span class="s0">&quot;(-0.33621234890372115+2.282986001579032j)&quot;)</span>
<span class="s0">ufunc_wrightomega_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_wrightomega_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_wrightomega_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_wrightomega_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_wrightomega_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wrightomega_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wrightomega_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wrightomega_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wrightomega_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wrightomega_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wrightomega_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wrightomega_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wrightomega_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega_real</span>
<span class="s0">ufunc_wrightomega_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega_real</span>
<span class="s0">ufunc_wrightomega_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega</span>
<span class="s0">ufunc_wrightomega_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega</span>
<span class="s0">ufunc_wrightomega_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_data[0] = &amp;ufunc_wrightomega_ptr[2*0]</span>
<span class="s0">ufunc_wrightomega_data[1] = &amp;ufunc_wrightomega_ptr[2*1]</span>
<span class="s0">ufunc_wrightomega_data[2] = &amp;ufunc_wrightomega_ptr[2*2]</span>
<span class="s0">ufunc_wrightomega_data[3] = &amp;ufunc_wrightomega_ptr[2*3]</span>
<span class="s0">wrightomega = np.PyUFunc_FromFuncAndData(ufunc_wrightomega_loops, ufunc_wrightomega_data, ufunc_wrightomega_types, 4, 1, 1, 0, &quot;wrightomega&quot;, ufunc_wrightomega_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_xlog1py_loops[4]</span>
<span class="s0">cdef void *ufunc_xlog1py_ptr[8]</span>
<span class="s0">cdef void *ufunc_xlog1py_data[4]</span>
<span class="s0">cdef char ufunc_xlog1py_types[12]</span>
<span class="s0">cdef char *ufunc_xlog1py_doc = (</span>
    <span class="s0">&quot;xlog1py(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Multiplier\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;z : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed x*log1p(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.13.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;This example shows how the function can be used to calculate the log of\n&quot;</span>
    <span class="s0">&quot;the probability mass function for a geometric discrete random variable.\n&quot;</span>
    <span class="s0">&quot;The probability mass function of the geometric distribution is defined\n&quot;</span>
    <span class="s0">&quot;as follows:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: f(k) = (1-p)^{k-1} p\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`p` is the probability of a single success\n&quot;</span>
    <span class="s0">&quot;and :math:`1-p` is the probability of a single failure\n&quot;</span>
    <span class="s0">&quot;and :math:`k` is the number of trials to get the first success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import xlog1py\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = 100\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _pmf = np.power(1 - p, k - 1) * p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _pmf\n&quot;</span>
    <span class="s0">&quot;7.888609052210118e-31\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If we take k as a relatively large number the value of the probability\n&quot;</span>
    <span class="s0">&quot;mass function can become very low. In such cases taking the log of the\n&quot;</span>
    <span class="s0">&quot;pmf would be more suitable as the log function can change the values\n&quot;</span>
    <span class="s0">&quot;to a scale that is more appropriate to work with.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _log_pmf = xlog1py(k - 1, -p) + np.log(p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _log_pmf\n&quot;</span>
    <span class="s0">&quot;-69.31471805599453\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can confirm that we get a value close to the original pmf value by\n&quot;</span>
    <span class="s0">&quot;taking the exponential of the log pmf.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _orig_pmf = np.exp(_log_pmf)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.isclose(_pmf, _orig_pmf)\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_xlog1py_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_xlog1py_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_xlog1py_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_xlog1py_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_xlog1py_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_ptr[2*0] = &lt;void*&gt;_func_xlog1py[double]</span>
<span class="s0">ufunc_xlog1py_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*1] = &lt;void*&gt;_func_xlog1py[double]</span>
<span class="s0">ufunc_xlog1py_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*2] = &lt;void*&gt;_func_xlog1py[double_complex]</span>
<span class="s0">ufunc_xlog1py_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*3] = &lt;void*&gt;_func_xlog1py[double_complex]</span>
<span class="s0">ufunc_xlog1py_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_data[0] = &amp;ufunc_xlog1py_ptr[2*0]</span>
<span class="s0">ufunc_xlog1py_data[1] = &amp;ufunc_xlog1py_ptr[2*1]</span>
<span class="s0">ufunc_xlog1py_data[2] = &amp;ufunc_xlog1py_ptr[2*2]</span>
<span class="s0">ufunc_xlog1py_data[3] = &amp;ufunc_xlog1py_ptr[2*3]</span>
<span class="s0">xlog1py = np.PyUFunc_FromFuncAndData(ufunc_xlog1py_loops, ufunc_xlog1py_data, ufunc_xlog1py_types, 4, 2, 1, 0, &quot;xlog1py&quot;, ufunc_xlog1py_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_xlogy_loops[4]</span>
<span class="s0">cdef void *ufunc_xlogy_ptr[8]</span>
<span class="s0">cdef void *ufunc_xlogy_data[4]</span>
<span class="s0">cdef char ufunc_xlogy_types[12]</span>
<span class="s0">cdef char *ufunc_xlogy_doc = (</span>
    <span class="s0">&quot;xlogy(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``x*log(y)`` so that the result is 0 if ``x = 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Multiplier\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;z : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed x*log(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The log function used in the computation is the natural log.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.13.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;We can use this function to calculate the binary logistic loss also\n&quot;</span>
    <span class="s0">&quot;known as the binary cross entropy. This loss function is used for\n&quot;</span>
    <span class="s0">&quot;binary classification problems and is defined as:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    L = 1/n * \\sum_{i=0}^n -(y_i*log(y\\_pred_i) + (1-y_i)*log(1-y\\_pred_i))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can define the parameters `x` and `y` as y and y_pred respectively.\n&quot;</span>
    <span class="s0">&quot;y is the array of the actual labels which over here can be either 0 or 1.\n&quot;</span>
    <span class="s0">&quot;y_pred is the array of the predicted probabilities with respect to\n&quot;</span>
    <span class="s0">&quot;the positive class (1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import xlogy\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0, 1, 0, 1, 1, 0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y_pred = np.array([0.3, 0.8, 0.4, 0.7, 0.9, 0.2])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = len(y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss = -(xlogy(y, y_pred) + xlogy(1 - y, 1 - y_pred)).sum()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss /= n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss\n&quot;</span>
    <span class="s0">&quot;0.29597052165495025\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;A lower loss is usually better as it indicates that the predictions are\n&quot;</span>
    <span class="s0">&quot;similar to the actual labels. In this example since our predicted\n&quot;</span>
    <span class="s0">&quot;probabilities are close to the actual labels, we get an overall loss\n&quot;</span>
    <span class="s0">&quot;that is reasonably low and appropriate.&quot;)</span>
<span class="s0">ufunc_xlogy_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_xlogy_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_xlogy_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_xlogy_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_xlogy_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_ptr[2*0] = &lt;void*&gt;_func_xlogy[double]</span>
<span class="s0">ufunc_xlogy_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*1] = &lt;void*&gt;_func_xlogy[double]</span>
<span class="s0">ufunc_xlogy_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*2] = &lt;void*&gt;_func_xlogy[double_complex]</span>
<span class="s0">ufunc_xlogy_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*3] = &lt;void*&gt;_func_xlogy[double_complex]</span>
<span class="s0">ufunc_xlogy_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_data[0] = &amp;ufunc_xlogy_ptr[2*0]</span>
<span class="s0">ufunc_xlogy_data[1] = &amp;ufunc_xlogy_ptr[2*1]</span>
<span class="s0">ufunc_xlogy_data[2] = &amp;ufunc_xlogy_ptr[2*2]</span>
<span class="s0">ufunc_xlogy_data[3] = &amp;ufunc_xlogy_ptr[2*3]</span>
<span class="s0">xlogy = np.PyUFunc_FromFuncAndData(ufunc_xlogy_loops, ufunc_xlogy_data, ufunc_xlogy_types, 4, 2, 1, 0, &quot;xlogy&quot;, ufunc_xlogy_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_y0_loops[2]</span>
<span class="s0">cdef void *ufunc_y0_ptr[4]</span>
<span class="s0">cdef void *ufunc_y0_data[2]</span>
<span class="s0">cdef char ufunc_y0_types[4]</span>
<span class="s0">cdef char *ufunc_y0_doc = (</span>
    <span class="s0">&quot;y0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the second kind of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;j0: Bessel function of the first kind of order 0\n&quot;</span>
    <span class="s0">&quot;yv: Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 5] and (5, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a rational approximation :math:`R(x)` is employed to\n&quot;</span>
    <span class="s0">&quot;compute,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Y_0(x) = R(x) + \\frac{2 \\log(x) J_0(x)}{\\pi},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the second interval, the Hankel asymptotic expansion is employed with\n&quot;</span>
    <span class="s0">&quot;two rational functions of degree 6/6 and 7/7.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `y0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import y0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y0(1.)\n&quot;</span>
    <span class="s0">&quot;0.08825696421567697\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y0(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.44451873,  0.51037567,  0.37685001])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = y0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_y0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_y0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_y0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y0_ptr[2*0] = &lt;void*&gt;_func_cephes_y0</span>
<span class="s0">ufunc_y0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y0&quot;)</span>
<span class="s0">ufunc_y0_ptr[2*1] = &lt;void*&gt;_func_cephes_y0</span>
<span class="s0">ufunc_y0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y0&quot;)</span>
<span class="s0">ufunc_y0_data[0] = &amp;ufunc_y0_ptr[2*0]</span>
<span class="s0">ufunc_y0_data[1] = &amp;ufunc_y0_ptr[2*1]</span>
<span class="s0">y0 = np.PyUFunc_FromFuncAndData(ufunc_y0_loops, ufunc_y0_data, ufunc_y0_types, 2, 1, 1, 0, &quot;y0&quot;, ufunc_y0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_y1_loops[2]</span>
<span class="s0">cdef void *ufunc_y1_ptr[4]</span>
<span class="s0">cdef void *ufunc_y1_data[2]</span>
<span class="s0">cdef char ufunc_y1_types[4]</span>
<span class="s0">cdef char *ufunc_y1_doc = (</span>
    <span class="s0">&quot;y1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the second kind of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;j1: Bessel function of the first kind of order 1\n&quot;</span>
    <span class="s0">&quot;yn: Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;yv: Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 8] and (8, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a 25 term Chebyshev expansion is used, and computing\n&quot;</span>
    <span class="s0">&quot;:math:`J_1` (the Bessel function of the first kind) is required. In the\n&quot;</span>
    <span class="s0">&quot;second, the asymptotic trigonometric representation is employed using two\n&quot;</span>
    <span class="s0">&quot;rational functions of degree 5/5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `y1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import y1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y1(1.)\n&quot;</span>
    <span class="s0">&quot;-0.7812128213002888\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y1(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([-1.47147239, -0.10703243,  0.32467442])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = y1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_y1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_y1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_y1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y1_ptr[2*0] = &lt;void*&gt;_func_cephes_y1</span>
<span class="s0">ufunc_y1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y1&quot;)</span>
<span class="s0">ufunc_y1_ptr[2*1] = &lt;void*&gt;_func_cephes_y1</span>
<span class="s0">ufunc_y1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y1&quot;)</span>
<span class="s0">ufunc_y1_data[0] = &amp;ufunc_y1_ptr[2*0]</span>
<span class="s0">ufunc_y1_data[1] = &amp;ufunc_y1_ptr[2*1]</span>
<span class="s0">y1 = np.PyUFunc_FromFuncAndData(ufunc_y1_loops, ufunc_y1_data, ufunc_y1_types, 2, 1, 1, 0, &quot;y1&quot;, ufunc_y1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_yn_loops[3]</span>
<span class="s0">cdef void *ufunc_yn_ptr[6]</span>
<span class="s0">cdef void *ufunc_yn_data[3]</span>
<span class="s0">cdef char ufunc_yn_types[9]</span>
<span class="s0">cdef char *ufunc_yn_doc = (</span>
    <span class="s0">&quot;yn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of integer order and real argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (integer).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function, :math:`Y_n(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;yv : For real order and real or complex argument.\n&quot;</span>
    <span class="s0">&quot;y0: faster implementation of this function for order 0\n&quot;</span>
    <span class="s0">&quot;y1: faster implementation of this function for order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `yn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is evaluated by forward recurrence on `n`, starting with\n&quot;</span>
    <span class="s0">&quot;values computed by the Cephes routines `y0` and `y1`. If `n = 0` or 1,\n&quot;</span>
    <span class="s0">&quot;the routine for `y0` or `y1` is called directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function of order 0 at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import yn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, 1.)\n&quot;</span>
    <span class="s0">&quot;0.08825696421567697\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, 1.), yn(1, 1.), yn(2, 1.)\n&quot;</span>
    <span class="s0">&quot;(0.08825696421567697, -0.7812128213002888, -1.6506826068162546)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The evaluation for different orders can be carried out in one call by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn([0, 1, 2], 1.)\n&quot;</span>
    <span class="s0">&quot;array([ 0.08825696, -0.78121282, -1.65068261])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0.5, 3., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, points)\n&quot;</span>
    <span class="s0">&quot;array([-0.44451873,  0.37685001,  0.22352149])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `z` is an array, the order parameter `v` must be broadcastable to\n&quot;</span>
    <span class="s0">&quot;the correct shape if different orders shall be computed in one call.\n&quot;</span>
    <span class="s0">&quot;To calculate the orders 0 and 1 for an 1D array:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[0], [1]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders.shape\n&quot;</span>
    <span class="s0">&quot;(2, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[-0.44451873,  0.37685001,  0.22352149],\n&quot;</span>
    <span class="s0">&quot;       [-1.47147239,  0.32467442, -0.15806046]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, yn(i, x), label=f'$Y_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-3, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_yn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_pd__As_pd_d</span>
<span class="s0">ufunc_yn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_yn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_yn_types[0] = &lt;char&gt;NPY_INTP</span>
<span class="s0">ufunc_yn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_ptr[2*0] = &lt;void*&gt;_func_cephes_yn_wrap</span>
<span class="s0">ufunc_yn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_ptr[2*1] = &lt;void*&gt;_func_yn_unsafe</span>
<span class="s0">ufunc_yn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_ptr[2*2] = &lt;void*&gt;_func_yn_unsafe</span>
<span class="s0">ufunc_yn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_data[0] = &amp;ufunc_yn_ptr[2*0]</span>
<span class="s0">ufunc_yn_data[1] = &amp;ufunc_yn_ptr[2*1]</span>
<span class="s0">ufunc_yn_data[2] = &amp;ufunc_yn_ptr[2*2]</span>
<span class="s0">yn = np.PyUFunc_FromFuncAndData(ufunc_yn_loops, ufunc_yn_data, ufunc_yn_types, 3, 2, 1, 0, &quot;yn&quot;, ufunc_yn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_zetac_loops[2]</span>
<span class="s0">cdef void *ufunc_zetac_ptr[4]</span>
<span class="s0">cdef void *ufunc_zetac_data[2]</span>
<span class="s0">cdef char ufunc_zetac_types[4]</span>
<span class="s0">cdef char *ufunc_zetac_doc = (</span>
    <span class="s0">&quot;zetac(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Riemann zeta function minus 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\zeta(x) = \\sum_{k=2}^{\\infty} 1 / k^x,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where ``x &gt; 1``.  For ``x &lt; 1`` the analytic continuation is\n&quot;</span>
    <span class="s0">&quot;computed. For more information on the Riemann zeta function, see\n&quot;</span>
    <span class="s0">&quot;[dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Values at which to compute zeta(x) - 1 (must be real).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of zeta(x) - 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;zeta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/25\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import zetac, zeta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Some special values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(2), np.pi**2/6 - 1\n&quot;</span>
    <span class="s0">&quot;(0.64493406684822641, 0.6449340668482264)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(-1), -1.0/12 - 1\n&quot;</span>
    <span class="s0">&quot;(-1.0833333333333333, -1.0833333333333333)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare ``zetac(x)`` to ``zeta(x) - 1`` for large `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(60), zeta(60) - 1\n&quot;</span>
    <span class="s0">&quot;(8.673617380119933e-19, 0.0)&quot;)</span>
<span class="s0">ufunc_zetac_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_zetac_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_zetac_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_zetac_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_zetac_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_zetac_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_zetac_ptr[2*0] = &lt;void*&gt;_func_cephes_zetac</span>
<span class="s0">ufunc_zetac_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;zetac&quot;)</span>
<span class="s0">ufunc_zetac_ptr[2*1] = &lt;void*&gt;_func_cephes_zetac</span>
<span class="s0">ufunc_zetac_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;zetac&quot;)</span>
<span class="s0">ufunc_zetac_data[0] = &amp;ufunc_zetac_ptr[2*0]</span>
<span class="s0">ufunc_zetac_data[1] = &amp;ufunc_zetac_ptr[2*1]</span>
<span class="s0">zetac = np.PyUFunc_FromFuncAndData(ufunc_zetac_loops, ufunc_zetac_data, ufunc_zetac_types, 2, 1, 1, 0, &quot;zetac&quot;, ufunc_zetac_doc, 0)</span>

<span class="s0">from ._special_ufuncs import (_cospi, _lambertw, _scaled_exp1, _sinpi, _spherical_jn, _spherical_jn_d, _spherical_yn, _spherical_yn_d, _spherical_in, _spherical_in_d, _spherical_kn, _spherical_kn_d, airy, airye, bei, beip, ber, berp, binom, exp1, expi, expit, exprel, gamma, gammaln, hankel1, hankel1e, hankel2, hankel2e, hyp2f1, it2i0k0, it2j0y0, it2struve0, itairy, iti0k0, itj0y0, itmodstruve0, itstruve0, iv, _iv_ratio, ive, jv, jve, kei, keip, kelvin, ker, kerp, kv, kve, log_expit, log_wright_bessel, loggamma, logit, mathieu_a, mathieu_b, mathieu_cem, mathieu_modcem1, mathieu_modcem2, mathieu_modsem1, mathieu_modsem2, mathieu_sem, modfresnelm, modfresnelp, obl_ang1, obl_ang1_cv, obl_cv, obl_rad1, obl_rad1_cv, obl_rad2, obl_rad2_cv, pbdv, pbvv, pbwa, pro_ang1, pro_ang1_cv, pro_cv, pro_rad1, pro_rad1_cv, pro_rad2, pro_rad2_cv, psi, rgamma, sph_harm, wright_bessel, yv, yve, _zeta)</span>

<span class="s0">#</span>
<span class="s0"># Aliases</span>
<span class="s0">#</span>
<span class="s0">jn = jv</span>
</pre>
</body>
</html>