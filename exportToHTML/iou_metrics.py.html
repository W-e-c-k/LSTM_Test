<html>
<head>
<title>iou_metrics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
iou_metrics.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">initializers</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">.</span><span class="s1">metric </span><span class="s0">import </span><span class="s1">Metric</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">.</span><span class="s1">metrics_utils </span><span class="s0">import </span><span class="s1">confusion_matrix</span>


<span class="s0">class </span><span class="s1">_IoUBase</span><span class="s2">(</span><span class="s1">Metric</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes the confusion matrix for Intersection-Over-Union metrics. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    From IoUs of individual classes, the MeanIoU can be computed as the mean of 
    the individual IoUs. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Args: 
        num_classes: The possible number of labels the prediction task can have. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            metric computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
            considered. 
        sparse_y_true: Whether labels are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        sparse_y_pred: Whether predictions are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        axis: (Optional) -1 is the dimension containing the logits. 
            Defaults to `-1`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_classes</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s5"># defaulting to float32 to avoid issues with confusion matrix</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype </span><span class="s0">or </span><span class="s6">&quot;float32&quot;</span><span class="s2">)</span>
        <span class="s5"># Metric should be maximized during optimization.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_direction </span><span class="s2">= </span><span class="s6">&quot;up&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes </span><span class="s2">= </span><span class="s1">num_classes</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class </span><span class="s2">= </span><span class="s1">ignore_class</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_true </span><span class="s2">= </span><span class="s1">sparse_y_true</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred </span><span class="s2">= </span><span class="s1">sparse_y_pred</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">add_variable</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s6">&quot;total_confusion_matrix&quot;</span><span class="s2">,</span>
            <span class="s1">shape</span><span class="s2">=(</span><span class="s1">num_classes</span><span class="s2">, </span><span class="s1">num_classes</span><span class="s2">),</span>
            <span class="s1">initializer</span><span class="s2">=</span><span class="s1">initializers</span><span class="s2">.</span><span class="s1">Zeros</span><span class="s2">(),</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">update_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">sample_weight</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Accumulates the confusion matrix statistics. 
 
        Args: 
            y_true: The ground truth values. 
            y_pred: The predicted values. 
            sample_weight: Optional weighting of each example. Can 
                be a `Tensor` whose rank is either 0, or the same as `y_true`, 
                and must be broadcastable to `y_true`. Defaults to `1`. 
 
        Returns: 
            Update op. 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_true</span><span class="s2">:</span>
            <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred</span><span class="s2">:</span>
            <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">)</span>

        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s5"># Flatten the input if its rank &gt; 1.</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, [-</span><span class="s4">1</span><span class="s2">])</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, [-</span><span class="s4">1</span><span class="s2">])</span>

        <span class="s0">if </span><span class="s1">sample_weight </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">sample_weight </span><span class="s2">= </span><span class="s4">1</span>

        <span class="s1">sample_weight </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">sample_weight</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sample_weight</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">sample_weight </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">sample_weight</span><span class="s2">, [-</span><span class="s4">1</span><span class="s2">])</span>

        <span class="s1">sample_weight </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">sample_weight</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">ignore_class </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s2">)</span>
            <span class="s1">valid_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">not_equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">ignore_class</span><span class="s2">)</span>
            <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">y_pred </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">sample_weight </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">sample_weight </span><span class="s2">= </span><span class="s1">sample_weight </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
                    <span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">sample_weight</span><span class="s2">.</span><span class="s1">dtype</span>
                <span class="s2">)</span>

        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">sample_weight </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">sample_weight</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">current_cm </span><span class="s2">= </span><span class="s1">confusion_matrix</span><span class="s2">(</span>
            <span class="s1">y_true</span><span class="s2">,</span>
            <span class="s1">y_pred</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s1">weights</span><span class="s2">=</span><span class="s1">sample_weight</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s6">&quot;float32&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">.</span><span class="s1">assign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm </span><span class="s2">+ </span><span class="s1">current_cm</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">reset_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">.</span><span class="s1">assign</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s6">&quot;keras.metrics.IoU&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">IoU</span><span class="s2">(</span><span class="s1">_IoUBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes the Intersection-Over-Union metric for specific target classes. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Note, this class first computes IoUs for all individual classes, then 
    returns the mean of IoUs for the classes that are specified by 
    `target_class_ids`. If `target_class_ids` has only one id value, the IoU of 
    that specific class is returned. 
 
    Args: 
        num_classes: The possible number of labels the prediction task can have. 
        target_class_ids: A tuple or list of target class ids for which the 
            metric is returned. To compute IoU for a specific class, a list 
            (or tuple) of a single id value should be provided. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            metric computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
              considered. 
        sparse_y_true: Whether labels are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        sparse_y_pred: Whether predictions are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        axis: (Optional) -1 is the dimension containing the logits. 
            Defaults to `-1`. 
 
    Examples: 
 
    &gt;&gt;&gt; # cm = [[1, 1], 
    &gt;&gt;&gt; #        [1, 1]] 
    &gt;&gt;&gt; # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1] 
    &gt;&gt;&gt; # iou = true_positives / (sum_row + sum_col - true_positives)) 
    &gt;&gt;&gt; # iou = [0.33, 0.33] 
    &gt;&gt;&gt; m = keras.metrics.IoU(num_classes=2, target_class_ids=[0]) 
    &gt;&gt;&gt; m.update_state([0, 0, 1, 1], [0, 1, 0, 1]) 
    &gt;&gt;&gt; m.result() 
    0.33333334 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([0, 0, 1, 1], [0, 1, 0, 1], 
    ...                sample_weight=[0.3, 0.3, 0.3, 0.1]) 
    &gt;&gt;&gt; # cm = [[0.3, 0.3], 
    &gt;&gt;&gt; #        [0.3, 0.1]] 
    &gt;&gt;&gt; # sum_row = [0.6, 0.4], sum_col = [0.6, 0.4], 
    &gt;&gt;&gt; # true_positives = [0.3, 0.1] 
    &gt;&gt;&gt; # iou = [0.33, 0.14] 
    &gt;&gt;&gt; m.result() 
    0.33333334 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile( 
        optimizer='sgd', 
        loss='mse', 
        metrics=[keras.metrics.IoU(num_classes=2, target_class_ids=[0])]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_classes</span><span class="s2">,</span>
        <span class="s1">target_class_ids</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">num_classes</span><span class="s2">=</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s1">ignore_class</span><span class="s2">=</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s1">sparse_y_true</span><span class="s2">,</span>
            <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">max</span><span class="s2">(</span><span class="s1">target_class_ids</span><span class="s2">) &gt;= </span><span class="s1">num_classes</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s6">f&quot;Target class id </span><span class="s0">{</span><span class="s1">max</span><span class="s2">(</span><span class="s1">target_class_ids</span><span class="s2">)</span><span class="s0">} </span><span class="s6">&quot;</span>
                <span class="s6">&quot;is out of range, which is &quot;</span>
                <span class="s6">f&quot;[</span><span class="s0">{</span><span class="s4">0</span><span class="s0">}</span><span class="s6">, </span><span class="s0">{</span><span class="s1">num_classes</span><span class="s0">}</span><span class="s6">).&quot;</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_class_ids </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">target_class_ids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Compute the intersection-over-union via the confusion matrix.&quot;&quot;&quot;</span>
        <span class="s1">sum_over_row </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s2">)</span>
        <span class="s1">sum_over_col </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s2">)</span>
        <span class="s1">true_positives </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_cm</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s5"># sum_over_row + sum_over_col =</span>
        <span class="s5">#     2 * true_positives + false_positives + false_negatives.</span>
        <span class="s1">denominator </span><span class="s2">= </span><span class="s1">sum_over_row </span><span class="s2">+ </span><span class="s1">sum_over_col </span><span class="s2">- </span><span class="s1">true_positives</span>

        <span class="s1">target_class_ids </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">target_class_ids</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s6">&quot;int32&quot;</span>
        <span class="s2">)</span>

        <span class="s5"># Only keep the target classes</span>
        <span class="s1">true_positives </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">take_along_axis</span><span class="s2">(</span>
            <span class="s1">true_positives</span><span class="s2">, </span><span class="s1">target_class_ids</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span>
        <span class="s2">)</span>
        <span class="s1">denominator </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">take_along_axis</span><span class="s2">(</span>
            <span class="s1">denominator</span><span class="s2">, </span><span class="s1">target_class_ids</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span>
        <span class="s2">)</span>

        <span class="s5"># If the denominator is 0, we need to ignore the class.</span>
        <span class="s1">num_valid_entries </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">greater</span><span class="s2">(</span><span class="s1">denominator</span><span class="s2">, </span><span class="s4">1e-9</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s1">iou </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">divide</span><span class="s2">(</span><span class="s1">true_positives</span><span class="s2">, </span><span class="s1">denominator </span><span class="s2">+ </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">())</span>

        <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">divide</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">iou</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">), </span><span class="s1">num_valid_entries </span><span class="s2">+ </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">()</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">config </span><span class="s2">= {</span>
            <span class="s6">&quot;num_classes&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s6">&quot;target_class_ids&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s6">&quot;ignore_class&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_true&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_true</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_pred&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s6">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s1">base_config </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">base_config</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()) + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">config</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s6">&quot;keras.metrics.BinaryIoU&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinaryIoU</span><span class="s2">(</span><span class="s1">IoU</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes the Intersection-Over-Union metric for class 0 and/or 1. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    This class can be used to compute IoUs for a binary classification task 
    where the predictions are provided as logits. First a `threshold` is applied 
    to the predicted values such that those that are below the `threshold` are 
    converted to class 0 and those that are above the `threshold` are converted 
    to class 1. 
 
    IoUs for classes 0 and 1 are then computed, the mean of IoUs for the classes 
    that are specified by `target_class_ids` is returned. 
 
    Note: with `threshold=0`, this metric has the same behavior as `IoU`. 
 
    Args: 
        target_class_ids: A tuple or list of target class ids for which the 
            metric is returned. Options are `[0]`, `[1]`, or `[0, 1]`. With 
            `[0]` (or `[1]`), the IoU metric for class 0 (or class 1, 
            respectively) is returned. With `[0, 1]`, the mean of IoUs for the 
            two classes is returned. 
        threshold: A threshold that applies to the prediction logits to convert 
            them to either predicted class 0 if the logit is below `threshold` 
            or predicted class 1 if the logit is above `threshold`. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
 
    Example: 
 
    Example: 
 
    &gt;&gt;&gt; m = keras.metrics.BinaryIoU(target_class_ids=[0, 1], threshold=0.3) 
    &gt;&gt;&gt; m.update_state([0, 1, 0, 1], [0.1, 0.2, 0.4, 0.7]) 
    &gt;&gt;&gt; m.result() 
    0.33333334 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([0, 1, 0, 1], [0.1, 0.2, 0.4, 0.7], 
    ...                sample_weight=[0.2, 0.3, 0.4, 0.1]) 
    &gt;&gt;&gt; # cm = [[0.2, 0.4], 
    &gt;&gt;&gt; #        [0.3, 0.1]] 
    &gt;&gt;&gt; # sum_row = [0.6, 0.4], sum_col = [0.5, 0.5], 
    &gt;&gt;&gt; # true_positives = [0.2, 0.1] 
    &gt;&gt;&gt; # iou = [0.222, 0.125] 
    &gt;&gt;&gt; m.result() 
    0.17361112 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile( 
        optimizer='sgd', 
        loss='mse', 
        metrics=[keras.metrics.BinaryIoU( 
            target_class_ids=[0], 
            threshold=0.5 
        )] 
    ) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">target_class_ids</span><span class="s2">=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">),</span>
        <span class="s1">threshold</span><span class="s2">=</span><span class="s4">0.5</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">num_classes</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
            <span class="s1">target_class_ids</span><span class="s2">=</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">threshold </span><span class="s2">= </span><span class="s1">threshold</span>

    <span class="s0">def </span><span class="s1">update_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">sample_weight</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Accumulates the confusion matrix statistics. 
 
        Before the confusion matrix is updated, the predicted values are 
        thresholded to be: 
            0 for values that are smaller than the `threshold` 
            1 for values that are larger or equal to the `threshold` 
 
        Args: 
            y_true: The ground truth values. 
            y_pred: The predicted values. 
            sample_weight: Optional weighting of each example. Can 
                be a `Tensor` whose rank is either 0, or the same as `y_true`, 
                and must be broadcastable to `y_true`. Defaults to `1`. 
 
        Returns: 
            Update op. 
        &quot;&quot;&quot;</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">update_state</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">sample_weight</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s6">&quot;target_class_ids&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s6">&quot;threshold&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">threshold</span><span class="s2">,</span>
            <span class="s6">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s6">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s6">&quot;keras.metrics.MeanIoU&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MeanIoU</span><span class="s2">(</span><span class="s1">IoU</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes the mean Intersection-Over-Union metric. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    Note that this class first computes IoUs for all individual classes, then 
    returns the mean of these values. 
 
    Args: 
        num_classes: The possible number of labels the prediction task can have. 
            This value must be provided, since a confusion matrix of dimension = 
            [num_classes, num_classes] will be allocated. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            metric computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
            considered. 
        sparse_y_true: Whether labels are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        sparse_y_pred: Whether predictions are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        axis: (Optional) The dimension containing the logits. Defaults to `-1`. 
 
    Example: 
 
    Example: 
 
    &gt;&gt;&gt; # cm = [[1, 1], 
    &gt;&gt;&gt; #        [1, 1]] 
    &gt;&gt;&gt; # sum_row = [2, 2], sum_col = [2, 2], true_positives = [1, 1] 
    &gt;&gt;&gt; # iou = true_positives / (sum_row + sum_col - true_positives)) 
    &gt;&gt;&gt; # result = (1 / (2 + 2 - 1) + 1 / (2 + 2 - 1)) / 2 = 0.33 
    &gt;&gt;&gt; m = keras.metrics.MeanIoU(num_classes=2) 
    &gt;&gt;&gt; m.update_state([0, 0, 1, 1], [0, 1, 0, 1]) 
    &gt;&gt;&gt; m.result() 
    0.33333334 
 
    &gt;&gt;&gt; m.reset_state() 
    &gt;&gt;&gt; m.update_state([0, 0, 1, 1], [0, 1, 0, 1], 
    ...                sample_weight=[0.3, 0.3, 0.3, 0.1]) 
    &gt;&gt;&gt; m.result().numpy() 
    0.23809525 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile( 
        optimizer='sgd', 
        loss='mse', 
        metrics=[keras.metrics.MeanIoU(num_classes=2)]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_classes</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">target_class_ids </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">num_classes</span><span class="s2">))</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">num_classes</span><span class="s2">=</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s1">target_class_ids</span><span class="s2">=</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">ignore_class</span><span class="s2">=</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s1">sparse_y_true</span><span class="s2">,</span>
            <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s6">&quot;num_classes&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s6">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s6">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype</span><span class="s2">,</span>
            <span class="s6">&quot;ignore_class&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_true&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_true</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_pred&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s6">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s6">&quot;keras.metrics.OneHotIoU&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">OneHotIoU</span><span class="s2">(</span><span class="s1">IoU</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes the Intersection-Over-Union metric for one-hot encoded labels. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    This class can be used to compute IoU for multi-class classification tasks 
    where the labels are one-hot encoded (the last axis should have one 
    dimension per class). Note that the predictions should also have the same 
    shape. To compute the IoU, first the labels and predictions are converted 
    back into integer format by taking the argmax over the class axis. Then the 
    same computation steps as for the base `IoU` class apply. 
 
    Note, if there is only one channel in the labels and predictions, this class 
    is the same as class `IoU`. In this case, use `IoU` instead. 
 
    Also, make sure that `num_classes` is equal to the number of classes in the 
    data, to avoid a &quot;labels out of bound&quot; error when the confusion matrix is 
    computed. 
 
    Args: 
        num_classes: The possible number of labels the prediction task can have. 
        target_class_ids: A tuple or list of target class ids for which the 
            metric is returned. To compute IoU for a specific class, a list 
            (or tuple) of a single id value should be provided. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            metric computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
            considered. 
        sparse_y_pred: Whether predictions are encoded using integers or 
            dense floating point vectors. If `False`, the `argmax` function 
            is used to determine each sample's most likely associated label. 
        axis: (Optional) The dimension containing the logits. Defaults to `-1`. 
 
    Example: 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]]) 
    &gt;&gt;&gt; y_pred = np.array([[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1], 
    ...                       [0.1, 0.4, 0.5]]) 
    &gt;&gt;&gt; sample_weight = [0.1, 0.2, 0.3, 0.4] 
    &gt;&gt;&gt; m = keras.metrics.OneHotIoU(num_classes=3, target_class_ids=[0, 2]) 
    &gt;&gt;&gt; m.update_state( 
    ...     y_true=y_true, y_pred=y_pred, sample_weight=sample_weight) 
    &gt;&gt;&gt; # cm = [[0, 0, 0.2+0.4], 
    &gt;&gt;&gt; #       [0.3, 0, 0], 
    &gt;&gt;&gt; #       [0, 0, 0.1]] 
    &gt;&gt;&gt; # sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1] 
    &gt;&gt;&gt; # true_positives = [0, 0, 0.1] 
    &gt;&gt;&gt; # single_iou = true_positives / (sum_row + sum_col - true_positives)) 
    &gt;&gt;&gt; # mean_iou = (0 / (0.3 + 0.6 - 0) + 0.1 / (0.7 + 0.1 - 0.1)) / 2 
    &gt;&gt;&gt; m.result() 
    0.071 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile( 
        optimizer='sgd', 
        loss='mse', 
        metrics=[keras.metrics.OneHotIoU( 
            num_classes=3, 
            target_class_id=[1] 
        )] 
    ) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_classes</span><span class="s2">,</span>
        <span class="s1">target_class_ids</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">num_classes</span><span class="s2">=</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s1">target_class_ids</span><span class="s2">=</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">ignore_class</span><span class="s2">=</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s6">&quot;num_classes&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s6">&quot;target_class_ids&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_class_ids</span><span class="s2">,</span>
            <span class="s6">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s6">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype</span><span class="s2">,</span>
            <span class="s6">&quot;ignore_class&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_pred&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s6">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s6">&quot;keras.metrics.OneHotMeanIoU&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">OneHotMeanIoU</span><span class="s2">(</span><span class="s1">MeanIoU</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Computes mean Intersection-Over-Union metric for one-hot encoded labels. 
 
    Formula: 
 
    ```python 
    iou = true_positives / (true_positives + false_positives + false_negatives) 
    ``` 
    Intersection-Over-Union is a common evaluation metric for semantic image 
    segmentation. 
 
    To compute IoUs, the predictions are accumulated in a confusion matrix, 
    weighted by `sample_weight` and the metric is then calculated from it. 
 
    If `sample_weight` is `None`, weights default to 1. 
    Use `sample_weight` of 0 to mask values. 
 
    This class can be used to compute the mean IoU for multi-class 
    classification tasks where the labels are one-hot encoded (the last axis 
    should have one dimension per class). Note that the predictions should also 
    have the same shape. To compute the mean IoU, first the labels and 
    predictions are converted back into integer format by taking the argmax over 
    the class axis. Then the same computation steps as for the base `MeanIoU` 
    class apply. 
 
    Note, if there is only one channel in the labels and predictions, this class 
    is the same as class `MeanIoU`. In this case, use `MeanIoU` instead. 
 
    Also, make sure that `num_classes` is equal to the number of classes in the 
    data, to avoid a &quot;labels out of bound&quot; error when the confusion matrix is 
    computed. 
 
    Args: 
        num_classes: The possible number of labels the prediction task can have. 
        name: (Optional) string name of the metric instance. 
        dtype: (Optional) data type of the metric result. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            metric computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
            considered. 
        sparse_y_pred: Whether predictions are encoded using natural numbers or 
            probability distribution vectors. If `False`, the `argmax` 
            function will be used to determine each sample's most likely 
            associated label. 
        axis: (Optional) The dimension containing the logits. Defaults to `-1`. 
 
    Example: 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 0]]) 
    &gt;&gt;&gt; y_pred = np.array([[0.2, 0.3, 0.5], [0.1, 0.2, 0.7], [0.5, 0.3, 0.1], 
    ...                       [0.1, 0.4, 0.5]]) 
    &gt;&gt;&gt; sample_weight = [0.1, 0.2, 0.3, 0.4] 
    &gt;&gt;&gt; m = keras.metrics.OneHotMeanIoU(num_classes=3) 
    &gt;&gt;&gt; m.update_state( 
    ...     y_true=y_true, y_pred=y_pred, sample_weight=sample_weight) 
    &gt;&gt;&gt; # cm = [[0, 0, 0.2+0.4], 
    &gt;&gt;&gt; #       [0.3, 0, 0], 
    &gt;&gt;&gt; #       [0, 0, 0.1]] 
    &gt;&gt;&gt; # sum_row = [0.3, 0, 0.7], sum_col = [0.6, 0.3, 0.1] 
    &gt;&gt;&gt; # true_positives = [0, 0, 0.1] 
    &gt;&gt;&gt; # single_iou = true_positives / (sum_row + sum_col - true_positives)) 
    &gt;&gt;&gt; # mean_iou = (0 + 0 + 0.1 / (0.7 + 0.1 - 0.1)) / 3 
    &gt;&gt;&gt; m.result() 
    0.048 
 
    Usage with `compile()` API: 
 
    ```python 
    model.compile( 
        optimizer='sgd', 
        loss='mse', 
        metrics=[keras.metrics.OneHotMeanIoU(num_classes=3)]) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_classes</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">num_classes</span><span class="s2">=</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">ignore_class</span><span class="s2">=</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s1">sparse_y_true</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">sparse_y_pred</span><span class="s2">=</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s6">&quot;num_classes&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_classes</span><span class="s2">,</span>
            <span class="s6">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s6">&quot;dtype&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype</span><span class="s2">,</span>
            <span class="s6">&quot;ignore_class&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">,</span>
            <span class="s6">&quot;sparse_y_pred&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sparse_y_pred</span><span class="s2">,</span>
            <span class="s6">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>
</pre>
</body>
</html>