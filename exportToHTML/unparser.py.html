<html>
<head>
<title>unparser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
unparser.py</font>
</center></td></tr></table>
<pre><span class="s0"># Code copied from Lib/ast.py from cpython 3.10 and slightly adjusted for gast</span>
<span class="s0">#</span>
<span class="s0"># PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2</span>
<span class="s0"># --------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># 1. This LICENSE AGREEMENT is between the Python Software Foundation</span>
<span class="s0"># (&quot;PSF&quot;), and the Individual or Organization (&quot;Licensee&quot;) accessing and</span>
<span class="s0"># otherwise using this software (&quot;Python&quot;) in source or binary form and</span>
<span class="s0"># its associated documentation.</span>
<span class="s0">#</span>
<span class="s0"># 2. Subject to the terms and conditions of this License Agreement, PSF hereby</span>
<span class="s0"># grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,</span>
<span class="s0"># analyze, test, perform and/or display publicly, prepare derivative works,</span>
<span class="s0"># distribute, and otherwise use Python alone or in any derivative version,</span>
<span class="s0"># provided, however, that PSF's License Agreement and PSF's notice of copyright,</span>
<span class="s0"># i.e., &quot;Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,</span>
<span class="s0"># 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Python Software Foundation;</span>
<span class="s0"># All Rights Reserved&quot; are retained in Python alone or in any derivative version</span>
<span class="s0"># prepared by Licensee.</span>
<span class="s0">#</span>
<span class="s0"># 3. In the event Licensee prepares a derivative work that is based on</span>
<span class="s0"># or incorporates Python or any part thereof, and wants to make</span>
<span class="s0"># the derivative work available to others as provided herein, then</span>
<span class="s0"># Licensee hereby agrees to include in any such work a brief summary of</span>
<span class="s0"># the changes made to Python.</span>
<span class="s0">#</span>
<span class="s0"># 4. PSF is making Python available to Licensee on an &quot;AS IS&quot;</span>
<span class="s0"># basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR</span>
<span class="s0"># IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND</span>
<span class="s0"># DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS</span>
<span class="s0"># FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT</span>
<span class="s0"># INFRINGE ANY THIRD PARTY RIGHTS.</span>
<span class="s0">#</span>
<span class="s0"># 5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON</span>
<span class="s0"># FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS</span>
<span class="s0"># A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,</span>
<span class="s0"># OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.</span>
<span class="s0">#</span>
<span class="s0"># 6. This License Agreement will automatically terminate upon a material</span>
<span class="s0"># breach of its terms and conditions.</span>
<span class="s0">#</span>
<span class="s0"># 7. Nothing in this License Agreement shall be deemed to create any</span>
<span class="s0"># relationship of agency, partnership, or joint venture between PSF and</span>
<span class="s0"># Licensee.  This License Agreement does not grant permission to use PSF</span>
<span class="s0"># trademarks or trade name in a trademark sense to endorse or promote</span>
<span class="s0"># products or services of Licensee, or any third party.</span>
<span class="s0">#</span>
<span class="s0"># 8. By copying, installing or otherwise using Python, Licensee</span>
<span class="s0"># agrees to be bound by the terms and conditions of this License</span>
<span class="s0"># Agreement.</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s3">*</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">string </span><span class="s2">import </span><span class="s1">printable</span>


<span class="s2">class </span><span class="s1">nullcontext</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">enter_result</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">enter_result </span><span class="s3">= </span><span class="s1">enter_result</span>

    <span class="s2">def </span><span class="s1">__enter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">enter_result</span>

    <span class="s2">def </span><span class="s1">__exit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">excinfo</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s0"># Large float and imaginary literals get turned into infinities in the AST.</span>
<span class="s0"># We unparse those infinities to INFSTR.</span>
<span class="s1">_INFSTR </span><span class="s3">= </span><span class="s4">&quot;1e&quot; </span><span class="s3">+ </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">float_info</span><span class="s3">.</span><span class="s1">max_10_exp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>

<span class="s2">class </span><span class="s1">_Precedence</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Precedence table that originated from python grammar.&quot;&quot;&quot;</span>

    <span class="s1">TUPLE </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">YIELD </span><span class="s3">= </span><span class="s5">2           </span><span class="s0"># 'yield', 'yield from'</span>
    <span class="s1">TEST </span><span class="s3">= </span><span class="s5">3            </span><span class="s0"># 'if'-'else', 'lambda'</span>
    <span class="s1">OR </span><span class="s3">= </span><span class="s5">4              </span><span class="s0"># 'or'</span>
    <span class="s1">AND </span><span class="s3">= </span><span class="s5">5             </span><span class="s0"># 'and'</span>
    <span class="s1">NOT </span><span class="s3">= </span><span class="s5">6             </span><span class="s0"># 'not'</span>
    <span class="s1">CMP </span><span class="s3">= </span><span class="s5">7             </span><span class="s0"># '&lt;', '&gt;', '==', '&gt;=', '&lt;=', '!=',</span>
                             <span class="s0"># 'in', 'not in', 'is', 'is not'</span>
    <span class="s1">EXPR </span><span class="s3">= </span><span class="s5">8</span>
    <span class="s1">BOR </span><span class="s3">= </span><span class="s1">EXPR               </span><span class="s0"># '|'</span>
    <span class="s1">BXOR </span><span class="s3">= </span><span class="s5">9            </span><span class="s0"># '^'</span>
    <span class="s1">BAND </span><span class="s3">= </span><span class="s5">10            </span><span class="s0"># '&amp;'</span>
    <span class="s1">SHIFT </span><span class="s3">= </span><span class="s5">11           </span><span class="s0"># '&lt;&lt;', '&gt;&gt;'</span>
    <span class="s1">ARITH </span><span class="s3">= </span><span class="s5">12           </span><span class="s0"># '+', '-'</span>
    <span class="s1">TERM </span><span class="s3">= </span><span class="s5">13            </span><span class="s0"># '*', '@', '/', '%', '//'</span>
    <span class="s1">FACTOR </span><span class="s3">= </span><span class="s5">14          </span><span class="s0"># unary '+', '-', '~'</span>
    <span class="s1">POWER </span><span class="s3">= </span><span class="s5">15           </span><span class="s0"># '**'</span>
    <span class="s1">AWAIT </span><span class="s3">= </span><span class="s5">16           </span><span class="s0"># 'await'</span>
    <span class="s1">ATOM </span><span class="s3">= </span><span class="s5">17</span>


<span class="s1">_SINGLE_QUOTES </span><span class="s3">= (</span><span class="s4">&quot;'&quot;</span><span class="s3">, </span><span class="s4">'&quot;'</span><span class="s3">)</span>
<span class="s1">_MULTI_QUOTES </span><span class="s3">= (</span><span class="s4">'&quot;&quot;&quot;'</span><span class="s3">, </span><span class="s4">&quot;'''&quot;</span><span class="s3">)</span>
<span class="s1">_ALL_QUOTES </span><span class="s3">= </span><span class="s1">_SINGLE_QUOTES </span><span class="s3">+ </span><span class="s1">_MULTI_QUOTES</span>

<span class="s2">class </span><span class="s1">_Unparser</span><span class="s3">(</span><span class="s1">NodeVisitor</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Methods in this class recursively traverse an AST and 
    output source code for the abstract syntax; original formatting 
    is disregarded.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">_avoid_backslashes</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_source </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_buffer </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_precedences </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_ignores </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_indent </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_avoid_backslashes </span><span class="s3">= </span><span class="s1">_avoid_backslashes</span>

    <span class="s2">def </span><span class="s1">interleave</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inter</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Call f on each item in seq, calling inter() in between.&quot;&quot;&quot;</span>
        <span class="s1">seq </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">f</span><span class="s3">(</span><span class="s1">next</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">))</span>
        <span class="s2">except </span><span class="s1">StopIteration</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">seq</span><span class="s3">:</span>
                <span class="s1">inter</span><span class="s3">()</span>
                <span class="s1">f</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">items_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">traverser</span><span class="s3">, </span><span class="s1">items</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Traverse and separate the given *items* with a comma and append it to 
        the buffer. If *items* is a single item sequence, a trailing comma 
        will be added.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">traverser</span><span class="s3">(</span><span class="s1">items</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;,&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">traverser</span><span class="s3">, </span><span class="s1">items</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">maybe_newline</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Adds a newline if it isn't the start of generated source&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_source</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">fill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Indent a piece of text and append it, according to the current 
        indentation level&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">maybe_newline</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;    &quot; </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indent </span><span class="s3">+ </span><span class="s1">text</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">write</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Append a piece of text&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_source</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">text</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">buffer_writer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_buffer</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">text</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">buffer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_buffer</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_buffer</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">block</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">extra </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;A context manager for preparing the source for blocks. It adds 
        the character':', increases the indentation on enter and decreases 
        the indentation on exit. If *extra* is given, it will be directly 
        appended after the colon character. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;:&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">extra</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_indent </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">yield</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_indent </span><span class="s3">-= </span><span class="s5">1</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">delimit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;A context manager for preparing the source for expressions. It adds 
        *start* to the buffer and enters, after exit it adds *end*.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
        <span class="s2">yield</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">delimit_if</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">condition</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">condition</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">nullcontext</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Shortcut to adding precedence related parens&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit_if</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_precedence</span><span class="s3">(</span><span class="s1">node</span><span class="s3">) &gt; </span><span class="s1">precedence</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_precedences</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">precedence</span><span class="s3">, *</span><span class="s1">nodes</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_precedences</span><span class="s3">[</span><span class="s1">node</span><span class="s3">] = </span><span class="s1">precedence</span>

    <span class="s2">def </span><span class="s1">get_raw_docstring</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;If a docstring node is found in the body of the *node* parameter, 
        return that docstring node, None otherwise. 
 
        Logic mirrored from ``_PyAST_GetDocString``.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">node</span><span class="s3">, (</span><span class="s1">AsyncFunctionDef</span><span class="s3">, </span><span class="s1">FunctionDef</span><span class="s3">, </span><span class="s1">ClassDef</span><span class="s3">, </span><span class="s1">Module</span><span class="s3">)</span>
        <span class="s3">) </span><span class="s2">or </span><span class="s1">len</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) &lt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">Expr</span><span class="s3">):</span>
            <span class="s2">return None</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">Constant</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">comment </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_ignores</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">) </span><span class="s2">or </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type_comment</span>
        <span class="s2">if </span><span class="s1">comment </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">&quot; # type: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">comment</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">node</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">super</span><span class="s3">(</span><span class="s1">_Unparser</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">visit</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

    <span class="s0"># Note: as visit() resets the output text, do NOT rely on</span>
    <span class="s0"># NodeVisitor.generic_visit to handle any nodes (as it calls back in to</span>
    <span class="s0"># the subclass visit() method, which resets self._source to an empty list)</span>
    <span class="s2">def </span><span class="s1">visit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Outputs a source code string that, if converted back to an ast 
        (using ast.parse) will generate an AST equivalent to *node*&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_source </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_source</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_write_docstring_and_traverse_body</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">docstring </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_raw_docstring</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">docstring</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_docstring</span><span class="s3">(</span><span class="s1">docstring</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_ignores </span><span class="s3">= {</span>
            <span class="s1">ignore</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">: </span><span class="s4">&quot;ignore{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">ignore</span><span class="s3">.</span><span class="s1">tag</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">ignore </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type_ignores</span>
        <span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_docstring_and_traverse_body</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_ignores</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">visit_FunctionType</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">argtypes</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; -&gt; &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">returns</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Expr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">YIELD</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_NamedExpr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TUPLE</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; := &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Import</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;import &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">names</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_ImportFrom</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;from &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;.&quot; </span><span class="s3">* </span><span class="s1">node</span><span class="s3">.</span><span class="s1">level</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">module</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">module</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; import &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">names</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Assign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">targets</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">target</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; = &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">type_comment </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">type_comment</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">type_comment</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_AugAssign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot; </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">op</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">] + </span><span class="s4">&quot;= &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_AnnAssign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">()</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit_if</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s2">not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">simple </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Name</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; = &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Return</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;return&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Pass</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;pass&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Break</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;break&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Continue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;continue&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Delete</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;del &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">targets</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Assert</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;assert &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Global</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;global &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">names</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Nonlocal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;nonlocal &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">names</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Await</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">AWAIT</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;await&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Yield</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">YIELD</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;yield&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_YieldFrom</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">YIELD</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;yield from &quot;</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Node can't be used without a value attribute.&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Raise</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;raise&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">exc</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">cause</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Node can't use cause without an exception.&quot;</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">exc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">cause</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; from &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">cause</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Try</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;try&quot;</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ex </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">handlers</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">ex</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;else&quot;</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">finalbody</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;finally&quot;</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">finalbody</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_ExceptHandler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;except&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; as &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_ClassDef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">maybe_newline</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">deco </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">decorator_list</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;@&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">deco</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;class &quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s4">&quot;type_params&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_params_helper</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type_params</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit_if</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s1">condition </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">bases </span><span class="s2">or </span><span class="s1">node</span><span class="s3">.</span><span class="s1">keywords</span><span class="s3">):</span>
            <span class="s1">comma </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">bases</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">comma</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">comma </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">keywords</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">comma</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">comma </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_docstring_and_traverse_body</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_FunctionDef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_function_helper</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s4">&quot;def&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_AsyncFunctionDef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_function_helper</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s4">&quot;async def&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_function_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">fill_suffix</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">maybe_newline</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">deco </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">decorator_list</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;@&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">deco</span><span class="s3">)</span>
        <span class="s1">def_str </span><span class="s3">= </span><span class="s1">fill_suffix </span><span class="s3">+ </span><span class="s4">&quot; &quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s1">def_str</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s4">&quot;type_params&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_params_helper</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type_params</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">returns</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; -&gt; &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">returns</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_docstring_and_traverse_body</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_type_params_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">type_params </span><span class="s2">is not None and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">type_params</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">type_params</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_TypeVar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">bound</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">bound</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_TypeVarTuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;*&quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_ParamSpec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;**&quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_TypeAlias</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;type &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_type_params_helper</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type_params</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; = &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_For</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_for_helper</span><span class="s3">(</span><span class="s4">&quot;for &quot;</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_AsyncFor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_for_helper</span><span class="s3">(</span><span class="s4">&quot;async for &quot;</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_for_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fill</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s1">fill</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; in &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">iter</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;else&quot;</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_If</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;if &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
        <span class="s0"># collapse nested ifs into equivalent elifs.</span>
        <span class="s2">while </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">If</span><span class="s3">):</span>
            <span class="s1">node </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;elif &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
        <span class="s0"># final else</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;else&quot;</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_While</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;while &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;else&quot;</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_With</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;with &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">items</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_AsyncWith</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;async with &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">items</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">(</span><span class="s1">extra</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_type_comment</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_str_literal_helper</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">string</span><span class="s3">, </span><span class="s1">quote_types</span><span class="s3">=</span><span class="s1">_ALL_QUOTES</span><span class="s3">, </span><span class="s1">escape_special_whitespace</span><span class="s3">=</span><span class="s2">False</span>
    <span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Helper for writing string literals, minimizing escapes. 
        Returns the tuple (string literal to write, possible quote types). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">escape_char</span><span class="s3">(</span><span class="s1">c</span><span class="s3">):</span>
            <span class="s0"># \n and \t are non-printable, but we only escape them if</span>
            <span class="s0"># escape_special_whitespace is True</span>
            <span class="s2">if not </span><span class="s1">escape_special_whitespace </span><span class="s2">and </span><span class="s1">c </span><span class="s2">in </span><span class="s4">&quot;</span><span class="s2">\n\t</span><span class="s4">&quot;</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">c</span>
            <span class="s0"># Always escape backslashes and other non-printable characters</span>
            <span class="s2">if </span><span class="s1">c </span><span class="s3">== </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot; </span><span class="s2">or not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">cc </span><span class="s2">in </span><span class="s1">printable </span><span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s4">&quot;unicode_escape&quot;</span><span class="s3">).</span><span class="s1">decode</span><span class="s3">(</span><span class="s4">&quot;ascii&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s1">escaped_string </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">escape_char</span><span class="s3">, </span><span class="s1">string</span><span class="s3">))</span>
        <span class="s1">possible_quotes </span><span class="s3">= </span><span class="s1">quote_types</span>
        <span class="s2">if </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s2">in </span><span class="s1">escaped_string</span><span class="s3">:</span>
            <span class="s1">possible_quotes </span><span class="s3">= [</span><span class="s1">q </span><span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">possible_quotes </span><span class="s2">if </span><span class="s1">q </span><span class="s2">in </span><span class="s1">_MULTI_QUOTES</span><span class="s3">]</span>
        <span class="s1">possible_quotes </span><span class="s3">= [</span><span class="s1">q </span><span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">possible_quotes </span><span class="s2">if </span><span class="s1">q </span><span class="s2">not in </span><span class="s1">escaped_string</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">possible_quotes</span><span class="s3">:</span>
            <span class="s0"># If there aren't any possible_quotes, fallback to using repr</span>
            <span class="s0"># on the original string. Try to use a quote from quote_types,</span>
            <span class="s0"># e.g., so that we use triple quotes for docstrings.</span>
            <span class="s1">string </span><span class="s3">= </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">string</span><span class="s3">)</span>
            <span class="s1">quote </span><span class="s3">= </span><span class="s1">next</span><span class="s3">((</span><span class="s1">q </span><span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">quote_types </span><span class="s2">if </span><span class="s1">string</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">in </span><span class="s1">q</span><span class="s3">), </span><span class="s1">string</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">string</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">], [</span><span class="s1">quote</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">escaped_string</span><span class="s3">:</span>
            <span class="s0"># Sort so that we prefer '''&quot;''' over &quot;&quot;&quot;\&quot;&quot;&quot;&quot;</span>
            <span class="s1">possible_quotes</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">q</span><span class="s3">: </span><span class="s1">q</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s1">escaped_string</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s0"># If we're using triple quotes and we'd need to escape a final</span>
            <span class="s0"># quote, escape it</span>
            <span class="s2">if </span><span class="s1">possible_quotes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] == </span><span class="s1">escaped_string</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]:</span>
                <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">possible_quotes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) == </span><span class="s5">3</span>
                <span class="s1">escaped_string </span><span class="s3">= </span><span class="s1">escaped_string</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot; </span><span class="s3">+ </span><span class="s1">escaped_string</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">escaped_string</span><span class="s3">, </span><span class="s1">possible_quotes</span>

    <span class="s2">def </span><span class="s1">_write_str_avoiding_backslashes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">string</span><span class="s3">, </span><span class="s1">quote_types</span><span class="s3">=</span><span class="s1">_ALL_QUOTES</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Write string literal value with a best effort attempt to avoid backslashes.&quot;&quot;&quot;</span>
        <span class="s1">string</span><span class="s3">, </span><span class="s1">quote_types </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_str_literal_helper</span><span class="s3">(</span><span class="s1">string</span><span class="s3">, </span><span class="s1">quote_types</span><span class="s3">=</span><span class="s1">quote_types</span><span class="s3">)</span>
        <span class="s1">quote_type </span><span class="s3">= </span><span class="s1">quote_types</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;{0}{1}{0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">quote_type</span><span class="s3">, </span><span class="s1">string</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_JoinedStr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;f&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_avoid_backslashes</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fstring_JoinedStr</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer_writer</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_str_avoiding_backslashes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s0"># If we don't need to avoid backslashes globally (i.e., we only need</span>
        <span class="s0"># to avoid them inside FormattedValues), it's cosmetically preferred</span>
        <span class="s0"># to use escaped whitespace. That is, it's preferred to use backslashes</span>
        <span class="s0"># for cases like: f&quot;{x}\n&quot;. To accomplish this, we keep track of what</span>
        <span class="s0"># in our buffer corresponds to FormattedValues and what corresponds to</span>
        <span class="s0"># Constant parts of the f-string, and allow escapes accordingly.</span>
        <span class="s1">buffer </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">values</span><span class="s3">:</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_fstring_&quot; </span><span class="s3">+ </span><span class="s1">type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">)</span>
            <span class="s1">meth</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer_writer</span><span class="s3">)</span>
            <span class="s1">buffer</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">Constant</span><span class="s3">)))</span>
        <span class="s1">new_buffer </span><span class="s3">= []</span>
        <span class="s1">quote_types </span><span class="s3">= </span><span class="s1">_ALL_QUOTES</span>
        <span class="s2">for </span><span class="s1">value</span><span class="s3">, </span><span class="s1">is_constant </span><span class="s2">in </span><span class="s1">buffer</span><span class="s3">:</span>
            <span class="s0"># Repeatedly narrow down the list of possible quote_types</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">quote_types </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_str_literal_helper</span><span class="s3">(</span>
                <span class="s1">value</span><span class="s3">, </span><span class="s1">quote_types</span><span class="s3">=</span><span class="s1">quote_types</span><span class="s3">,</span>
                <span class="s1">escape_special_whitespace</span><span class="s3">=</span><span class="s1">is_constant</span>
            <span class="s3">)</span>
            <span class="s1">new_buffer</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">new_buffer</span><span class="s3">)</span>
        <span class="s1">quote_type </span><span class="s3">= </span><span class="s1">quote_types</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;{0}{1}{0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">quote_type</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_FormattedValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;f&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fstring_FormattedValue</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer_writer</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_str_avoiding_backslashes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fstring_JoinedStr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">write</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">values</span><span class="s3">:</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_fstring_&quot; </span><span class="s3">+ </span><span class="s1">type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">)</span>
            <span class="s1">meth</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">write</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fstring_Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">write</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Constants inside JoinedStr should be a string.&quot;</span><span class="s3">)</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;{{&quot;</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;}&quot;</span><span class="s3">, </span><span class="s4">&quot;}}&quot;</span><span class="s3">)</span>
        <span class="s1">write</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fstring_FormattedValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">write</span><span class="s3">):</span>
        <span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">)</span>
        <span class="s1">unparser </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)(</span><span class="s1">_avoid_backslashes</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">unparser</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">unparser</span><span class="s3">.</span><span class="s1">visit</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">):</span>
            <span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)  </span><span class="s0"># Separate pair of opening brackets as &quot;{ {&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot; </span><span class="s2">in </span><span class="s1">expr</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unable to avoid backslash in f-string expression part&quot;</span><span class="s3">)</span>
        <span class="s1">write</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">conversion </span><span class="s3">!= -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">conversion </span><span class="s3">= </span><span class="s1">chr</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">conversion</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">conversion </span><span class="s2">not in </span><span class="s4">&quot;sra&quot;</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown f-string conversion.&quot;</span><span class="s3">)</span>
            <span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;!{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">conversion</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">format_spec</span><span class="s3">:</span>
            <span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;:&quot;</span><span class="s3">)</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_fstring_&quot; </span><span class="s3">+ </span><span class="s1">type</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">format_spec</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">)</span>
            <span class="s1">meth</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">format_spec</span><span class="s3">, </span><span class="s1">write</span><span class="s3">)</span>
        <span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;}&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_write_docstring</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;u&quot;</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;u&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_str_avoiding_backslashes</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">quote_types</span><span class="s3">=</span><span class="s1">_MULTI_QUOTES</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_write_constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">)):</span>
            <span class="s0"># Substitute overflowing decimal literal for AST infinities,</span>
            <span class="s0"># and inf - inf for NaNs.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span>
                <span class="s1">repr</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;inf&quot;</span><span class="s3">, </span><span class="s1">_INFSTR</span><span class="s3">)</span>
                <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;nan&quot;</span><span class="s3">, </span><span class="s4">&quot;({0}-{0})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">_INFSTR</span><span class="s3">))</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_avoid_backslashes </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_str_avoiding_backslashes</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">items_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write_constant</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">value </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;...&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;u&quot;</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;u&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_constant</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_List</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_ListComp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">elt</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">gen </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">generators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_GeneratorExp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">elt</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">gen </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">generators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_SetComp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">elt</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">gen </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">generators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_DictComp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">key</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">gen </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">generators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_comprehension</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_async</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; async for &quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; for &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TUPLE</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; in &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">iter</span><span class="s3">, *</span><span class="s1">node</span><span class="s3">.</span><span class="s1">ifs</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">iter</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">if_clause </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">ifs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; if &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">if_clause</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_IfExp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; if &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">test</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; else &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">orelse</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># `{}` would be interpreted as a dictionary literal, and</span>
            <span class="s0"># `set` might be shadowed. Thus:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'{*()}'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">write_key_value_pair</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">write_item</span><span class="s3">(</span><span class="s1">item</span><span class="s3">):</span>
            <span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= </span><span class="s1">item</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s0"># for dictionary unpacking operator in dicts {**{'y': 2}}</span>
                <span class="s0"># see PEP 448 for details</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;**&quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">EXPR</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">write_key_value_pair</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">write_item</span><span class="s3">, </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">values</span><span class="s3">)</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">items_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">)</span>

    <span class="s1">unop </span><span class="s3">= {</span><span class="s4">&quot;Invert&quot;</span><span class="s3">: </span><span class="s4">&quot;~&quot;</span><span class="s3">, </span><span class="s4">&quot;Not&quot;</span><span class="s3">: </span><span class="s4">&quot;not&quot;</span><span class="s3">, </span><span class="s4">&quot;UAdd&quot;</span><span class="s3">: </span><span class="s4">&quot;+&quot;</span><span class="s3">, </span><span class="s4">&quot;USub&quot;</span><span class="s3">: </span><span class="s4">&quot;-&quot;</span><span class="s3">}</span>
    <span class="s1">unop_precedence </span><span class="s3">= {</span>
        <span class="s4">&quot;not&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">NOT</span><span class="s3">,</span>
        <span class="s4">&quot;~&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">FACTOR</span><span class="s3">,</span>
        <span class="s4">&quot;+&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">FACTOR</span><span class="s3">,</span>
        <span class="s4">&quot;-&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">FACTOR</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">visit_UnaryOp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">operator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">unop</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">op</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">]</span>
        <span class="s1">operator_precedence </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">unop_precedence</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">operator_precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">)</span>
            <span class="s0"># factor prefixes (+, -, ~) shouldn't be seperated</span>
            <span class="s0"># from the value they belong, (e.g: +1 instead of + 1)</span>
            <span class="s2">if </span><span class="s1">operator_precedence </span><span class="s2">is not </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">FACTOR</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">operator_precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">operand</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">operand</span><span class="s3">)</span>

    <span class="s1">binop </span><span class="s3">= {</span>
        <span class="s4">&quot;Add&quot;</span><span class="s3">: </span><span class="s4">&quot;+&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Sub&quot;</span><span class="s3">: </span><span class="s4">&quot;-&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Mult&quot;</span><span class="s3">: </span><span class="s4">&quot;*&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;MatMult&quot;</span><span class="s3">: </span><span class="s4">&quot;@&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Div&quot;</span><span class="s3">: </span><span class="s4">&quot;/&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Mod&quot;</span><span class="s3">: </span><span class="s4">&quot;%&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LShift&quot;</span><span class="s3">: </span><span class="s4">&quot;&lt;&lt;&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;RShift&quot;</span><span class="s3">: </span><span class="s4">&quot;&gt;&gt;&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;BitOr&quot;</span><span class="s3">: </span><span class="s4">&quot;|&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;BitXor&quot;</span><span class="s3">: </span><span class="s4">&quot;^&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;BitAnd&quot;</span><span class="s3">: </span><span class="s4">&quot;&amp;&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;FloorDiv&quot;</span><span class="s3">: </span><span class="s4">&quot;//&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Pow&quot;</span><span class="s3">: </span><span class="s4">&quot;**&quot;</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s1">binop_precedence </span><span class="s3">= {</span>
        <span class="s4">&quot;+&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ARITH</span><span class="s3">,</span>
        <span class="s4">&quot;-&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ARITH</span><span class="s3">,</span>
        <span class="s4">&quot;*&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TERM</span><span class="s3">,</span>
        <span class="s4">&quot;@&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TERM</span><span class="s3">,</span>
        <span class="s4">&quot;/&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TERM</span><span class="s3">,</span>
        <span class="s4">&quot;%&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TERM</span><span class="s3">,</span>
        <span class="s4">&quot;&lt;&lt;&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">SHIFT</span><span class="s3">,</span>
        <span class="s4">&quot;&gt;&gt;&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">SHIFT</span><span class="s3">,</span>
        <span class="s4">&quot;|&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BOR</span><span class="s3">,</span>
        <span class="s4">&quot;^&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BXOR</span><span class="s3">,</span>
        <span class="s4">&quot;&amp;&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BAND</span><span class="s3">,</span>
        <span class="s4">&quot;//&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TERM</span><span class="s3">,</span>
        <span class="s4">&quot;**&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">POWER</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s1">binop_rassoc </span><span class="s3">= </span><span class="s1">frozenset</span><span class="s3">((</span><span class="s4">&quot;**&quot;</span><span class="s3">,))</span>
    <span class="s2">def </span><span class="s1">visit_BinOp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">operator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">op</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">]</span>
        <span class="s1">operator_precedence </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">binop_precedence</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">operator_precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">operator </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">binop_rassoc</span><span class="s3">:</span>
                <span class="s1">left_precedence </span><span class="s3">= </span><span class="s1">operator_precedence </span><span class="s3">+ </span><span class="s5">1</span>
                <span class="s1">right_precedence </span><span class="s3">= </span><span class="s1">operator_precedence</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">left_precedence </span><span class="s3">= </span><span class="s1">operator_precedence</span>
                <span class="s1">right_precedence </span><span class="s3">= </span><span class="s1">operator_precedence </span><span class="s3">+ </span><span class="s5">1</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">left_precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; {} &quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">right_precedence</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">right</span><span class="s3">)</span>

    <span class="s1">cmpops </span><span class="s3">= {</span>
        <span class="s4">&quot;Eq&quot;</span><span class="s3">: </span><span class="s4">&quot;==&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;NotEq&quot;</span><span class="s3">: </span><span class="s4">&quot;!=&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Lt&quot;</span><span class="s3">: </span><span class="s4">&quot;&lt;&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LtE&quot;</span><span class="s3">: </span><span class="s4">&quot;&lt;=&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Gt&quot;</span><span class="s3">: </span><span class="s4">&quot;&gt;&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;GtE&quot;</span><span class="s3">: </span><span class="s4">&quot;&gt;=&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Is&quot;</span><span class="s3">: </span><span class="s4">&quot;is&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;IsNot&quot;</span><span class="s3">: </span><span class="s4">&quot;is not&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;In&quot;</span><span class="s3">: </span><span class="s4">&quot;in&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;NotIn&quot;</span><span class="s3">: </span><span class="s4">&quot;not in&quot;</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">visit_Compare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">CMP</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">CMP </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">, *</span><span class="s1">node</span><span class="s3">.</span><span class="s1">comparators</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">left</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">o</span><span class="s3">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">ops</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">comparators</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot; </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cmpops</span><span class="s3">[</span><span class="s1">o</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">] + </span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>

    <span class="s1">boolops </span><span class="s3">= {</span><span class="s4">&quot;And&quot;</span><span class="s3">: </span><span class="s4">&quot;and&quot;</span><span class="s3">, </span><span class="s4">&quot;Or&quot;</span><span class="s3">: </span><span class="s4">&quot;or&quot;</span><span class="s3">}</span>
    <span class="s1">boolop_precedence </span><span class="s3">= {</span><span class="s4">&quot;and&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">AND</span><span class="s3">, </span><span class="s4">&quot;or&quot;</span><span class="s3">: </span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">OR</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">visit_BoolOp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">operator </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">boolops</span><span class="s3">[</span><span class="s1">node</span><span class="s3">.</span><span class="s1">op</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">]</span>
        <span class="s1">operator_precedence </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">boolop_precedence</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]]</span>

        <span class="s2">def </span><span class="s1">increasing_level_traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">operator_precedence</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">operator_precedence</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">operator_precedence</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">&quot; {} &quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">s</span><span class="s3">), </span><span class="s1">increasing_level_traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">values</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Attribute</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s0"># Special case: 3.__abs__() is a syntax error, so if node.value</span>
        <span class="s0"># is an integer literal then we need to either parenthesize</span>
        <span class="s0"># it or add an extra space to get 3 .__abs__().</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">Constant</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">func</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">func</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">comma </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">comma</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">comma </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">keywords</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">comma</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">comma </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Subscript</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">is_simple_tuple</span><span class="s3">(</span><span class="s1">slice_value</span><span class="s3">):</span>
            <span class="s0"># when unparsing a non-empty tuple, the parentheses can be safely</span>
            <span class="s0"># omitted if there aren't any elements that explicitly requires</span>
            <span class="s0"># parentheses (such as starred expressions).</span>
            <span class="s2">return </span><span class="s3">(</span>
                <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">slice_value</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">slice_value</span><span class="s3">.</span><span class="s1">elts</span>
                <span class="s2">and not </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">elt</span><span class="s3">, </span><span class="s1">Starred</span><span class="s3">) </span><span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">slice_value</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">is_simple_tuple</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">items_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">elts</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Starred</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;*&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">EXPR</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Ellipsis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;...&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;:&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">step</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;:&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">step</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Match</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;match &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">subject</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">cases</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">case</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_arg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_arguments</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">first </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s0"># normal arguments</span>
        <span class="s1">all_args </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">posonlyargs </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">args</span>
        <span class="s1">defaults </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">all_args</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">defaults</span><span class="s3">)) + </span><span class="s1">node</span><span class="s3">.</span><span class="s1">defaults</span>
        <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">elements </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">all_args</span><span class="s3">, </span><span class="s1">defaults</span><span class="s3">), </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">d </span><span class="s3">= </span><span class="s1">elements</span>
            <span class="s2">if </span><span class="s1">first</span><span class="s3">:</span>
                <span class="s1">first </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">d</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;=&quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">index </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">posonlyargs</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, /&quot;</span><span class="s3">)</span>

        <span class="s0"># varargs, or bare '*' if no varargs but keyword-only arguments present</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">vararg </span><span class="s2">or </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwonlyargs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">first</span><span class="s3">:</span>
                <span class="s1">first </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;*&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>

        <span class="s0"># keyword-only arguments</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwonlyargs</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwonlyargs</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kw_defaults</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">d</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;=&quot;</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>

        <span class="s0"># kwargs</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwarg</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">first</span><span class="s3">:</span>
                <span class="s1">first </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;**&quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwarg</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwarg</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwarg</span><span class="s3">.</span><span class="s1">annotation</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_keyword</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">arg </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;**&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;=&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_Lambda</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;lambda &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_alias</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">asname</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; as &quot; </span><span class="s3">+ </span><span class="s1">node</span><span class="s3">.</span><span class="s1">asname</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_withitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">context_expr</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">optional_vars</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; as &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">optional_vars</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_match_case</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">&quot;case &quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">pattern</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">guard</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; if &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">guard</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">block</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_MatchValue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_MatchSingleton</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write_constant</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_MatchSequence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">patterns</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_MatchStar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s4">&quot;_&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;*{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_MatchMapping</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">write_key_pattern_pair</span><span class="s3">(</span><span class="s1">pair</span><span class="s3">):</span>
            <span class="s1">k</span><span class="s3">, </span><span class="s1">p </span><span class="s3">= </span><span class="s1">pair</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;: &quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s3">):</span>
            <span class="s1">keys </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">keys</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">),</span>
                <span class="s1">write_key_pattern_pair</span><span class="s3">,</span>
                <span class="s1">zip</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">patterns</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span><span class="s3">),</span>
            <span class="s3">)</span>
            <span class="s1">rest </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">rest</span>
            <span class="s2">if </span><span class="s1">rest </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">keys</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;**{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">rest</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_MatchClass</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">ATOM</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delimit</span><span class="s3">(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s3">):</span>
            <span class="s1">patterns </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">patterns</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">patterns</span>
            <span class="s3">)</span>
            <span class="s1">attrs </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwd_attrs</span>
            <span class="s2">if </span><span class="s1">attrs</span><span class="s3">:</span>
                <span class="s2">def </span><span class="s1">write_attr_pattern</span><span class="s3">(</span><span class="s1">pair</span><span class="s3">):</span>
                    <span class="s1">attr</span><span class="s3">, </span><span class="s1">pattern </span><span class="s3">= </span><span class="s1">pair</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;{}=&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">))</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">patterns</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span>
                    <span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">),</span>
                    <span class="s1">write_attr_pattern</span><span class="s3">,</span>
                    <span class="s1">zip</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">kwd_patterns</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span><span class="s3">),</span>
                <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_MatchAs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">pattern </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">pattern</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">pattern </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">TEST</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BOR</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">pattern</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">pattern</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; as {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">visit_MatchOr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">require_parens</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BOR</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">_Precedence</span><span class="s3">.</span><span class="s1">BOR </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, *</span><span class="s1">node</span><span class="s3">.</span><span class="s1">patterns</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">interleave</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">&quot; | &quot;</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">traverse</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">patterns</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">unparse</span><span class="s3">(</span><span class="s1">ast_obj</span><span class="s3">):</span>
    <span class="s1">unparser </span><span class="s3">= </span><span class="s1">_Unparser</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">unparser</span><span class="s3">.</span><span class="s1">visit</span><span class="s3">(</span><span class="s1">ast_obj</span><span class="s3">)</span>
</pre>
</body>
</html>