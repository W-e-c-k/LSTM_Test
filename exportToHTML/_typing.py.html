<html>
<head>
<title>_typing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_typing.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">MutableMapping</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
    <span class="s1">tzinfo</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">os </span><span class="s0">import </span><span class="s1">PathLike</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Protocol</span><span class="s2">,</span>
    <span class="s1">Type </span><span class="s0">as </span><span class="s1">type_t</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s3"># To prevent import cycles place any internal imports in the branch below</span>
<span class="s3"># and use a string literal forward reference to it in subsequent types</span>
<span class="s3"># https://mypy.readthedocs.io/en/latest/common_issues.html#import-cycles</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">as </span><span class="s1">npt</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">NaTType</span><span class="s2">,</span>
        <span class="s1">Period</span><span class="s2">,</span>
        <span class="s1">Timedelta</span><span class="s2">,</span>
        <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs </span><span class="s0">import </span><span class="s1">BaseOffset</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>

    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Interval</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">DatetimeArray</span><span class="s2">,</span>
        <span class="s1">TimedeltaArray</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">frame </span><span class="s0">import </span><span class="s1">DataFrame</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s1">NDFrame</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">DataFrameGroupBy</span><span class="s2">,</span>
        <span class="s1">GroupBy</span><span class="s2">,</span>
        <span class="s1">SeriesGroupBy</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">Index</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">internals </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">ArrayManager</span><span class="s2">,</span>
        <span class="s1">BlockManager</span><span class="s2">,</span>
        <span class="s1">SingleArrayManager</span><span class="s2">,</span>
        <span class="s1">SingleBlockManager</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">resample </span><span class="s0">import </span><span class="s1">Resampler</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">series </span><span class="s0">import </span><span class="s1">Series</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">window</span><span class="s2">.</span><span class="s1">rolling </span><span class="s0">import </span><span class="s1">BaseWindow</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">io</span><span class="s2">.</span><span class="s1">formats</span><span class="s2">.</span><span class="s1">format </span><span class="s0">import </span><span class="s1">EngFormatter</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tseries</span><span class="s2">.</span><span class="s1">holiday </span><span class="s0">import </span><span class="s1">AbstractHolidayCalendar</span>

    <span class="s1">ScalarLike_co </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
        <span class="s1">int</span><span class="s2">,</span>
        <span class="s1">float</span><span class="s2">,</span>
        <span class="s1">complex</span><span class="s2">,</span>
        <span class="s1">str</span><span class="s2">,</span>
        <span class="s1">bytes</span><span class="s2">,</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">generic</span><span class="s2">,</span>
    <span class="s2">]</span>

    <span class="s3"># numpy compatible types</span>
    <span class="s1">NumpyValueArrayLike </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">ScalarLike_co</span><span class="s2">, </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike</span><span class="s2">]</span>
    <span class="s3"># Name &quot;npt._ArrayLikeInt_co&quot; is not defined  [name-defined]</span>
    <span class="s1">NumpySorter </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">npt</span><span class="s2">.</span><span class="s1">_ArrayLikeInt_co</span><span class="s2">]  </span><span class="s3"># type: ignore[name-defined]</span>

    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">SupportsIndex</span>

    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeGuard  </span><span class="s3"># pyright: ignore[reportUnusedImport]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">TypeGuard  </span><span class="s3"># pyright: ignore[reportUnusedImport]</span>

    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">11</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Self  </span><span class="s3"># pyright: ignore[reportUnusedImport]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Self  </span><span class="s3"># pyright: ignore[reportUnusedImport]</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">npt</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">Self</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">TypeGuard</span><span class="s2">: </span><span class="s1">Any </span><span class="s2">= </span><span class="s0">None</span>

<span class="s1">HashableT </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;HashableT&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">Hashable</span><span class="s2">)</span>
<span class="s1">MutableMappingT </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;MutableMappingT&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">MutableMapping</span><span class="s2">)</span>

<span class="s3"># array-like</span>

<span class="s1">ArrayLike </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;ExtensionArray&quot;</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">]</span>
<span class="s1">AnyArrayLike </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s5">&quot;Index&quot;</span><span class="s2">, </span><span class="s5">&quot;Series&quot;</span><span class="s2">]</span>
<span class="s1">TimeArrayLike </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;DatetimeArray&quot;</span><span class="s2">, </span><span class="s5">&quot;TimedeltaArray&quot;</span><span class="s2">]</span>

<span class="s3"># list-like</span>

<span class="s3"># from https://github.com/hauntsaninja/useful_types</span>
<span class="s3"># includes Sequence-like objects but excludes str and bytes</span>
<span class="s1">_T_co </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;_T_co&quot;</span><span class="s2">, </span><span class="s1">covariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">SequenceNotStr</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">[</span><span class="s1">_T_co</span><span class="s2">]):</span>
    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">SupportsIndex</span><span class="s2">, /) </span><span class="s1">-&gt; _T_co</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">slice</span><span class="s2">, /) </span><span class="s1">-&gt; Sequence</span><span class="s2">[</span><span class="s1">_T_co</span><span class="s2">]:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">__contains__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">object</span><span class="s2">, /) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">_T_co</span><span class="s2">]:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, /, </span><span class="s1">start</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s4">0</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= ...) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">count</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">, /) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">__reversed__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">_T_co</span><span class="s2">]:</span>
        <span class="s2">...</span>


<span class="s1">ListLike </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">AnyArrayLike</span><span class="s2">, </span><span class="s1">SequenceNotStr</span><span class="s2">, </span><span class="s1">range</span><span class="s2">]</span>

<span class="s3"># scalars</span>

<span class="s1">PythonScalar </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">]</span>
<span class="s1">DatetimeLikeScalar </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;Period&quot;</span><span class="s2">, </span><span class="s5">&quot;Timestamp&quot;</span><span class="s2">, </span><span class="s5">&quot;Timedelta&quot;</span><span class="s2">]</span>
<span class="s1">PandasScalar </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;Period&quot;</span><span class="s2">, </span><span class="s5">&quot;Timestamp&quot;</span><span class="s2">, </span><span class="s5">&quot;Timedelta&quot;</span><span class="s2">, </span><span class="s5">&quot;Interval&quot;</span><span class="s2">]</span>
<span class="s1">Scalar </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">PythonScalar</span><span class="s2">, </span><span class="s1">PandasScalar</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">timedelta64</span><span class="s2">, </span><span class="s1">date</span><span class="s2">]</span>
<span class="s1">IntStrT </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;IntStrT&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">])</span>


<span class="s3"># timestamp and timedelta convertible types</span>

<span class="s1">TimestampConvertibleTypes </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s5">&quot;Timestamp&quot;</span><span class="s2">, </span><span class="s1">date</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">str</span>
<span class="s2">]</span>
<span class="s1">TimestampNonexistent </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;shift_forward&quot;</span><span class="s2">, </span><span class="s5">&quot;shift_backward&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;raise&quot;</span><span class="s2">], </span><span class="s1">timedelta</span>
<span class="s2">]</span>
<span class="s1">TimedeltaConvertibleTypes </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s5">&quot;Timedelta&quot;</span><span class="s2">, </span><span class="s1">timedelta</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">timedelta64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">str</span>
<span class="s2">]</span>
<span class="s1">Timezone </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">tzinfo</span><span class="s2">]</span>

<span class="s1">ToTimestampHow </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;s&quot;</span><span class="s2">, </span><span class="s5">&quot;e&quot;</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">]</span>

<span class="s3"># NDFrameT is stricter and ensures that the same subclass of NDFrame always is</span>
<span class="s3"># used. E.g. `def func(a: NDFrameT) -&gt; NDFrameT: ...` means that if a</span>
<span class="s3"># Series is passed into a function, a Series is always returned and if a DataFrame is</span>
<span class="s3"># passed in, a DataFrame is always returned.</span>
<span class="s1">NDFrameT </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;NDFrameT&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s5">&quot;NDFrame&quot;</span><span class="s2">)</span>

<span class="s1">NumpyIndexT </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;NumpyIndexT&quot;</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s5">&quot;Index&quot;</span><span class="s2">)</span>

<span class="s1">AxisInt </span><span class="s2">= </span><span class="s1">int</span>
<span class="s1">Axis </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">AxisInt</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;index&quot;</span><span class="s2">, </span><span class="s5">&quot;columns&quot;</span><span class="s2">, </span><span class="s5">&quot;rows&quot;</span><span class="s2">]]</span>
<span class="s1">IndexLabel </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">]]</span>
<span class="s1">Level </span><span class="s2">= </span><span class="s1">Hashable</span>
<span class="s1">Shape </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, ...]</span>
<span class="s1">Suffixes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">], </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]]</span>
<span class="s1">Ordered </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">]</span>
<span class="s1">JSONSerializable </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">PythonScalar</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">]]</span>
<span class="s1">Frequency </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s5">&quot;BaseOffset&quot;</span><span class="s2">]</span>
<span class="s1">Axes </span><span class="s2">= </span><span class="s1">ListLike</span>

<span class="s1">RandomState </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">int</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">BitGenerator</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># dtypes</span>
<span class="s1">NpDtype </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">type_t</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">object</span><span class="s2">]]]</span>
<span class="s1">Dtype </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;ExtensionDtype&quot;</span><span class="s2">, </span><span class="s1">NpDtype</span><span class="s2">]</span>
<span class="s1">AstypeArg </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;ExtensionDtype&quot;</span><span class="s2">, </span><span class="s5">&quot;npt.DTypeLike&quot;</span><span class="s2">]</span>
<span class="s3"># DtypeArg specifies all allowable dtypes in a functions its dtype argument</span>
<span class="s1">DtypeArg </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Dtype</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Dtype</span><span class="s2">]]</span>
<span class="s1">DtypeObj </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s5">&quot;ExtensionDtype&quot;</span><span class="s2">]</span>

<span class="s3"># converters</span>
<span class="s1">ConvertersArg </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Dtype</span><span class="s2">], </span><span class="s1">Dtype</span><span class="s2">]]</span>

<span class="s3"># parse_dates</span>
<span class="s1">ParseDatesArg </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">bool</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">], </span><span class="s1">list</span><span class="s2">[</span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">]], </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">]]</span>
<span class="s2">]</span>

<span class="s3"># For functions like rename that convert one label to another</span>
<span class="s1">Renamer </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Hashable</span><span class="s2">], </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Hashable</span><span class="s2">]]</span>

<span class="s3"># to maintain type information across generic functions and parametrization</span>
<span class="s1">T </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;T&quot;</span><span class="s2">)</span>

<span class="s3"># used in decorators to preserve the signature of the function it decorates</span>
<span class="s3"># see https://mypy.readthedocs.io/en/stable/generics.html#declaring-decorators</span>
<span class="s1">FuncType </span><span class="s2">= </span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">Any</span><span class="s2">]</span>
<span class="s1">F </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;F&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">FuncType</span><span class="s2">)</span>

<span class="s3"># types of vectorized key functions for DataFrame::sort_values and</span>
<span class="s3"># DataFrame::sort_index, among others</span>
<span class="s1">ValueKeyFunc </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s5">&quot;Series&quot;</span><span class="s2">], </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;Series&quot;</span><span class="s2">, </span><span class="s1">AnyArrayLike</span><span class="s2">]]]</span>
<span class="s1">IndexKeyFunc </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s5">&quot;Index&quot;</span><span class="s2">], </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;Index&quot;</span><span class="s2">, </span><span class="s1">AnyArrayLike</span><span class="s2">]]]</span>

<span class="s3"># types of `func` kwarg for DataFrame.aggregate and Series.aggregate</span>
<span class="s1">AggFuncTypeBase </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]</span>
<span class="s1">AggFuncTypeDict </span><span class="s2">= </span><span class="s1">MutableMapping</span><span class="s2">[</span>
    <span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">]]</span>
<span class="s2">]</span>
<span class="s1">AggFuncType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">AggFuncTypeBase</span><span class="s2">,</span>
    <span class="s1">list</span><span class="s2">[</span><span class="s1">AggFuncTypeBase</span><span class="s2">],</span>
    <span class="s1">AggFuncTypeDict</span><span class="s2">,</span>
<span class="s2">]</span>
<span class="s1">AggObjType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s5">&quot;Series&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;DataFrame&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;GroupBy&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;SeriesGroupBy&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;DataFrameGroupBy&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;BaseWindow&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;Resampler&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s1">PythonFuncType </span><span class="s2">= </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">Any</span><span class="s2">]</span>

<span class="s3"># filenames and file-like-objects</span>
<span class="s1">AnyStr_co </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;AnyStr_co&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">covariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s1">AnyStr_contra </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s5">&quot;AnyStr_contra&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">BaseBuffer</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">mode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s3"># for _get_filepath_or_buffer</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">seek</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">__offset</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">__whence</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= ...) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s3"># with one argument: gzip.GzipFile, bz2.BZ2File</span>
        <span class="s3"># with two arguments: zip.ZipFile, read_sas</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">seekable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3"># for bz2.BZ2File</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">tell</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s3"># for zip.ZipFile, read_stata, to_stata</span>
        <span class="s2">...</span>


<span class="s0">class </span><span class="s1">ReadBuffer</span><span class="s2">(</span><span class="s1">BaseBuffer</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">[</span><span class="s1">AnyStr_co</span><span class="s2">]):</span>
    <span class="s0">def </span><span class="s1">read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">__n</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= ...) </span><span class="s1">-&gt; AnyStr_co</span><span class="s2">:</span>
        <span class="s3"># for BytesIOWrapper, gzip.GzipFile, bz2.BZ2File</span>
        <span class="s2">...</span>


<span class="s0">class </span><span class="s1">WriteBuffer</span><span class="s2">(</span><span class="s1">BaseBuffer</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">[</span><span class="s1">AnyStr_contra</span><span class="s2">]):</span>
    <span class="s0">def </span><span class="s1">write</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">__b</span><span class="s2">: </span><span class="s1">AnyStr_contra</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s3"># for gzip.GzipFile, bz2.BZ2File</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">flush</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s3"># for gzip.GzipFile, bz2.BZ2File</span>
        <span class="s2">...</span>


<span class="s0">class </span><span class="s1">ReadPickleBuffer</span><span class="s2">(</span><span class="s1">ReadBuffer</span><span class="s2">[</span><span class="s1">bytes</span><span class="s2">], </span><span class="s1">Protocol</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">readline</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bytes</span><span class="s2">:</span>
        <span class="s2">...</span>


<span class="s0">class </span><span class="s1">WriteExcelBuffer</span><span class="s2">(</span><span class="s1">WriteBuffer</span><span class="s2">[</span><span class="s1">bytes</span><span class="s2">], </span><span class="s1">Protocol</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">truncate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= ...) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s2">...</span>


<span class="s0">class </span><span class="s1">ReadCsvBuffer</span><span class="s2">(</span><span class="s1">ReadBuffer</span><span class="s2">[</span><span class="s1">AnyStr_co</span><span class="s2">], </span><span class="s1">Protocol</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">AnyStr_co</span><span class="s2">]:</span>
        <span class="s3"># for engine=python</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">fileno</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s3"># for _MMapWrapper</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">readline</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; AnyStr_co</span><span class="s2">:</span>
        <span class="s3"># for engine=python</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">closed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3"># for enine=pyarrow</span>
        <span class="s2">...</span>


<span class="s1">FilePath </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s5">&quot;PathLike[str]&quot;</span><span class="s2">]</span>

<span class="s3"># for arbitrary kwargs passed during reading/writing files</span>
<span class="s1">StorageOptions </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]</span>


<span class="s3"># compression keywords and compression</span>
<span class="s1">CompressionDict </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]</span>
<span class="s1">CompressionOptions </span><span class="s2">= </span><span class="s1">Optional</span><span class="s2">[</span>
    <span class="s1">Union</span><span class="s2">[</span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;infer&quot;</span><span class="s2">, </span><span class="s5">&quot;gzip&quot;</span><span class="s2">, </span><span class="s5">&quot;bz2&quot;</span><span class="s2">, </span><span class="s5">&quot;zip&quot;</span><span class="s2">, </span><span class="s5">&quot;xz&quot;</span><span class="s2">, </span><span class="s5">&quot;zstd&quot;</span><span class="s2">, </span><span class="s5">&quot;tar&quot;</span><span class="s2">], </span><span class="s1">CompressionDict</span><span class="s2">]</span>
<span class="s2">]</span>

<span class="s3"># types in DataFrameFormatter</span>
<span class="s1">FormattersType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">list</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">], </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">, ...], </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">], </span><span class="s1">Callable</span><span class="s2">]</span>
<span class="s2">]</span>
<span class="s1">ColspaceType </span><span class="s2">= </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]]</span>
<span class="s1">FloatFormatType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s5">&quot;EngFormatter&quot;</span><span class="s2">]</span>
<span class="s1">ColspaceArgType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]], </span><span class="s1">Mapping</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]]</span>
<span class="s2">]</span>

<span class="s3"># Arguments for fillna()</span>
<span class="s1">FillnaOptions </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;backfill&quot;</span><span class="s2">, </span><span class="s5">&quot;bfill&quot;</span><span class="s2">, </span><span class="s5">&quot;ffill&quot;</span><span class="s2">, </span><span class="s5">&quot;pad&quot;</span><span class="s2">]</span>
<span class="s1">InterpolateOptions </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span>
    <span class="s5">&quot;linear&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;time&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;index&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;values&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;nearest&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;zero&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;slinear&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;quadratic&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;cubic&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;barycentric&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;polynomial&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;krogh&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;piecewise_polynomial&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;spline&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;pchip&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;akima&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;cubicspline&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;from_derivatives&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># internals</span>
<span class="s1">Manager </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s5">&quot;ArrayManager&quot;</span><span class="s2">, </span><span class="s5">&quot;SingleArrayManager&quot;</span><span class="s2">, </span><span class="s5">&quot;BlockManager&quot;</span><span class="s2">, </span><span class="s5">&quot;SingleBlockManager&quot;</span>
<span class="s2">]</span>
<span class="s1">SingleManager </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;SingleArrayManager&quot;</span><span class="s2">, </span><span class="s5">&quot;SingleBlockManager&quot;</span><span class="s2">]</span>
<span class="s1">Manager2D </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s5">&quot;ArrayManager&quot;</span><span class="s2">, </span><span class="s5">&quot;BlockManager&quot;</span><span class="s2">]</span>

<span class="s3"># indexing</span>
<span class="s3"># PositionalIndexer -&gt; valid 1D positional indexer, e.g. can pass</span>
<span class="s3"># to ndarray.__getitem__</span>
<span class="s3"># ScalarIndexer is for a single value as the index</span>
<span class="s3"># SequenceIndexer is for list like or slices (but not tuples)</span>
<span class="s3"># PositionalIndexerTuple is extends the PositionalIndexer for 2D arrays</span>
<span class="s3"># These are used in various __getitem__ overloads</span>
<span class="s3"># TODO(typing#684): add Ellipsis, see</span>
<span class="s3"># https://github.com/python/typing/issues/684#issuecomment-548203158</span>
<span class="s3"># https://bugs.python.org/issue41810</span>
<span class="s3"># Using List[int] here rather than Sequence[int] to disallow tuples.</span>
<span class="s1">ScalarIndexer </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">]</span>
<span class="s1">SequenceIndexer </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">]</span>
<span class="s1">PositionalIndexer </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">ScalarIndexer</span><span class="s2">, </span><span class="s1">SequenceIndexer</span><span class="s2">]</span>
<span class="s1">PositionalIndexerTuple </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">PositionalIndexer</span><span class="s2">, </span><span class="s1">PositionalIndexer</span><span class="s2">]</span>
<span class="s1">PositionalIndexer2D </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">PositionalIndexer</span><span class="s2">, </span><span class="s1">PositionalIndexerTuple</span><span class="s2">]</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s1">TakeIndexer </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">], </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">]]</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">TakeIndexer </span><span class="s2">= </span><span class="s1">Any</span>

<span class="s3"># Shared by functions such as drop and astype</span>
<span class="s1">IgnoreRaise </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s5">&quot;raise&quot;</span><span class="s2">]</span>

<span class="s3"># Windowing rank methods</span>
<span class="s1">WindowingRankType </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;average&quot;</span><span class="s2">, </span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s5">&quot;max&quot;</span><span class="s2">]</span>

<span class="s3"># read_csv engines</span>
<span class="s1">CSVEngine </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;c&quot;</span><span class="s2">, </span><span class="s5">&quot;python&quot;</span><span class="s2">, </span><span class="s5">&quot;pyarrow&quot;</span><span class="s2">, </span><span class="s5">&quot;python-fwf&quot;</span><span class="s2">]</span>

<span class="s3"># read_json engines</span>
<span class="s1">JSONEngine </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;ujson&quot;</span><span class="s2">, </span><span class="s5">&quot;pyarrow&quot;</span><span class="s2">]</span>

<span class="s3"># read_xml parsers</span>
<span class="s1">XMLParsers </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;lxml&quot;</span><span class="s2">, </span><span class="s5">&quot;etree&quot;</span><span class="s2">]</span>

<span class="s3"># read_html flavors</span>
<span class="s1">HTMLFlavors </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;lxml&quot;</span><span class="s2">, </span><span class="s5">&quot;html5lib&quot;</span><span class="s2">, </span><span class="s5">&quot;bs4&quot;</span><span class="s2">]</span>

<span class="s3"># Interval closed type</span>
<span class="s1">IntervalLeftRight </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">]</span>
<span class="s1">IntervalClosedType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">IntervalLeftRight</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;both&quot;</span><span class="s2">, </span><span class="s5">&quot;neither&quot;</span><span class="s2">]]</span>

<span class="s3"># datetime and NaTType</span>
<span class="s1">DatetimeNaTType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">datetime</span><span class="s2">, </span><span class="s5">&quot;NaTType&quot;</span><span class="s2">]</span>
<span class="s1">DateTimeErrorChoices </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">IgnoreRaise</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;coerce&quot;</span><span class="s2">]]</span>

<span class="s3"># sort_index</span>
<span class="s1">SortKind </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;quicksort&quot;</span><span class="s2">, </span><span class="s5">&quot;mergesort&quot;</span><span class="s2">, </span><span class="s5">&quot;heapsort&quot;</span><span class="s2">, </span><span class="s5">&quot;stable&quot;</span><span class="s2">]</span>
<span class="s1">NaPosition </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s5">&quot;last&quot;</span><span class="s2">]</span>

<span class="s3"># Arguments for nsmalles and n_largest</span>
<span class="s1">NsmallestNlargestKeep </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s5">&quot;all&quot;</span><span class="s2">]</span>

<span class="s3"># quantile interpolation</span>
<span class="s1">QuantileInterpolation </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;linear&quot;</span><span class="s2">, </span><span class="s5">&quot;lower&quot;</span><span class="s2">, </span><span class="s5">&quot;higher&quot;</span><span class="s2">, </span><span class="s5">&quot;midpoint&quot;</span><span class="s2">, </span><span class="s5">&quot;nearest&quot;</span><span class="s2">]</span>

<span class="s3"># plotting</span>
<span class="s1">PlottingOrientation </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;horizontal&quot;</span><span class="s2">, </span><span class="s5">&quot;vertical&quot;</span><span class="s2">]</span>

<span class="s3"># dropna</span>
<span class="s1">AnyAll </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;any&quot;</span><span class="s2">, </span><span class="s5">&quot;all&quot;</span><span class="s2">]</span>

<span class="s3"># merge</span>
<span class="s1">MergeHow </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;inner&quot;</span><span class="s2">, </span><span class="s5">&quot;outer&quot;</span><span class="s2">, </span><span class="s5">&quot;cross&quot;</span><span class="s2">]</span>
<span class="s1">MergeValidate </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span>
    <span class="s5">&quot;one_to_one&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;1:1&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;one_to_many&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;1:m&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;many_to_one&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;m:1&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;many_to_many&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;m:m&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># join</span>
<span class="s1">JoinHow </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;inner&quot;</span><span class="s2">, </span><span class="s5">&quot;outer&quot;</span><span class="s2">]</span>
<span class="s1">JoinValidate </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span>
    <span class="s5">&quot;one_to_one&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;1:1&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;one_to_many&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;1:m&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;many_to_one&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;m:1&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;many_to_many&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;m:m&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># reindex</span>
<span class="s1">ReindexMethod </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">FillnaOptions</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;nearest&quot;</span><span class="s2">]]</span>

<span class="s1">MatplotlibColor </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">float</span><span class="s2">]]</span>
<span class="s1">TimeGrouperOrigin </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s5">&quot;Timestamp&quot;</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;epoch&quot;</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;start_day&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;end_day&quot;</span><span class="s2">]</span>
<span class="s2">]</span>
<span class="s1">TimeAmbiguous </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;infer&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;raise&quot;</span><span class="s2">], </span><span class="s5">&quot;npt.NDArray[np.bool_]&quot;</span><span class="s2">]</span>
<span class="s1">TimeNonexistent </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;shift_forward&quot;</span><span class="s2">, </span><span class="s5">&quot;shift_backward&quot;</span><span class="s2">, </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;raise&quot;</span><span class="s2">], </span><span class="s1">timedelta</span>
<span class="s2">]</span>
<span class="s1">DropKeep </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">]</span>
<span class="s1">CorrelationMethod </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;pearson&quot;</span><span class="s2">, </span><span class="s5">&quot;kendall&quot;</span><span class="s2">, </span><span class="s5">&quot;spearman&quot;</span><span class="s2">], </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">], </span><span class="s1">float</span><span class="s2">]</span>
<span class="s2">]</span>
<span class="s1">AlignJoin </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;outer&quot;</span><span class="s2">, </span><span class="s5">&quot;inner&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">]</span>
<span class="s1">DtypeBackend </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;pyarrow&quot;</span><span class="s2">, </span><span class="s5">&quot;numpy_nullable&quot;</span><span class="s2">]</span>

<span class="s1">TimeUnit </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;s&quot;</span><span class="s2">, </span><span class="s5">&quot;ms&quot;</span><span class="s2">, </span><span class="s5">&quot;us&quot;</span><span class="s2">, </span><span class="s5">&quot;ns&quot;</span><span class="s2">]</span>
<span class="s1">OpenFileErrors </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span>
    <span class="s5">&quot;strict&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;ignore&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;replace&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;surrogateescape&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;xmlcharrefreplace&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;backslashreplace&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;namereplace&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># update</span>
<span class="s1">UpdateJoin </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">]</span>

<span class="s3"># applymap</span>
<span class="s1">NaAction </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;ignore&quot;</span><span class="s2">]</span>

<span class="s3"># from_dict</span>
<span class="s1">FromDictOrient </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;columns&quot;</span><span class="s2">, </span><span class="s5">&quot;index&quot;</span><span class="s2">, </span><span class="s5">&quot;tight&quot;</span><span class="s2">]</span>

<span class="s3"># to_gbc</span>
<span class="s1">ToGbqIfexist </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;fail&quot;</span><span class="s2">, </span><span class="s5">&quot;replace&quot;</span><span class="s2">, </span><span class="s5">&quot;append&quot;</span><span class="s2">]</span>

<span class="s3"># to_stata</span>
<span class="s1">ToStataByteorder </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s5">&quot;&lt;&quot;</span><span class="s2">, </span><span class="s5">&quot;little&quot;</span><span class="s2">, </span><span class="s5">&quot;big&quot;</span><span class="s2">]</span>

<span class="s3"># ExcelWriter</span>
<span class="s1">ExcelWriterIfSheetExists </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;error&quot;</span><span class="s2">, </span><span class="s5">&quot;new&quot;</span><span class="s2">, </span><span class="s5">&quot;replace&quot;</span><span class="s2">, </span><span class="s5">&quot;overlay&quot;</span><span class="s2">]</span>

<span class="s3"># Offsets</span>
<span class="s1">OffsetCalendar </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">busdaycalendar</span><span class="s2">, </span><span class="s5">&quot;AbstractHolidayCalendar&quot;</span><span class="s2">]</span>

<span class="s3"># read_csv: usecols</span>
<span class="s1">UsecolsArgType </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span>
    <span class="s1">SequenceNotStr</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">],</span>
    <span class="s1">range</span><span class="s2">,</span>
    <span class="s1">AnyArrayLike</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">[[</span><span class="s1">HashableT</span><span class="s2">], </span><span class="s1">bool</span><span class="s2">],</span>
    <span class="s0">None</span><span class="s2">,</span>
<span class="s2">]</span>
</pre>
</body>
</html>