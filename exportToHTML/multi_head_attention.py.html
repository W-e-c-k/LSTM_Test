<html>
<head>
<title>multi_head_attention.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multi_head_attention.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">string</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">constraints</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">initializers</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">regularizers</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">activations</span><span class="s2">.</span><span class="s1">softmax </span><span class="s0">import </span><span class="s1">Softmax</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">einsum_dense </span><span class="s0">import </span><span class="s1">EinsumDense</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">layer </span><span class="s0">import </span><span class="s1">Layer</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">layers</span><span class="s2">.</span><span class="s1">regularization</span><span class="s2">.</span><span class="s1">dropout </span><span class="s0">import </span><span class="s1">Dropout</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.layers.MultiHeadAttention&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MultiHeadAttention</span><span class="s2">(</span><span class="s1">Layer</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;MultiHeadAttention layer. 
 
    This is an implementation of multi-headed attention as described in the 
    paper &quot;Attention is all you Need&quot; 
    [Vaswani et al., 2017](https://arxiv.org/abs/1706.03762). 
    If `query`, `key,` `value` are the same, then 
    this is self-attention. Each timestep in `query` attends to the 
    corresponding sequence in `key`, and returns a fixed-width vector. 
 
    This layer first projects `query`, `key` and `value`. These are 
    (effectively) a list of tensors of length `num_attention_heads`, where the 
    corresponding shapes are `(batch_size, &lt;query dimensions&gt;, key_dim)`, 
    `(batch_size, &lt;key/value dimensions&gt;, key_dim)`, 
    `(batch_size, &lt;key/value dimensions&gt;, value_dim)`. 
 
    Then, the query and key tensors are dot-producted and scaled. These are 
    softmaxed to obtain attention probabilities. The value tensors are then 
    interpolated by these probabilities, then concatenated back to a single 
    tensor. 
 
    Finally, the result tensor with the last dimension as `value_dim` can take 
    a linear projection and return. 
 
    Args: 
        num_heads: Number of attention heads. 
        key_dim: Size of each attention head for query and key. 
        value_dim: Size of each attention head for value. 
        dropout: Dropout probability. 
        use_bias: Boolean, whether the dense layers use bias vectors/matrices. 
        output_shape: The expected shape of an output tensor, besides the batch 
            and sequence dims. If not specified, projects back to the query 
            feature dim (the query input's last dimension). 
        attention_axes: axes over which the attention is applied. `None` means 
            attention over all axes, but batch, heads, and features. 
        kernel_initializer: Initializer for dense layer kernels. 
        bias_initializer: Initializer for dense layer biases. 
        kernel_regularizer: Regularizer for dense layer kernels. 
        bias_regularizer: Regularizer for dense layer biases. 
        activity_regularizer: Regularizer for dense layer activity. 
        kernel_constraint: Constraint for dense layer kernels. 
        bias_constraint: Constraint for dense layer kernels. 
        seed: Optional integer to seed the dropout layer. 
 
    Call arguments: 
        query: Query tensor of shape `(B, T, dim)`, where `B` is the batch size, 
            `T` is the target sequence length, and dim is the feature dimension. 
        value: Value tensor of shape `(B, S, dim)`, where `B` is the batch size, 
            `S` is the source sequence length, and dim is the feature dimension. 
        key: Optional key tensor of shape `(B, S, dim)`. If not given, will 
            use `value` for both `key` and `value`, which is the most common 
            case. 
        attention_mask: a boolean mask of shape `(B, T, S)`, that prevents 
            attention to certain positions. The boolean mask specifies which 
            query elements can attend to which key elements, 1 indicates 
            attention and 0 indicates no attention. Broadcasting can happen for 
            the missing batch dimensions and the head dimension. 
        return_attention_scores: A boolean to indicate whether the output should 
            be `(attention_output, attention_scores)` if `True`, or 
            `attention_output` if `False`. Defaults to `False`. 
        training: Python boolean indicating whether the layer should behave in 
            training mode (adding dropout) or in inference mode (no dropout). 
            Will go with either using the training mode of the parent 
            layer/model, or `False` (inference) if there is no parent layer. 
        use_causal_mask: A boolean to indicate whether to apply a causal mask to 
            prevent tokens from attending to future tokens (e.g., used in a 
            decoder Transformer). 
 
    Returns: 
        attention_output: The result of the computation, of shape `(B, T, E)`, 
            where `T` is for target sequence shapes and `E` is the query input 
            last dimension if `output_shape` is `None`. Otherwise, the 
            multi-head outputs are projected to the shape specified by 
            `output_shape`. 
        attention_scores: (Optional) multi-head attention coefficients over 
            attention axes. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">num_heads</span><span class="s2">,</span>
        <span class="s1">key_dim</span><span class="s2">,</span>
        <span class="s1">value_dim</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dropout</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
        <span class="s1">use_bias</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">output_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">attention_axes</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">kernel_initializer</span><span class="s2">=</span><span class="s3">&quot;glorot_uniform&quot;</span><span class="s2">,</span>
        <span class="s1">bias_initializer</span><span class="s2">=</span><span class="s3">&quot;zeros&quot;</span><span class="s2">,</span>
        <span class="s1">kernel_regularizer</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">bias_regularizer</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">activity_regularizer</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">kernel_constraint</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">bias_constraint</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">seed</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">supports_masking </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads </span><span class="s2">= </span><span class="s1">num_heads</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim </span><span class="s2">= </span><span class="s1">key_dim</span>
        <span class="s6"># Cache 1.0 / math.sqrt(self._key_dim).</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inverse_sqrt_key_dim </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dim </span><span class="s2">= </span><span class="s1">value_dim </span><span class="s0">if </span><span class="s1">value_dim </span><span class="s0">else </span><span class="s1">key_dim</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout </span><span class="s2">= </span><span class="s1">dropout</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias </span><span class="s2">= </span><span class="s1">use_bias</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape </span><span class="s2">= </span><span class="s1">output_shape</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_initializer </span><span class="s2">= </span><span class="s1">initializers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">kernel_initializer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_initializer </span><span class="s2">= </span><span class="s1">initializers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">bias_initializer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_regularizer </span><span class="s2">= </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">kernel_regularizer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_regularizer </span><span class="s2">= </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">bias_regularizer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_activity_regularizer </span><span class="s2">= </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">activity_regularizer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_constraint </span><span class="s2">= </span><span class="s1">constraints</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">kernel_constraint</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_constraint </span><span class="s2">= </span><span class="s1">constraints</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">bias_constraint</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attention_axes</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s1">attention_axes </span><span class="s2">= (</span><span class="s1">attention_axes</span><span class="s2">,)</span>
        <span class="s0">elif </span><span class="s1">attention_axes </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attention_axes</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;`attention_axes` must be an int, list, or tuple.&quot;</span>
                <span class="s3">f&quot;Received: attention_axes=</span><span class="s0">{</span><span class="s1">attention_axes</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes </span><span class="s2">= </span><span class="s1">attention_axes</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">seed </span><span class="s2">= </span><span class="s1">seed</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">num_heads</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key_dim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">value_dim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dim</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">dropout</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">use_bias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">output_shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">attention_axes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">base_config </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">config </span><span class="s2">= {</span>
            <span class="s3">&quot;num_heads&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads</span><span class="s2">,</span>
            <span class="s3">&quot;key_dim&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim</span><span class="s2">,</span>
            <span class="s3">&quot;value_dim&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dim</span><span class="s2">,</span>
            <span class="s3">&quot;dropout&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout</span><span class="s2">,</span>
            <span class="s3">&quot;use_bias&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias</span><span class="s2">,</span>
            <span class="s3">&quot;output_shape&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span><span class="s2">,</span>
            <span class="s3">&quot;attention_axes&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span><span class="s2">,</span>
            <span class="s3">&quot;kernel_initializer&quot;</span><span class="s2">: </span><span class="s1">initializers</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_initializer</span>
            <span class="s2">),</span>
            <span class="s3">&quot;bias_initializer&quot;</span><span class="s2">: </span><span class="s1">initializers</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_initializer</span><span class="s2">),</span>
            <span class="s3">&quot;kernel_regularizer&quot;</span><span class="s2">: </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_regularizer</span>
            <span class="s2">),</span>
            <span class="s3">&quot;bias_regularizer&quot;</span><span class="s2">: </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_regularizer</span><span class="s2">),</span>
            <span class="s3">&quot;activity_regularizer&quot;</span><span class="s2">: </span><span class="s1">regularizers</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_activity_regularizer</span>
            <span class="s2">),</span>
            <span class="s3">&quot;kernel_constraint&quot;</span><span class="s2">: </span><span class="s1">constraints</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_constraint</span><span class="s2">),</span>
            <span class="s3">&quot;bias_constraint&quot;</span><span class="s2">: </span><span class="s1">constraints</span><span class="s2">.</span><span class="s1">serialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_constraint</span><span class="s2">),</span>
            <span class="s3">&quot;seed&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s0">return </span><span class="s2">{**</span><span class="s1">base_config</span><span class="s2">, **</span><span class="s1">config</span><span class="s2">}</span>

    <span class="s0">def </span><span class="s1">build</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">query_shape</span><span class="s2">,</span>
        <span class="s1">value_shape</span><span class="s2">,</span>
        <span class="s1">key_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Builds layers and variables. 
 
        Args: 
            query_shape: Shape of the `query` tensor. 
            value_shape: Shape of the `value` tensor. 
            key: Optional shape of the `key` tensor. 
        &quot;&quot;&quot;</span>
        <span class="s1">key_shape </span><span class="s2">= </span><span class="s1">value_shape </span><span class="s0">if </span><span class="s1">key_shape </span><span class="s0">is None else </span><span class="s1">key_shape</span>

        <span class="s0">if </span><span class="s1">query_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">value_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;The last dimension of `query_shape` and `value_shape` &quot;</span>
                <span class="s3">f&quot;must be equal, but are </span><span class="s0">{</span><span class="s1">query_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">value_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s3">. &quot;</span>
                <span class="s3">&quot;Received: query_shape={query_shape}, value_shape={value_shape}&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">value_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">key_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;All dimensions of `value` and `key`, except the last one, &quot;</span>
                <span class="s3">f&quot;must be equal. Received: value_shape=</span><span class="s0">{</span><span class="s1">value_shape</span><span class="s0">} </span><span class="s3">and &quot;</span>
                <span class="s3">f&quot;key_shape=</span><span class="s0">{</span><span class="s1">key_shape</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>

        <span class="s1">query_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">query_shape</span><span class="s2">)</span>
        <span class="s1">value_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">value_shape</span><span class="s2">)</span>
        <span class="s1">key_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">key_shape</span><span class="s2">)</span>
        <span class="s1">einsum_equation</span><span class="s2">, </span><span class="s1">bias_axes</span><span class="s2">, </span><span class="s1">output_rank </span><span class="s2">= </span><span class="s1">_build_proj_equation</span><span class="s2">(</span>
            <span class="s1">query_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">bound_dims</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">output_dims</span><span class="s2">=</span><span class="s5">2</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_query_dense </span><span class="s2">= </span><span class="s1">EinsumDense</span><span class="s2">(</span>
            <span class="s1">einsum_equation</span><span class="s2">,</span>
            <span class="s1">output_shape</span><span class="s2">=</span><span class="s1">_get_output_shape</span><span class="s2">(</span>
                <span class="s1">output_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim</span><span class="s2">]</span>
            <span class="s2">),</span>
            <span class="s1">bias_axes</span><span class="s2">=</span><span class="s1">bias_axes </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias </span><span class="s0">else None</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;query&quot;</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_common_kwargs_for_sublayer</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_query_dense</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">query_shape</span><span class="s2">)</span>
        <span class="s1">einsum_equation</span><span class="s2">, </span><span class="s1">bias_axes</span><span class="s2">, </span><span class="s1">output_rank </span><span class="s2">= </span><span class="s1">_build_proj_equation</span><span class="s2">(</span>
            <span class="s1">key_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">bound_dims</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">output_dims</span><span class="s2">=</span><span class="s5">2</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dense </span><span class="s2">= </span><span class="s1">EinsumDense</span><span class="s2">(</span>
            <span class="s1">einsum_equation</span><span class="s2">,</span>
            <span class="s1">output_shape</span><span class="s2">=</span><span class="s1">_get_output_shape</span><span class="s2">(</span>
                <span class="s1">output_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim</span><span class="s2">]</span>
            <span class="s2">),</span>
            <span class="s1">bias_axes</span><span class="s2">=</span><span class="s1">bias_axes </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias </span><span class="s0">else None</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;key&quot;</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_common_kwargs_for_sublayer</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dense</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">key_shape</span><span class="s2">)</span>
        <span class="s1">einsum_equation</span><span class="s2">, </span><span class="s1">bias_axes</span><span class="s2">, </span><span class="s1">output_rank </span><span class="s2">= </span><span class="s1">_build_proj_equation</span><span class="s2">(</span>
            <span class="s1">value_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">bound_dims</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">output_dims</span><span class="s2">=</span><span class="s5">2</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dense </span><span class="s2">= </span><span class="s1">EinsumDense</span><span class="s2">(</span>
            <span class="s1">einsum_equation</span><span class="s2">,</span>
            <span class="s1">output_shape</span><span class="s2">=</span><span class="s1">_get_output_shape</span><span class="s2">(</span>
                <span class="s1">output_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_num_heads</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dim</span><span class="s2">]</span>
            <span class="s2">),</span>
            <span class="s1">bias_axes</span><span class="s2">=</span><span class="s1">bias_axes </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias </span><span class="s0">else None</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;value&quot;</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_common_kwargs_for_sublayer</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dense</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">value_shape</span><span class="s2">)</span>

        <span class="s6"># Builds the attention computations for multi-head dot product</span>
        <span class="s6"># attention.  These computations could be wrapped into the keras</span>
        <span class="s6"># attention layer once it supports multi-head einsum computations.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_build_attention</span><span class="s2">(</span><span class="s1">output_rank</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_output_dense </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_make_output_dense</span><span class="s2">(</span>
            <span class="s1">query_shape</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_common_kwargs_for_sublayer</span><span class="s2">(),</span>
            <span class="s3">&quot;attention_output&quot;</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">output_dense_input_shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_query_dense</span><span class="s2">.</span><span class="s1">compute_output_shape</span><span class="s2">(</span><span class="s1">query_shape</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">output_dense_input_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dim</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_output_dense</span><span class="s2">.</span><span class="s1">build</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">output_dense_input_shape</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">built </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">query_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_query_dense</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dense</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">value_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dense</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">output_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_dense</span>

    <span class="s0">def </span><span class="s1">_get_common_kwargs_for_sublayer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">common_kwargs </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span>
            <span class="s1">kernel_regularizer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_regularizer</span><span class="s2">,</span>
            <span class="s1">bias_regularizer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_regularizer</span><span class="s2">,</span>
            <span class="s1">activity_regularizer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_activity_regularizer</span><span class="s2">,</span>
            <span class="s1">kernel_constraint</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_constraint</span><span class="s2">,</span>
            <span class="s1">bias_constraint</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_constraint</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype_policy</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s6"># Create new clone of kernel/bias initializer, so that we don't reuse</span>
        <span class="s6"># the initializer instance, which could lead to same init value since</span>
        <span class="s6"># initializer is stateless.</span>
        <span class="s1">kernel_initializer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_initializer</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">from_config</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_kernel_initializer</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s2">)</span>
        <span class="s1">bias_initializer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_initializer</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">from_config</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_bias_initializer</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s2">)</span>
        <span class="s1">common_kwargs</span><span class="s2">[</span><span class="s3">&quot;kernel_initializer&quot;</span><span class="s2">] = </span><span class="s1">kernel_initializer</span>
        <span class="s1">common_kwargs</span><span class="s2">[</span><span class="s3">&quot;bias_initializer&quot;</span><span class="s2">] = </span><span class="s1">bias_initializer</span>
        <span class="s0">return </span><span class="s1">common_kwargs</span>

    <span class="s0">def </span><span class="s1">_make_output_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">query_shape</span><span class="s2">, </span><span class="s1">common_kwargs</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Builds the output projection matrix. 
 
        Args: 
            free_dims: Number of free dimensions for einsum equation building. 
            common_kwargs: Common keyword arguments for einsum layer. 
            name: Name for the projection layer. 
 
        Returns: 
            Projection layer. 
        &quot;&quot;&quot;</span>
        <span class="s1">query_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">query_shape</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Sized</span><span class="s2">):</span>
                <span class="s1">output_shape </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">output_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">output_shape </span><span class="s2">= [</span><span class="s1">query_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]]</span>
        <span class="s1">einsum_equation</span><span class="s2">, </span><span class="s1">bias_axes</span><span class="s2">, </span><span class="s1">output_rank </span><span class="s2">= </span><span class="s1">_build_proj_equation</span><span class="s2">(</span>
            <span class="s1">query_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">bound_dims</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">output_dims</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">output_shape</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">EinsumDense</span><span class="s2">(</span>
            <span class="s1">einsum_equation</span><span class="s2">,</span>
            <span class="s1">output_shape</span><span class="s2">=</span><span class="s1">_get_output_shape</span><span class="s2">(</span><span class="s1">output_rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">output_shape</span><span class="s2">),</span>
            <span class="s1">bias_axes</span><span class="s2">=</span><span class="s1">bias_axes </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_use_bias </span><span class="s0">else None</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">common_kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_build_attention</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Builds multi-head dot-product attention computations. 
 
        This function builds attributes necessary for `_compute_attention` to 
        customize attention computation to replace the default dot-product 
        attention. 
 
        Args: 
            rank: the rank of query, key, value tensors. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">rank </span><span class="s2">- </span><span class="s5">2</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span><span class="s2">)</span>
        <span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_dot_product_equation</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_combine_equation</span><span class="s2">,</span>
            <span class="s1">attn_scores_rank</span><span class="s2">,</span>
        <span class="s2">) = </span><span class="s1">_build_attention_equation</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">, </span><span class="s1">attn_axes</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span><span class="s2">)</span>
        <span class="s1">norm_axes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
            <span class="s1">range</span><span class="s2">(</span>
                <span class="s1">attn_scores_rank </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span><span class="s2">), </span><span class="s1">attn_scores_rank</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_softmax </span><span class="s2">= </span><span class="s1">Softmax</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">norm_axes</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype_policy</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout_layer </span><span class="s2">= </span><span class="s1">Dropout</span><span class="s2">(</span>
            <span class="s1">rate</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype_policy</span><span class="s2">, </span><span class="s1">seed</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">seed</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_inverse_sqrt_key_dim </span><span class="s2">= </span><span class="s5">1.0 </span><span class="s2">/ </span><span class="s1">math</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">float</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dim</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_masked_softmax</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attention_scores</span><span class="s2">, </span><span class="s1">attention_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6"># Normalize the attention scores to probabilities.</span>
        <span class="s6"># attention_scores = [B, N, T, S]</span>
        <span class="s0">if </span><span class="s1">attention_mask </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s6"># The expand dim happens starting from the `num_heads` dimension,</span>
            <span class="s6"># (&lt;batch_dims&gt;, num_heads, &lt;query_attention_dims,</span>
            <span class="s6"># key_attention_dims&gt;)</span>
            <span class="s1">mask_expansion_axis </span><span class="s2">= -</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attention_axes</span><span class="s2">) * </span><span class="s5">2 </span><span class="s2">- </span><span class="s5">1</span>
            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span>
                <span class="s1">len</span><span class="s2">(</span><span class="s1">attention_scores</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) - </span><span class="s1">len</span><span class="s2">(</span><span class="s1">attention_mask</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s1">attention_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span>
                    <span class="s1">attention_mask</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">mask_expansion_axis</span>
                <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_softmax</span><span class="s2">(</span><span class="s1">attention_scores</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">attention_mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_compute_attention</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">attention_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">training</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Applies Dot-product attention with query, key, value tensors. 
 
        This function defines the computation inside `call` with projected 
        multi-head Q, K, V inputs. Users can override this function for 
        customized attention implementation. 
 
        Args: 
            query: Projected query tensor of shape `(B, T, N, key_dim)`. 
            key: Projected key tensor of shape `(B, S, N, key_dim)`. 
            value: Projected value tensor of shape `(B, S, N, value_dim)`. 
            attention_mask: a boolean mask of shape `(B, T, S)`, that prevents 
                attention to certain positions. It is generally not needed if 
                the `query` and `value` (and/or `key`) are masked. 
            training: Python boolean indicating whether the layer should behave 
                in training mode (adding dropout) or in inference mode (doing 
                nothing). 
 
        Returns: 
          attention_output: Multi-headed outputs of attention computation. 
          attention_scores: Multi-headed attention weights. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Note: Applying scalar multiply at the smaller end of einsum improves</span>
        <span class="s6"># XLA performance, but may introduce slight numeric differences in</span>
        <span class="s6"># the Transformer attention head.</span>
        <span class="s1">query </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span>
            <span class="s1">query</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inverse_sqrt_key_dim</span><span class="s2">, </span><span class="s1">query</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s6"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw</span>
        <span class="s6"># attention scores.</span>
        <span class="s1">attention_scores </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dot_product_equation</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">query</span><span class="s2">)</span>

        <span class="s1">attention_scores </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_masked_softmax</span><span class="s2">(</span>
            <span class="s1">attention_scores</span><span class="s2">, </span><span class="s1">attention_mask</span>
        <span class="s2">)</span>

        <span class="s6"># This is actually dropping out entire tokens to attend to, which might</span>
        <span class="s6"># seem a bit unusual, but is taken from the original Transformer paper.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dropout</span><span class="s2">:</span>
            <span class="s1">final_attn_scores </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dropout_layer</span><span class="s2">(</span>
                <span class="s1">attention_scores</span><span class="s2">, </span><span class="s1">training</span><span class="s2">=</span><span class="s1">training</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">final_attn_scores </span><span class="s2">= </span><span class="s1">attention_scores</span>

        <span class="s6"># `context_layer` = [B, T, N, H]</span>
        <span class="s1">attention_output </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_combine_equation</span><span class="s2">, </span><span class="s1">final_attn_scores</span><span class="s2">, </span><span class="s1">value</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">attention_output</span><span class="s2">, </span><span class="s1">attention_scores</span>

    <span class="s0">def </span><span class="s1">call</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">query</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">key</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">query_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">value_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">key_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">attention_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">return_attention_scores</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">training</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">use_causal_mask</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">value</span>

        <span class="s1">attention_mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_attention_mask</span><span class="s2">(</span>
            <span class="s1">query</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">query_mask</span><span class="s2">=</span><span class="s1">query_mask</span><span class="s2">,</span>
            <span class="s1">value_mask</span><span class="s2">=</span><span class="s1">value_mask</span><span class="s2">,</span>
            <span class="s1">key_mask</span><span class="s2">=</span><span class="s1">key_mask</span><span class="s2">,</span>
            <span class="s1">attention_mask</span><span class="s2">=</span><span class="s1">attention_mask</span><span class="s2">,</span>
            <span class="s1">use_causal_mask</span><span class="s2">=</span><span class="s1">use_causal_mask</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s6">#   N = `num_attention_heads`</span>
        <span class="s6">#   H = `size_per_head`</span>
        <span class="s6"># `query` = [B, T, N ,H]</span>
        <span class="s1">query </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_query_dense</span><span class="s2">(</span><span class="s1">query</span><span class="s2">)</span>

        <span class="s6"># `key` = [B, S, N, H]</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_dense</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s6"># `value` = [B, S, N, H]</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_dense</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

        <span class="s1">attention_output</span><span class="s2">, </span><span class="s1">attention_scores </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_attention</span><span class="s2">(</span>
            <span class="s1">query</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">attention_mask</span><span class="s2">, </span><span class="s1">training</span>
        <span class="s2">)</span>
        <span class="s1">attention_output </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_dense</span><span class="s2">(</span><span class="s1">attention_output</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">return_attention_scores</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">attention_output</span><span class="s2">, </span><span class="s1">attention_scores</span>
        <span class="s0">return </span><span class="s1">attention_output</span>

    <span class="s0">def </span><span class="s1">_compute_attention_mask</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">query</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">query_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">value_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">key_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">attention_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">use_causal_mask</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Computes the attention mask, using the Keras masks of the inputs. 
 
        * The `query`'s mask is reshaped from [B, T] to [B, T, 1]. 
        * The `value`'s mask is reshaped from [B, S] to [B, 1, S]. 
        * The `key`'s mask is reshaped from [B, S] to [B, 1, S]. The `key`'s 
          mask is ignored if `key` is `None` or if `key is value`. 
        * If `use_causal_mask=True`, then the causal mask is computed. Its shape 
          is [1, T, S]. 
 
        All defined masks are merged using a logical AND operation (`&amp;`). 
 
        In general, if the `query` and `value` are masked, then there is no need 
        to define the `attention_mask`. 
 
        Args: 
            query: Projected query tensor of shape `(B, T, N, key_dim)`. 
            key: Projected key tensor of shape `(B, T, N, key_dim)`. 
            value: Projected value tensor of shape `(B, T, N, value_dim)`. 
            attention_mask: a boolean mask of shape `(B, T, S)`, that prevents 
                attention to certain positions. 
            use_causal_mask: A boolean to indicate whether to apply a causal 
                mask to prevent tokens from attending to future tokens (e.g., 
                used in a decoder Transformer). 
 
        Returns: 
            attention_mask: a boolean mask of shape `(B, T, S)`, that prevents 
                attention to certain positions, based on the Keras masks of the 
                `query`, `key`, `value`, and `attention_mask` tensors, and the 
                causal mask if `use_causal_mask=True`. 
        &quot;&quot;&quot;</span>
        <span class="s1">auto_mask </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">query_mask </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">query_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">query_mask</span><span class="s2">, </span><span class="s3">&quot;bool&quot;</span><span class="s2">)  </span><span class="s6"># defensive casting</span>
            <span class="s6"># B = batch size, T = max query length</span>
            <span class="s1">auto_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">query_mask</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)  </span><span class="s6"># shape is [B, T, 1]</span>
        <span class="s0">if </span><span class="s1">value_mask </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">value_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">value_mask</span><span class="s2">, </span><span class="s3">&quot;bool&quot;</span><span class="s2">)  </span><span class="s6"># defensive casting</span>
            <span class="s6"># B = batch size, S == max value length</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">value_mask</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">)  </span><span class="s6"># shape is [B, 1, S]</span>
            <span class="s1">auto_mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s0">if </span><span class="s1">auto_mask </span><span class="s0">is None else </span><span class="s1">auto_mask </span><span class="s2">&amp; </span><span class="s1">mask</span>
        <span class="s0">if </span><span class="s1">key_mask </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">key_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">key_mask</span><span class="s2">, </span><span class="s3">&quot;bool&quot;</span><span class="s2">)  </span><span class="s6"># defensive casting</span>
            <span class="s6"># B == batch size, S == max key length == max value length</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">key_mask</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">)  </span><span class="s6"># shape is [B, 1, S]</span>
            <span class="s1">auto_mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s0">if </span><span class="s1">auto_mask </span><span class="s0">is None else </span><span class="s1">auto_mask </span><span class="s2">&amp; </span><span class="s1">mask</span>
        <span class="s0">if </span><span class="s1">use_causal_mask</span><span class="s2">:</span>
            <span class="s6"># the shape of the causal mask is [1, T, S]</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_causal_mask</span><span class="s2">(</span><span class="s1">query</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s1">auto_mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s0">if </span><span class="s1">auto_mask </span><span class="s0">is None else </span><span class="s1">auto_mask </span><span class="s2">&amp; </span><span class="s1">mask</span>
        <span class="s0">if </span><span class="s1">auto_mask </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s6"># merge attention_mask &amp; automatic mask, to shape [B, T, S]</span>
            <span class="s1">attention_mask </span><span class="s2">= (</span>
                <span class="s1">auto_mask</span>
                <span class="s0">if </span><span class="s1">attention_mask </span><span class="s0">is None</span>
                <span class="s0">else </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">attention_mask</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">) &amp; </span><span class="s1">auto_mask</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">attention_mask</span>

    <span class="s0">def </span><span class="s1">_compute_causal_mask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Computes a causal mask (e.g., for masked self-attention layers). 
 
        For example, if query and value both contain sequences of length 4, 
        this function returns a boolean tensor equal to: 
 
        ``` 
        [[[True,  False, False, False], 
          [True,  True,  False, False], 
          [True,  True,  True,  False], 
          [True,  True,  True,  True]]] 
        ``` 
 
        Args: 
            query: query tensor of shape `(B, T, ...)`. 
            value: value tensor of shape `(B, S, ...)` (optional, defaults to 
                query). 
 
        Returns: 
            mask: a boolean tensor of shape `(1, T, S)` containing a lower 
                triangular matrix of shape `(T, S)`. 
        &quot;&quot;&quot;</span>
        <span class="s1">q_seq_length </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">query</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">v_seq_length </span><span class="s2">= </span><span class="s1">q_seq_length </span><span class="s0">if </span><span class="s1">value </span><span class="s0">is None else </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">ones_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">q_seq_length</span><span class="s2">, </span><span class="s1">v_seq_length</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">&quot;int32&quot;</span><span class="s2">)</span>
        <span class="s1">row_index </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">ones_mask</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">col_index </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">ones_mask</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">greater_equal</span><span class="s2">(</span><span class="s1">row_index</span><span class="s2">, </span><span class="s1">col_index</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compute_output_shape</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">query_shape</span><span class="s2">,</span>
        <span class="s1">value_shape</span><span class="s2">,</span>
        <span class="s1">key_shape</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">key_shape </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">key_shape </span><span class="s2">= </span><span class="s1">value_shape</span>

        <span class="s0">if </span><span class="s1">query_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">value_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;The last dimension of `query_shape` and `value_shape` &quot;</span>
                <span class="s3">f&quot;must be equal, but are </span><span class="s0">{</span><span class="s1">query_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">value_shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s3">. &quot;</span>
                <span class="s3">&quot;Received: query_shape={query_shape}, value_shape={value_shape}&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">value_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">key_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;All dimensions of `value` and `key`, except the last one, &quot;</span>
                <span class="s3">f&quot;must be equal. Received: value_shape=</span><span class="s0">{</span><span class="s1">value_shape</span><span class="s0">} </span><span class="s3">and &quot;</span>
                <span class="s3">f&quot;key_shape=</span><span class="s0">{</span><span class="s1">key_shape</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">query_shape</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_output_shape</span>

        <span class="s0">return </span><span class="s1">query_shape</span>

    <span class="s0">def </span><span class="s1">compute_output_spec</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">query</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">key</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">query_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">value_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">key_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">attention_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">return_attention_scores</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">training</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">use_causal_mask</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">key_shape </span><span class="s2">= </span><span class="s1">key</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">key_shape </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">output_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_output_shape</span><span class="s2">(</span>
            <span class="s1">query</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">key_shape</span>
        <span class="s2">)</span>
        <span class="s1">output_spec </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">KerasTensor</span><span class="s2">(</span>
            <span class="s1">output_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dtype</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">return_attention_scores</span><span class="s2">:</span>
            <span class="s1">length </span><span class="s2">= </span><span class="s1">query</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">attention_shape </span><span class="s2">= (</span><span class="s1">query</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">num_heads</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">length</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">output_spec</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">KerasTensor</span><span class="s2">(</span>
                <span class="s1">attention_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">compute_dtype</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">output_spec</span>


<span class="s0">def </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Coverts an index to a einsum variable name. 
 
    We simply map indices to lowercase characters, e.g. 0 -&gt; 'a', 1 -&gt; 'b'. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">string</span><span class="s2">.</span><span class="s1">ascii_lowercase</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_build_attention_equation</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">, </span><span class="s1">attn_axes</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Builds einsum equations for the attention computation. 
 
    Query, key, value inputs after projection are expected to have the shape as: 
    `(bs, &lt;non-attention dims&gt;, &lt;attention dims&gt;, num_heads, channels)`. 
    `bs` and `&lt;non-attention dims&gt;` are treated as `&lt;batch dims&gt;`. 
 
    The attention operations can be generalized: 
    1. Query-key dot product: 
        (&lt;batch dims&gt;, &lt;query attention dims&gt;, num_heads, channels), 
        (&lt;batch dims&gt;, &lt;key attention dims&gt;, num_heads, channels) -&gt; 
        (&lt;batch dims&gt;, num_heads, &lt;query attention dims&gt;, &lt;key attention dims&gt;) 
    2. Combination: 
        (&lt;batch dims&gt;, num_heads, &lt;query attention dims&gt;, &lt;key attention dims&gt;), 
        (&lt;batch dims&gt;, &lt;value attention dims&gt;, num_heads, channels) -&gt; (&lt;batch 
        dims&gt;, &lt;query attention dims&gt;, num_heads, channels) 
 
    Args: 
        rank: Rank of query, key, value tensors. 
        attn_axes: List/tuple of axes, `[-1, rank)`, 
            that attention will be applied to. 
 
    Returns: 
        Einsum equations. 
    &quot;&quot;&quot;</span>
    <span class="s1">target_notation </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">):</span>
        <span class="s1">target_notation </span><span class="s2">+= </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
    <span class="s6"># `batch_dims` includes the head dim.</span>
    <span class="s1">batch_dims </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">), </span><span class="s1">attn_axes </span><span class="s2">+ (</span><span class="s1">rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">,)))</span>
    <span class="s1">letter_offset </span><span class="s2">= </span><span class="s1">rank</span>
    <span class="s1">source_notation </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">batch_dims </span><span class="s0">or </span><span class="s1">i </span><span class="s2">== </span><span class="s1">rank </span><span class="s2">- </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">source_notation </span><span class="s2">+= </span><span class="s1">target_notation</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">source_notation </span><span class="s2">+= </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">letter_offset</span><span class="s2">)</span>
            <span class="s1">letter_offset </span><span class="s2">+= </span><span class="s5">1</span>

    <span class="s1">product_notation </span><span class="s2">= </span><span class="s3">&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">target_notation</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">batch_dims</span><span class="s2">]</span>
        <span class="s2">+ [</span><span class="s1">target_notation</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">attn_axes</span><span class="s2">]</span>
        <span class="s2">+ [</span><span class="s1">source_notation</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">attn_axes</span><span class="s2">]</span>
    <span class="s2">)</span>
    <span class="s1">dot_product_equation </span><span class="s2">= </span><span class="s3">&quot;%s,%s-&gt;%s&quot; </span><span class="s2">% (</span>
        <span class="s1">source_notation</span><span class="s2">,</span>
        <span class="s1">target_notation</span><span class="s2">,</span>
        <span class="s1">product_notation</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">attn_scores_rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">product_notation</span><span class="s2">)</span>
    <span class="s1">combine_equation </span><span class="s2">= </span><span class="s3">&quot;%s,%s-&gt;%s&quot; </span><span class="s2">% (</span>
        <span class="s1">product_notation</span><span class="s2">,</span>
        <span class="s1">source_notation</span><span class="s2">,</span>
        <span class="s1">target_notation</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">dot_product_equation</span><span class="s2">, </span><span class="s1">combine_equation</span><span class="s2">, </span><span class="s1">attn_scores_rank</span>


<span class="s0">def </span><span class="s1">_build_proj_equation</span><span class="s2">(</span><span class="s1">free_dims</span><span class="s2">, </span><span class="s1">bound_dims</span><span class="s2">, </span><span class="s1">output_dims</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Builds an einsum equation for projections inside multi-head attention.&quot;&quot;&quot;</span>
    <span class="s1">input_str </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">kernel_str </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">output_str </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">bias_axes </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">letter_offset </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">free_dims</span><span class="s2">):</span>
        <span class="s1">char </span><span class="s2">= </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">letter_offset</span><span class="s2">)</span>
        <span class="s1">input_str </span><span class="s2">+= </span><span class="s1">char</span>
        <span class="s1">output_str </span><span class="s2">+= </span><span class="s1">char</span>

    <span class="s1">letter_offset </span><span class="s2">+= </span><span class="s1">free_dims</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">bound_dims</span><span class="s2">):</span>
        <span class="s1">char </span><span class="s2">= </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">letter_offset</span><span class="s2">)</span>
        <span class="s1">input_str </span><span class="s2">+= </span><span class="s1">char</span>
        <span class="s1">kernel_str </span><span class="s2">+= </span><span class="s1">char</span>

    <span class="s1">letter_offset </span><span class="s2">+= </span><span class="s1">bound_dims</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">output_dims</span><span class="s2">):</span>
        <span class="s1">char </span><span class="s2">= </span><span class="s1">_index_to_einsum_variable</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">letter_offset</span><span class="s2">)</span>
        <span class="s1">kernel_str </span><span class="s2">+= </span><span class="s1">char</span>
        <span class="s1">output_str </span><span class="s2">+= </span><span class="s1">char</span>
        <span class="s1">bias_axes </span><span class="s2">+= </span><span class="s1">char</span>
    <span class="s1">equation </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">input_str</span><span class="s0">}</span><span class="s3">,</span><span class="s0">{</span><span class="s1">kernel_str</span><span class="s0">}</span><span class="s3">-&gt;</span><span class="s0">{</span><span class="s1">output_str</span><span class="s0">}</span><span class="s3">&quot;</span>

    <span class="s0">return </span><span class="s1">equation</span><span class="s2">, </span><span class="s1">bias_axes</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">output_str</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_output_shape</span><span class="s2">(</span><span class="s1">output_rank</span><span class="s2">, </span><span class="s1">known_last_dims</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">[</span><span class="s0">None</span><span class="s2">] * (</span><span class="s1">output_rank </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">known_last_dims</span><span class="s2">)) + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">known_last_dims</span><span class="s2">)</span>
</pre>
</body>
</html>