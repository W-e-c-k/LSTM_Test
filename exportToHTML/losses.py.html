<html>
<head>
<title>losses.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
losses.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">backend</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">api_export </span><span class="s0">import </span><span class="s1">keras_export</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">losses</span><span class="s2">.</span><span class="s1">loss </span><span class="s0">import </span><span class="s1">Loss</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">losses</span><span class="s2">.</span><span class="s1">loss </span><span class="s0">import </span><span class="s1">squeeze_or_expand_to_same_rank</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">saving </span><span class="s0">import </span><span class="s1">serialization_lib</span>
<span class="s0">from </span><span class="s1">keras</span><span class="s2">.</span><span class="s1">src</span><span class="s2">.</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">numerical_utils </span><span class="s0">import </span><span class="s1">normalize</span>


<span class="s0">class </span><span class="s1">LossFunctionWrapper</span><span class="s2">(</span><span class="s1">Loss</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fn</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fn </span><span class="s2">= </span><span class="s1">fn</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_fn_kwargs </span><span class="s2">= </span><span class="s1">kwargs</span>

    <span class="s0">def </span><span class="s1">call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
        <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fn</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, **</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fn_kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">config </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">get_config</span><span class="s2">()</span>
        <span class="s1">config</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">&quot;fn&quot;</span><span class="s2">: </span><span class="s1">serialization_lib</span><span class="s2">.</span><span class="s1">serialize_keras_object</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fn</span><span class="s2">)})</span>
        <span class="s1">config</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">serialization_lib</span><span class="s2">.</span><span class="s1">serialize_keras_object</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fn_kwargs</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">config</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_config</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">config</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s3">&quot;fn&quot; </span><span class="s0">in </span><span class="s1">config</span><span class="s2">:</span>
            <span class="s1">config </span><span class="s2">= </span><span class="s1">serialization_lib</span><span class="s2">.</span><span class="s1">deserialize_keras_object</span><span class="s2">(</span><span class="s1">config</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(**</span><span class="s1">config</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.MeanSquaredError&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MeanSquaredError</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean of squares of errors between labels and predictions. 
 
    Formula: 
 
    ```python 
    loss = mean(square(y_true - y_pred)) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;mean_squared_error&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">mean_squared_error</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.MeanAbsoluteError&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MeanAbsoluteError</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean of absolute difference between labels and predictions. 
 
    Formula: 
 
    ```python 
    loss = mean(abs(y_true - y_pred)) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;mean_absolute_error&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">mean_absolute_error</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.MeanAbsolutePercentageError&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MeanAbsolutePercentageError</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean absolute percentage error between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = 100 * mean(abs((y_true - y_pred) / y_true)) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;mean_absolute_percentage_error&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">mean_absolute_percentage_error</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.MeanSquaredLogarithmicError&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MeanSquaredLogarithmicError</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean squared logarithmic error between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = mean(square(log(y_true + 1) - log(y_pred + 1))) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;mean_squared_logarithmic_error&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">mean_squared_logarithmic_error</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.CosineSimilarity&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CosineSimilarity</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the cosine similarity between `y_true` &amp; `y_pred`. 
 
    Note that it is a number between -1 and 1. When it is a negative number 
    between -1 and 0, 0 indicates orthogonality and values closer to -1 
    indicate greater similarity. This makes it usable as a loss function in a 
    setting where you try to maximize the proximity between predictions and 
    targets. If either `y_true` or `y_pred` is a zero vector, cosine similarity 
    will be 0 regardless of the proximity between predictions and targets. 
 
    Formula: 
 
    ```python 
    loss = -sum(l2_norm(y_true) * l2_norm(y_pred)) 
    ``` 
 
    Args: 
        axis: The axis along which the cosine similarity is computed 
            (the features axis). Defaults to `-1`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;cosine_similarity&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">cosine_similarity</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.Huber&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Huber</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Huber loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    for x in error: 
        if abs(x) &lt;= delta: 
            loss.append(0.5 * x^2) 
        elif abs(x) &gt; delta: 
            loss.append(delta * abs(x) - 0.5 * delta^2) 
 
    loss = mean(loss, axis=-1) 
    ``` 
    See: [Huber loss](https://en.wikipedia.org/wiki/Huber_loss). 
 
    Args: 
        delta: A float, the point where the Huber loss function changes from a 
            quadratic to linear. 
        reduction: Type of reduction to apply to loss. Options are `&quot;sum&quot;`, 
            `&quot;sum_over_batch_size&quot;` or `None`. Defaults to 
            `&quot;sum_over_batch_size&quot;`. 
        name: Optional name for the instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">delta</span><span class="s2">=</span><span class="s5">1.0</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;huber_loss&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">huber</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">=</span><span class="s1">delta</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.LogCosh&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">LogCosh</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the logarithm of the hyperbolic cosine of the prediction error. 
 
    Formula: 
 
    ```python 
    error = y_pred - y_true 
    logcosh = mean(log((exp(error) + exp(-error))/2), axis=-1)` 
    ``` 
    where x is the error `y_pred - y_true`. 
 
    Args: 
        reduction: Type of reduction to apply to loss. Options are `&quot;sum&quot;`, 
            `&quot;sum_over_batch_size&quot;` or `None`. Defaults to 
            `&quot;sum_over_batch_size&quot;`. 
        name: Optional name for the instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;log_cosh&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">log_cosh</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.Hinge&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Hinge</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = maximum(1 - y_true * y_pred, 0) 
    ``` 
 
    `y_true` values are expected to be -1 or 1. If binary (0 or 1) labels are 
    provided we will convert them to -1 or 1. 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;hinge&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">hinge</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.SquaredHinge&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SquaredHinge</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the squared hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = square(maximum(1 - y_true * y_pred, 0)) 
    ``` 
 
    `y_true` values are expected to be -1 or 1. If binary (0 or 1) labels are 
    provided we will convert them to -1 or 1. 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;squared_hinge&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">squared_hinge</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.CategoricalHinge&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CategoricalHinge</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the categorical hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = maximum(neg - pos + 1, 0) 
    ``` 
 
    where `neg=maximum((1-y_true)*y_pred)` and `pos=sum(y_true*y_pred)` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;categorical_hinge&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">categorical_hinge</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.KLDivergence&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">KLDivergence</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes Kullback-Leibler divergence loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = y_true * log(y_true / y_pred) 
    ``` 
 
    `y_true` and `y_pred` are expected to be probability 
    distributions, with values between 0 and 1. They will get 
    clipped to the `[0, 1]` range. 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;kl_divergence&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">kl_divergence</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.Poisson&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Poisson</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Poisson loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = y_pred - y_true * log(y_pred) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;poisson&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">poisson</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Loss</span><span class="s2">.</span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.BinaryCrossentropy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinaryCrossentropy</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the cross-entropy loss between true labels and predicted labels. 
 
    Use this cross-entropy loss for binary (0 or 1) classification applications. 
    The loss function requires the following inputs: 
 
    - `y_true` (true label): This is either 0 or 1. 
    - `y_pred` (predicted value): This is the model's prediction, i.e, a single 
        floating-point value which either represents a 
        [logit](https://en.wikipedia.org/wiki/Logit), (i.e, value in [-inf, inf] 
        when `from_logits=True`) or a probability (i.e, value in [0., 1.] when 
        `from_logits=False`). 
 
    Args: 
        from_logits: Whether to interpret `y_pred` as a tensor of 
            [logit](https://en.wikipedia.org/wiki/Logit) values. By default, we 
            assume that `y_pred` is probabilities (i.e., values in [0, 1]). 
        label_smoothing: Float in range [0, 1]. When 0, no smoothing occurs. 
            When &gt; 0, we compute the loss between the predicted labels 
            and a smoothed version of the true labels, where the smoothing 
            squeezes the labels towards 0.5. Larger values of 
            `label_smoothing` correspond to heavier smoothing. 
        axis: The axis along which to compute crossentropy (the features axis). 
            Defaults to `-1`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Examples: 
 
    **Recommended Usage:** (set `from_logits=True`) 
 
    With `compile()` API: 
 
    ```python 
    model.compile( 
        loss=keras.losses.BinaryCrossentropy(from_logits=True), 
        ... 
    ) 
    ``` 
 
    As a standalone function: 
 
    &gt;&gt;&gt; # Example 1: (batch_size = 1, number of samples = 4) 
    &gt;&gt;&gt; y_true = [0, 1, 0, 0] 
    &gt;&gt;&gt; y_pred = [-18.6, 0.51, 2.94, -12.8] 
    &gt;&gt;&gt; bce = keras.losses.BinaryCrossentropy(from_logits=True) 
    &gt;&gt;&gt; bce(y_true, y_pred) 
    0.865 
 
    &gt;&gt;&gt; # Example 2: (batch_size = 2, number of samples = 4) 
    &gt;&gt;&gt; y_true = [[0, 1], [0, 0]] 
    &gt;&gt;&gt; y_pred = [[-18.6, 0.51], [2.94, -12.8]] 
    &gt;&gt;&gt; # Using default 'auto'/'sum_over_batch_size' reduction type. 
    &gt;&gt;&gt; bce = keras.losses.BinaryCrossentropy(from_logits=True) 
    &gt;&gt;&gt; bce(y_true, y_pred) 
    0.865 
    &gt;&gt;&gt; # Using 'sample_weight' attribute 
    &gt;&gt;&gt; bce(y_true, y_pred, sample_weight=[0.8, 0.2]) 
    0.243 
    &gt;&gt;&gt; # Using 'sum' reduction` type. 
    &gt;&gt;&gt; bce = keras.losses.BinaryCrossentropy(from_logits=True, 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; bce(y_true, y_pred) 
    1.730 
    &gt;&gt;&gt; # Using 'none' reduction type. 
    &gt;&gt;&gt; bce = keras.losses.BinaryCrossentropy(from_logits=True, 
    ...     reduction=None) 
    &gt;&gt;&gt; bce(y_true, y_pred) 
    array([0.235, 1.496], dtype=float32) 
 
    **Default Usage:** (set `from_logits=False`) 
 
    &gt;&gt;&gt; # Make the following updates to the above &quot;Recommended Usage&quot; section 
    &gt;&gt;&gt; # 1. Set `from_logits=False` 
    &gt;&gt;&gt; keras.losses.BinaryCrossentropy() # OR ...('from_logits=False') 
    &gt;&gt;&gt; # 2. Update `y_pred` to use probabilities instead of logits 
    &gt;&gt;&gt; y_pred = [0.6, 0.3, 0.2, 0.8] # OR [[0.6, 0.3], [0.2, 0.8]] 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;binary_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">binary_crossentropy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits </span><span class="s2">= </span><span class="s1">from_logits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing </span><span class="s2">= </span><span class="s1">label_smoothing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;from_logits&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s3">&quot;label_smoothing&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s3">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.BinaryFocalCrossentropy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinaryFocalCrossentropy</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes focal cross-entropy loss between true labels and predictions. 
 
    Binary cross-entropy loss is often used for binary (0 or 1) classification 
    tasks. The loss function requires the following inputs: 
 
    - `y_true` (true label): This is either 0 or 1. 
    - `y_pred` (predicted value): This is the model's prediction, i.e, a single 
        floating-point value which either represents a 
        [logit](https://en.wikipedia.org/wiki/Logit), (i.e, value in [-inf, inf] 
        when `from_logits=True`) or a probability (i.e, value in `[0., 1.]` when 
        `from_logits=False`). 
 
    According to [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf), it 
    helps to apply a &quot;focal factor&quot; to down-weight easy examples and focus more 
    on hard examples. By default, the focal tensor is computed as follows: 
 
    `focal_factor = (1 - output) ** gamma` for class 1 
    `focal_factor = output ** gamma` for class 0 
    where `gamma` is a focusing parameter. When `gamma=0`, this function is 
    equivalent to the binary crossentropy loss. 
 
    Args: 
        apply_class_balancing: A bool, whether to apply weight balancing on the 
            binary classes 0 and 1. 
        alpha: A weight balancing factor for class 1, default is `0.25` as 
            mentioned in reference [Lin et al., 2018]( 
            https://arxiv.org/pdf/1708.02002.pdf).  The weight for class 0 is 
            `1.0 - alpha`. 
        gamma: A focusing parameter used to compute the focal factor, default is 
            `2.0` as mentioned in the reference 
            [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf). 
        from_logits: Whether to interpret `y_pred` as a tensor of 
            [logit](https://en.wikipedia.org/wiki/Logit) values. By default, we 
            assume that `y_pred` are probabilities (i.e., values in `[0, 1]`). 
        label_smoothing: Float in `[0, 1]`. When `0`, no smoothing occurs. 
            When &gt; `0`, we compute the loss between the predicted labels 
            and a smoothed version of the true labels, where the smoothing 
            squeezes the labels towards `0.5`. 
            Larger values of `label_smoothing` correspond to heavier smoothing. 
        axis: The axis along which to compute crossentropy (the features axis). 
            Defaults to `-1`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Examples: 
 
    With the `compile()` API: 
 
    ```python 
    model.compile( 
        loss=keras.losses.BinaryFocalCrossentropy( 
            gamma=2.0, from_logits=True), 
        ... 
    ) 
    ``` 
 
    As a standalone function: 
 
    &gt;&gt;&gt; # Example 1: (batch_size = 1, number of samples = 4) 
    &gt;&gt;&gt; y_true = [0, 1, 0, 0] 
    &gt;&gt;&gt; y_pred = [-18.6, 0.51, 2.94, -12.8] 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...    gamma=2, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    0.691 
 
    &gt;&gt;&gt; # Apply class weight 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     apply_class_balancing=True, gamma=2, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    0.51 
 
    &gt;&gt;&gt; # Example 2: (batch_size = 2, number of samples = 4) 
    &gt;&gt;&gt; y_true = [[0, 1], [0, 0]] 
    &gt;&gt;&gt; y_pred = [[-18.6, 0.51], [2.94, -12.8]] 
    &gt;&gt;&gt; # Using default 'auto'/'sum_over_batch_size' reduction type. 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     gamma=3, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    0.647 
 
    &gt;&gt;&gt; # Apply class weight 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...      apply_class_balancing=True, gamma=3, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    0.482 
 
    &gt;&gt;&gt; # Using 'sample_weight' attribute with focal effect 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     gamma=3, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred, sample_weight=[0.8, 0.2]) 
    0.133 
 
    &gt;&gt;&gt; # Apply class weight 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...      apply_class_balancing=True, gamma=3, from_logits=True) 
    &gt;&gt;&gt; loss(y_true, y_pred, sample_weight=[0.8, 0.2]) 
    0.097 
 
    &gt;&gt;&gt; # Using 'sum' reduction` type. 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     gamma=4, from_logits=True, 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    1.222 
 
    &gt;&gt;&gt; # Apply class weight 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     apply_class_balancing=True, gamma=4, from_logits=True, 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    0.914 
 
    &gt;&gt;&gt; # Using 'none' reduction type. 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     gamma=5, from_logits=True, 
    ...     reduction=None) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    array([0.0017 1.1561], dtype=float32) 
 
    &gt;&gt;&gt; # Apply class weight 
    &gt;&gt;&gt; loss = keras.losses.BinaryFocalCrossentropy( 
    ...     apply_class_balancing=True, gamma=5, from_logits=True, 
    ...     reduction=None) 
    &gt;&gt;&gt; loss(y_true, y_pred) 
    array([0.0004 0.8670], dtype=float32) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">apply_class_balancing</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.25</span><span class="s2">,</span>
        <span class="s1">gamma</span><span class="s2">=</span><span class="s5">2.0</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;binary_focal_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">binary_focal_crossentropy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">apply_class_balancing</span><span class="s2">=</span><span class="s1">apply_class_balancing</span><span class="s2">,</span>
            <span class="s1">alpha</span><span class="s2">=</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s1">gamma</span><span class="s2">=</span><span class="s1">gamma</span><span class="s2">,</span>
            <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits </span><span class="s2">= </span><span class="s1">from_logits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing </span><span class="s2">= </span><span class="s1">label_smoothing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">apply_class_balancing </span><span class="s2">= </span><span class="s1">apply_class_balancing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alpha </span><span class="s2">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gamma </span><span class="s2">= </span><span class="s1">gamma</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;from_logits&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s3">&quot;label_smoothing&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s3">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s3">&quot;apply_class_balancing&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_class_balancing</span><span class="s2">,</span>
            <span class="s3">&quot;alpha&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s3">&quot;gamma&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gamma</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.CategoricalCrossentropy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CategoricalCrossentropy</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the crossentropy loss between the labels and predictions. 
 
    Use this crossentropy loss function when there are two or more label 
    classes. We expect labels to be provided in a `one_hot` representation. If 
    you want to provide labels as integers, please use 
    `SparseCategoricalCrossentropy` loss. There should be `num_classes` floating 
    point values per feature, i.e., the shape of both `y_pred` and `y_true` are 
    `[batch_size, num_classes]`. 
 
    Args: 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        label_smoothing: Float in [0, 1]. When &gt; 0, label values are smoothed, 
            meaning the confidence on label values are relaxed. For example, if 
            `0.1`, use `0.1 / num_classes` for non-target labels and 
            `0.9 + 0.1 / num_classes` for target labels. 
        axis: The axis along which to compute crossentropy (the features 
            axis). Defaults to `-1`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Examples: 
 
    Standalone usage: 
 
    &gt;&gt;&gt; y_true = [[0, 1, 0], [0, 0, 1]] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.95, 0], [0.1, 0.8, 0.1]] 
    &gt;&gt;&gt; # Using 'auto'/'sum_over_batch_size' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalCrossentropy() 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    1.177 
 
    &gt;&gt;&gt; # Calling with 'sample_weight'. 
    &gt;&gt;&gt; cce(y_true, y_pred, sample_weight=np.array([0.3, 0.7])) 
    0.814 
 
    &gt;&gt;&gt; # Using 'sum' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalCrossentropy( 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    2.354 
 
    &gt;&gt;&gt; # Using 'none' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalCrossentropy( 
    ...     reduction=None) 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    array([0.0513, 2.303], dtype=float32) 
 
    Usage with the `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss=keras.losses.CategoricalCrossentropy()) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;categorical_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">categorical_crossentropy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits </span><span class="s2">= </span><span class="s1">from_logits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing </span><span class="s2">= </span><span class="s1">label_smoothing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;from_logits&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s3">&quot;label_smoothing&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s3">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.CategoricalFocalCrossentropy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CategoricalFocalCrossentropy</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the alpha balanced focal crossentropy loss. 
 
    Use this crossentropy loss function when there are two or more label 
    classes and if you want to handle class imbalance without using 
    `class_weights`. We expect labels to be provided in a `one_hot` 
    representation. 
 
    According to [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf), it 
    helps to apply a focal factor to down-weight easy examples and focus more on 
    hard examples. The general formula for the focal loss (FL) 
    is as follows: 
 
    `FL(p_t) = (1 - p_t) ** gamma * log(p_t)` 
 
    where `p_t` is defined as follows: 
    `p_t = output if y_true == 1, else 1 - output` 
 
    `(1 - p_t) ** gamma` is the `modulating_factor`, where `gamma` is a focusing 
    parameter. When `gamma` = 0, there is no focal effect on the cross entropy. 
    `gamma` reduces the importance given to simple examples in a smooth manner. 
 
    The authors use alpha-balanced variant of focal loss (FL) in the paper: 
    `FL(p_t) = -alpha * (1 - p_t) ** gamma * log(p_t)` 
 
    where `alpha` is the weight factor for the classes. If `alpha` = 1, the 
    loss won't be able to handle class imbalance properly as all 
    classes will have the same weight. This can be a constant or a list of 
    constants. If alpha is a list, it must have the same length as the number 
    of classes. 
 
    The formula above can be generalized to: 
    `FL(p_t) = alpha * (1 - p_t) ** gamma * CrossEntropy(y_true, y_pred)` 
 
    where minus comes from `CrossEntropy(y_true, y_pred)` (CE). 
 
    Extending this to multi-class case is straightforward: 
    `FL(p_t) = alpha * (1 - p_t) ** gamma * CategoricalCE(y_true, y_pred)` 
 
    In the snippet below, there is `num_classes` floating pointing values per 
    example. The shape of both `y_pred` and `y_true` are 
    `(batch_size, num_classes)`. 
 
    Args: 
        alpha: A weight balancing factor for all classes, default is `0.25` as 
            mentioned in the reference. It can be a list of floats or a scalar. 
            In the multi-class case, alpha may be set by inverse class 
            frequency by using `compute_class_weight` from `sklearn.utils`. 
        gamma: A focusing parameter, default is `2.0` as mentioned in the 
            reference. It helps to gradually reduce the importance given to 
            simple (easy) examples in a smooth manner. 
        from_logits: Whether `output` is expected to be a logits tensor. By 
            default, we consider that `output` encodes a probability 
            distribution. 
        label_smoothing: Float in [0, 1]. When &gt; 0, label values are smoothed, 
            meaning the confidence on label values are relaxed. For example, if 
            `0.1`, use `0.1 / num_classes` for non-target labels and 
            `0.9 + 0.1 / num_classes` for target labels. 
        axis: The axis along which to compute crossentropy (the features 
            axis). Defaults to `-1`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Examples: 
 
    Standalone usage: 
 
    &gt;&gt;&gt; y_true = [[0., 1., 0.], [0., 0., 1.]] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.95, 0], [0.1, 0.8, 0.1]] 
    &gt;&gt;&gt; # Using 'auto'/'sum_over_batch_size' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalFocalCrossentropy() 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    0.23315276 
 
    &gt;&gt;&gt; # Calling with 'sample_weight'. 
    &gt;&gt;&gt; cce(y_true, y_pred, sample_weight=np.array([0.3, 0.7])) 
    0.1632 
 
    &gt;&gt;&gt; # Using 'sum' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalFocalCrossentropy( 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    0.46631 
 
    &gt;&gt;&gt; # Using 'none' reduction type. 
    &gt;&gt;&gt; cce = keras.losses.CategoricalFocalCrossentropy( 
    ...     reduction=None) 
    &gt;&gt;&gt; cce(y_true, y_pred) 
    array([3.2058331e-05, 4.6627346e-01], dtype=float32) 
 
    Usage with the `compile()` API: 
 
    ```python 
    model.compile(optimizer='adam', 
                  loss=keras.losses.CategoricalFocalCrossentropy()) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.25</span><span class="s2">,</span>
        <span class="s1">gamma</span><span class="s2">=</span><span class="s5">2.0</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;categorical_focal_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Initializes `CategoricalFocalCrossentropy` instance.&quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">categorical_focal_crossentropy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">alpha</span><span class="s2">=</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s1">gamma</span><span class="s2">=</span><span class="s1">gamma</span><span class="s2">,</span>
            <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits </span><span class="s2">= </span><span class="s1">from_logits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing </span><span class="s2">= </span><span class="s1">label_smoothing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alpha </span><span class="s2">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gamma </span><span class="s2">= </span><span class="s1">gamma</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;from_logits&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s3">&quot;label_smoothing&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label_smoothing</span><span class="s2">,</span>
            <span class="s3">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s3">&quot;alpha&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s3">&quot;gamma&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gamma</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.SparseCategoricalCrossentropy&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SparseCategoricalCrossentropy</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the crossentropy loss between the labels and predictions. 
 
    Use this crossentropy loss function when there are two or more label 
    classes.  We expect labels to be provided as integers. If you want to 
    provide labels using `one-hot` representation, please use 
    `CategoricalCrossentropy` loss.  There should be `# classes` floating point 
    values per feature for `y_pred` and a single floating point value per 
    feature for `y_true`. 
 
    In the snippet below, there is a single floating point value per example for 
    `y_true` and `num_classes` floating pointing values per example for 
    `y_pred`. The shape of `y_true` is `[batch_size]` and the shape of `y_pred` 
    is `[batch_size, num_classes]`. 
 
    Args: 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Examples: 
 
    &gt;&gt;&gt; y_true = [1, 2] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.95, 0], [0.1, 0.8, 0.1]] 
    &gt;&gt;&gt; # Using 'auto'/'sum_over_batch_size' reduction type. 
    &gt;&gt;&gt; scce = keras.losses.SparseCategoricalCrossentropy() 
    &gt;&gt;&gt; scce(y_true, y_pred) 
    1.177 
 
    &gt;&gt;&gt; # Calling with 'sample_weight'. 
    &gt;&gt;&gt; scce(y_true, y_pred, sample_weight=np.array([0.3, 0.7])) 
    0.814 
 
    &gt;&gt;&gt; # Using 'sum' reduction type. 
    &gt;&gt;&gt; scce = keras.losses.SparseCategoricalCrossentropy( 
    ...     reduction=&quot;sum&quot;) 
    &gt;&gt;&gt; scce(y_true, y_pred) 
    2.354 
 
    &gt;&gt;&gt; # Using 'none' reduction type. 
    &gt;&gt;&gt; scce = keras.losses.SparseCategoricalCrossentropy( 
    ...     reduction=None) 
    &gt;&gt;&gt; scce(y_true, y_pred) 
    array([0.0513, 2.303], dtype=float32) 
 
    Usage with the `compile()` API: 
 
    ```python 
    model.compile(optimizer='sgd', 
                  loss=keras.losses.SparseCategoricalCrossentropy()) 
    ``` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;sparse_categorical_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">sparse_categorical_crossentropy</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s1">ignore_class</span><span class="s2">=</span><span class="s1">ignore_class</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits </span><span class="s2">= </span><span class="s1">from_logits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class </span><span class="s2">= </span><span class="s1">ignore_class</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;from_logits&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">from_logits</span><span class="s2">,</span>
            <span class="s3">&quot;ignore_class&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_class</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s0">def </span><span class="s1">convert_binary_labels_to_hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Converts binary labels into -1/1 for hinge loss/metric calculation.&quot;&quot;&quot;</span>
    <span class="s1">are_zeros </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">are_ones </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">is_binary </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">all</span><span class="s2">((</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span><span class="s1">are_zeros</span><span class="s2">, </span><span class="s1">are_ones</span><span class="s2">)))</span>

    <span class="s0">def </span><span class="s1">_convert_binary_labels</span><span class="s2">():</span>
        <span class="s6"># Convert the binary labels to -1 or 1.</span>
        <span class="s0">return </span><span class="s5">2.0 </span><span class="s2">* </span><span class="s1">y_true </span><span class="s2">- </span><span class="s5">1.0</span>

    <span class="s0">def </span><span class="s1">_return_labels_unconverted</span><span class="s2">():</span>
        <span class="s6"># Returns the labels unchanged if they are non-binary</span>
        <span class="s0">return </span><span class="s1">y_true</span>

    <span class="s1">updated_y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span>
        <span class="s1">is_binary</span><span class="s2">, </span><span class="s1">_convert_binary_labels</span><span class="s2">, </span><span class="s1">_return_labels_unconverted</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">updated_y_true</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.hinge&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.hinge&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = mean(maximum(1 - y_true * y_pred, 0), axis=-1) 
    ``` 
 
    Args: 
        y_true: The ground truth values. `y_true` values are expected to be -1 
            or 1. If binary (0 or 1) labels are provided they will be converted 
            to -1 or 1 with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Hinge loss values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.choice([-1, 1], size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.hinge(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">convert_binary_labels_to_hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.squared_hinge&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.squared_hinge&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">squared_hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the squared hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = mean(square(maximum(1 - y_true * y_pred, 0)), axis=-1) 
    ``` 
 
    Args: 
        y_true: The ground truth values. `y_true` values are expected to be -1 
            or 1. If binary (0 or 1) labels are provided we will convert them 
            to -1 or 1 with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Squared hinge loss values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.choice([-1, 1], size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.squared_hinge(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">convert_binary_labels_to_hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">)), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.categorical_hinge&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.categorical_hinge&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">categorical_hinge</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the categorical hinge loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = maximum(neg - pos + 1, 0) 
    ``` 
 
    where `neg=maximum((1-y_true)*y_pred)` and `pos=sum(y_true*y_pred)` 
 
    Args: 
        y_true: The ground truth values. `y_true` values are expected to be 
            either `{-1, +1}` or `{0, 1}` (i.e. a one-hot-encoded tensor) with 
            shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Categorical hinge loss values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 3, size=(2,)) 
    &gt;&gt;&gt; y_true = np.eye(np.max(y_true) + 1)[y_true] 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.categorical_hinge(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">pos </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">neg </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">max</span><span class="s2">((</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">y_true</span><span class="s2">) * </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">zero </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">neg </span><span class="s2">- </span><span class="s1">pos </span><span class="s2">+ </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.mean_squared_error&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.mean_squared_error&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.mse&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.MSE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.mse&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.MSE&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">mean_squared_error</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean squared error between labels and predictions. 
 
    Formula: 
 
    ```python 
    loss = mean(square(y_true - y_pred), axis=-1) 
    ``` 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 2, size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.mean_squared_error(y_true, y_pred) 
 
    Args: 
        y_true: Ground truth values with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Mean squared error values with shape = `[batch_size, d0, .. dN-1]`. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">- </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.mean_absolute_error&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.mean_absolute_error&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.MAE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.mae&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.MAE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.mae&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">mean_absolute_error</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean absolute error between labels and predictions. 
 
    ```python 
    loss = mean(abs(y_true - y_pred), axis=-1) 
    ``` 
 
    Args: 
        y_true: Ground truth values with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Mean absolute error values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 2, size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.mean_absolute_error(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">- </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.mean_absolute_percentage_error&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.mean_absolute_percentage_error&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.mape&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.MAPE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.mape&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.MAPE&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">mean_absolute_percentage_error</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean absolute percentage error between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = 100 * mean(abs((y_true - y_pred) / y_true), axis=-1) 
    ``` 
 
    Division by zero is prevented by dividing by `maximum(y_true, epsilon)` 
    where `epsilon = keras.backend.epsilon()` 
    (default to `1e-7`). 
 
    Args: 
        y_true: Ground truth values with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Mean absolute percentage error values with shape = `[batch_size, d0, .. 
        dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.mean_absolute_percentage_error(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">diff </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">((</span><span class="s1">y_true </span><span class="s2">- </span><span class="s1">y_pred</span><span class="s2">) / </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">), </span><span class="s1">epsilon</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s5">100.0 </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.mean_squared_logarithmic_error&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.mean_squared_logarithmic_error&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.msle&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.MSLE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.msle&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.MSLE&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">mean_squared_logarithmic_error</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the mean squared logarithmic error between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = mean(square(log(y_true + 1) - log(y_pred + 1)), axis=-1) 
    ``` 
 
    Note that `y_pred` and `y_true` cannot be less or equal to 0. Negative 
    values and 0 values will be replaced with `keras.backend.epsilon()` 
    (default to `1e-7`). 
 
    Args: 
        y_true: Ground truth values with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Mean squared logarithmic error values with shape = `[batch_size, d0, .. 
        dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 2, size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.mean_squared_logarithmic_error(y_true, y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">())</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">first_log </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">) + </span><span class="s5">1.0</span><span class="s2">)</span>
    <span class="s1">second_log </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">) + </span><span class="s5">1.0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">first_log </span><span class="s2">- </span><span class="s1">second_log</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.cosine_similarity&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">cosine_similarity</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the cosine similarity between labels and predictions. 
 
    Formula: 
    ```python 
    loss = -sum(l2_norm(y_true) * l2_norm(y_pred)) 
    ``` 
 
    Note that it is a number between -1 and 1. When it is a negative number 
    between -1 and 0, 0 indicates orthogonality and values closer to -1 
    indicate greater similarity. This makes it usable as a loss function in a 
    setting where you try to maximize the proximity between predictions and 
    targets. If either `y_true` or `y_pred` is a zero vector, cosine 
    similarity will be 0 regardless of the proximity between predictions 
    and targets. 
 
    Args: 
        y_true: Tensor of true targets. 
        y_pred: Tensor of predicted targets. 
        axis: Axis along which to determine similarity. Defaults to `-1`. 
 
    Returns: 
        Cosine similarity tensor. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0., 1.], [1., 1.], [1., 1.]] 
    &gt;&gt;&gt; y_pred = [[1., 0.], [1., 1.], [-1., -1.]] 
    &gt;&gt;&gt; loss = keras.losses.cosine_similarity(y_true, y_pred, axis=-1) 
    [-0., -0.99999994, 0.99999994] 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">normalize</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">normalize</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s2">-</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">([</span><span class="s3">&quot;keras.losses.huber&quot;</span><span class="s2">, </span><span class="s3">&quot;keras.metrics.huber&quot;</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">huber</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">=</span><span class="s5">1.0</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes Huber loss value. 
 
    Formula: 
    ```python 
    for x in error: 
        if abs(x) &lt;= delta: 
            loss.append(0.5 * x^2) 
        elif abs(x) &gt; delta: 
            loss.append(delta * abs(x) - 0.5 * delta^2) 
 
    loss = mean(loss, axis=-1) 
    ``` 
    See: [Huber loss](https://en.wikipedia.org/wiki/Huber_loss). 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0, 1], [0, 0]] 
    &gt;&gt;&gt; y_pred = [[0.6, 0.4], [0.4, 0.6]] 
    &gt;&gt;&gt; loss = keras.losses.huber(y_true, y_pred) 
    0.155 
 
 
    Args: 
        y_true: tensor of true targets. 
        y_pred: tensor of predicted targets. 
        delta: A float, the point where the Huber loss function changes from a 
            quadratic to linear. Defaults to `1.0`. 
 
    Returns: 
        Tensor with one scalar loss entry per sample. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">delta </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">error </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">subtract</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">)</span>
    <span class="s1">abs_error </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">error</span><span class="s2">)</span>
    <span class="s1">half </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">abs_error</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span>
            <span class="s1">abs_error </span><span class="s2">&lt;= </span><span class="s1">delta</span><span class="s2">,</span>
            <span class="s1">half </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">error</span><span class="s2">),</span>
            <span class="s1">delta </span><span class="s2">* </span><span class="s1">abs_error </span><span class="s2">- </span><span class="s1">half </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">square</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.losses.log_cosh&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.metrics.log_cosh&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.logcosh&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.logcosh&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">log_cosh</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Logarithm of the hyperbolic cosine of the prediction error. 
 
    Formula: 
    ```python 
    loss = mean(log(cosh(y_pred - y_true)), axis=-1) 
    ``` 
 
    Note that `log(cosh(x))` is approximately equal to `(x ** 2) / 2` for small 
    `x` and to `abs(x) - log(2)` for large `x`. This means that 'logcosh' works 
    mostly like the mean squared error, but will not be so strongly affected by 
    the occasional wildly incorrect prediction. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0., 1.], [0., 0.]] 
    &gt;&gt;&gt; y_pred = [[1., 1.], [0., 0.]] 
    &gt;&gt;&gt; loss = keras.losses.log_cosh(y_true, y_pred) 
    0.108 
 
    Args: 
        y_true: Ground truth values with shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values with shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Logcosh error values with shape = `[batch_size, d0, .. dN-1]`. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred </span><span class="s2">= </span><span class="s1">squeeze_or_expand_to_same_rank</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">log2 </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s5">2.0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_logcosh</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">softplus</span><span class="s2">(</span><span class="s1">x </span><span class="s2">* -</span><span class="s5">2.0</span><span class="s2">) - </span><span class="s1">log2</span>

    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">_logcosh</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">- </span><span class="s1">y_true</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.kl_divergence&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.kl_divergence&quot;</span><span class="s2">,</span>
        <span class="s6"># Legacy aliases</span>
        <span class="s3">&quot;keras._legacy.losses.KLD&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.kld&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.losses.kullback_leibler_divergence&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.KLD&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.kld&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras._legacy.metrics.kullback_leibler_divergence&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">kl_divergence</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes Kullback-Leibler divergence loss between `y_true` &amp; `y_pred`. 
 
    Formula: 
 
    ```python 
    loss = y_true * log(y_true / y_pred) 
    ``` 
 
    `y_true` and `y_pred` are expected to be probability 
    distributions, with values between 0 and 1. They will get 
    clipped to the `[0, 1]` range. 
 
    Args: 
        y_true: Tensor of true targets. 
        y_pred: Tensor of predicted targets. 
 
    Returns: 
        KL Divergence loss values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 2, size=(2, 3)).astype(np.float32) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.kl_divergence(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; y_true = ops.clip(y_true, 1e-7, 1) 
    &gt;&gt;&gt; y_pred = ops.clip(y_pred, 1e-7, 1) 
    &gt;&gt;&gt; assert np.array_equal( 
    ...     loss, np.sum(y_true * np.log(y_true / y_pred), axis=-1)) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(), </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(), </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">/ </span><span class="s1">y_pred</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.poisson&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.poisson&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">poisson</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Poisson loss between y_true and y_pred. 
 
    Formula: 
 
    ```python 
    loss = y_pred - y_true * log(y_pred) 
    ``` 
 
    Args: 
        y_true: Ground truth values. shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values. shape = `[batch_size, d0, .. dN]`. 
 
    Returns: 
        Poisson loss values with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = np.random.randint(0, 2, size=(2, 3)) 
    &gt;&gt;&gt; y_pred = np.random.random(size=(2, 3)) 
    &gt;&gt;&gt; loss = keras.losses.poisson(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; y_pred = y_pred + 1e-7 
    &gt;&gt;&gt; assert np.allclose( 
    ...     loss, np.mean(y_pred - y_true * np.log(y_pred), axis=-1), 
    ...     atol=1e-5) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">- </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">+ </span><span class="s1">epsilon</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.categorical_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.categorical_crossentropy&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">categorical_crossentropy</span><span class="s2">(</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span>
<span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the categorical crossentropy loss. 
 
    Args: 
        y_true: Tensor of one-hot true targets. 
        y_pred: Tensor of predicted targets. 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        label_smoothing: Float in [0, 1]. If &gt; `0` then smooth the labels. For 
            example, if `0.1`, use `0.1 / num_classes` for non-target labels 
            and `0.9 + 0.1 / num_classes` for target labels. 
        axis: Defaults to `-1`. The dimension along which the entropy is 
            computed. 
 
    Returns: 
        Categorical crossentropy loss value. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0, 1, 0], [0, 0, 1]] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.95, 0], [0.1, 0.8, 0.1]] 
    &gt;&gt;&gt; loss = keras.losses.categorical_crossentropy(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.0513, 2.303], dtype=float32) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;`axis` must be of type `int`. &quot;</span>
            <span class="s3">f&quot;Received: axis=</span><span class="s0">{</span><span class="s1">axis</span><span class="s0">} </span><span class="s3">of type </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;In loss categorical_crossentropy, expected &quot;</span>
            <span class="s3">&quot;y_pred.shape to be (batch_size, num_classes) &quot;</span>
            <span class="s3">f&quot;with num_classes &gt; 1. Received: y_pred.shape=</span><span class="s0">{</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s3">. &quot;</span>
            <span class="s3">&quot;Consider using 'binary_crossentropy' if you only have 2 classes.&quot;</span><span class="s2">,</span>
            <span class="s1">SyntaxWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">label_smoothing</span><span class="s2">:</span>
        <span class="s1">num_classes </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* (</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">label_smoothing</span><span class="s2">) + (</span>
            <span class="s1">label_smoothing </span><span class="s2">/ </span><span class="s1">num_classes</span>
        <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">categorical_crossentropy</span><span class="s2">(</span>
        <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.categorical_focal_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.categorical_focal_crossentropy&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">categorical_focal_crossentropy</span><span class="s2">(</span>
    <span class="s1">y_true</span><span class="s2">,</span>
    <span class="s1">y_pred</span><span class="s2">,</span>
    <span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.25</span><span class="s2">,</span>
    <span class="s1">gamma</span><span class="s2">=</span><span class="s5">2.0</span><span class="s2">,</span>
    <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
    <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the categorical focal crossentropy loss. 
 
    Args: 
        y_true: Tensor of one-hot true targets. 
        y_pred: Tensor of predicted targets. 
        alpha: A weight balancing factor for all classes, default is `0.25` as 
            mentioned in the reference. It can be a list of floats or a scalar. 
            In the multi-class case, alpha may be set by inverse class 
            frequency by using `compute_class_weight` from `sklearn.utils`. 
        gamma: A focusing parameter, default is `2.0` as mentioned in the 
            reference. It helps to gradually reduce the importance given to 
            simple examples in a smooth manner. When `gamma` = 0, there is 
            no focal effect on the categorical crossentropy. 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability 
            distribution. 
        label_smoothing: Float in [0, 1]. If &gt; `0` then smooth the labels. For 
            example, if `0.1`, use `0.1 / num_classes` for non-target labels 
            and `0.9 + 0.1 / num_classes` for target labels. 
        axis: Defaults to `-1`. The dimension along which the entropy is 
            computed. 
 
    Returns: 
        Categorical focal crossentropy loss value. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0, 1, 0], [0, 0, 1]] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.9, 0.05], [0.1, 0.85, 0.05]] 
    &gt;&gt;&gt; loss = keras.losses.categorical_focal_crossentropy(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([2.63401289e-04, 6.75912094e-01], dtype=float32) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;`axis` must be of type `int`. &quot;</span>
            <span class="s3">f&quot;Received: axis=</span><span class="s0">{</span><span class="s1">axis</span><span class="s0">} </span><span class="s3">of type </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;In loss categorical_focal_crossentropy, expected &quot;</span>
            <span class="s3">&quot;y_pred.shape to be (batch_size, num_classes) &quot;</span>
            <span class="s3">f&quot;with num_classes &gt; 1. Received: y_pred.shape=</span><span class="s0">{</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s3">. &quot;</span>
            <span class="s3">&quot;Consider using 'binary_crossentropy' if you only have 2 classes.&quot;</span><span class="s2">,</span>
            <span class="s1">SyntaxWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">label_smoothing</span><span class="s2">:</span>
        <span class="s1">num_classes </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* (</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">label_smoothing</span><span class="s2">) + (</span>
            <span class="s1">label_smoothing </span><span class="s2">/ </span><span class="s1">num_classes</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">from_logits</span><span class="s2">:</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">softmax</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s6"># Adjust the predictions so that the probability of</span>
    <span class="s6"># each class for every sample adds up to 1</span>
    <span class="s6"># This is needed to ensure that the cross entropy is</span>
    <span class="s6"># computed correctly.</span>
    <span class="s1">output </span><span class="s2">= </span><span class="s1">y_pred </span><span class="s2">/ </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">output </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(), </span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">())</span>

    <span class="s6"># Calculate cross entropy</span>
    <span class="s1">cce </span><span class="s2">= -</span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">output</span><span class="s2">)</span>

    <span class="s6"># Calculate factors</span>
    <span class="s1">modulating_factor </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">power</span><span class="s2">(</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">output</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">)</span>
    <span class="s1">weighting_factor </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">modulating_factor</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">)</span>

    <span class="s6"># Apply weighting factor</span>
    <span class="s1">focal_cce </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">weighting_factor</span><span class="s2">, </span><span class="s1">cce</span><span class="s2">)</span>
    <span class="s1">focal_cce </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">focal_cce</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">focal_cce</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.sparse_categorical_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.sparse_categorical_crossentropy&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">sparse_categorical_crossentropy</span><span class="s2">(</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">ignore_class</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span>
<span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the sparse categorical crossentropy loss. 
 
    Args: 
        y_true: Ground truth values. 
        y_pred: The predicted values. 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        ignore_class: Optional integer. The ID of a class to be ignored during 
            loss computation. This is useful, for example, in segmentation 
            problems featuring a &quot;void&quot; class (commonly -1 or 255) in 
            segmentation maps. By default (`ignore_class=None`), all classes are 
            considered. 
        axis: Defaults to `-1`. The dimension along which the entropy is 
            computed. 
 
    Returns: 
        Sparse categorical crossentropy loss value. 
 
    Examples: 
 
    &gt;&gt;&gt; y_true = [1, 2] 
    &gt;&gt;&gt; y_pred = [[0.05, 0.95, 0], [0.1, 0.8, 0.1]] 
    &gt;&gt;&gt; loss = keras.losses.sparse_categorical_crossentropy(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.0513, 2.303], dtype=float32) 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) </span><span class="s0">and </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">ignore_class </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">res_shape </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)[:-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">valid_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">not_equal</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ignore_class</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">y_pred </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
            <span class="s1">ops</span><span class="s2">.</span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">), </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sparse_categorical_crossentropy</span><span class="s2">(</span>
        <span class="s1">y_true</span><span class="s2">,</span>
        <span class="s1">y_pred</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">ignore_class </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">valid_mask </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">res_shape</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">valid_mask</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">_keras_mask </span><span class="s2">= </span><span class="s1">valid_mask</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.binary_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.binary_crossentropy&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">binary_crossentropy</span><span class="s2">(</span>
    <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span>
<span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the binary crossentropy loss. 
 
    Args: 
        y_true: Ground truth values. shape = `[batch_size, d0, .. dN]`. 
        y_pred: The predicted values. shape = `[batch_size, d0, .. dN]`. 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        label_smoothing: Float in `[0, 1]`. If &gt; `0` then smooth the labels by 
            squeezing them towards 0.5, that is, 
            using `1. - 0.5 * label_smoothing` for the target class 
            and `0.5 * label_smoothing` for the non-target class. 
        axis: The axis along which the mean is computed. Defaults to `-1`. 
 
    Returns: 
        Binary crossentropy loss value. shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0, 1], [0, 0]] 
    &gt;&gt;&gt; y_pred = [[0.6, 0.4], [0.4, 0.6]] 
    &gt;&gt;&gt; loss = keras.losses.binary_crossentropy(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.916 , 0.714], dtype=float32) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">label_smoothing</span><span class="s2">:</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* (</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">label_smoothing</span><span class="s2">) + </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s1">label_smoothing</span>

    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">binary_crossentropy</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">from_logits</span><span class="s2">=</span><span class="s1">from_logits</span><span class="s2">),</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s3">&quot;keras.metrics.binary_focal_crossentropy&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;keras.losses.binary_focal_crossentropy&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">binary_focal_crossentropy</span><span class="s2">(</span>
    <span class="s1">y_true</span><span class="s2">,</span>
    <span class="s1">y_pred</span><span class="s2">,</span>
    <span class="s1">apply_class_balancing</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.25</span><span class="s2">,</span>
    <span class="s1">gamma</span><span class="s2">=</span><span class="s5">2.0</span><span class="s2">,</span>
    <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">label_smoothing</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">,</span>
    <span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the binary focal crossentropy loss. 
 
    According to [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf), it 
    helps to apply a focal factor to down-weight easy examples and focus more on 
    hard examples. By default, the focal tensor is computed as follows: 
 
    `focal_factor = (1 - output) ** gamma` for class 1 
    `focal_factor = output ** gamma` for class 0 
    where `gamma` is a focusing parameter. When `gamma` = 0, there is no focal 
    effect on the binary crossentropy loss. 
 
    If `apply_class_balancing == True`, this function also takes into account a 
    weight balancing factor for the binary classes 0 and 1 as follows: 
 
    `weight = alpha` for class 1 (`target == 1`) 
    `weight = 1 - alpha` for class 0 
    where `alpha` is a float in the range of `[0, 1]`. 
 
    Args: 
        y_true: Ground truth values, of shape `(batch_size, d0, .. dN)`. 
        y_pred: The predicted values, of shape `(batch_size, d0, .. dN)`. 
        apply_class_balancing: A bool, whether to apply weight balancing on the 
            binary classes 0 and 1. 
        alpha: A weight balancing factor for class 1, default is `0.25` as 
            mentioned in the reference. The weight for class 0 is `1.0 - alpha`. 
        gamma: A focusing parameter, default is `2.0` as mentioned in the 
            reference. 
        from_logits: Whether `y_pred` is expected to be a logits tensor. By 
            default, we assume that `y_pred` encodes a probability distribution. 
        label_smoothing: Float in `[0, 1]`. If &gt; `0` then smooth the labels by 
            squeezing them towards 0.5, that is, 
            using `1. - 0.5 * label_smoothing` for the target class 
            and `0.5 * label_smoothing` for the non-target class. 
        axis: The axis along which the mean is computed. Defaults to `-1`. 
 
    Returns: 
        Binary focal crossentropy loss value 
        with shape = `[batch_size, d0, .. dN-1]`. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[0, 1], [0, 0]] 
    &gt;&gt;&gt; y_pred = [[0.6, 0.4], [0.4, 0.6]] 
    &gt;&gt;&gt; loss = keras.losses.binary_focal_crossentropy( 
    ...        y_true, y_pred, gamma=2) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.330, 0.206], dtype=float32) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">label_smoothing</span><span class="s2">:</span>
        <span class="s1">y_true </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* (</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">label_smoothing</span><span class="s2">) + </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s1">label_smoothing</span>

    <span class="s0">if </span><span class="s1">from_logits</span><span class="s2">:</span>
        <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sigmoid</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>

    <span class="s1">bce </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">binary_crossentropy</span><span class="s2">(</span>
        <span class="s1">target</span><span class="s2">=</span><span class="s1">y_true</span><span class="s2">,</span>
        <span class="s1">output</span><span class="s2">=</span><span class="s1">y_pred</span><span class="s2">,</span>
        <span class="s1">from_logits</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s6"># Calculate focal factor</span>
    <span class="s1">p_t </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">y_pred </span><span class="s2">+ (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">y_true</span><span class="s2">) * (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">focal_factor </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">power</span><span class="s2">(</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">p_t</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">)</span>

    <span class="s1">focal_bce </span><span class="s2">= </span><span class="s1">focal_factor </span><span class="s2">* </span><span class="s1">bce</span>

    <span class="s0">if </span><span class="s1">apply_class_balancing</span><span class="s2">:</span>
        <span class="s1">weight </span><span class="s2">= </span><span class="s1">y_true </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">+ (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">y_true</span><span class="s2">) * (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">alpha</span><span class="s2">)</span>
        <span class="s1">focal_bce </span><span class="s2">= </span><span class="s1">weight </span><span class="s2">* </span><span class="s1">focal_bce</span>

    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">focal_bce</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.CTC&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CTC</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;CTC (Connectionist Temporal Classification) loss. 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;ctc&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">ctc</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.ctc&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">ctc</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;CTC (Connectionist Temporal Classification) loss. 
 
    Args: 
        y_true: A tensor of shape `(batch_size, max_length)` containing 
            the true labels in integer format. `0` always represents 
            the blank/mask index and should not be used for classes. 
        y_pred: A tensor of shape `(batch_size, max_length, num_classes)` 
            containing logits (the output of your model). 
            They should *not* be normalized via softmax. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)) != </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;Targets `y_true` are expected to be a tensor of shape &quot;</span>
            <span class="s3">&quot;`(batch_size, max_length)` in integer format. &quot;</span>
            <span class="s3">f&quot;Received: y_true.shape=</span><span class="s0">{</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)) != </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;Logits `y_pred` are expected to be a tensor of shape &quot;</span>
            <span class="s3">&quot;`(batch_size, max_length, num_classes)`. &quot;</span>
            <span class="s3">f&quot;Received: y_pred.shape=</span><span class="s0">{</span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>

    <span class="s1">mask_index </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">batch_length </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">input_length </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">input_length </span><span class="s2">= </span><span class="s1">input_length </span><span class="s2">* </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s1">batch_length</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">&quot;int32&quot;</span><span class="s2">)</span>
    <span class="s1">label_length </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_true </span><span class="s2">!= </span><span class="s1">mask_index</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">&quot;int32&quot;</span>
    <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">ctc_loss</span><span class="s2">(</span>
        <span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">label_length</span><span class="s2">, </span><span class="s1">input_length</span><span class="s2">, </span><span class="s1">mask_index</span><span class="s2">=</span><span class="s1">mask_index</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.Dice&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Dice</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Dice loss value between `y_true` and `y_pred`. 
 
    Formula: 
    ```python 
    loss = 1 - (2 * sum(y_true * y_pred)) / (sum(y_true) + sum(y_pred)) 
    ``` 
 
    Args: 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        axis: Tuple for which dimensions the loss is calculated. Defaults to 
            `None`. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Returns: 
        Dice loss value. 
 
    Example: 
 
    &gt;&gt;&gt; y_true = [[[[1.0], [1.0]], [[0.0], [0.0]]], 
    ...           [[[1.0], [1.0]], [[0.0], [0.0]]]] 
    &gt;&gt;&gt; y_pred = [[[[0.0], [1.0]], [[0.0], [1.0]]], 
    ...           [[[0.4], [0.0]], [[0.0], [0.9]]]] 
    &gt;&gt;&gt; axis = (1, 2, 3) 
    &gt;&gt;&gt; loss = keras.losses.dice(y_true, y_pred, axis=axis) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.5, 0.75757575], shape=(2,), dtype=float32) 
 
    &gt;&gt;&gt; loss = keras.losses.dice(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == () 
    &gt;&gt;&gt; loss 
    array(0.6164384, shape=(), dtype=float32) 
 
    &gt;&gt;&gt; y_true = np.array(y_true) 
    &gt;&gt;&gt; y_pred = np.array(y_pred) 
    &gt;&gt;&gt; loss = keras.losses.Dice(axis=axis, reduction=None)(y_true, y_pred) 
    &gt;&gt;&gt; assert loss.shape == (2,) 
    &gt;&gt;&gt; loss 
    array([0.5, 0.75757575], shape=(2,), dtype=float32) 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;dice&quot;</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">dice</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s3">&quot;axis&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.dice&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">dice</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Dice loss value between `y_true` and `y_pred`. 
 
    Formula: 
    ```python 
    loss = 1 - (2 * sum(y_true * y_pred)) / (sum(y_true) + sum(y_pred)) 
    ``` 
 
    Args: 
        y_true: tensor of true targets. 
        y_pred: tensor of predicted targets. 
        axis: tuple for which dimensions the loss is calculated 
 
    Returns: 
        Dice loss value. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">inputs </span><span class="s2">= </span><span class="s1">y_true</span>
    <span class="s1">targets </span><span class="s2">= </span><span class="s1">y_pred</span>

    <span class="s1">intersection </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">inputs </span><span class="s2">* </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">dice </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">divide</span><span class="s2">(</span>
        <span class="s5">2.0 </span><span class="s2">* </span><span class="s1">intersection</span><span class="s2">,</span>
        <span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s2">+ </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s2">+ </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(),</span>
    <span class="s2">)</span>

    <span class="s0">return </span><span class="s5">1 </span><span class="s2">- </span><span class="s1">dice</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.Tversky&quot;</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Tversky</span><span class="s2">(</span><span class="s1">LossFunctionWrapper</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Tversky loss value between `y_true` and `y_pred`. 
 
    This loss function is weighted by the alpha and beta coefficients 
    that penalize false positives and false negatives. 
 
    With `alpha=0.5` and `beta=0.5`, the loss value becomes equivalent to 
    Dice Loss. 
 
    Args: 
        alpha: The coefficient controlling incidence of false positives. 
            Defaults to `0.5`. 
        beta: The coefficient controlling incidence of false negatives. 
            Defaults to `0.5`. 
        reduction: Type of reduction to apply to the loss. In almost all cases 
            this should be `&quot;sum_over_batch_size&quot;`. 
            Supported options are `&quot;sum&quot;`, `&quot;sum_over_batch_size&quot;` or `None`. 
        name: Optional name for the loss instance. 
        dtype: The dtype of the loss's computations. Defaults to `None`, which 
            means using `keras.backend.floatx()`. `keras.backend.floatx()` is a 
            `&quot;float32&quot;` unless set to different value 
            (via `keras.backend.set_floatx()`). If a `keras.DTypePolicy` is 
            provided, then the `compute_dtype` will be utilized. 
 
    Returns: 
        Tversky loss value. 
 
    Reference: 
 
    - [Salehi et al., 2017](https://arxiv.org/abs/1706.05721) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">,</span>
        <span class="s1">beta</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">,</span>
        <span class="s1">reduction</span><span class="s2">=</span><span class="s3">&quot;sum_over_batch_size&quot;</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;tversky&quot;</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">tversky</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">reduction</span><span class="s2">=</span><span class="s1">reduction</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">alpha</span><span class="s2">=</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s1">beta</span><span class="s2">=</span><span class="s1">beta</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">alpha </span><span class="s2">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">beta </span><span class="s2">= </span><span class="s1">beta</span>

    <span class="s0">def </span><span class="s1">get_config</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">&quot;alpha&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">alpha</span><span class="s2">,</span>
            <span class="s3">&quot;beta&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">beta</span><span class="s2">,</span>
            <span class="s3">&quot;reduction&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reduction</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s2">@</span><span class="s1">keras_export</span><span class="s2">(</span><span class="s3">&quot;keras.losses.tversky&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">tversky</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Tversky loss value between `y_true` and `y_pred`. 
 
    This loss function is weighted by the alpha and beta coefficients 
    that penalize false positives and false negatives. 
 
    With `alpha=0.5` and `beta=0.5`, the loss value becomes equivalent to 
    Dice Loss. 
 
    Args: 
        y_true: tensor of true targets. 
        y_pred: tensor of predicted targets. 
        alpha: coefficient controlling incidence of false positives. 
        beta: coefficient controlling incidence of false negatives. 
 
    Returns: 
        Tversky loss value. 
 
    Reference: 
 
    - [Salehi et al., 2017](https://arxiv.org/abs/1706.05721) 
    &quot;&quot;&quot;</span>
    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">convert_to_tensor</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">)</span>
    <span class="s1">y_true </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, </span><span class="s1">y_pred</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">inputs </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_true</span><span class="s2">, [-</span><span class="s5">1</span><span class="s2">])</span>
    <span class="s1">targets </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">y_pred</span><span class="s2">, [-</span><span class="s5">1</span><span class="s2">])</span>

    <span class="s1">intersection </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">inputs </span><span class="s2">* </span><span class="s1">targets</span><span class="s2">)</span>
    <span class="s1">fp </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">targets</span><span class="s2">) * </span><span class="s1">inputs</span><span class="s2">)</span>
    <span class="s1">fn </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">targets </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">inputs</span><span class="s2">))</span>
    <span class="s1">tversky </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">divide</span><span class="s2">(</span>
        <span class="s1">intersection</span><span class="s2">,</span>
        <span class="s1">intersection </span><span class="s2">+ </span><span class="s1">fp </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">+ </span><span class="s1">fn </span><span class="s2">* </span><span class="s1">beta </span><span class="s2">+ </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">epsilon</span><span class="s2">(),</span>
    <span class="s2">)</span>

    <span class="s0">return </span><span class="s5">1 </span><span class="s2">- </span><span class="s1">tversky</span>
</pre>
</body>
</html>