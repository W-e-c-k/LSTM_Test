<html>
<head>
<title>etree.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
etree.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># cython: binding=True</span>
<span class="s0"># cython: auto_pickle=False</span>
<span class="s0"># cython: language_level=3</span>

<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">The ``lxml.etree`` module implements the extended ElementTree API for XML.</span>
<span class="s0">&quot;&quot;&quot;</span>

<span class="s0">__docformat__ = &quot;restructuredtext en&quot;</span>

<span class="s0">__all__ = [</span>
    <span class="s0">'AttributeBasedElementClassLookup', 'C14NError', 'C14NWriterTarget', 'CDATA',</span>
    <span class="s0">'Comment', 'CommentBase', 'CustomElementClassLookup', 'DEBUG',</span>
    <span class="s0">'DTD', 'DTDError', 'DTDParseError', 'DTDValidateError',</span>
    <span class="s0">'DocumentInvalid', 'ETCompatXMLParser', 'ETXPath', 'Element',</span>
    <span class="s0">'ElementBase', 'ElementClassLookup', 'ElementDefaultClassLookup',</span>
    <span class="s0">'ElementNamespaceClassLookup', 'ElementTree', 'Entity', 'EntityBase',</span>
    <span class="s0">'Error', 'ErrorDomains', 'ErrorLevels', 'ErrorTypes', 'Extension',</span>
    <span class="s0">'FallbackElementClassLookup', 'FunctionNamespace', 'HTML', 'HTMLParser',</span>
    <span class="s0">'ICONV_COMPILED_VERSION',</span>
    <span class="s0">'LIBXML_COMPILED_VERSION', 'LIBXML_VERSION',</span>
    <span class="s0">'LIBXSLT_COMPILED_VERSION', 'LIBXSLT_VERSION',</span>
    <span class="s0">'LXML_VERSION',</span>
    <span class="s0">'LxmlError', 'LxmlRegistryError', 'LxmlSyntaxError',</span>
    <span class="s0">'NamespaceRegistryError', 'PI', 'PIBase', 'ParseError',</span>
    <span class="s0">'ParserBasedElementClassLookup', 'ParserError', 'ProcessingInstruction',</span>
    <span class="s0">'PyErrorLog', 'PythonElementClassLookup', 'QName', 'RelaxNG',</span>
    <span class="s0">'RelaxNGError', 'RelaxNGErrorTypes', 'RelaxNGParseError',</span>
    <span class="s0">'RelaxNGValidateError', 'Resolver', 'Schematron', 'SchematronError',</span>
    <span class="s0">'SchematronParseError', 'SchematronValidateError', 'SerialisationError',</span>
    <span class="s0">'SubElement', 'TreeBuilder', 'XInclude', 'XIncludeError', 'XML',</span>
    <span class="s0">'XMLDTDID', 'XMLID', 'XMLParser', 'XMLSchema', 'XMLSchemaError',</span>
    <span class="s0">'XMLSchemaParseError', 'XMLSchemaValidateError', 'XMLSyntaxError',</span>
    <span class="s0">'XMLTreeBuilder', 'XPath', 'XPathDocumentEvaluator', 'XPathError',</span>
    <span class="s0">'XPathEvalError', 'XPathEvaluator', 'XPathFunctionError', 'XPathResultError',</span>
    <span class="s0">'XPathSyntaxError', 'XSLT', 'XSLTAccessControl', 'XSLTApplyError',</span>
    <span class="s0">'XSLTError', 'XSLTExtension', 'XSLTExtensionError', 'XSLTParseError',</span>
    <span class="s0">'XSLTSaveError', 'canonicalize',</span>
    <span class="s0">'cleanup_namespaces', 'clear_error_log', 'dump',</span>
    <span class="s0">'fromstring', 'fromstringlist', 'get_default_parser', 'iselement',</span>
    <span class="s0">'iterparse', 'iterwalk', 'parse', 'parseid', 'register_namespace',</span>
    <span class="s0">'set_default_parser', 'set_element_class_lookup', 'strip_attributes',</span>
    <span class="s0">'strip_elements', 'strip_tags', 'tostring', 'tostringlist', 'tounicode',</span>
    <span class="s0">'use_global_python_log'</span>
    <span class="s0">]</span>

<span class="s0">cimport cython</span>

<span class="s0">from lxml cimport python</span>
<span class="s0">from lxml.includes cimport tree, config</span>
<span class="s0">from lxml.includes.tree cimport xmlDoc, xmlNode, xmlAttr, xmlNs, _isElement, _getNs</span>
<span class="s0">from lxml.includes.tree cimport const_xmlChar, xmlChar, _xcstr</span>
<span class="s0">from lxml.python cimport _cstr, _isString</span>
<span class="s0">from lxml.includes cimport xpath</span>
<span class="s0">from lxml.includes cimport c14n</span>

<span class="s0"># Cython's standard declarations</span>
<span class="s0">cimport cpython.mem</span>
<span class="s0">cimport cpython.ref</span>
<span class="s0">from libc cimport limits, stdio, stdlib</span>
<span class="s0">from libc cimport string as cstring_h   # not to be confused with stdlib 'string'</span>
<span class="s0">from libc.string cimport const_char</span>

<span class="s0">cdef object os_path_abspath</span>
<span class="s0">from os.path import abspath as os_path_abspath</span>

<span class="s0">cdef object BytesIO, StringIO</span>
<span class="s0">from io import BytesIO, StringIO</span>

<span class="s0">cdef object OrderedDict</span>
<span class="s0">from collections import OrderedDict</span>

<span class="s0">cdef object _elementpath</span>
<span class="s0">from lxml import _elementpath</span>

<span class="s0">cdef object sys</span>
<span class="s0">import sys</span>

<span class="s0">cdef object re</span>
<span class="s0">import re</span>

<span class="s0">cdef object partial</span>
<span class="s0">from functools import partial</span>

<span class="s0">cdef object islice</span>
<span class="s0">from itertools import islice</span>

<span class="s0">cdef object ITER_EMPTY = iter(())</span>

<span class="s0">cdef object MutableMapping</span>
<span class="s0">from collections.abc import MutableMapping</span>

<span class="s0">class _ImmutableMapping(MutableMapping):</span>
    <span class="s0">def __getitem__(self, key):</span>
        <span class="s0">raise KeyError, key</span>

    <span class="s0">def __setitem__(self, key, value):</span>
        <span class="s0">raise KeyError, key</span>

    <span class="s0">def __delitem__(self, key):</span>
        <span class="s0">raise KeyError, key</span>

    <span class="s0">def __contains__(self, key):</span>
        <span class="s0">return False</span>

    <span class="s0">def __len__(self):</span>
        <span class="s0">return 0</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">return ITER_EMPTY</span>
    <span class="s0">iterkeys = itervalues = iteritems = __iter__</span>

<span class="s0">cdef object IMMUTABLE_EMPTY_MAPPING = _ImmutableMapping()</span>
<span class="s0">del _ImmutableMapping</span>


<span class="s0"># the rules</span>
<span class="s0"># ---------</span>
<span class="s0"># any libxml C argument/variable is prefixed with c_</span>
<span class="s0"># any non-public function/class is prefixed with an underscore</span>
<span class="s0"># instance creation is always through factories</span>

<span class="s0"># what to do with libxml2/libxslt error messages?</span>
<span class="s0"># 0 : drop</span>
<span class="s0"># 1 : use log</span>
<span class="s0">DEF __DEBUG = 1</span>

<span class="s0"># maximum number of lines in the libxml2/xslt log if __DEBUG == 1</span>
<span class="s0">DEF __MAX_LOG_SIZE = 100</span>

<span class="s0"># make the compiled-in debug state publicly available</span>
<span class="s0">DEBUG = __DEBUG</span>

<span class="s0"># A struct to store a cached qualified tag name+href pair.</span>
<span class="s0"># While we can borrow the c_name from the document dict,</span>
<span class="s0"># PyPy requires us to store a Python reference for the</span>
<span class="s0"># namespace in order to keep the byte buffer alive.</span>
<span class="s0">cdef struct qname:</span>
    <span class="s0">const_xmlChar* c_name</span>
    <span class="s0">python.PyObject* href</span>

<span class="s0"># initialize parser (and threading)</span>
<span class="s0">xmlparser.xmlInitParser()</span>

<span class="s0"># global per-thread setup</span>
<span class="s0">tree.xmlThrDefIndentTreeOutput(1)</span>
<span class="s0">tree.xmlThrDefLineNumbersDefaultValue(1)</span>

<span class="s0">_initThreadLogging()</span>

<span class="s0"># filename encoding</span>
<span class="s0">cdef bytes _FILENAME_ENCODING = (sys.getfilesystemencoding() or sys.getdefaultencoding() or 'ascii').encode(&quot;UTF-8&quot;)</span>
<span class="s0">cdef char* _C_FILENAME_ENCODING = _cstr(_FILENAME_ENCODING)</span>

<span class="s0"># set up some default namespace prefixes</span>
<span class="s0">cdef dict _DEFAULT_NAMESPACE_PREFIXES = {</span>
    <span class="s0">b&quot;http://www.w3.org/XML/1998/namespace&quot;: b'xml',</span>
    <span class="s0">b&quot;http://www.w3.org/1999/xhtml&quot;: b&quot;html&quot;,</span>
    <span class="s0">b&quot;http://www.w3.org/1999/XSL/Transform&quot;: b&quot;xsl&quot;,</span>
    <span class="s0">b&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;: b&quot;rdf&quot;,</span>
    <span class="s0">b&quot;http://schemas.xmlsoap.org/wsdl/&quot;: b&quot;wsdl&quot;,</span>
    <span class="s0"># xml schema</span>
    <span class="s0">b&quot;http://www.w3.org/2001/XMLSchema&quot;: b&quot;xs&quot;,</span>
    <span class="s0">b&quot;http://www.w3.org/2001/XMLSchema-instance&quot;: b&quot;xsi&quot;,</span>
    <span class="s0"># dublin core</span>
    <span class="s0">b&quot;http://purl.org/dc/elements/1.1/&quot;: b&quot;dc&quot;,</span>
    <span class="s0"># objectify</span>
    <span class="s0">b&quot;http://codespeak.net/lxml/objectify/pytype&quot; : b&quot;py&quot;,</span>
<span class="s0">}</span>

<span class="s0"># To avoid runtime encoding overhead, we keep a Unicode copy</span>
<span class="s0"># of the uri-prefix mapping as (str, str) items view.</span>
<span class="s0">cdef object _DEFAULT_NAMESPACE_PREFIXES_ITEMS = []</span>

<span class="s0">cdef _update_default_namespace_prefixes_items():</span>
    <span class="s0">cdef bytes ns, prefix</span>
    <span class="s0">global _DEFAULT_NAMESPACE_PREFIXES_ITEMS</span>
    <span class="s0">_DEFAULT_NAMESPACE_PREFIXES_ITEMS = {</span>
        <span class="s0">ns.decode('utf-8') : prefix.decode('utf-8')</span>
        <span class="s0">for ns, prefix in _DEFAULT_NAMESPACE_PREFIXES.items()</span>
    <span class="s0">}.items()</span>

<span class="s0">_update_default_namespace_prefixes_items()</span>

<span class="s0">cdef object _check_internal_prefix = re.compile(br&quot;ns\d+$&quot;).match</span>

<span class="s0">def register_namespace(prefix, uri):</span>
    <span class="s0">&quot;&quot;&quot;Registers a namespace prefix that newly created Elements in that</span>
    <span class="s0">namespace will use.  The registry is global, and any existing</span>
    <span class="s0">mapping for either the given prefix or the namespace URI will be</span>
    <span class="s0">removed.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">prefix_utf, uri_utf = _utf8(prefix), _utf8(uri)</span>
    <span class="s0">if _check_internal_prefix(prefix_utf):</span>
        <span class="s0">raise ValueError(&quot;Prefix format reserved for internal use&quot;)</span>
    <span class="s0">_tagValidOrRaise(prefix_utf)</span>
    <span class="s0">_uriValidOrRaise(uri_utf)</span>
    <span class="s0">if (uri_utf == b&quot;http://www.w3.org/XML/1998/namespace&quot; and prefix_utf != b'xml'</span>
            <span class="s0">or prefix_utf == b'xml' and uri_utf != b&quot;http://www.w3.org/XML/1998/namespace&quot;):</span>
        <span class="s0">raise ValueError(&quot;Cannot change the 'xml' prefix of the XML namespace&quot;)</span>
    <span class="s0">for k, v in list(_DEFAULT_NAMESPACE_PREFIXES.items()):</span>
        <span class="s0">if k == uri_utf or v == prefix_utf:</span>
            <span class="s0">del _DEFAULT_NAMESPACE_PREFIXES[k]</span>
    <span class="s0">_DEFAULT_NAMESPACE_PREFIXES[uri_utf] = prefix_utf</span>
    <span class="s0">_update_default_namespace_prefixes_items()</span>


<span class="s0"># Error superclass for ElementTree compatibility</span>
<span class="s0">cdef class Error(Exception):</span>
    <span class="s0">pass</span>

<span class="s0"># module level superclass for all exceptions</span>
<span class="s0">cdef class LxmlError(Error):</span>
    <span class="s0">&quot;&quot;&quot;Main exception base class for lxml.  All other exceptions inherit from</span>
    <span class="s0">this one.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self, message, error_log=None):</span>
        <span class="s0">super(_Error, self).__init__(message)</span>
        <span class="s0">if error_log is None:</span>
            <span class="s0">self.error_log = __copyGlobalErrorLog()</span>
        <span class="s0">else:</span>
            <span class="s0">self.error_log = error_log.copy()</span>

<span class="s0">cdef object _Error = Error</span>


<span class="s0"># superclass for all syntax errors</span>
<span class="s0">class LxmlSyntaxError(LxmlError, SyntaxError):</span>
    <span class="s0">&quot;&quot;&quot;Base class for all syntax errors.</span>
    <span class="s0">&quot;&quot;&quot;</span>

<span class="s0">cdef class C14NError(LxmlError):</span>
    <span class="s0">&quot;&quot;&quot;Error during C14N serialisation.</span>
    <span class="s0">&quot;&quot;&quot;</span>

<span class="s0"># version information</span>
<span class="s0">cdef tuple __unpackDottedVersion(version):</span>
    <span class="s0">version_list = []</span>
    <span class="s0">l = (version.decode(&quot;ascii&quot;).replace('-', '.').split('.') + [0]*4)[:4]</span>
    <span class="s0">for item in l:</span>
        <span class="s0">try:</span>
            <span class="s0">item = int(item)</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">if item.startswith('dev'):</span>
                <span class="s0">count = item[3:]</span>
                <span class="s0">item = -300</span>
            <span class="s0">elif item.startswith('alpha'):</span>
                <span class="s0">count = item[5:]</span>
                <span class="s0">item = -200</span>
            <span class="s0">elif item.startswith('beta'):</span>
                <span class="s0">count = item[4:]</span>
                <span class="s0">item = -100</span>
            <span class="s0">else:</span>
                <span class="s0">count = 0</span>
            <span class="s0">if count:</span>
                <span class="s0">item += int(count)</span>
        <span class="s0">version_list.append(item)</span>
    <span class="s0">return tuple(version_list)</span>

<span class="s0">cdef tuple __unpackIntVersion(int c_version, int base=100):</span>
    <span class="s0">return (</span>
        <span class="s0">((c_version // (base*base)) % base),</span>
        <span class="s0">((c_version // base)        % base),</span>
        <span class="s0">(c_version                  % base)</span>
        <span class="s0">)</span>

<span class="s0">cdef int _LIBXML_VERSION_INT</span>
<span class="s0">try:</span>
    <span class="s0">_LIBXML_VERSION_INT = int(</span>
        <span class="s0">re.match('[0-9]+', (&lt;unsigned char*&gt;tree.xmlParserVersion).decode(&quot;ascii&quot;)).group(0))</span>
<span class="s0">except Exception:</span>
    <span class="s0">print(&quot;Unknown libxml2 version: &quot; + (&lt;unsigned char*&gt;tree.xmlParserVersion).decode(&quot;latin1&quot;))</span>
    <span class="s0">_LIBXML_VERSION_INT = 0</span>

<span class="s0">LIBXML_VERSION = __unpackIntVersion(_LIBXML_VERSION_INT)</span>
<span class="s0">LIBXML_COMPILED_VERSION = __unpackIntVersion(tree.LIBXML_VERSION)</span>
<span class="s0">LXML_VERSION = __unpackDottedVersion(tree.LXML_VERSION_STRING)</span>

<span class="s0">__version__ = tree.LXML_VERSION_STRING.decode(&quot;ascii&quot;)</span>

<span class="s0">cdef extern from *:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">#ifdef ZLIB_VERNUM</span>
      <span class="s0">#define __lxml_zlib_version (ZLIB_VERNUM &gt;&gt; 4)</span>
    <span class="s0">#else</span>
      <span class="s0">#define __lxml_zlib_version 0</span>
    <span class="s0">#endif</span>
    <span class="s0">#ifdef _LIBICONV_VERSION</span>
      <span class="s0">#define __lxml_iconv_version (_LIBICONV_VERSION &lt;&lt; 8)</span>
    <span class="s0">#else</span>
      <span class="s0">#define __lxml_iconv_version 0</span>
    <span class="s0">#endif</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># zlib isn't included automatically by libxml2's headers</span>
    <span class="s0">#long ZLIB_HEX_VERSION &quot;__lxml_zlib_version&quot;</span>
    <span class="s0">long LIBICONV_HEX_VERSION &quot;__lxml_iconv_version&quot;</span>

<span class="s0">#ZLIB_COMPILED_VERSION = __unpackIntVersion(ZLIB_HEX_VERSION, base=0x10)</span>
<span class="s0">ICONV_COMPILED_VERSION = __unpackIntVersion(LIBICONV_HEX_VERSION, base=0x100)[:2]</span>


<span class="s0"># class for temporary storage of Python references,</span>
<span class="s0"># used e.g. for XPath results</span>
<span class="s0">@cython.final</span>
<span class="s0">@cython.internal</span>
<span class="s0">cdef class _TempStore:</span>
    <span class="s0">cdef list _storage</span>
    <span class="s0">def __init__(self):</span>
        <span class="s0">self._storage = []</span>

    <span class="s0">cdef int add(self, obj) except -1:</span>
        <span class="s0">self._storage.append(obj)</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef int clear(self) except -1:</span>
        <span class="s0">del self._storage[:]</span>
        <span class="s0">return 0</span>


<span class="s0"># class for temporarily storing exceptions raised in extensions</span>
<span class="s0">@cython.internal</span>
<span class="s0">cdef class _ExceptionContext:</span>
    <span class="s0">cdef object _exc_info</span>
    <span class="s0">cdef int clear(self) except -1:</span>
        <span class="s0">self._exc_info = None</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef void _store_raised(self) noexcept:</span>
        <span class="s0">try:</span>
            <span class="s0">self._exc_info = sys.exc_info()</span>
        <span class="s0">except BaseException as e:</span>
            <span class="s0">self._store_exception(e)</span>
        <span class="s0">finally:</span>
            <span class="s0">return  # and swallow any further exceptions</span>

    <span class="s0">cdef int _store_exception(self, exception) except -1:</span>
        <span class="s0">self._exc_info = (exception, None, None)</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef bint _has_raised(self) except -1:</span>
        <span class="s0">return self._exc_info is not None</span>

    <span class="s0">cdef int _raise_if_stored(self) except -1:</span>
        <span class="s0">if self._exc_info is None:</span>
            <span class="s0">return 0</span>
        <span class="s0">type, value, traceback = self._exc_info</span>
        <span class="s0">self._exc_info = None</span>
        <span class="s0">if value is None and traceback is None:</span>
            <span class="s0">raise type</span>
        <span class="s0">else:</span>
            <span class="s0">raise type, value, traceback</span>


<span class="s0"># type of a function that steps from node to node</span>
<span class="s0">ctypedef public xmlNode* (*_node_to_node_function)(xmlNode*)</span>


<span class="s0">################################################################################</span>
<span class="s0"># Include submodules</span>

<span class="s0">include &quot;proxy.pxi&quot;        # Proxy handling (element backpointers/memory/etc.)</span>
<span class="s0">include &quot;apihelpers.pxi&quot;   # Private helper functions</span>
<span class="s0">include &quot;xmlerror.pxi&quot;     # Error and log handling</span>


<span class="s0">################################################################################</span>
<span class="s0"># Public Python API</span>

<span class="s0">@cython.final</span>
<span class="s0">@cython.freelist(8)</span>
<span class="s0">cdef public class _Document [ type LxmlDocumentType, object LxmlDocument ]:</span>
    <span class="s0">&quot;&quot;&quot;Internal base class to reference a libxml document.</span>

    <span class="s0">When instances of this class are garbage collected, the libxml</span>
    <span class="s0">document is cleaned up.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef int _ns_counter</span>
    <span class="s0">cdef bytes _prefix_tail</span>
    <span class="s0">cdef xmlDoc* _c_doc</span>
    <span class="s0">cdef _BaseParser _parser</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0"># if there are no more references to the document, it is safe</span>
        <span class="s0"># to clean the whole thing up, as all nodes have a reference to</span>
        <span class="s0"># the document</span>
        <span class="s0">tree.xmlFreeDoc(self._c_doc)</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef getroot(self):</span>
        <span class="s0"># return an element proxy for the document root</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">c_node = tree.xmlDocGetRootElement(self._c_doc)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">return None</span>
        <span class="s0">return _elementFactory(self, c_node)</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef bint hasdoctype(self) noexcept:</span>
        <span class="s0"># DOCTYPE gets parsed into internal subset (xmlDTD*)</span>
        <span class="s0">return self._c_doc is not NULL and self._c_doc.intSubset is not NULL</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef getdoctype(self):</span>
        <span class="s0"># get doctype info: root tag, public/system ID (or None if not known)</span>
        <span class="s0">cdef tree.xmlDtd* c_dtd</span>
        <span class="s0">cdef xmlNode* c_root_node</span>
        <span class="s0">public_id = None</span>
        <span class="s0">sys_url   = None</span>
        <span class="s0">c_dtd = self._c_doc.intSubset</span>
        <span class="s0">if c_dtd is not NULL:</span>
            <span class="s0">if c_dtd.ExternalID is not NULL:</span>
                <span class="s0">public_id = funicode(c_dtd.ExternalID)</span>
            <span class="s0">if c_dtd.SystemID is not NULL:</span>
                <span class="s0">sys_url = funicode(c_dtd.SystemID)</span>
        <span class="s0">c_dtd = self._c_doc.extSubset</span>
        <span class="s0">if c_dtd is not NULL:</span>
            <span class="s0">if not public_id and c_dtd.ExternalID is not NULL:</span>
                <span class="s0">public_id = funicode(c_dtd.ExternalID)</span>
            <span class="s0">if not sys_url and c_dtd.SystemID is not NULL:</span>
                <span class="s0">sys_url = funicode(c_dtd.SystemID)</span>
        <span class="s0">c_root_node = tree.xmlDocGetRootElement(self._c_doc)</span>
        <span class="s0">if c_root_node is NULL:</span>
            <span class="s0">root_name = None</span>
        <span class="s0">else:</span>
            <span class="s0">root_name = funicode(c_root_node.name)</span>
        <span class="s0">return root_name, public_id, sys_url</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef getxmlinfo(self):</span>
        <span class="s0"># return XML version and encoding (or None if not known)</span>
        <span class="s0">cdef xmlDoc* c_doc = self._c_doc</span>
        <span class="s0">if c_doc.version is NULL:</span>
            <span class="s0">version = None</span>
        <span class="s0">else:</span>
            <span class="s0">version = funicode(c_doc.version)</span>
        <span class="s0">if c_doc.encoding is NULL:</span>
            <span class="s0">encoding = None</span>
        <span class="s0">else:</span>
            <span class="s0">encoding = funicode(c_doc.encoding)</span>
        <span class="s0">return version, encoding</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef isstandalone(self):</span>
        <span class="s0"># returns True for &quot;standalone=true&quot;,</span>
        <span class="s0"># False for &quot;standalone=false&quot;, None if not provided</span>
        <span class="s0">if self._c_doc.standalone == -1:</span>
            <span class="s0">return None</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;bint&gt;(self._c_doc.standalone == 1)</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef bytes buildNewPrefix(self):</span>
        <span class="s0"># get a new unique prefix (&quot;nsX&quot;) for this document</span>
        <span class="s0">cdef bytes ns</span>
        <span class="s0">if self._ns_counter &lt; len(_PREFIX_CACHE):</span>
            <span class="s0">ns = _PREFIX_CACHE[self._ns_counter]</span>
        <span class="s0">else:</span>
            <span class="s0">ns = python.PyBytes_FromFormat(&quot;ns%d&quot;, self._ns_counter)</span>
        <span class="s0">if self._prefix_tail is not None:</span>
            <span class="s0">ns += self._prefix_tail</span>
        <span class="s0">self._ns_counter += 1</span>
        <span class="s0">if self._ns_counter &lt; 0:</span>
            <span class="s0"># overflow!</span>
            <span class="s0">self._ns_counter = 0</span>
            <span class="s0">if self._prefix_tail is None:</span>
                <span class="s0">self._prefix_tail = b&quot;A&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">self._prefix_tail += b&quot;A&quot;</span>
        <span class="s0">return ns</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef xmlNs* _findOrBuildNodeNs(self, xmlNode* c_node,</span>
                                   <span class="s0">const_xmlChar* c_href, const_xmlChar* c_prefix,</span>
                                   <span class="s0">bint is_attribute) except NULL:</span>
        <span class="s0">&quot;&quot;&quot;Get or create namespace structure for a node.  Reuses the prefix if</span>
        <span class="s0">possible.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNs* c_ns</span>
        <span class="s0">cdef xmlNs* c_doc_ns</span>
        <span class="s0">cdef python.PyObject* dict_result</span>
        <span class="s0">if c_node.type != tree.XML_ELEMENT_NODE:</span>
            <span class="s0">assert c_node.type == tree.XML_ELEMENT_NODE, \</span>
                <span class="s0">&quot;invalid node type %d, expected %d&quot; % (</span>
                <span class="s0">c_node.type, tree.XML_ELEMENT_NODE)</span>
        <span class="s0"># look for existing ns declaration</span>
        <span class="s0">c_ns = _searchNsByHref(c_node, c_href, is_attribute)</span>
        <span class="s0">if c_ns is not NULL:</span>
            <span class="s0">if is_attribute and c_ns.prefix is NULL:</span>
                <span class="s0"># do not put namespaced attributes into the default</span>
                <span class="s0"># namespace as this would break serialisation</span>
                <span class="s0">pass</span>
            <span class="s0">else:</span>
                <span class="s0">return c_ns</span>

        <span class="s0"># none found =&gt; determine a suitable new prefix</span>
        <span class="s0">if c_prefix is NULL:</span>
            <span class="s0">dict_result = python.PyDict_GetItem(</span>
                <span class="s0">_DEFAULT_NAMESPACE_PREFIXES, &lt;unsigned char*&gt;c_href)</span>
            <span class="s0">if dict_result is not NULL:</span>
                <span class="s0">prefix = &lt;object&gt;dict_result</span>
            <span class="s0">else:</span>
                <span class="s0">prefix = self.buildNewPrefix()</span>
            <span class="s0">c_prefix = _xcstr(prefix)</span>

        <span class="s0"># make sure the prefix is not in use already</span>
        <span class="s0">while tree.xmlSearchNs(self._c_doc, c_node, c_prefix) is not NULL:</span>
            <span class="s0">prefix = self.buildNewPrefix()</span>
            <span class="s0">c_prefix = _xcstr(prefix)</span>

        <span class="s0"># declare the namespace and return it</span>
        <span class="s0">c_ns = tree.xmlNewNs(c_node, c_href, c_prefix)</span>
        <span class="s0">if c_ns is NULL:</span>
            <span class="s0">raise MemoryError()</span>
        <span class="s0">return c_ns</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef int _setNodeNs(self, xmlNode* c_node, const_xmlChar* c_href) except -1:</span>
        <span class="s0">&quot;Lookup namespace structure and set it for the node.&quot;</span>
        <span class="s0">c_ns = self._findOrBuildNodeNs(c_node, c_href, NULL, 0)</span>
        <span class="s0">tree.xmlSetNs(c_node, c_ns)</span>

<span class="s0">cdef tuple __initPrefixCache():</span>
    <span class="s0">cdef int i</span>
    <span class="s0">return tuple([ python.PyBytes_FromFormat(&quot;ns%d&quot;, i)</span>
                   <span class="s0">for i in range(30) ])</span>

<span class="s0">cdef tuple _PREFIX_CACHE = __initPrefixCache()</span>

<span class="s0">cdef _Document _documentFactory(xmlDoc* c_doc, _BaseParser parser):</span>
    <span class="s0">cdef _Document result</span>
    <span class="s0">result = _Document.__new__(_Document)</span>
    <span class="s0">result._c_doc = c_doc</span>
    <span class="s0">result._ns_counter = 0</span>
    <span class="s0">result._prefix_tail = None</span>
    <span class="s0">if parser is None:</span>
        <span class="s0">parser = __GLOBAL_PARSER_CONTEXT.getDefaultParser()</span>
    <span class="s0">result._parser = parser</span>
    <span class="s0">return result</span>


<span class="s0">cdef object _find_invalid_public_id_characters = re.compile(</span>
    <span class="s0">ur&quot;[^\x20\x0D\x0Aa-zA-Z0-9'()+,./:=?;!*#@$_%-]+&quot;).search</span>


<span class="s0">cdef class DocInfo:</span>
    <span class="s0">&quot;Document information provided by parser and DTD.&quot;</span>
    <span class="s0">cdef _Document _doc</span>
    <span class="s0">def __cinit__(self, tree):</span>
        <span class="s0">&quot;Create a DocInfo object for an ElementTree object or root Element.&quot;</span>
        <span class="s0">self._doc = _documentOrRaise(tree)</span>
        <span class="s0">root_name, public_id, system_url = self._doc.getdoctype()</span>
        <span class="s0">if not root_name and (public_id or system_url):</span>
            <span class="s0">raise ValueError, &quot;Could not find root node&quot;</span>

    <span class="s0">@property</span>
    <span class="s0">def root_name(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the name of the root node as defined by the DOCTYPE.&quot;&quot;&quot;</span>
        <span class="s0">root_name, public_id, system_url = self._doc.getdoctype()</span>
        <span class="s0">return root_name</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef tree.xmlDtd* _get_c_dtd(self):</span>
        <span class="s0">&quot;&quot;&quot;&quot;Return the DTD. Create it if it does not yet exist.&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlDoc* c_doc = self._doc._c_doc</span>
        <span class="s0">cdef xmlNode* c_root_node</span>
        <span class="s0">cdef const_xmlChar* c_name</span>

        <span class="s0">if c_doc.intSubset:</span>
            <span class="s0">return c_doc.intSubset</span>

        <span class="s0">c_root_node = tree.xmlDocGetRootElement(c_doc)</span>
        <span class="s0">c_name = c_root_node.name if c_root_node else NULL</span>
        <span class="s0">return  tree.xmlCreateIntSubset(c_doc, c_name, NULL, NULL)</span>

    <span class="s0">def clear(self):</span>
        <span class="s0">&quot;&quot;&quot;Removes DOCTYPE and internal subset from the document.&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlDoc* c_doc = self._doc._c_doc</span>
        <span class="s0">cdef tree.xmlNode* c_dtd = &lt;xmlNode*&gt;c_doc.intSubset</span>
        <span class="s0">if c_dtd is NULL:</span>
            <span class="s0">return</span>
        <span class="s0">tree.xmlUnlinkNode(c_dtd)</span>
        <span class="s0">tree.xmlFreeNode(c_dtd)</span>

    <span class="s0">property public_id:</span>
        <span class="s0">&quot;&quot;&quot;Public ID of the DOCTYPE.</span>

        <span class="s0">Mutable.  May be set to a valid string or None.  If a DTD does not</span>
        <span class="s0">exist, setting this variable (even to None) will create one.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">root_name, public_id, system_url = self._doc.getdoctype()</span>
            <span class="s0">return public_id</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">cdef xmlChar* c_value = NULL</span>
            <span class="s0">if value is not None:</span>
                <span class="s0">match = _find_invalid_public_id_characters(value)</span>
                <span class="s0">if match:</span>
                    <span class="s0">raise ValueError, f'Invalid character(s) {match.group(0)!r} in public_id.'</span>
                <span class="s0">value = _utf8(value)</span>
                <span class="s0">c_value = tree.xmlStrdup(_xcstr(value))</span>
                <span class="s0">if not c_value:</span>
                    <span class="s0">raise MemoryError()</span>

            <span class="s0">c_dtd = self._get_c_dtd()</span>
            <span class="s0">if not c_dtd:</span>
                <span class="s0">tree.xmlFree(c_value)</span>
                <span class="s0">raise MemoryError()</span>
            <span class="s0">if c_dtd.ExternalID:</span>
                <span class="s0">tree.xmlFree(&lt;void*&gt;c_dtd.ExternalID)</span>
            <span class="s0">c_dtd.ExternalID = c_value</span>

    <span class="s0">property system_url:</span>
        <span class="s0">&quot;&quot;&quot;System ID of the DOCTYPE.</span>

        <span class="s0">Mutable.  May be set to a valid string or None.  If a DTD does not</span>
        <span class="s0">exist, setting this variable (even to None) will create one.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">root_name, public_id, system_url = self._doc.getdoctype()</span>
            <span class="s0">return system_url</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">cdef xmlChar* c_value = NULL</span>
            <span class="s0">if value is not None:</span>
                <span class="s0">bvalue = _utf8(value)</span>
                <span class="s0"># sys_url may be any valid unicode string that can be</span>
                <span class="s0"># enclosed in single quotes or quotes.</span>
                <span class="s0">if b&quot;'&quot; in bvalue and b'&quot;' in bvalue:</span>
                    <span class="s0">raise ValueError(</span>
                        <span class="s0">'System URL may not contain both single (\') and double quotes (&quot;).')</span>
                <span class="s0">c_value = tree.xmlStrdup(_xcstr(bvalue))</span>
                <span class="s0">if not c_value:</span>
                    <span class="s0">raise MemoryError()</span>

            <span class="s0">c_dtd = self._get_c_dtd()</span>
            <span class="s0">if not c_dtd:</span>
                <span class="s0">tree.xmlFree(c_value)</span>
                <span class="s0">raise MemoryError()</span>
            <span class="s0">if c_dtd.SystemID:</span>
                <span class="s0">tree.xmlFree(&lt;void*&gt;c_dtd.SystemID)</span>
            <span class="s0">c_dtd.SystemID = c_value</span>

    <span class="s0">@property</span>
    <span class="s0">def xml_version(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the XML version as declared by the document.&quot;&quot;&quot;</span>
        <span class="s0">xml_version, encoding = self._doc.getxmlinfo()</span>
        <span class="s0">return xml_version</span>

    <span class="s0">@property</span>
    <span class="s0">def encoding(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the encoding name as declared by the document.&quot;&quot;&quot;</span>
        <span class="s0">xml_version, encoding = self._doc.getxmlinfo()</span>
        <span class="s0">return encoding</span>

    <span class="s0">@property</span>
    <span class="s0">def standalone(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the standalone flag as declared by the document.  The possible</span>
        <span class="s0">values are True (``standalone='yes'``), False</span>
        <span class="s0">(``standalone='no'`` or flag not provided in the declaration),</span>
        <span class="s0">and None (unknown or no declaration found).  Note that a</span>
        <span class="s0">normal truth test on this value will always tell if the</span>
        <span class="s0">``standalone`` flag was set to ``'yes'`` or not.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._doc.isstandalone()</span>

    <span class="s0">property URL:</span>
        <span class="s0">&quot;The source URL of the document (or None if unknown).&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">if self._doc._c_doc.URL is NULL:</span>
                <span class="s0">return None</span>
            <span class="s0">return _decodeFilename(self._doc._c_doc.URL)</span>
        <span class="s0">def __set__(self, url):</span>
            <span class="s0">url = _encodeFilename(url)</span>
            <span class="s0">c_oldurl = self._doc._c_doc.URL</span>
            <span class="s0">if url is None:</span>
                <span class="s0">self._doc._c_doc.URL = NULL</span>
            <span class="s0">else:</span>
                <span class="s0">self._doc._c_doc.URL = tree.xmlStrdup(_xcstr(url))</span>
            <span class="s0">if c_oldurl is not NULL:</span>
                <span class="s0">tree.xmlFree(&lt;void*&gt;c_oldurl)</span>

    <span class="s0">@property</span>
    <span class="s0">def doctype(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a DOCTYPE declaration string for the document.&quot;&quot;&quot;</span>
        <span class="s0">root_name, public_id, system_url = self._doc.getdoctype()</span>
        <span class="s0">if system_url:</span>
            <span class="s0"># If '&quot;' in system_url, we must escape it with single</span>
            <span class="s0"># quotes, otherwise escape with double quotes. If url</span>
            <span class="s0"># contains both a single quote and a double quote, XML</span>
            <span class="s0"># standard is being violated.</span>
            <span class="s0">if '&quot;' in system_url:</span>
                <span class="s0">quoted_system_url = f&quot;'{system_url}'&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">quoted_system_url = f'&quot;{system_url}&quot;'</span>
        <span class="s0">if public_id:</span>
            <span class="s0">if system_url:</span>
                <span class="s0">return f'&lt;!DOCTYPE {root_name} PUBLIC &quot;{public_id}&quot; {quoted_system_url}&gt;'</span>
            <span class="s0">else:</span>
                <span class="s0">return f'&lt;!DOCTYPE {root_name} PUBLIC &quot;{public_id}&quot;&gt;'</span>
        <span class="s0">elif system_url:</span>
            <span class="s0">return f'&lt;!DOCTYPE {root_name} SYSTEM {quoted_system_url}&gt;'</span>
        <span class="s0">elif self._doc.hasdoctype():</span>
            <span class="s0">return f'&lt;!DOCTYPE {root_name}&gt;'</span>
        <span class="s0">else:</span>
            <span class="s0">return ''</span>

    <span class="s0">@property</span>
    <span class="s0">def internalDTD(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a DTD validator based on the internal subset of the document.&quot;&quot;&quot;</span>
        <span class="s0">return _dtdFactory(self._doc._c_doc.intSubset)</span>

    <span class="s0">@property</span>
    <span class="s0">def externalDTD(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a DTD validator based on the external subset of the document.&quot;&quot;&quot;</span>
        <span class="s0">return _dtdFactory(self._doc._c_doc.extSubset)</span>


<span class="s0">@cython.no_gc_clear</span>
<span class="s0">cdef public class _Element [ type LxmlElementType, object LxmlElement ]:</span>
    <span class="s0">&quot;&quot;&quot;Element class.</span>

    <span class="s0">References a document object and a libxml node.</span>

    <span class="s0">By pointing to a Document instance, a reference is kept to</span>
    <span class="s0">_Document as long as there is some pointer to a node in it.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document _doc</span>
    <span class="s0">cdef xmlNode* _c_node</span>
    <span class="s0">cdef object _tag</span>

    <span class="s0">def _init(self):</span>
        <span class="s0">&quot;&quot;&quot;_init(self)</span>

        <span class="s0">Called after object initialisation.  Custom subclasses may override</span>
        <span class="s0">this if they recursively call _init() in the superclasses.</span>
        <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">@cython.linetrace(False)</span>
    <span class="s0">@cython.profile(False)</span>
    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">#print(&quot;trying to free node:&quot;, &lt;int&gt;self._c_node)</span>
        <span class="s0">#displayNode(self._c_node, 0)</span>
        <span class="s0">if self._c_node is not NULL:</span>
            <span class="s0">_unregisterProxy(self)</span>
            <span class="s0">attemptDeallocation(self._c_node)</span>

    <span class="s0"># MANIPULATORS</span>

    <span class="s0">def __setitem__(self, x, value):</span>
        <span class="s0">&quot;&quot;&quot;__setitem__(self, x, value)</span>

        <span class="s0">Replaces the given subelement index or slice.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node = NULL</span>
        <span class="s0">cdef xmlNode* c_next</span>
        <span class="s0">cdef xmlDoc* c_source_doc</span>
        <span class="s0">cdef _Element element</span>
        <span class="s0">cdef bint left_to_right</span>
        <span class="s0">cdef Py_ssize_t slicelength = 0, step = 0</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">if value is None:</span>
            <span class="s0">raise ValueError, &quot;cannot assign None&quot;</span>
        <span class="s0">if isinstance(x, slice):</span>
            <span class="s0"># slice assignment</span>
            <span class="s0">_findChildSlice(&lt;slice&gt;x, self._c_node, &amp;c_node, &amp;step, &amp;slicelength)</span>
            <span class="s0">if step &gt; 0:</span>
                <span class="s0">left_to_right = 1</span>
            <span class="s0">else:</span>
                <span class="s0">left_to_right = 0</span>
                <span class="s0">step = -step</span>
            <span class="s0">_replaceSlice(self, c_node, slicelength, step, left_to_right, value)</span>
            <span class="s0">return</span>
        <span class="s0">else:</span>
            <span class="s0"># otherwise: normal item assignment</span>
            <span class="s0">element = value</span>
            <span class="s0">_assertValidNode(element)</span>
            <span class="s0">c_node = _findChild(self._c_node, x)</span>
            <span class="s0">if c_node is NULL:</span>
                <span class="s0">raise IndexError, &quot;list index out of range&quot;</span>
            <span class="s0">c_source_doc = element._c_node.doc</span>
            <span class="s0">c_next = element._c_node.next</span>
            <span class="s0">_removeText(c_node.next)</span>
            <span class="s0">tree.xmlReplaceNode(c_node, element._c_node)</span>
            <span class="s0">_moveTail(c_next, element._c_node)</span>
            <span class="s0">moveNodeToDocument(self._doc, c_source_doc, element._c_node)</span>
            <span class="s0">if not attemptDeallocation(c_node):</span>
                <span class="s0">moveNodeToDocument(self._doc, c_node.doc, c_node)</span>

    <span class="s0">def __delitem__(self, x):</span>
        <span class="s0">&quot;&quot;&quot;__delitem__(self, x)</span>

        <span class="s0">Deletes the given subelement or a slice.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node = NULL</span>
        <span class="s0">cdef xmlNode* c_next</span>
        <span class="s0">cdef Py_ssize_t step = 0, slicelength = 0</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">if isinstance(x, slice):</span>
            <span class="s0"># slice deletion</span>
            <span class="s0">if _isFullSlice(&lt;slice&gt;x):</span>
                <span class="s0">c_node = self._c_node.children</span>
                <span class="s0">if c_node is not NULL:</span>
                    <span class="s0">if not _isElement(c_node):</span>
                        <span class="s0">c_node = _nextElement(c_node)</span>
                    <span class="s0">while c_node is not NULL:</span>
                        <span class="s0">c_next = _nextElement(c_node)</span>
                        <span class="s0">_removeNode(self._doc, c_node)</span>
                        <span class="s0">c_node = c_next</span>
            <span class="s0">else:</span>
                <span class="s0">_findChildSlice(&lt;slice&gt;x, self._c_node, &amp;c_node, &amp;step, &amp;slicelength)</span>
                <span class="s0">_deleteSlice(self._doc, c_node, slicelength, step)</span>
        <span class="s0">else:</span>
            <span class="s0"># item deletion</span>
            <span class="s0">c_node = _findChild(self._c_node, x)</span>
            <span class="s0">if c_node is NULL:</span>
                <span class="s0">raise IndexError, f&quot;index out of range: {x}&quot;</span>
            <span class="s0">_removeNode(self._doc, c_node)</span>

    <span class="s0">def __deepcopy__(self, memo):</span>
        <span class="s0">&quot;__deepcopy__(self, memo)&quot;</span>
        <span class="s0">return self.__copy__()</span>

    <span class="s0">def __copy__(self):</span>
        <span class="s0">&quot;__copy__(self)&quot;</span>
        <span class="s0">cdef xmlDoc* c_doc</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef _Document new_doc</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">c_doc = _copyDocRoot(self._doc._c_doc, self._c_node) # recursive</span>
        <span class="s0">new_doc = _documentFactory(c_doc, self._doc._parser)</span>
        <span class="s0">root = new_doc.getroot()</span>
        <span class="s0">if root is not None:</span>
            <span class="s0">return root</span>
        <span class="s0"># Comment/PI</span>
        <span class="s0">c_node = c_doc.children</span>
        <span class="s0">while c_node is not NULL and c_node.type != self._c_node.type:</span>
            <span class="s0">c_node = c_node.next</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">return None</span>
        <span class="s0">return _elementFactory(new_doc, c_node)</span>

    <span class="s0">def set(self, key, value):</span>
        <span class="s0">&quot;&quot;&quot;set(self, key, value)</span>

        <span class="s0">Sets an element attribute.</span>
        <span class="s0">In HTML documents (not XML or XHTML), the value None is allowed and creates</span>
        <span class="s0">an attribute without value (just the attribute name).</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_setAttributeValue(self, key, value)</span>

    <span class="s0">def append(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;append(self, element)</span>

        <span class="s0">Adds a subelement to the end of this element.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">_appendChild(self, element)</span>

    <span class="s0">def addnext(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;addnext(self, element)</span>

        <span class="s0">Adds the element as a following sibling directly after this</span>
        <span class="s0">element.</span>

        <span class="s0">This is normally used to set a processing instruction or comment after</span>
        <span class="s0">the root node of a document.  Note that tail text is automatically</span>
        <span class="s0">discarded when adding at the root level.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">if self._c_node.parent != NULL and not _isElement(self._c_node.parent):</span>
            <span class="s0">if element._c_node.type not in (tree.XML_PI_NODE, tree.XML_COMMENT_NODE):</span>
                <span class="s0">raise TypeError, &quot;Only processing instructions and comments can be siblings of the root element&quot;</span>
            <span class="s0">element.tail = None</span>
        <span class="s0">_appendSibling(self, element)</span>

    <span class="s0">def addprevious(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;addprevious(self, element)</span>

        <span class="s0">Adds the element as a preceding sibling directly before this</span>
        <span class="s0">element.</span>

        <span class="s0">This is normally used to set a processing instruction or comment</span>
        <span class="s0">before the root node of a document.  Note that tail text is</span>
        <span class="s0">automatically discarded when adding at the root level.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">if self._c_node.parent != NULL and not _isElement(self._c_node.parent):</span>
            <span class="s0">if element._c_node.type != tree.XML_PI_NODE:</span>
                <span class="s0">if element._c_node.type != tree.XML_COMMENT_NODE:</span>
                    <span class="s0">raise TypeError, &quot;Only processing instructions and comments can be siblings of the root element&quot;</span>
            <span class="s0">element.tail = None</span>
        <span class="s0">_prependSibling(self, element)</span>

    <span class="s0">def extend(self, elements):</span>
        <span class="s0">&quot;&quot;&quot;extend(self, elements)</span>

        <span class="s0">Extends the current children by the elements in the iterable.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef _Element element</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">for element in elements:</span>
            <span class="s0">if element is None:</span>
                <span class="s0">raise TypeError, &quot;Node must not be None&quot;</span>
            <span class="s0">_assertValidNode(element)</span>
            <span class="s0">_appendChild(self, element)</span>

    <span class="s0">def clear(self, bint keep_tail=False):</span>
        <span class="s0">&quot;&quot;&quot;clear(self, keep_tail=False)</span>

        <span class="s0">Resets an element.  This function removes all subelements, clears</span>
        <span class="s0">all attributes and sets the text and tail properties to None.</span>

        <span class="s0">Pass ``keep_tail=True`` to leave the tail text untouched.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlAttr* c_attr</span>
        <span class="s0">cdef xmlAttr* c_attr_next</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef xmlNode* c_node_next</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">c_node = self._c_node</span>
        <span class="s0"># remove self.text and self.tail</span>
        <span class="s0">_removeText(c_node.children)</span>
        <span class="s0">if not keep_tail:</span>
            <span class="s0">_removeText(c_node.next)</span>
        <span class="s0"># remove all attributes</span>
        <span class="s0">c_attr = c_node.properties</span>
        <span class="s0">if c_attr:</span>
            <span class="s0">c_node.properties = NULL</span>
            <span class="s0">tree.xmlFreePropList(c_attr)</span>
        <span class="s0"># remove all subelements</span>
        <span class="s0">c_node = c_node.children</span>
        <span class="s0">if c_node and not _isElement(c_node):</span>
            <span class="s0">c_node = _nextElement(c_node)</span>
        <span class="s0">while c_node is not NULL:</span>
            <span class="s0">c_node_next = _nextElement(c_node)</span>
            <span class="s0">_removeNode(self._doc, c_node)</span>
            <span class="s0">c_node = c_node_next</span>

    <span class="s0">def insert(self, index: int, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;insert(self, index, element)</span>

        <span class="s0">Inserts a subelement at the given position in this element</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef xmlNode* c_next</span>
        <span class="s0">cdef xmlDoc* c_source_doc</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">c_node = _findChild(self._c_node, index)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">_appendChild(self, element)</span>
            <span class="s0">return</span>
        <span class="s0"># prevent cycles</span>
        <span class="s0">if _isAncestorOrSame(element._c_node, self._c_node):</span>
            <span class="s0">raise ValueError(&quot;cannot append parent to itself&quot;)</span>
        <span class="s0">c_source_doc = element._c_node.doc</span>
        <span class="s0">c_next = element._c_node.next</span>
        <span class="s0">tree.xmlAddPrevSibling(c_node, element._c_node)</span>
        <span class="s0">_moveTail(c_next, element._c_node)</span>
        <span class="s0">moveNodeToDocument(self._doc, c_source_doc, element._c_node)</span>

    <span class="s0">def remove(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;remove(self, element)</span>

        <span class="s0">Removes a matching subelement. Unlike the find methods, this</span>
        <span class="s0">method compares elements based on identity, not on tag value</span>
        <span class="s0">or contents.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef xmlNode* c_next</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">c_node = element._c_node</span>
        <span class="s0">if c_node.parent is not self._c_node:</span>
            <span class="s0">raise ValueError, &quot;Element is not a child of this node.&quot;</span>
        <span class="s0">c_next = element._c_node.next</span>
        <span class="s0">tree.xmlUnlinkNode(c_node)</span>
        <span class="s0">_moveTail(c_next, c_node)</span>
        <span class="s0"># fix namespace declarations</span>
        <span class="s0">moveNodeToDocument(self._doc, c_node.doc, c_node)</span>

    <span class="s0">def replace(self, _Element old_element not None,</span>
                <span class="s0">_Element new_element not None):</span>
        <span class="s0">&quot;&quot;&quot;replace(self, old_element, new_element)</span>

        <span class="s0">Replaces a subelement with the element passed as second argument.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_old_node</span>
        <span class="s0">cdef xmlNode* c_old_next</span>
        <span class="s0">cdef xmlNode* c_new_node</span>
        <span class="s0">cdef xmlNode* c_new_next</span>
        <span class="s0">cdef xmlDoc* c_source_doc</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(old_element)</span>
        <span class="s0">_assertValidNode(new_element)</span>
        <span class="s0">c_old_node = old_element._c_node</span>
        <span class="s0">if c_old_node.parent is not self._c_node:</span>
            <span class="s0">raise ValueError, &quot;Element is not a child of this node.&quot;</span>
        <span class="s0">c_new_node = new_element._c_node</span>
        <span class="s0"># prevent cycles</span>
        <span class="s0">if _isAncestorOrSame(c_new_node, self._c_node):</span>
            <span class="s0">raise ValueError(&quot;cannot append parent to itself&quot;)</span>
        <span class="s0"># replace node</span>
        <span class="s0">c_old_next = c_old_node.next</span>
        <span class="s0">c_new_next = c_new_node.next</span>
        <span class="s0">c_source_doc = c_new_node.doc</span>
        <span class="s0">tree.xmlReplaceNode(c_old_node, c_new_node)</span>
        <span class="s0">_moveTail(c_new_next, c_new_node)</span>
        <span class="s0">_moveTail(c_old_next, c_old_node)</span>
        <span class="s0">moveNodeToDocument(self._doc, c_source_doc, c_new_node)</span>
        <span class="s0"># fix namespace declarations</span>
        <span class="s0">moveNodeToDocument(self._doc, c_old_node.doc, c_old_node)</span>

    <span class="s0"># PROPERTIES</span>
    <span class="s0">property tag:</span>
        <span class="s0">&quot;&quot;&quot;Element tag</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">if self._tag is not None:</span>
                <span class="s0">return self._tag</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">self._tag = _namespacedName(self._c_node)</span>
            <span class="s0">return self._tag</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">cdef _BaseParser parser</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">ns, name = _getNsTag(value)</span>
            <span class="s0">parser = self._doc._parser</span>
            <span class="s0">if parser is not None and parser._for_html:</span>
                <span class="s0">_htmlTagValidOrRaise(name)</span>
            <span class="s0">else:</span>
                <span class="s0">_tagValidOrRaise(name)</span>
            <span class="s0">self._tag = value</span>
            <span class="s0">tree.xmlNodeSetName(self._c_node, _xcstr(name))</span>
            <span class="s0">if ns is None:</span>
                <span class="s0">self._c_node.ns = NULL</span>
            <span class="s0">else:</span>
                <span class="s0">self._doc._setNodeNs(self._c_node, _xcstr(ns))</span>

    <span class="s0">@property</span>
    <span class="s0">def attrib(self):</span>
        <span class="s0">&quot;&quot;&quot;Element attribute dictionary. Where possible, use get(), set(),</span>
        <span class="s0">keys(), values() and items() to access element attributes.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return _Attrib.__new__(_Attrib, self)</span>

    <span class="s0">property text:</span>
        <span class="s0">&quot;&quot;&quot;Text before the first subelement. This is either a string or</span>
        <span class="s0">the value None, if there was no text.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">return _collectText(self._c_node.children)</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">if isinstance(value, QName):</span>
                <span class="s0">value = _resolveQNameText(self, value).decode('utf8')</span>
            <span class="s0">_setNodeText(self._c_node, value)</span>

        <span class="s0"># using 'del el.text' is the wrong thing to do</span>
        <span class="s0">#def __del__(self):</span>
        <span class="s0">#    _setNodeText(self._c_node, None)</span>

    <span class="s0">property tail:</span>
        <span class="s0">&quot;&quot;&quot;Text after this element's end tag, but before the next sibling</span>
        <span class="s0">element's start tag. This is either a string or the value None, if</span>
        <span class="s0">there was no text.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">return _collectText(self._c_node.next)</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">_setTailText(self._c_node, value)</span>

        <span class="s0"># using 'del el.tail' is the wrong thing to do</span>
        <span class="s0">#def __del__(self):</span>
        <span class="s0">#    _setTailText(self._c_node, None)</span>

    <span class="s0"># not in ElementTree, read-only</span>
    <span class="s0">@property</span>
    <span class="s0">def prefix(self):</span>
        <span class="s0">&quot;&quot;&quot;Namespace prefix or None.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._c_node.ns is not NULL:</span>
            <span class="s0">if self._c_node.ns.prefix is not NULL:</span>
                <span class="s0">return funicode(self._c_node.ns.prefix)</span>
        <span class="s0">return None</span>

    <span class="s0"># not in ElementTree, read-only</span>
    <span class="s0">property sourceline:</span>
        <span class="s0">&quot;&quot;&quot;Original line number as found by the parser or None if unknown.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">cdef long line</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">line = tree.xmlGetLineNo(self._c_node)</span>
            <span class="s0">return line if line &gt; 0 else None</span>

        <span class="s0">def __set__(self, line):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">if line &lt;= 0:</span>
                <span class="s0">self._c_node.line = 0</span>
            <span class="s0">else:</span>
                <span class="s0">self._c_node.line = line</span>

    <span class="s0"># not in ElementTree, read-only</span>
    <span class="s0">@property</span>
    <span class="s0">def nsmap(self):</span>
        <span class="s0">&quot;&quot;&quot;Namespace prefix-&gt;URI mapping known in the context of this</span>
        <span class="s0">Element.  This includes all namespace declarations of the</span>
        <span class="s0">parents.</span>

        <span class="s0">Note that changing the returned dict has no effect on the Element.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _build_nsmap(self._c_node)</span>

    <span class="s0"># not in ElementTree, read-only</span>
    <span class="s0">property base:</span>
        <span class="s0">&quot;&quot;&quot;The base URI of the Element (xml:base or HTML base URL).</span>
        <span class="s0">None if the base URI is unknown.</span>

        <span class="s0">Note that the value depends on the URL of the document that</span>
        <span class="s0">holds the Element if there is no xml:base attribute on the</span>
        <span class="s0">Element or its ancestors.</span>

        <span class="s0">Setting this property will set an xml:base attribute on the</span>
        <span class="s0">Element, regardless of the document type (XML or HTML).</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">c_base = tree.xmlNodeGetBase(self._doc._c_doc, self._c_node)</span>
            <span class="s0">if c_base is NULL:</span>
                <span class="s0">if self._doc._c_doc.URL is NULL:</span>
                    <span class="s0">return None</span>
                <span class="s0">return _decodeFilename(self._doc._c_doc.URL)</span>
            <span class="s0">try:</span>
                <span class="s0">base = _decodeFilename(c_base)</span>
            <span class="s0">finally:</span>
                <span class="s0">tree.xmlFree(c_base)</span>
            <span class="s0">return base</span>

        <span class="s0">def __set__(self, url):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">if url is None:</span>
                <span class="s0">c_base = &lt;const_xmlChar*&gt;NULL</span>
            <span class="s0">else:</span>
                <span class="s0">url = _encodeFilename(url)</span>
                <span class="s0">c_base = _xcstr(url)</span>
            <span class="s0">tree.xmlNodeSetBase(self._c_node, c_base)</span>

    <span class="s0"># ACCESSORS</span>
    <span class="s0">def __repr__(self):</span>
        <span class="s0">&quot;__repr__(self)&quot;</span>
        <span class="s0">return &quot;&lt;Element %s at 0x%x&gt;&quot; % (self.tag, id(self))</span>

    <span class="s0">def __getitem__(self, x):</span>
        <span class="s0">&quot;&quot;&quot;Returns the subelement at the given position or the requested</span>
        <span class="s0">slice.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node = NULL</span>
        <span class="s0">cdef Py_ssize_t step = 0, slicelength = 0</span>
        <span class="s0">cdef Py_ssize_t c, i</span>
        <span class="s0">cdef _node_to_node_function next_element</span>
        <span class="s0">cdef list result</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">if isinstance(x, slice):</span>
            <span class="s0"># slicing</span>
            <span class="s0">if _isFullSlice(&lt;slice&gt;x):</span>
                <span class="s0">return _collectChildren(self)</span>
            <span class="s0">_findChildSlice(&lt;slice&gt;x, self._c_node, &amp;c_node, &amp;step, &amp;slicelength)</span>
            <span class="s0">if c_node is NULL:</span>
                <span class="s0">return []</span>
            <span class="s0">if step &gt; 0:</span>
                <span class="s0">next_element = _nextElement</span>
            <span class="s0">else:</span>
                <span class="s0">step = -step</span>
                <span class="s0">next_element = _previousElement</span>
            <span class="s0">result = []</span>
            <span class="s0">c = 0</span>
            <span class="s0">while c_node is not NULL and c &lt; slicelength:</span>
                <span class="s0">result.append(_elementFactory(self._doc, c_node))</span>
                <span class="s0">c += 1</span>
                <span class="s0">for i in range(step):</span>
                    <span class="s0">c_node = next_element(c_node)</span>
                    <span class="s0">if c_node is NULL:</span>
                        <span class="s0">break</span>
            <span class="s0">return result</span>
        <span class="s0">else:</span>
            <span class="s0"># indexing</span>
            <span class="s0">c_node = _findChild(self._c_node, x)</span>
            <span class="s0">if c_node is NULL:</span>
                <span class="s0">raise IndexError, &quot;list index out of range&quot;</span>
            <span class="s0">return _elementFactory(self._doc, c_node)</span>

    <span class="s0">def __len__(self):</span>
        <span class="s0">&quot;&quot;&quot;__len__(self)</span>

        <span class="s0">Returns the number of subelements.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _countElements(self._c_node.children)</span>

    <span class="s0">def __bool__(self):</span>
        <span class="s0">&quot;&quot;&quot;__bool__(self)&quot;&quot;&quot;</span>
        <span class="s0">import warnings</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;The behavior of this method will change in future versions. &quot;</span>
            <span class="s0">&quot;Use specific 'len(elem)' or 'elem is not None' test instead.&quot;,</span>
            <span class="s0">FutureWarning</span>
            <span class="s0">)</span>
        <span class="s0"># emulate old behaviour</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _hasChild(self._c_node)</span>

    <span class="s0">def __contains__(self, element):</span>
        <span class="s0">&quot;__contains__(self, element)&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">if not isinstance(element, _Element):</span>
            <span class="s0">return 0</span>
        <span class="s0">c_node = (&lt;_Element&gt;element)._c_node</span>
        <span class="s0">return c_node is not NULL and c_node.parent is self._c_node</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">&quot;__iter__(self)&quot;</span>
        <span class="s0">return ElementChildIterator(self)</span>

    <span class="s0">def __reversed__(self):</span>
        <span class="s0">&quot;__reversed__(self)&quot;</span>
        <span class="s0">return ElementChildIterator(self, reversed=True)</span>

    <span class="s0">def index(self, child: _Element, start: int = None, stop: int = None):</span>
        <span class="s0">&quot;&quot;&quot;index(self, child, start=None, stop=None)</span>

        <span class="s0">Find the position of the child within the parent.</span>

        <span class="s0">This method is not part of the original ElementTree API.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef Py_ssize_t k, l</span>
        <span class="s0">cdef Py_ssize_t c_start, c_stop</span>
        <span class="s0">cdef xmlNode* c_child</span>
        <span class="s0">cdef xmlNode* c_start_node</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">_assertValidNode(child)</span>
        <span class="s0">c_child = child._c_node</span>
        <span class="s0">if c_child.parent is not self._c_node:</span>
            <span class="s0">raise ValueError, &quot;Element is not a child of this node.&quot;</span>

        <span class="s0"># handle the unbounded search straight away (normal case)</span>
        <span class="s0">if stop is None and (start is None or start == 0):</span>
            <span class="s0">k = 0</span>
            <span class="s0">c_child = c_child.prev</span>
            <span class="s0">while c_child is not NULL:</span>
                <span class="s0">if _isElement(c_child):</span>
                    <span class="s0">k += 1</span>
                <span class="s0">c_child = c_child.prev</span>
            <span class="s0">return k</span>

        <span class="s0"># check indices</span>
        <span class="s0">if start is None:</span>
            <span class="s0">c_start = 0</span>
        <span class="s0">else:</span>
            <span class="s0">c_start = start</span>
        <span class="s0">if stop is None:</span>
            <span class="s0">c_stop = 0</span>
        <span class="s0">else:</span>
            <span class="s0">c_stop = stop</span>
            <span class="s0">if c_stop == 0 or \</span>
                   <span class="s0">c_start &gt;= c_stop and (c_stop &gt; 0 or c_start &lt; 0):</span>
                <span class="s0">raise ValueError, &quot;list.index(x): x not in slice&quot;</span>

        <span class="s0"># for negative slice indices, check slice before searching index</span>
        <span class="s0">if c_start &lt; 0 or c_stop &lt; 0:</span>
            <span class="s0"># start from right, at most up to leftmost(c_start, c_stop)</span>
            <span class="s0">if c_start &lt; c_stop:</span>
                <span class="s0">k = -c_start</span>
            <span class="s0">else:</span>
                <span class="s0">k = -c_stop</span>
            <span class="s0">c_start_node = self._c_node.last</span>
            <span class="s0">l = 1</span>
            <span class="s0">while c_start_node != c_child and l &lt; k:</span>
                <span class="s0">if _isElement(c_start_node):</span>
                    <span class="s0">l += 1</span>
                <span class="s0">c_start_node = c_start_node.prev</span>
            <span class="s0">if c_start_node == c_child:</span>
                <span class="s0"># found! before slice end?</span>
                <span class="s0">if c_stop &lt; 0 and l &lt;= -c_stop:</span>
                    <span class="s0">raise ValueError, &quot;list.index(x): x not in slice&quot;</span>
            <span class="s0">elif c_start &lt; 0:</span>
                <span class="s0">raise ValueError, &quot;list.index(x): x not in slice&quot;</span>

        <span class="s0"># now determine the index backwards from child</span>
        <span class="s0">c_child = c_child.prev</span>
        <span class="s0">k = 0</span>
        <span class="s0">if c_stop &gt; 0:</span>
            <span class="s0"># we can optimize: stop after c_stop elements if not found</span>
            <span class="s0">while c_child != NULL and k &lt; c_stop:</span>
                <span class="s0">if _isElement(c_child):</span>
                    <span class="s0">k += 1</span>
                <span class="s0">c_child = c_child.prev</span>
            <span class="s0">if k &lt; c_stop:</span>
                <span class="s0">return k</span>
        <span class="s0">else:</span>
            <span class="s0"># traverse all</span>
            <span class="s0">while c_child != NULL:</span>
                <span class="s0">if _isElement(c_child):</span>
                    <span class="s0">k = k + 1</span>
                <span class="s0">c_child = c_child.prev</span>
            <span class="s0">if c_start &gt; 0:</span>
                <span class="s0">if k &gt;= c_start:</span>
                    <span class="s0">return k</span>
            <span class="s0">else:</span>
                <span class="s0">return k</span>
        <span class="s0">if c_start != 0 or c_stop != 0:</span>
            <span class="s0">raise ValueError, &quot;list.index(x): x not in slice&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError, &quot;list.index(x): x not in list&quot;</span>

    <span class="s0">def get(self, key, default=None):</span>
        <span class="s0">&quot;&quot;&quot;get(self, key, default=None)</span>

        <span class="s0">Gets an element attribute.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _getAttributeValue(self, key, default)</span>

    <span class="s0">def keys(self):</span>
        <span class="s0">&quot;&quot;&quot;keys(self)</span>

        <span class="s0">Gets a list of attribute names.  The names are returned in an</span>
        <span class="s0">arbitrary order (just like for an ordinary Python dictionary).</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _collectAttributes(self._c_node, 1)</span>

    <span class="s0">def values(self):</span>
        <span class="s0">&quot;&quot;&quot;values(self)</span>

        <span class="s0">Gets element attribute values as a sequence of strings.  The</span>
        <span class="s0">attributes are returned in an arbitrary order.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _collectAttributes(self._c_node, 2)</span>

    <span class="s0">def items(self):</span>
        <span class="s0">&quot;&quot;&quot;items(self)</span>

        <span class="s0">Gets element attributes, as a sequence. The attributes are returned in</span>
        <span class="s0">an arbitrary order.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _collectAttributes(self._c_node, 3)</span>

    <span class="s0">def getchildren(self):</span>
        <span class="s0">&quot;&quot;&quot;getchildren(self)</span>

        <span class="s0">Returns all direct children.  The elements are returned in document</span>
        <span class="s0">order.</span>

        <span class="s0">:deprecated: Note that this method has been deprecated as of</span>
          <span class="s0">ElementTree 1.3 and lxml 2.0.  New code should use</span>
          <span class="s0">``list(element)`` or simply iterate over elements.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return _collectChildren(self)</span>

    <span class="s0">def getparent(self):</span>
        <span class="s0">&quot;&quot;&quot;getparent(self)</span>

        <span class="s0">Returns the parent of this element or None for the root element.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">#_assertValidNode(self) # not needed</span>
        <span class="s0">c_node = _parentElement(self._c_node)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">return None</span>
        <span class="s0">return _elementFactory(self._doc, c_node)</span>

    <span class="s0">def getnext(self):</span>
        <span class="s0">&quot;&quot;&quot;getnext(self)</span>

        <span class="s0">Returns the following sibling of this element or None.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">#_assertValidNode(self) # not needed</span>
        <span class="s0">c_node = _nextElement(self._c_node)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">return None</span>
        <span class="s0">return _elementFactory(self._doc, c_node)</span>

    <span class="s0">def getprevious(self):</span>
        <span class="s0">&quot;&quot;&quot;getprevious(self)</span>

        <span class="s0">Returns the preceding sibling of this element or None.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">#_assertValidNode(self) # not needed</span>
        <span class="s0">c_node = _previousElement(self._c_node)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">return None</span>
        <span class="s0">return _elementFactory(self._doc, c_node)</span>

    <span class="s0">def itersiblings(self, tag=None, *tags, preceding=False):</span>
        <span class="s0">&quot;&quot;&quot;itersiblings(self, tag=None, *tags, preceding=False)</span>

        <span class="s0">Iterate over the following or preceding siblings of this element.</span>

        <span class="s0">The direction is determined by the 'preceding' keyword which</span>
        <span class="s0">defaults to False, i.e. forward iteration over the following</span>
        <span class="s0">siblings.  When True, the iterator yields the preceding</span>
        <span class="s0">siblings in reverse document order, i.e. starting right before</span>
        <span class="s0">the current element and going backwards.</span>

        <span class="s0">Can be restricted to find only elements with specific tags,</span>
        <span class="s0">see `iter`.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if preceding:</span>
            <span class="s0">if self._c_node and not self._c_node.prev:</span>
                <span class="s0">return ITER_EMPTY</span>
        <span class="s0">elif self._c_node and not self._c_node.next:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return SiblingsIterator(self, tags, preceding=preceding)</span>

    <span class="s0">def iterancestors(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;iterancestors(self, tag=None, *tags)</span>

        <span class="s0">Iterate over the ancestors of this element (from parent to parent).</span>

        <span class="s0">Can be restricted to find only elements with specific tags,</span>
        <span class="s0">see `iter`.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._c_node and not self._c_node.parent:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return AncestorsIterator(self, tags)</span>

    <span class="s0">def iterdescendants(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;iterdescendants(self, tag=None, *tags)</span>

        <span class="s0">Iterate over the descendants of this element in document order.</span>

        <span class="s0">As opposed to ``el.iter()``, this iterator does not yield the element</span>
        <span class="s0">itself.  The returned elements can be restricted to find only elements</span>
        <span class="s0">with specific tags, see `iter`.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._c_node and not self._c_node.children:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return ElementDepthFirstIterator(self, tags, inclusive=False)</span>

    <span class="s0">def iterchildren(self, tag=None, *tags, reversed=False):</span>
        <span class="s0">&quot;&quot;&quot;iterchildren(self, tag=None, *tags, reversed=False)</span>

        <span class="s0">Iterate over the children of this element.</span>

        <span class="s0">As opposed to using normal iteration on this element, the returned</span>
        <span class="s0">elements can be reversed with the 'reversed' keyword and restricted</span>
        <span class="s0">to find only elements with specific tags, see `iter`.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._c_node and not self._c_node.children:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return ElementChildIterator(self, tags, reversed=reversed)</span>

    <span class="s0">def getroottree(self):</span>
        <span class="s0">&quot;&quot;&quot;getroottree(self)</span>

        <span class="s0">Return an ElementTree for the root node of the document that</span>
        <span class="s0">contains this element.</span>

        <span class="s0">This is the same as following element.getparent() up the tree until it</span>
        <span class="s0">returns None (for the root element) and then build an ElementTree for</span>
        <span class="s0">the last parent that was returned.&quot;&quot;&quot;</span>
        <span class="s0">_assertValidDoc(self._doc)</span>
        <span class="s0">return _elementTreeFactory(self._doc, None)</span>

    <span class="s0">def getiterator(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;getiterator(self, tag=None, *tags)</span>

        <span class="s0">Returns a sequence or iterator of all elements in the subtree in</span>
        <span class="s0">document order (depth first pre-order), starting with this</span>
        <span class="s0">element.</span>

        <span class="s0">Can be restricted to find only elements with specific tags,</span>
        <span class="s0">see `iter`.</span>

        <span class="s0">:deprecated: Note that this method is deprecated as of</span>
          <span class="s0">ElementTree 1.3 and lxml 2.0.  It returns an iterator in</span>
          <span class="s0">lxml, which diverges from the original ElementTree</span>
          <span class="s0">behaviour.  If you want an efficient iterator, use the</span>
          <span class="s0">``element.iter()`` method instead.  You should only use this</span>
          <span class="s0">method in new code if you require backwards compatibility</span>
          <span class="s0">with older versions of lxml or ElementTree.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return ElementDepthFirstIterator(self, tags)</span>

    <span class="s0">def iter(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;iter(self, tag=None, *tags)</span>

        <span class="s0">Iterate over all elements in the subtree in document order (depth</span>
        <span class="s0">first pre-order), starting with this element.</span>

        <span class="s0">Can be restricted to find only elements with specific tags:</span>
        <span class="s0">pass ``&quot;{ns}localname&quot;`` as tag. Either or both of ``ns`` and</span>
        <span class="s0">``localname`` can be ``*`` for a wildcard; ``ns`` can be empty</span>
        <span class="s0">for no namespace. ``&quot;localname&quot;`` is equivalent to ``&quot;{}localname&quot;``</span>
        <span class="s0">(i.e. no namespace) but ``&quot;*&quot;`` is ``&quot;{*}*&quot;`` (any or no namespace),</span>
        <span class="s0">not ``&quot;{}*&quot;``.</span>

        <span class="s0">You can also pass the Element, Comment, ProcessingInstruction and</span>
        <span class="s0">Entity factory functions to look only for the specific element type.</span>

        <span class="s0">Passing multiple tags (or a sequence of tags) instead of a single tag</span>
        <span class="s0">will let the iterator return all elements matching any of these tags,</span>
        <span class="s0">in document order.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return ElementDepthFirstIterator(self, tags)</span>

    <span class="s0">def itertext(self, tag=None, *tags, with_tail=True):</span>
        <span class="s0">&quot;&quot;&quot;itertext(self, tag=None, *tags, with_tail=True)</span>

        <span class="s0">Iterates over the text content of a subtree.</span>

        <span class="s0">You can pass tag names to restrict text content to specific elements,</span>
        <span class="s0">see `iter`.</span>

        <span class="s0">You can set the ``with_tail`` keyword argument to ``False`` to skip</span>
        <span class="s0">over tail text.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return ElementTextIterator(self, tags, with_tail=with_tail)</span>

    <span class="s0">def makeelement(self, _tag, attrib=None, nsmap=None, **_extra):</span>
        <span class="s0">&quot;&quot;&quot;makeelement(self, _tag, attrib=None, nsmap=None, **_extra)</span>

        <span class="s0">Creates a new element associated with the same document.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidDoc(self._doc)</span>
        <span class="s0">return _makeElement(_tag, NULL, self._doc, None, None, None,</span>
                            <span class="s0">attrib, nsmap, _extra)</span>

    <span class="s0">def find(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;find(self, path, namespaces=None)</span>

        <span class="s0">Finds the first matching subelement, by tag name or path.</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(path, QName):</span>
            <span class="s0">path = (&lt;QName&gt;path).text</span>
        <span class="s0">return _elementpath.find(self, path, namespaces, with_prefixes=not _isHtmlDocument(self))</span>

    <span class="s0">def findtext(self, path, default=None, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;findtext(self, path, default=None, namespaces=None)</span>

        <span class="s0">Finds text for the first matching subelement, by tag name or path.</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(path, QName):</span>
            <span class="s0">path = (&lt;QName&gt;path).text</span>
        <span class="s0">return _elementpath.findtext(self, path, default, namespaces, with_prefixes=not _isHtmlDocument(self))</span>

    <span class="s0">def findall(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;findall(self, path, namespaces=None)</span>

        <span class="s0">Finds all matching subelements, by tag name or path.</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(path, QName):</span>
            <span class="s0">path = (&lt;QName&gt;path).text</span>
        <span class="s0">return _elementpath.findall(self, path, namespaces, with_prefixes=not _isHtmlDocument(self))</span>

    <span class="s0">def iterfind(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;iterfind(self, path, namespaces=None)</span>

        <span class="s0">Iterates over all matching subelements, by tag name or path.</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(path, QName):</span>
            <span class="s0">path = (&lt;QName&gt;path).text</span>
        <span class="s0">return _elementpath.iterfind(self, path, namespaces, with_prefixes=not _isHtmlDocument(self))</span>

    <span class="s0">def xpath(self, _path, *, namespaces=None, extensions=None,</span>
              <span class="s0">smart_strings=True, **_variables):</span>
        <span class="s0">&quot;&quot;&quot;xpath(self, _path, namespaces=None, extensions=None, smart_strings=True, **_variables)</span>

        <span class="s0">Evaluate an xpath expression using the element as context node.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">evaluator = XPathElementEvaluator(self, namespaces=namespaces,</span>
                                          <span class="s0">extensions=extensions,</span>
                                          <span class="s0">smart_strings=smart_strings)</span>
        <span class="s0">return evaluator(_path, **_variables)</span>

    <span class="s0">def cssselect(self, expr, *, translator='xml'):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Run the CSS expression on this element and its children,</span>
        <span class="s0">returning a list of the results.</span>

        <span class="s0">Equivalent to lxml.cssselect.CSSSelect(expr)(self) -- note</span>
        <span class="s0">that pre-compiling the expression can provide a substantial</span>
        <span class="s0">speedup.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># Do the import here to make the dependency optional.</span>
        <span class="s0">from lxml.cssselect import CSSSelector</span>
        <span class="s0">return CSSSelector(expr, translator=translator)(self)</span>


<span class="s0">cdef extern from &quot;includes/etree_defs.h&quot;:</span>
    <span class="s0"># macro call to 't-&gt;tp_new()' for fast instantiation</span>
    <span class="s0">cdef object NEW_ELEMENT &quot;PY_NEW&quot; (object t)</span>


<span class="s0">@cython.linetrace(False)</span>
<span class="s0">cdef _Element _elementFactory(_Document doc, xmlNode* c_node):</span>
    <span class="s0">cdef _Element result</span>
    <span class="s0">result = getProxy(c_node)</span>
    <span class="s0">if result is not None:</span>
        <span class="s0">return result</span>
    <span class="s0">if c_node is NULL:</span>
        <span class="s0">return None</span>

    <span class="s0">element_class = LOOKUP_ELEMENT_CLASS(</span>
        <span class="s0">ELEMENT_CLASS_LOOKUP_STATE, doc, c_node)</span>
    <span class="s0">if hasProxy(c_node):</span>
        <span class="s0"># prevent re-entry race condition - we just called into Python</span>
        <span class="s0">return getProxy(c_node)</span>
    <span class="s0">result = NEW_ELEMENT(element_class)</span>
    <span class="s0">if hasProxy(c_node):</span>
        <span class="s0"># prevent re-entry race condition - we just called into Python</span>
        <span class="s0">result._c_node = NULL</span>
        <span class="s0">return getProxy(c_node)</span>

    <span class="s0">_registerProxy(result, doc, c_node)</span>
    <span class="s0">if element_class is not _Element:</span>
        <span class="s0">result._init()</span>
    <span class="s0">return result</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class __ContentOnlyElement(_Element):</span>
    <span class="s0">cdef int _raiseImmutable(self) except -1:</span>
        <span class="s0">raise TypeError, &quot;this element does not have children or attributes&quot;</span>

    <span class="s0">def set(self, key, value):</span>
        <span class="s0">&quot;set(self, key, value)&quot;</span>
        <span class="s0">self._raiseImmutable()</span>

    <span class="s0">def append(self, value):</span>
        <span class="s0">&quot;append(self, value)&quot;</span>
        <span class="s0">self._raiseImmutable()</span>

    <span class="s0">def insert(self, index, value):</span>
        <span class="s0">&quot;insert(self, index, value)&quot;</span>
        <span class="s0">self._raiseImmutable()</span>

    <span class="s0">def __setitem__(self, index, value):</span>
        <span class="s0">&quot;__setitem__(self, index, value)&quot;</span>
        <span class="s0">self._raiseImmutable()</span>

    <span class="s0">@property</span>
    <span class="s0">def attrib(self):</span>
        <span class="s0">return IMMUTABLE_EMPTY_MAPPING</span>

    <span class="s0">property text:</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">return funicodeOrEmpty(self._c_node.content)</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">cdef tree.xmlDict* c_dict</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">if value is None:</span>
                <span class="s0">c_text = &lt;const_xmlChar*&gt;NULL</span>
            <span class="s0">else:</span>
                <span class="s0">value = _utf8(value)</span>
                <span class="s0">c_text = _xcstr(value)</span>
            <span class="s0">tree.xmlNodeSetContent(self._c_node, c_text)</span>

    <span class="s0"># ACCESSORS</span>
    <span class="s0">def __getitem__(self, x):</span>
        <span class="s0">&quot;__getitem__(self, x)&quot;</span>
        <span class="s0">if isinstance(x, slice):</span>
            <span class="s0">return []</span>
        <span class="s0">else:</span>
            <span class="s0">raise IndexError, &quot;list index out of range&quot;</span>

    <span class="s0">def __len__(self):</span>
        <span class="s0">&quot;__len__(self)&quot;</span>
        <span class="s0">return 0</span>

    <span class="s0">def get(self, key, default=None):</span>
        <span class="s0">&quot;get(self, key, default=None)&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def keys(self):</span>
        <span class="s0">&quot;keys(self)&quot;</span>
        <span class="s0">return []</span>

    <span class="s0">def items(self):</span>
        <span class="s0">&quot;items(self)&quot;</span>
        <span class="s0">return []</span>

    <span class="s0">def values(self):</span>
        <span class="s0">&quot;values(self)&quot;</span>
        <span class="s0">return []</span>

<span class="s0">cdef class _Comment(__ContentOnlyElement):</span>
    <span class="s0">@property</span>
    <span class="s0">def tag(self):</span>
        <span class="s0">return Comment</span>

    <span class="s0">def __repr__(self):</span>
        <span class="s0">return &quot;&lt;!--%s--&gt;&quot; % self.text</span>

<span class="s0">cdef class _ProcessingInstruction(__ContentOnlyElement):</span>
    <span class="s0">@property</span>
    <span class="s0">def tag(self):</span>
        <span class="s0">return ProcessingInstruction</span>

    <span class="s0">property target:</span>
        <span class="s0"># not in ElementTree</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">return funicode(self._c_node.name)</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">value = _utf8(value)</span>
            <span class="s0">c_text = _xcstr(value)</span>
            <span class="s0">tree.xmlNodeSetName(self._c_node, c_text)</span>

    <span class="s0">def __repr__(self):</span>
        <span class="s0">text = self.text</span>
        <span class="s0">if text:</span>
            <span class="s0">return &quot;&lt;?%s %s?&gt;&quot; % (self.target, text)</span>
        <span class="s0">else:</span>
            <span class="s0">return &quot;&lt;?%s?&gt;&quot; % self.target</span>

    <span class="s0">def get(self, key, default=None):</span>
        <span class="s0">&quot;&quot;&quot;get(self, key, default=None)</span>

        <span class="s0">Try to parse pseudo-attributes from the text content of the</span>
        <span class="s0">processing instruction, search for one with the given key as</span>
        <span class="s0">name and return its associated value.</span>

        <span class="s0">Note that this is only a convenience method for the most</span>
        <span class="s0">common case that all text content is structured in</span>
        <span class="s0">attribute-like name-value pairs with properly quoted values.</span>
        <span class="s0">It is not guaranteed to work for all possible text content.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.attrib.get(key, default)</span>

    <span class="s0">@property</span>
    <span class="s0">def attrib(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a dict containing all pseudo-attributes that can be</span>
        <span class="s0">parsed from the text content of this processing instruction.</span>
        <span class="s0">Note that modifying the dict currently has no effect on the</span>
        <span class="s0">XML node, although this is not guaranteed to stay this way.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return { attr : (value1 or value2)</span>
                 <span class="s0">for attr, value1, value2 in _FIND_PI_ATTRIBUTES(' ' + self.text) }</span>

<span class="s0">cdef object _FIND_PI_ATTRIBUTES = re.compile(r'\s+(\w+)\s*=\s*(?:\'([^\']*)\'|&quot;([^&quot;]*)&quot;)', re.U).findall</span>

<span class="s0">cdef class _Entity(__ContentOnlyElement):</span>
    <span class="s0">@property</span>
    <span class="s0">def tag(self):</span>
        <span class="s0">return Entity</span>

    <span class="s0">property name:</span>
        <span class="s0"># not in ElementTree</span>
        <span class="s0">def __get__(self):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">return funicode(self._c_node.name)</span>

        <span class="s0">def __set__(self, value):</span>
            <span class="s0">_assertValidNode(self)</span>
            <span class="s0">value_utf = _utf8(value)</span>
            <span class="s0">if b'&amp;' in value_utf or b';' in value_utf:</span>
                <span class="s0">raise ValueError, f&quot;Invalid entity name '{value}'&quot;</span>
            <span class="s0">tree.xmlNodeSetName(self._c_node, _xcstr(value_utf))</span>

    <span class="s0">@property</span>
    <span class="s0">def text(self):</span>
        <span class="s0"># FIXME: should this be None or '&amp;[VALUE];' or the resolved</span>
        <span class="s0"># entity value ?</span>
        <span class="s0">_assertValidNode(self)</span>
        <span class="s0">return f'&amp;{funicode(self._c_node.name)};'</span>

    <span class="s0">def __repr__(self):</span>
        <span class="s0">return &quot;&amp;%s;&quot; % self.name</span>


<span class="s0">cdef class QName:</span>
    <span class="s0">&quot;&quot;&quot;QName(text_or_uri_or_element, tag=None)</span>

    <span class="s0">QName wrapper for qualified XML names.</span>

    <span class="s0">Pass a tag name by itself or a namespace URI and a tag name to</span>
    <span class="s0">create a qualified name.  Alternatively, pass an Element to</span>
    <span class="s0">extract its tag name.  ``None`` as first argument is ignored in</span>
    <span class="s0">order to allow for generic 2-argument usage.</span>

    <span class="s0">The ``text`` property holds the qualified name in</span>
    <span class="s0">``{namespace}tagname`` notation.  The ``namespace`` and</span>
    <span class="s0">``localname`` properties hold the respective parts of the tag</span>
    <span class="s0">name.</span>

    <span class="s0">You can pass QName objects wherever a tag name is expected.  Also,</span>
    <span class="s0">setting Element text from a QName will resolve the namespace prefix</span>
    <span class="s0">on assignment and set a qualified text value.  This is helpful in XML</span>
    <span class="s0">languages like SOAP or XML-Schema that use prefixed tag names in</span>
    <span class="s0">their text content.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef readonly unicode text</span>
    <span class="s0">cdef readonly unicode localname</span>
    <span class="s0">cdef readonly unicode namespace</span>
    <span class="s0">def __init__(self, text_or_uri_or_element, tag=None):</span>
        <span class="s0">if text_or_uri_or_element is None:</span>
            <span class="s0"># Allow None as no namespace.</span>
            <span class="s0">text_or_uri_or_element, tag = tag, None</span>
        <span class="s0">if not _isString(text_or_uri_or_element):</span>
            <span class="s0">if isinstance(text_or_uri_or_element, _Element):</span>
                <span class="s0">text_or_uri_or_element = (&lt;_Element&gt;text_or_uri_or_element).tag</span>
                <span class="s0">if not _isString(text_or_uri_or_element):</span>
                    <span class="s0">raise ValueError, f&quot;Invalid input tag of type {type(text_or_uri_or_element)!r}&quot;</span>
            <span class="s0">elif isinstance(text_or_uri_or_element, QName):</span>
                <span class="s0">text_or_uri_or_element = (&lt;QName&gt;text_or_uri_or_element).text</span>
            <span class="s0">elif text_or_uri_or_element is not None:</span>
                <span class="s0">text_or_uri_or_element = unicode(text_or_uri_or_element)</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError, f&quot;Invalid input tag of type {type(text_or_uri_or_element)!r}&quot;</span>

        <span class="s0">ns_utf, tag_utf = _getNsTag(text_or_uri_or_element)</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0"># either ('ns', 'tag') or ('{ns}oldtag', 'newtag')</span>
            <span class="s0">if ns_utf is None:</span>
                <span class="s0">ns_utf = tag_utf # case 1: namespace ended up as tag name</span>
            <span class="s0">tag_utf = _utf8(tag)</span>
        <span class="s0">_tagValidOrRaise(tag_utf)</span>
        <span class="s0">self.localname = (&lt;bytes&gt;tag_utf).decode('utf8')</span>
        <span class="s0">if ns_utf is None:</span>
            <span class="s0">self.namespace = None</span>
            <span class="s0">self.text = self.localname</span>
        <span class="s0">else:</span>
            <span class="s0">self.namespace = (&lt;bytes&gt;ns_utf).decode('utf8')</span>
            <span class="s0">self.text = &quot;{%s}%s&quot; % (self.namespace, self.localname)</span>
    <span class="s0">def __str__(self):</span>
        <span class="s0">return self.text</span>
    <span class="s0">def __hash__(self):</span>
        <span class="s0">return hash(self.text)</span>
    <span class="s0">def __richcmp__(self, other, int op):</span>
        <span class="s0">try:</span>
            <span class="s0">if type(other) is QName:</span>
                <span class="s0">other = (&lt;QName&gt;other).text</span>
            <span class="s0">elif not isinstance(other, unicode):</span>
                <span class="s0">other = unicode(other)</span>
        <span class="s0">except (ValueError, UnicodeDecodeError):</span>
            <span class="s0">return NotImplemented</span>
        <span class="s0">return python.PyObject_RichCompare(self.text, other, op)</span>


<span class="s0">cdef public class _ElementTree [ type LxmlElementTreeType,</span>
                                 <span class="s0">object LxmlElementTree ]:</span>
    <span class="s0">cdef _Document _doc</span>
    <span class="s0">cdef _Element _context_node</span>

    <span class="s0"># Note that _doc is only used to store the original document if we do not</span>
    <span class="s0"># have a _context_node.  All methods should prefer self._context_node._doc</span>
    <span class="s0"># to honour tree restructuring.  _doc can happily be None!</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef int _assertHasRoot(self) except -1:</span>
        <span class="s0">&quot;&quot;&quot;We have to take care here: the document may not have a root node!</span>
        <span class="s0">This can happen if ElementTree() is called without any argument and</span>
        <span class="s0">the caller 'forgets' to call parse() afterwards, so this is a bug in</span>
        <span class="s0">the caller program.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">assert self._context_node is not None, \</span>
               <span class="s0">&quot;ElementTree not initialized, missing root&quot;</span>
        <span class="s0">return 0</span>

    <span class="s0">def parse(self, source, _BaseParser parser=None, *, base_url=None):</span>
        <span class="s0">&quot;&quot;&quot;parse(self, source, parser=None, base_url=None)</span>

        <span class="s0">Updates self with the content of source and returns its root.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef _Document doc = None</span>
        <span class="s0">try:</span>
            <span class="s0">doc = _parseDocument(source, parser, base_url)</span>
        <span class="s0">except _TargetParserResult as result_container:</span>
            <span class="s0"># raises a TypeError if we don't get an _Element</span>
            <span class="s0">self._context_node = result_container.result</span>
        <span class="s0">else:</span>
            <span class="s0">self._context_node = doc.getroot()</span>
        <span class="s0">self._doc = None if self._context_node is not None else doc</span>
        <span class="s0">return self._context_node</span>

    <span class="s0">def _setroot(self, _Element root not None):</span>
        <span class="s0">&quot;&quot;&quot;_setroot(self, root)</span>

        <span class="s0">Relocate the ElementTree to a new root node.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">_assertValidNode(root)</span>
        <span class="s0">if root._c_node.type != tree.XML_ELEMENT_NODE:</span>
            <span class="s0">raise TypeError, &quot;Only elements can be the root of an ElementTree&quot;</span>
        <span class="s0">self._context_node = root</span>
        <span class="s0">self._doc = None</span>

    <span class="s0">def getroot(self):</span>
        <span class="s0">&quot;&quot;&quot;getroot(self)</span>

        <span class="s0">Gets the root element for this tree.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._context_node</span>

    <span class="s0">def __copy__(self):</span>
        <span class="s0">return _elementTreeFactory(self._doc, self._context_node)</span>

    <span class="s0">def __deepcopy__(self, memo):</span>
        <span class="s0">cdef _Element root</span>
        <span class="s0">cdef _Document doc</span>
        <span class="s0">cdef xmlDoc* c_doc</span>
        <span class="s0">if self._context_node is not None:</span>
            <span class="s0">root = self._context_node.__copy__()</span>
            <span class="s0">assert root is not None</span>
            <span class="s0">_assertValidNode(root)</span>
            <span class="s0">_copyNonElementSiblings(self._context_node._c_node, root._c_node)</span>
            <span class="s0">return _elementTreeFactory(None, root)</span>
        <span class="s0">elif self._doc is not None:</span>
            <span class="s0">_assertValidDoc(self._doc)</span>
            <span class="s0">c_doc = tree.xmlCopyDoc(self._doc._c_doc, 1)</span>
            <span class="s0">if c_doc is NULL:</span>
                <span class="s0">raise MemoryError()</span>
            <span class="s0">doc = _documentFactory(c_doc, self._doc._parser)</span>
            <span class="s0">return _elementTreeFactory(doc, None)</span>
        <span class="s0">else:</span>
            <span class="s0"># so what ...</span>
            <span class="s0">return self</span>

    <span class="s0"># not in ElementTree</span>
    <span class="s0">@property</span>
    <span class="s0">def docinfo(self) -&gt; DocInfo:</span>
        <span class="s0">&quot;&quot;&quot;Information about the document provided by parser and DTD.&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">return DocInfo(self._context_node._doc)</span>

    <span class="s0"># not in ElementTree, read-only</span>
    <span class="s0">@property</span>
    <span class="s0">def parser(self):</span>
        <span class="s0">&quot;&quot;&quot;The parser that was used to parse the document in this ElementTree.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._context_node is not None and \</span>
               <span class="s0">self._context_node._doc is not None:</span>
            <span class="s0">return self._context_node._doc._parser</span>
        <span class="s0">if self._doc is not None:</span>
            <span class="s0">return self._doc._parser</span>
        <span class="s0">return None</span>

    <span class="s0">def write(self, file, *, encoding=None, method=&quot;xml&quot;,</span>
              <span class="s0">bint pretty_print=False, xml_declaration=None, bint with_tail=True,</span>
              <span class="s0">standalone=None, doctype=None, compression=0,</span>
              <span class="s0">bint exclusive=False, inclusive_ns_prefixes=None,</span>
              <span class="s0">bint with_comments=True, bint strip_text=False,</span>
              <span class="s0">docstring=None):</span>
        <span class="s0">&quot;&quot;&quot;write(self, file, encoding=None, method=&quot;xml&quot;,</span>
                  <span class="s0">pretty_print=False, xml_declaration=None, with_tail=True,</span>
                  <span class="s0">standalone=None, doctype=None, compression=0,</span>
                  <span class="s0">exclusive=False, inclusive_ns_prefixes=None,</span>
                  <span class="s0">with_comments=True, strip_text=False)</span>

        <span class="s0">Write the tree to a filename, file or file-like object.</span>

        <span class="s0">Defaults to ASCII encoding and writing a declaration as needed.</span>

        <span class="s0">The keyword argument 'method' selects the output method:</span>
        <span class="s0">'xml', 'html', 'text', 'c14n' or 'c14n2'.  Default is 'xml'.</span>

        <span class="s0">With ``method=&quot;c14n&quot;`` (C14N version 1), the options ``exclusive``,</span>
        <span class="s0">``with_comments`` and ``inclusive_ns_prefixes`` request exclusive</span>
        <span class="s0">C14N, include comments, and list the inclusive prefixes respectively.</span>

        <span class="s0">With ``method=&quot;c14n2&quot;`` (C14N version 2), the ``with_comments`` and</span>
        <span class="s0">``strip_text`` options control the output of comments and text space</span>
        <span class="s0">according to C14N 2.0.</span>

        <span class="s0">Passing a boolean value to the ``standalone`` option will</span>
        <span class="s0">output an XML declaration with the corresponding</span>
        <span class="s0">``standalone`` flag.</span>

        <span class="s0">The ``doctype`` option allows passing in a plain string that will</span>
        <span class="s0">be serialised before the XML tree.  Note that passing in non</span>
        <span class="s0">well-formed content here will make the XML output non well-formed.</span>
        <span class="s0">Also, an existing doctype in the document tree will not be removed</span>
        <span class="s0">when serialising an ElementTree instance.</span>

        <span class="s0">The ``compression`` option enables GZip compression level 1-9.</span>

        <span class="s0">The ``inclusive_ns_prefixes`` should be a list of namespace strings</span>
        <span class="s0">(i.e. ['xs', 'xsi']) that will be promoted to the top-level element</span>
        <span class="s0">during exclusive C14N serialisation.  This parameter is ignored if</span>
        <span class="s0">exclusive mode=False.</span>

        <span class="s0">If exclusive=True and no list is provided, a namespace will only be</span>
        <span class="s0">rendered if it is used by the immediate parent or one of its attributes</span>
        <span class="s0">and its prefix and values have not already been rendered by an ancestor</span>
        <span class="s0">of the namespace node's parent element.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef bint write_declaration</span>
        <span class="s0">cdef int is_standalone</span>

        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">_assertValidNode(self._context_node)</span>
        <span class="s0">if compression is None or compression &lt; 0:</span>
            <span class="s0">compression = 0</span>

        <span class="s0"># C14N serialisation</span>
        <span class="s0">if method in ('c14n', 'c14n2'):</span>
            <span class="s0">if encoding is not None:</span>
                <span class="s0">raise ValueError(&quot;Cannot specify encoding with C14N&quot;)</span>
            <span class="s0">if xml_declaration:</span>
                <span class="s0">raise ValueError(&quot;Cannot enable XML declaration in C14N&quot;)</span>

            <span class="s0">if method == 'c14n':</span>
                <span class="s0">_tofilelikeC14N(file, self._context_node, exclusive, with_comments,</span>
                                <span class="s0">compression, inclusive_ns_prefixes)</span>
            <span class="s0">else:  # c14n2</span>
                <span class="s0">with _open_utf8_file(file, compression=compression) as f:</span>
                    <span class="s0">target = C14NWriterTarget(</span>
                        <span class="s0">f.write, with_comments=with_comments, strip_text=strip_text)</span>
                    <span class="s0">_tree_to_target(self, target)</span>
            <span class="s0">return</span>

        <span class="s0">if not with_comments:</span>
            <span class="s0">raise ValueError(&quot;Can only discard comments in C14N serialisation&quot;)</span>
        <span class="s0"># suppress decl. in default case (purely for ElementTree compatibility)</span>
        <span class="s0">if xml_declaration is not None:</span>
            <span class="s0">write_declaration = xml_declaration</span>
            <span class="s0">if encoding is None:</span>
                <span class="s0">encoding = 'ASCII'</span>
            <span class="s0">else:</span>
                <span class="s0">encoding = encoding.upper()</span>
        <span class="s0">elif encoding is None:</span>
            <span class="s0">encoding = 'ASCII'</span>
            <span class="s0">write_declaration = 0</span>
        <span class="s0">else:</span>
            <span class="s0">encoding = encoding.upper()</span>
            <span class="s0">write_declaration = encoding not in (</span>
                <span class="s0">'US-ASCII', 'ASCII', 'UTF8', 'UTF-8')</span>
        <span class="s0">if standalone is None:</span>
            <span class="s0">is_standalone = -1</span>
        <span class="s0">elif standalone:</span>
            <span class="s0">write_declaration = 1</span>
            <span class="s0">is_standalone = 1</span>
        <span class="s0">else:</span>
            <span class="s0">write_declaration = 1</span>
            <span class="s0">is_standalone = 0</span>

        <span class="s0">if docstring is not None and doctype is None:</span>
            <span class="s0">import warnings</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;The 'docstring' option is deprecated. Use 'doctype' instead.&quot;,</span>
                <span class="s0">DeprecationWarning)</span>
            <span class="s0">doctype = docstring</span>

        <span class="s0">_tofilelike(file, self._context_node, encoding, doctype, method,</span>
                    <span class="s0">write_declaration, 1, pretty_print, with_tail,</span>
                    <span class="s0">is_standalone, compression)</span>

    <span class="s0">def getpath(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;getpath(self, element)</span>

        <span class="s0">Returns a structural, absolute XPath expression to find the element.</span>

        <span class="s0">For namespaced elements, the expression uses prefixes from the</span>
        <span class="s0">document, which therefore need to be provided in order to make any</span>
        <span class="s0">use of the expression in XPath.</span>

        <span class="s0">Also see the method getelementpath(self, element), which returns a</span>
        <span class="s0">self-contained ElementPath expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef _Document doc</span>
        <span class="s0">cdef _Element root</span>
        <span class="s0">cdef xmlDoc* c_doc</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">if self._context_node is not None:</span>
            <span class="s0">root = self._context_node</span>
            <span class="s0">doc = root._doc</span>
        <span class="s0">elif self._doc is not None:</span>
            <span class="s0">doc = self._doc</span>
            <span class="s0">root = doc.getroot()</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError, &quot;Element is not in this tree.&quot;</span>
        <span class="s0">_assertValidDoc(doc)</span>
        <span class="s0">_assertValidNode(root)</span>
        <span class="s0">if element._doc is not doc:</span>
            <span class="s0">raise ValueError, &quot;Element is not in this tree.&quot;</span>

        <span class="s0">c_doc = _fakeRootDoc(doc._c_doc, root._c_node)</span>
        <span class="s0">c_path = tree.xmlGetNodePath(element._c_node)</span>
        <span class="s0">_destroyFakeDoc(doc._c_doc, c_doc)</span>
        <span class="s0">if c_path is NULL:</span>
            <span class="s0">raise MemoryError()</span>
        <span class="s0">path = funicode(c_path)</span>
        <span class="s0">tree.xmlFree(c_path)</span>
        <span class="s0">return path</span>

    <span class="s0">def getelementpath(self, _Element element not None):</span>
        <span class="s0">&quot;&quot;&quot;getelementpath(self, element)</span>

        <span class="s0">Returns a structural, absolute ElementPath expression to find the</span>
        <span class="s0">element.  This path can be used in the .find() method to look up</span>
        <span class="s0">the element, provided that the elements along the path and their</span>
        <span class="s0">list of immediate children were not modified in between.</span>

        <span class="s0">ElementPath has the advantage over an XPath expression (as returned</span>
        <span class="s0">by the .getpath() method) that it does not require additional prefix</span>
        <span class="s0">declarations.  It is always self-contained.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef _Element root</span>
        <span class="s0">cdef Py_ssize_t count</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">if element._c_node.type != tree.XML_ELEMENT_NODE:</span>
            <span class="s0">raise ValueError, &quot;input is not an Element&quot;</span>
        <span class="s0">if self._context_node is not None:</span>
            <span class="s0">root = self._context_node</span>
        <span class="s0">elif self._doc is not None:</span>
            <span class="s0">root = self._doc.getroot()</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError, &quot;Element is not in this tree&quot;</span>
        <span class="s0">_assertValidNode(root)</span>
        <span class="s0">if element._doc is not root._doc:</span>
            <span class="s0">raise ValueError, &quot;Element is not in this tree&quot;</span>

        <span class="s0">path = []</span>
        <span class="s0">c_element = element._c_node</span>
        <span class="s0">while c_element is not root._c_node:</span>
            <span class="s0">c_name = c_element.name</span>
            <span class="s0">c_href = _getNs(c_element)</span>
            <span class="s0">tag = _namespacedNameFromNsName(c_href, c_name)</span>
            <span class="s0">if c_href is NULL:</span>
                <span class="s0">c_href = &lt;const_xmlChar*&gt;b''  # no namespace (NULL is wildcard)</span>
            <span class="s0"># use tag[N] if there are preceding siblings with the same tag</span>
            <span class="s0">count = 0</span>
            <span class="s0">c_node = c_element.prev</span>
            <span class="s0">while c_node is not NULL:</span>
                <span class="s0">if c_node.type == tree.XML_ELEMENT_NODE:</span>
                    <span class="s0">if _tagMatches(c_node, c_href, c_name):</span>
                        <span class="s0">count += 1</span>
                <span class="s0">c_node = c_node.prev</span>
            <span class="s0">if count:</span>
                <span class="s0">tag = f'{tag}[{count+1}]'</span>
            <span class="s0">else:</span>
                <span class="s0"># use tag[1] if there are following siblings with the same tag</span>
                <span class="s0">c_node = c_element.next</span>
                <span class="s0">while c_node is not NULL:</span>
                    <span class="s0">if c_node.type == tree.XML_ELEMENT_NODE:</span>
                        <span class="s0">if _tagMatches(c_node, c_href, c_name):</span>
                            <span class="s0">tag += '[1]'</span>
                            <span class="s0">break</span>
                    <span class="s0">c_node = c_node.next</span>

            <span class="s0">path.append(tag)</span>
            <span class="s0">c_element = c_element.parent</span>
            <span class="s0">if c_element is NULL or c_element.type != tree.XML_ELEMENT_NODE:</span>
                <span class="s0">raise ValueError, &quot;Element is not in this tree.&quot;</span>
        <span class="s0">if not path:</span>
            <span class="s0">return '.'</span>
        <span class="s0">path.reverse()</span>
        <span class="s0">return '/'.join(path)</span>

    <span class="s0">def getiterator(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;getiterator(self, *tags, tag=None)</span>

        <span class="s0">Returns a sequence or iterator of all elements in document order</span>
        <span class="s0">(depth first pre-order), starting with the root element.</span>

        <span class="s0">Can be restricted to find only elements with specific tags,</span>
        <span class="s0">see `_Element.iter`.</span>

        <span class="s0">:deprecated: Note that this method is deprecated as of</span>
          <span class="s0">ElementTree 1.3 and lxml 2.0.  It returns an iterator in</span>
          <span class="s0">lxml, which diverges from the original ElementTree</span>
          <span class="s0">behaviour.  If you want an efficient iterator, use the</span>
          <span class="s0">``tree.iter()`` method instead.  You should only use this</span>
          <span class="s0">method in new code if you require backwards compatibility</span>
          <span class="s0">with older versions of lxml or ElementTree.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if root is None:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return root.getiterator(*tags)</span>

    <span class="s0">def iter(self, tag=None, *tags):</span>
        <span class="s0">&quot;&quot;&quot;iter(self, tag=None, *tags)</span>

        <span class="s0">Creates an iterator for the root element.  The iterator loops over</span>
        <span class="s0">all elements in this tree, in document order.  Note that siblings</span>
        <span class="s0">of the root element (comments or processing instructions) are not</span>
        <span class="s0">returned by the iterator.</span>

        <span class="s0">Can be restricted to find only elements with specific tags,</span>
        <span class="s0">see `_Element.iter`.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if root is None:</span>
            <span class="s0">return ITER_EMPTY</span>
        <span class="s0">if tag is not None:</span>
            <span class="s0">tags += (tag,)</span>
        <span class="s0">return root.iter(*tags)</span>

    <span class="s0">def find(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;find(self, path, namespaces=None)</span>

        <span class="s0">Finds the first toplevel element with given tag.  Same as</span>
        <span class="s0">``tree.getroot().find(path)``.</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if _isString(path):</span>
            <span class="s0">if path[:1] == &quot;/&quot;:</span>
                <span class="s0">path = &quot;.&quot; + path</span>
                <span class="s0">from warnings import warn</span>
                <span class="s0">warn(</span>
                    <span class="s0">&quot;This search incorrectly ignores the root element, and will be &quot;</span>
                    <span class="s0">&quot;fixed in a future version.  If you rely on the current &quot;</span>
                    <span class="s0">f&quot;behaviour, change it to {path!r}&quot;,</span>
                    <span class="s0">FutureWarning, stacklevel=1</span>
                <span class="s0">)</span>
        <span class="s0">return root.find(path, namespaces)</span>

    <span class="s0">def findtext(self, path, default=None, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;findtext(self, path, default=None, namespaces=None)</span>

        <span class="s0">Finds the text for the first element matching the ElementPath</span>
        <span class="s0">expression.  Same as getroot().findtext(path)</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if _isString(path):</span>
            <span class="s0">if path[:1] == &quot;/&quot;:</span>
                <span class="s0">path = &quot;.&quot; + path</span>
                <span class="s0">from warnings import warn</span>
                <span class="s0">warn(</span>
                    <span class="s0">&quot;This search incorrectly ignores the root element, and will be &quot;</span>
                    <span class="s0">&quot;fixed in a future version.  If you rely on the current &quot;</span>
                    <span class="s0">f&quot;behaviour, change it to {path!r}&quot;,</span>
                    <span class="s0">FutureWarning, stacklevel=1</span>
                <span class="s0">)</span>
        <span class="s0">return root.findtext(path, default, namespaces)</span>

    <span class="s0">def findall(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;findall(self, path, namespaces=None)</span>

        <span class="s0">Finds all elements matching the ElementPath expression.  Same as</span>
        <span class="s0">getroot().findall(path).</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if _isString(path):</span>
            <span class="s0">if path[:1] == &quot;/&quot;:</span>
                <span class="s0">path = &quot;.&quot; + path</span>
                <span class="s0">from warnings import warn</span>
                <span class="s0">warn(</span>
                    <span class="s0">&quot;This search incorrectly ignores the root element, and will be &quot;</span>
                    <span class="s0">&quot;fixed in a future version.  If you rely on the current &quot;</span>
                    <span class="s0">f&quot;behaviour, change it to {path!r}&quot;,</span>
                    <span class="s0">FutureWarning, stacklevel=1</span>
                <span class="s0">)</span>
        <span class="s0">return root.findall(path, namespaces)</span>

    <span class="s0">def iterfind(self, path, namespaces=None):</span>
        <span class="s0">&quot;&quot;&quot;iterfind(self, path, namespaces=None)</span>

        <span class="s0">Iterates over all elements matching the ElementPath expression.</span>
        <span class="s0">Same as getroot().iterfind(path).</span>

        <span class="s0">The optional ``namespaces`` argument accepts a</span>
        <span class="s0">prefix-to-namespace mapping that allows the usage of XPath</span>
        <span class="s0">prefixes in the path expression.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">root = self.getroot()</span>
        <span class="s0">if _isString(path):</span>
            <span class="s0">if path[:1] == &quot;/&quot;:</span>
                <span class="s0">path = &quot;.&quot; + path</span>
                <span class="s0">from warnings import warn</span>
                <span class="s0">warn(</span>
                    <span class="s0">&quot;This search incorrectly ignores the root element, and will be &quot;</span>
                    <span class="s0">&quot;fixed in a future version.  If you rely on the current &quot;</span>
                    <span class="s0">f&quot;behaviour, change it to {path!r}&quot;,</span>
                    <span class="s0">FutureWarning, stacklevel=1</span>
                <span class="s0">)</span>
        <span class="s0">return root.iterfind(path, namespaces)</span>

    <span class="s0">def xpath(self, _path, *, namespaces=None, extensions=None,</span>
              <span class="s0">smart_strings=True, **_variables):</span>
        <span class="s0">&quot;&quot;&quot;xpath(self, _path, namespaces=None, extensions=None, smart_strings=True, **_variables)</span>

        <span class="s0">XPath evaluate in context of document.</span>

        <span class="s0">``namespaces`` is an optional dictionary with prefix to namespace URI</span>
        <span class="s0">mappings, used by XPath.  ``extensions`` defines additional extension</span>
        <span class="s0">functions.</span>

        <span class="s0">Returns a list (nodeset), or bool, float or string.</span>

        <span class="s0">In case of a list result, return Element for element nodes,</span>
        <span class="s0">string for text and attribute values.</span>

        <span class="s0">Note: if you are going to apply multiple XPath expressions</span>
        <span class="s0">against the same document, it is more efficient to use</span>
        <span class="s0">XPathEvaluator directly.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">evaluator = XPathDocumentEvaluator(self, namespaces=namespaces,</span>
                                           <span class="s0">extensions=extensions,</span>
                                           <span class="s0">smart_strings=smart_strings)</span>
        <span class="s0">return evaluator(_path, **_variables)</span>

    <span class="s0">def xslt(self, _xslt, extensions=None, access_control=None, **_kw):</span>
        <span class="s0">&quot;&quot;&quot;xslt(self, _xslt, extensions=None, access_control=None, **_kw)</span>

        <span class="s0">Transform this document using other document.</span>

        <span class="s0">xslt is a tree that should be XSLT</span>
        <span class="s0">keyword parameters are XSLT transformation parameters.</span>

        <span class="s0">Returns the transformed tree.</span>

        <span class="s0">Note: if you are going to apply the same XSLT stylesheet against</span>
        <span class="s0">multiple documents, it is more efficient to use the XSLT</span>
        <span class="s0">class directly.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">style = XSLT(_xslt, extensions=extensions,</span>
                     <span class="s0">access_control=access_control)</span>
        <span class="s0">return style(self, **_kw)</span>

    <span class="s0">def relaxng(self, relaxng):</span>
        <span class="s0">&quot;&quot;&quot;relaxng(self, relaxng)</span>

        <span class="s0">Validate this document using other document.</span>

        <span class="s0">The relaxng argument is a tree that should contain a Relax NG schema.</span>

        <span class="s0">Returns True or False, depending on whether validation</span>
        <span class="s0">succeeded.</span>

        <span class="s0">Note: if you are going to apply the same Relax NG schema against</span>
        <span class="s0">multiple documents, it is more efficient to use the RelaxNG</span>
        <span class="s0">class directly.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">schema = RelaxNG(relaxng)</span>
        <span class="s0">return schema.validate(self)</span>

    <span class="s0">def xmlschema(self, xmlschema):</span>
        <span class="s0">&quot;&quot;&quot;xmlschema(self, xmlschema)</span>

        <span class="s0">Validate this document using other document.</span>

        <span class="s0">The xmlschema argument is a tree that should contain an XML Schema.</span>

        <span class="s0">Returns True or False, depending on whether validation</span>
        <span class="s0">succeeded.</span>

        <span class="s0">Note: If you are going to apply the same XML Schema against</span>
        <span class="s0">multiple documents, it is more efficient to use the XMLSchema</span>
        <span class="s0">class directly.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">schema = XMLSchema(xmlschema)</span>
        <span class="s0">return schema.validate(self)</span>

    <span class="s0">def xinclude(self):</span>
        <span class="s0">&quot;&quot;&quot;xinclude(self)</span>

        <span class="s0">Process the XInclude nodes in this document and include the</span>
        <span class="s0">referenced XML fragments.</span>

        <span class="s0">There is support for loading files through the file system, HTTP and</span>
        <span class="s0">FTP.</span>

        <span class="s0">Note that XInclude does not support custom resolvers in Python space</span>
        <span class="s0">due to restrictions of libxml2 &lt;= 2.6.29.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">XInclude()(self._context_node)</span>

    <span class="s0">def write_c14n(self, file, *, bint exclusive=False, bint with_comments=True,</span>
                   <span class="s0">compression=0, inclusive_ns_prefixes=None):</span>
        <span class="s0">&quot;&quot;&quot;write_c14n(self, file, exclusive=False, with_comments=True,</span>
                       <span class="s0">compression=0, inclusive_ns_prefixes=None)</span>

        <span class="s0">C14N write of document. Always writes UTF-8.</span>

        <span class="s0">The ``compression`` option enables GZip compression level 1-9.</span>

        <span class="s0">The ``inclusive_ns_prefixes`` should be a list of namespace strings</span>
        <span class="s0">(i.e. ['xs', 'xsi']) that will be promoted to the top-level element</span>
        <span class="s0">during exclusive C14N serialisation.  This parameter is ignored if</span>
        <span class="s0">exclusive mode=False.</span>

        <span class="s0">If exclusive=True and no list is provided, a namespace will only be</span>
        <span class="s0">rendered if it is used by the immediate parent or one of its attributes</span>
        <span class="s0">and its prefix and values have not already been rendered by an ancestor</span>
        <span class="s0">of the namespace node's parent element.</span>

        <span class="s0">NOTE: This method is deprecated as of lxml 4.4 and will be removed in a</span>
        <span class="s0">future release.  Use ``.write(f, method=&quot;c14n&quot;)`` instead.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._assertHasRoot()</span>
        <span class="s0">_assertValidNode(self._context_node)</span>
        <span class="s0">if compression is None or compression &lt; 0:</span>
            <span class="s0">compression = 0</span>

        <span class="s0">_tofilelikeC14N(file, self._context_node, exclusive, with_comments,</span>
                        <span class="s0">compression, inclusive_ns_prefixes)</span>

<span class="s0">cdef _ElementTree _elementTreeFactory(_Document doc, _Element context_node):</span>
    <span class="s0">return _newElementTree(doc, context_node, _ElementTree)</span>

<span class="s0">cdef _ElementTree _newElementTree(_Document doc, _Element context_node,</span>
                                  <span class="s0">object baseclass):</span>
    <span class="s0">cdef _ElementTree result</span>
    <span class="s0">result = baseclass()</span>
    <span class="s0">if context_node is None and doc is not None:</span>
        <span class="s0">context_node = doc.getroot()</span>
    <span class="s0">if context_node is None:</span>
        <span class="s0">_assertValidDoc(doc)</span>
        <span class="s0">result._doc = doc</span>
    <span class="s0">else:</span>
        <span class="s0">_assertValidNode(context_node)</span>
    <span class="s0">result._context_node = context_node</span>
    <span class="s0">return result</span>


<span class="s0">@cython.final</span>
<span class="s0">@cython.freelist(16)</span>
<span class="s0">cdef class _Attrib:</span>
    <span class="s0">&quot;&quot;&quot;A dict-like proxy for the ``Element.attrib`` property.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Element _element</span>
    <span class="s0">def __cinit__(self, _Element element not None):</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">self._element = element</span>

    <span class="s0"># MANIPULATORS</span>
    <span class="s0">def __setitem__(self, key, value):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">_setAttributeValue(self._element, key, value)</span>

    <span class="s0">def __delitem__(self, key):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">_delAttribute(self._element, key)</span>

    <span class="s0">def update(self, sequence_or_dict):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">if isinstance(sequence_or_dict, (dict, _Attrib)):</span>
            <span class="s0">sequence_or_dict = sequence_or_dict.items()</span>
        <span class="s0">for key, value in sequence_or_dict:</span>
            <span class="s0">_setAttributeValue(self._element, key, value)</span>

    <span class="s0">def pop(self, key, *default):</span>
        <span class="s0">if len(default) &gt; 1:</span>
            <span class="s0">raise TypeError, f&quot;pop expected at most 2 arguments, got {len(default)+1}&quot;</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">result = _getAttributeValue(self._element, key, None)</span>
        <span class="s0">if result is None:</span>
            <span class="s0">if not default:</span>
                <span class="s0">raise KeyError, key</span>
            <span class="s0">result = default[0]</span>
        <span class="s0">else:</span>
            <span class="s0">_delAttribute(self._element, key)</span>
        <span class="s0">return result</span>

    <span class="s0">def clear(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">c_attrs = self._element._c_node.properties</span>
        <span class="s0">if c_attrs:</span>
            <span class="s0">self._element._c_node.properties = NULL</span>
            <span class="s0">tree.xmlFreePropList(c_attrs)</span>

    <span class="s0"># ACCESSORS</span>
    <span class="s0">def __repr__(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return repr(dict( _collectAttributes(self._element._c_node, 3) ))</span>

    <span class="s0">def __copy__(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return dict(_collectAttributes(self._element._c_node, 3))</span>

    <span class="s0">def __deepcopy__(self, memo):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return dict(_collectAttributes(self._element._c_node, 3))</span>

    <span class="s0">def __getitem__(self, key):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">result = _getAttributeValue(self._element, key, None)</span>
        <span class="s0">if result is None:</span>
            <span class="s0">raise KeyError, key</span>
        <span class="s0">return result</span>

    <span class="s0">def __bool__(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">cdef xmlAttr* c_attr = self._element._c_node.properties</span>
        <span class="s0">while c_attr is not NULL:</span>
            <span class="s0">if c_attr.type == tree.XML_ATTRIBUTE_NODE:</span>
                <span class="s0">return 1</span>
            <span class="s0">c_attr = c_attr.next</span>
        <span class="s0">return 0</span>

    <span class="s0">def __len__(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">cdef xmlAttr* c_attr = self._element._c_node.properties</span>
        <span class="s0">cdef Py_ssize_t c = 0</span>
        <span class="s0">while c_attr is not NULL:</span>
            <span class="s0">if c_attr.type == tree.XML_ATTRIBUTE_NODE:</span>
                <span class="s0">c += 1</span>
            <span class="s0">c_attr = c_attr.next</span>
        <span class="s0">return c</span>

    <span class="s0">def get(self, key, default=None):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return _getAttributeValue(self._element, key, default)</span>

    <span class="s0">def keys(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return _collectAttributes(self._element._c_node, 1)</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return iter(_collectAttributes(self._element._c_node, 1))</span>

    <span class="s0">def iterkeys(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return iter(_collectAttributes(self._element._c_node, 1))</span>

    <span class="s0">def values(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return _collectAttributes(self._element._c_node, 2)</span>

    <span class="s0">def itervalues(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return iter(_collectAttributes(self._element._c_node, 2))</span>

    <span class="s0">def items(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return _collectAttributes(self._element._c_node, 3)</span>

    <span class="s0">def iteritems(self):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return iter(_collectAttributes(self._element._c_node, 3))</span>

    <span class="s0">def has_key(self, key):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">return key in self</span>

    <span class="s0">def __contains__(self, key):</span>
        <span class="s0">_assertValidNode(self._element)</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">ns, tag = _getNsTag(key)</span>
        <span class="s0">c_node = self._element._c_node</span>
        <span class="s0">c_href = &lt;const_xmlChar*&gt;NULL if ns is None else _xcstr(ns)</span>
        <span class="s0">return 1 if tree.xmlHasNsProp(c_node, _xcstr(tag), c_href) else 0</span>

    <span class="s0">def __richcmp__(self, other, int op):</span>
        <span class="s0">try:</span>
            <span class="s0">one = dict(self.items())</span>
            <span class="s0">if not isinstance(other, dict):</span>
                <span class="s0">other = dict(other)</span>
        <span class="s0">except (TypeError, ValueError):</span>
            <span class="s0">return NotImplemented</span>
        <span class="s0">return python.PyObject_RichCompare(one, other, op)</span>

<span class="s0">MutableMapping.register(_Attrib)</span>


<span class="s0">@cython.final</span>
<span class="s0">@cython.internal</span>
<span class="s0">cdef class _AttribIterator:</span>
    <span class="s0">&quot;&quot;&quot;Attribute iterator - for internal use only!</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># XML attributes must not be removed while running!</span>
    <span class="s0">cdef _Element _node</span>
    <span class="s0">cdef xmlAttr* _c_attr</span>
    <span class="s0">cdef int _keysvalues # 1 - keys, 2 - values, 3 - items (key, value)</span>
    <span class="s0">def __iter__(self):</span>
        <span class="s0">return self</span>

    <span class="s0">def __next__(self):</span>
        <span class="s0">cdef xmlAttr* c_attr</span>
        <span class="s0">if self._node is None:</span>
            <span class="s0">raise StopIteration</span>
        <span class="s0">c_attr = self._c_attr</span>
        <span class="s0">while c_attr is not NULL and c_attr.type != tree.XML_ATTRIBUTE_NODE:</span>
            <span class="s0">c_attr = c_attr.next</span>
        <span class="s0">if c_attr is NULL:</span>
            <span class="s0">self._node = None</span>
            <span class="s0">raise StopIteration</span>

        <span class="s0">self._c_attr = c_attr.next</span>
        <span class="s0">if self._keysvalues == 1:</span>
            <span class="s0">return _namespacedName(&lt;xmlNode*&gt;c_attr)</span>
        <span class="s0">elif self._keysvalues == 2:</span>
            <span class="s0">return _attributeValue(self._node._c_node, c_attr)</span>
        <span class="s0">else:</span>
            <span class="s0">return (_namespacedName(&lt;xmlNode*&gt;c_attr),</span>
                    <span class="s0">_attributeValue(self._node._c_node, c_attr))</span>

<span class="s0">cdef object _attributeIteratorFactory(_Element element, int keysvalues):</span>
    <span class="s0">cdef _AttribIterator attribs</span>
    <span class="s0">if element._c_node.properties is NULL:</span>
        <span class="s0">return ITER_EMPTY</span>
    <span class="s0">attribs = _AttribIterator()</span>
    <span class="s0">attribs._node = element</span>
    <span class="s0">attribs._c_attr = element._c_node.properties</span>
    <span class="s0">attribs._keysvalues = keysvalues</span>
    <span class="s0">return attribs</span>


<span class="s0">cdef public class _ElementTagMatcher [ object LxmlElementTagMatcher,</span>
                                       <span class="s0">type LxmlElementTagMatcherType ]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Dead but public. :)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef object _pystrings</span>
    <span class="s0">cdef int _node_type</span>
    <span class="s0">cdef char* _href</span>
    <span class="s0">cdef char* _name</span>
    <span class="s0">cdef _initTagMatch(self, tag):</span>
        <span class="s0">self._href = NULL</span>
        <span class="s0">self._name = NULL</span>
        <span class="s0">if tag is None:</span>
            <span class="s0">self._node_type = 0</span>
        <span class="s0">elif tag is Comment:</span>
            <span class="s0">self._node_type = tree.XML_COMMENT_NODE</span>
        <span class="s0">elif tag is ProcessingInstruction:</span>
            <span class="s0">self._node_type = tree.XML_PI_NODE</span>
        <span class="s0">elif tag is Entity:</span>
            <span class="s0">self._node_type = tree.XML_ENTITY_REF_NODE</span>
        <span class="s0">elif tag is Element:</span>
            <span class="s0">self._node_type = tree.XML_ELEMENT_NODE</span>
        <span class="s0">else:</span>
            <span class="s0">self._node_type = tree.XML_ELEMENT_NODE</span>
            <span class="s0">self._pystrings = _getNsTag(tag)</span>
            <span class="s0">if self._pystrings[0] is not None:</span>
                <span class="s0">self._href = _cstr(self._pystrings[0])</span>
            <span class="s0">self._name = _cstr(self._pystrings[1])</span>
            <span class="s0">if self._name[0] == c'*' and self._name[1] == c'\0':</span>
                <span class="s0">self._name = NULL</span>

<span class="s0">cdef public class _ElementIterator(_ElementTagMatcher) [</span>
    <span class="s0">object LxmlElementIterator, type LxmlElementIteratorType ]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Dead but public. :)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># we keep Python references here to control GC</span>
    <span class="s0">cdef _Element _node</span>
    <span class="s0">cdef _node_to_node_function _next_element</span>
    <span class="s0">def __iter__(self):</span>
        <span class="s0">return self</span>

    <span class="s0">cdef void _storeNext(self, _Element node):</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">c_node = self._next_element(node._c_node)</span>
        <span class="s0">while c_node is not NULL and \</span>
                  <span class="s0">self._node_type != 0 and \</span>
                  <span class="s0">(&lt;tree.xmlElementType&gt;self._node_type != c_node.type or</span>
                   <span class="s0">not _tagMatches(c_node, &lt;const_xmlChar*&gt;self._href, &lt;const_xmlChar*&gt;self._name)):</span>
            <span class="s0">c_node = self._next_element(c_node)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">self._node = None</span>
        <span class="s0">else:</span>
            <span class="s0"># Python ref:</span>
            <span class="s0">self._node = _elementFactory(node._doc, c_node)</span>

    <span class="s0">def __next__(self):</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef _Element current_node</span>
        <span class="s0">if self._node is None:</span>
            <span class="s0">raise StopIteration</span>
        <span class="s0"># Python ref:</span>
        <span class="s0">current_node = self._node</span>
        <span class="s0">self._storeNext(current_node)</span>
        <span class="s0">return current_node</span>

<span class="s0">@cython.final</span>
<span class="s0">@cython.internal</span>
<span class="s0">cdef class _MultiTagMatcher:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Match an xmlNode against a list of tags.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef list _py_tags</span>
    <span class="s0">cdef qname* _cached_tags</span>
    <span class="s0">cdef size_t _tag_count</span>
    <span class="s0">cdef size_t _cached_size</span>
    <span class="s0">cdef _Document _cached_doc</span>
    <span class="s0">cdef int _node_types</span>

    <span class="s0">def __cinit__(self, tags):</span>
        <span class="s0">self._py_tags = []</span>
        <span class="s0">self.initTagMatch(tags)</span>

    <span class="s0">def __dealloc__(self):</span>
        <span class="s0">self._clear()</span>

    <span class="s0">cdef bint rejectsAll(self) noexcept:</span>
        <span class="s0">return not self._tag_count and not self._node_types</span>

    <span class="s0">cdef bint rejectsAllAttributes(self) noexcept:</span>
        <span class="s0">return not self._tag_count</span>

    <span class="s0">cdef bint matchesType(self, int node_type) noexcept:</span>
        <span class="s0">if node_type == tree.XML_ELEMENT_NODE and self._tag_count:</span>
            <span class="s0">return True</span>
        <span class="s0">return self._node_types &amp; (1 &lt;&lt; node_type)</span>

    <span class="s0">cdef void _clear(self) noexcept:</span>
        <span class="s0">cdef size_t i, count</span>
        <span class="s0">count = self._tag_count</span>
        <span class="s0">self._tag_count = 0</span>
        <span class="s0">if self._cached_tags:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">cpython.ref.Py_XDECREF(self._cached_tags[i].href)</span>
            <span class="s0">python.lxml_free(self._cached_tags)</span>
            <span class="s0">self._cached_tags = NULL</span>

    <span class="s0">cdef initTagMatch(self, tags):</span>
        <span class="s0">self._cached_doc = None</span>
        <span class="s0">del self._py_tags[:]</span>
        <span class="s0">self._clear()</span>
        <span class="s0">if tags is None or tags == ():</span>
            <span class="s0"># no selection in tags argument =&gt; match anything</span>
            <span class="s0">self._node_types = (</span>
                <span class="s0">1 &lt;&lt; tree.XML_COMMENT_NODE |</span>
                <span class="s0">1 &lt;&lt; tree.XML_PI_NODE |</span>
                <span class="s0">1 &lt;&lt; tree.XML_ENTITY_REF_NODE |</span>
                <span class="s0">1 &lt;&lt; tree.XML_ELEMENT_NODE)</span>
        <span class="s0">else:</span>
            <span class="s0">self._node_types = 0</span>
            <span class="s0">self._storeTags(tags, set())</span>

    <span class="s0">cdef _storeTags(self, tag, set seen):</span>
        <span class="s0">if tag is Comment:</span>
            <span class="s0">self._node_types |= 1 &lt;&lt; tree.XML_COMMENT_NODE</span>
        <span class="s0">elif tag is ProcessingInstruction:</span>
            <span class="s0">self._node_types |= 1 &lt;&lt; tree.XML_PI_NODE</span>
        <span class="s0">elif tag is Entity:</span>
            <span class="s0">self._node_types |= 1 &lt;&lt; tree.XML_ENTITY_REF_NODE</span>
        <span class="s0">elif tag is Element:</span>
            <span class="s0">self._node_types |= 1 &lt;&lt; tree.XML_ELEMENT_NODE</span>
        <span class="s0">elif python._isString(tag):</span>
            <span class="s0">if tag in seen:</span>
                <span class="s0">return</span>
            <span class="s0">seen.add(tag)</span>
            <span class="s0">if tag in ('*', '{*}*'):</span>
                <span class="s0">self._node_types |= 1 &lt;&lt; tree.XML_ELEMENT_NODE</span>
            <span class="s0">else:</span>
                <span class="s0">href, name = _getNsTag(tag)</span>
                <span class="s0">if name == b'*':</span>
                    <span class="s0">name = None</span>
                <span class="s0">if href is None:</span>
                    <span class="s0">href = b''  # no namespace</span>
                <span class="s0">elif href == b'*':</span>
                    <span class="s0">href = None  # wildcard: any namespace, including none</span>
                <span class="s0">self._py_tags.append((href, name))</span>
        <span class="s0">elif isinstance(tag, QName):</span>
            <span class="s0">self._storeTags(tag.text, seen)</span>
        <span class="s0">else:</span>
            <span class="s0"># support a sequence of tags</span>
            <span class="s0">for item in tag:</span>
                <span class="s0">self._storeTags(item, seen)</span>

    <span class="s0">cdef inline int cacheTags(self, _Document doc, bint force_into_dict=False) except -1:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Look up the tag names in the doc dict to enable string pointer comparisons.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef size_t dict_size = tree.xmlDictSize(doc._c_doc.dict)</span>
        <span class="s0">if doc is self._cached_doc and dict_size == self._cached_size:</span>
            <span class="s0"># doc and dict didn't change =&gt; names already cached</span>
            <span class="s0">return 0</span>
        <span class="s0">self._tag_count = 0</span>
        <span class="s0">if not self._py_tags:</span>
            <span class="s0">self._cached_doc = doc</span>
            <span class="s0">self._cached_size = dict_size</span>
            <span class="s0">return 0</span>
        <span class="s0">if not self._cached_tags:</span>
            <span class="s0">self._cached_tags = &lt;qname*&gt;python.lxml_malloc(len(self._py_tags), sizeof(qname))</span>
            <span class="s0">if not self._cached_tags:</span>
                <span class="s0">self._cached_doc = None</span>
                <span class="s0">raise MemoryError()</span>
        <span class="s0">self._tag_count = &lt;size_t&gt;_mapTagsToQnameMatchArray(</span>
            <span class="s0">doc._c_doc, self._py_tags, self._cached_tags, force_into_dict)</span>
        <span class="s0">self._cached_doc = doc</span>
        <span class="s0">self._cached_size = dict_size</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef inline bint matches(self, xmlNode* c_node) noexcept:</span>
        <span class="s0">cdef qname* c_qname</span>
        <span class="s0">if self._node_types &amp; (1 &lt;&lt; c_node.type):</span>
            <span class="s0">return True</span>
        <span class="s0">elif c_node.type == tree.XML_ELEMENT_NODE:</span>
            <span class="s0">for c_qname in self._cached_tags[:self._tag_count]:</span>
                <span class="s0">if _tagMatchesExactly(c_node, c_qname):</span>
                    <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">cdef inline bint matchesNsTag(self, const_xmlChar* c_href,</span>
                                  <span class="s0">const_xmlChar* c_name) noexcept:</span>
        <span class="s0">cdef qname* c_qname</span>
        <span class="s0">if self._node_types &amp; (1 &lt;&lt; tree.XML_ELEMENT_NODE):</span>
            <span class="s0">return True</span>
        <span class="s0">for c_qname in self._cached_tags[:self._tag_count]:</span>
            <span class="s0">if _nsTagMatchesExactly(c_href, c_name, c_qname):</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">cdef inline bint matchesAttribute(self, xmlAttr* c_attr) noexcept:</span>
        <span class="s0">&quot;&quot;&quot;Attribute matches differ from Element matches in that they do</span>
        <span class="s0">not care about node types.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef qname* c_qname</span>
        <span class="s0">for c_qname in self._cached_tags[:self._tag_count]:</span>
            <span class="s0">if _tagMatchesExactly(&lt;xmlNode*&gt;c_attr, c_qname):</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

<span class="s0">cdef class _ElementMatchIterator:</span>
    <span class="s0">cdef _Element _node</span>
    <span class="s0">cdef _node_to_node_function _next_element</span>
    <span class="s0">cdef _MultiTagMatcher _matcher</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef _initTagMatcher(self, tags):</span>
        <span class="s0">self._matcher = _MultiTagMatcher.__new__(_MultiTagMatcher, tags)</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">return self</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef int _storeNext(self, _Element node) except -1:</span>
        <span class="s0">self._matcher.cacheTags(node._doc)</span>
        <span class="s0">c_node = self._next_element(node._c_node)</span>
        <span class="s0">while c_node is not NULL and not self._matcher.matches(c_node):</span>
            <span class="s0">c_node = self._next_element(c_node)</span>
        <span class="s0"># store Python ref to next node to make sure it's kept alive</span>
        <span class="s0">self._node = _elementFactory(node._doc, c_node) if c_node is not NULL else None</span>
        <span class="s0">return 0</span>

    <span class="s0">def __next__(self):</span>
        <span class="s0">cdef _Element current_node = self._node</span>
        <span class="s0">if current_node is None:</span>
            <span class="s0">raise StopIteration</span>
        <span class="s0">self._storeNext(current_node)</span>
        <span class="s0">return current_node</span>

<span class="s0">cdef class ElementChildIterator(_ElementMatchIterator):</span>
    <span class="s0">&quot;&quot;&quot;ElementChildIterator(self, node, tag=None, reversed=False)</span>
    <span class="s0">Iterates over the children of an element.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __cinit__(self, _Element node not None, tag=None, *, bint reversed=False):</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">_assertValidNode(node)</span>
        <span class="s0">self._initTagMatcher(tag)</span>
        <span class="s0">if reversed:</span>
            <span class="s0">c_node = _findChildBackwards(node._c_node, 0)</span>
            <span class="s0">self._next_element = _previousElement</span>
        <span class="s0">else:</span>
            <span class="s0">c_node = _findChildForwards(node._c_node, 0)</span>
            <span class="s0">self._next_element = _nextElement</span>
        <span class="s0">self._matcher.cacheTags(node._doc)</span>
        <span class="s0">while c_node is not NULL and not self._matcher.matches(c_node):</span>
            <span class="s0">c_node = self._next_element(c_node)</span>
        <span class="s0"># store Python ref to next node to make sure it's kept alive</span>
        <span class="s0">self._node = _elementFactory(node._doc, c_node) if c_node is not NULL else None</span>

<span class="s0">cdef class SiblingsIterator(_ElementMatchIterator):</span>
    <span class="s0">&quot;&quot;&quot;SiblingsIterator(self, node, tag=None, preceding=False)</span>
    <span class="s0">Iterates over the siblings of an element.</span>

    <span class="s0">You can pass the boolean keyword ``preceding`` to specify the direction.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __cinit__(self, _Element node not None, tag=None, *, bint preceding=False):</span>
        <span class="s0">_assertValidNode(node)</span>
        <span class="s0">self._initTagMatcher(tag)</span>
        <span class="s0">if preceding:</span>
            <span class="s0">self._next_element = _previousElement</span>
        <span class="s0">else:</span>
            <span class="s0">self._next_element = _nextElement</span>
        <span class="s0">self._storeNext(node)</span>

<span class="s0">cdef class AncestorsIterator(_ElementMatchIterator):</span>
    <span class="s0">&quot;&quot;&quot;AncestorsIterator(self, node, tag=None)</span>
    <span class="s0">Iterates over the ancestors of an element (from parent to parent).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __cinit__(self, _Element node not None, tag=None):</span>
        <span class="s0">_assertValidNode(node)</span>
        <span class="s0">self._initTagMatcher(tag)</span>
        <span class="s0">self._next_element = _parentElement</span>
        <span class="s0">self._storeNext(node)</span>

<span class="s0">cdef class ElementDepthFirstIterator:</span>
    <span class="s0">&quot;&quot;&quot;ElementDepthFirstIterator(self, node, tag=None, inclusive=True)</span>
    <span class="s0">Iterates over an element and its sub-elements in document order (depth</span>
    <span class="s0">first pre-order).</span>

    <span class="s0">Note that this also includes comments, entities and processing</span>
    <span class="s0">instructions.  To filter them out, check if the ``tag`` property</span>
    <span class="s0">of the returned element is a string (i.e. not None and not a</span>
    <span class="s0">factory function), or pass the ``Element`` factory for the ``tag``</span>
    <span class="s0">argument to receive only Elements.</span>

    <span class="s0">If the optional ``tag`` argument is not None, the iterator returns only</span>
    <span class="s0">the elements that match the respective name and namespace.</span>

    <span class="s0">The optional boolean argument 'inclusive' defaults to True and can be set</span>
    <span class="s0">to False to exclude the start element itself.</span>

    <span class="s0">Note that the behaviour of this iterator is completely undefined if the</span>
    <span class="s0">tree it traverses is modified during iteration.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># we keep Python references here to control GC</span>
    <span class="s0"># keep the next Element after the one we return, and the (s)top node</span>
    <span class="s0">cdef _Element _next_node</span>
    <span class="s0">cdef _Element _top_node</span>
    <span class="s0">cdef _MultiTagMatcher _matcher</span>
    <span class="s0">def __cinit__(self, _Element node not None, tag=None, *, bint inclusive=True):</span>
        <span class="s0">_assertValidNode(node)</span>
        <span class="s0">self._top_node  = node</span>
        <span class="s0">self._next_node = node</span>
        <span class="s0">self._matcher = _MultiTagMatcher.__new__(_MultiTagMatcher, tag)</span>
        <span class="s0">self._matcher.cacheTags(node._doc)</span>
        <span class="s0">if not inclusive or not self._matcher.matches(node._c_node):</span>
            <span class="s0"># find start node (this cannot raise StopIteration, self._next_node != None)</span>
            <span class="s0">next(self)</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">return self</span>

    <span class="s0">def __next__(self):</span>
        <span class="s0">cdef xmlNode* c_node</span>
        <span class="s0">cdef _Element current_node = self._next_node</span>
        <span class="s0">if current_node is None:</span>
            <span class="s0">raise StopIteration</span>
        <span class="s0">c_node = current_node._c_node</span>
        <span class="s0">self._matcher.cacheTags(current_node._doc)</span>
        <span class="s0">if not self._matcher._tag_count:</span>
            <span class="s0"># no tag name was found in the dict =&gt; not in document either</span>
            <span class="s0"># try to match by node type</span>
            <span class="s0">c_node = self._nextNodeAnyTag(c_node)</span>
        <span class="s0">else:</span>
            <span class="s0">c_node = self._nextNodeMatchTag(c_node)</span>
        <span class="s0">if c_node is NULL:</span>
            <span class="s0">self._next_node = None</span>
        <span class="s0">else:</span>
            <span class="s0">self._next_node = _elementFactory(current_node._doc, c_node)</span>
        <span class="s0">return current_node</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef xmlNode* _nextNodeAnyTag(self, xmlNode* c_node) noexcept:</span>
        <span class="s0">cdef int node_types = self._matcher._node_types</span>
        <span class="s0">if not node_types:</span>
            <span class="s0">return NULL</span>
        <span class="s0">tree.BEGIN_FOR_EACH_ELEMENT_FROM(self._top_node._c_node, c_node, 0)</span>
        <span class="s0">if node_types &amp; (1 &lt;&lt; c_node.type):</span>
            <span class="s0">return c_node</span>
        <span class="s0">tree.END_FOR_EACH_ELEMENT_FROM(c_node)</span>
        <span class="s0">return NULL</span>

    <span class="s0">@cython.final</span>
    <span class="s0">cdef xmlNode* _nextNodeMatchTag(self, xmlNode* c_node) noexcept:</span>
        <span class="s0">tree.BEGIN_FOR_EACH_ELEMENT_FROM(self._top_node._c_node, c_node, 0)</span>
        <span class="s0">if self._matcher.matches(c_node):</span>
            <span class="s0">return c_node</span>
        <span class="s0">tree.END_FOR_EACH_ELEMENT_FROM(c_node)</span>
        <span class="s0">return NULL</span>


<span class="s0">cdef class ElementTextIterator:</span>
    <span class="s0">&quot;&quot;&quot;ElementTextIterator(self, element, tag=None, with_tail=True)</span>
    <span class="s0">Iterates over the text content of a subtree.</span>

    <span class="s0">You can pass the ``tag`` keyword argument to restrict text content to a</span>
    <span class="s0">specific tag name.</span>

    <span class="s0">You can set the ``with_tail`` keyword argument to ``False`` to skip over</span>
    <span class="s0">tail text (e.g. if you know that it's only whitespace from pretty-printing).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef object _events</span>
    <span class="s0">cdef _Element _start_element</span>
    <span class="s0">def __cinit__(self, _Element element not None, tag=None, *, bint with_tail=True):</span>
        <span class="s0">_assertValidNode(element)</span>
        <span class="s0">if with_tail:</span>
            <span class="s0">events = (&quot;start&quot;, &quot;comment&quot;, &quot;pi&quot;, &quot;end&quot;)</span>
        <span class="s0">else:</span>
            <span class="s0">events = (&quot;start&quot;,)</span>
        <span class="s0">self._start_element = element</span>
        <span class="s0">self._events = iterwalk(element, events=events, tag=tag)</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">return self</span>

    <span class="s0">def __next__(self):</span>
        <span class="s0">cdef _Element element</span>
        <span class="s0">result = None</span>
        <span class="s0">while result is None:</span>
            <span class="s0">event, element = next(self._events)  # raises StopIteration</span>
            <span class="s0">if event == &quot;start&quot;:</span>
                <span class="s0">result = element.text</span>
            <span class="s0">elif element is not self._start_element:</span>
                <span class="s0">result = element.tail</span>
        <span class="s0">return result</span>


<span class="s0">cdef xmlNode* _createElement(xmlDoc* c_doc, object name_utf) except NULL:</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">c_node = tree.xmlNewDocNode(c_doc, NULL, _xcstr(name_utf), NULL)</span>
    <span class="s0">return c_node</span>

<span class="s0">cdef xmlNode* _createComment(xmlDoc* c_doc, const_xmlChar* text) noexcept:</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">c_node = tree.xmlNewDocComment(c_doc, text)</span>
    <span class="s0">return c_node</span>

<span class="s0">cdef xmlNode* _createPI(xmlDoc* c_doc, const_xmlChar* target, const_xmlChar* text) noexcept:</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">c_node = tree.xmlNewDocPI(c_doc, target, text)</span>
    <span class="s0">return c_node</span>

<span class="s0">cdef xmlNode* _createEntity(xmlDoc* c_doc, const_xmlChar* name) noexcept:</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">c_node = tree.xmlNewReference(c_doc, name)</span>
    <span class="s0">return c_node</span>

<span class="s0"># module-level API for ElementTree</span>

<span class="s0">def Element(_tag, attrib=None, nsmap=None, **_extra):</span>
    <span class="s0">&quot;&quot;&quot;Element(_tag, attrib=None, nsmap=None, **_extra)</span>

    <span class="s0">Element factory.  This function returns an object implementing the</span>
    <span class="s0">Element interface.</span>

    <span class="s0">Also look at the `_Element.makeelement()` and</span>
    <span class="s0">`_BaseParser.makeelement()` methods, which provide a faster way to</span>
    <span class="s0">create an Element within a specific document or parser context.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return _makeElement(_tag, NULL, None, None, None, None,</span>
                        <span class="s0">attrib, nsmap, _extra)</span>


<span class="s0">def Comment(text=None):</span>
    <span class="s0">&quot;&quot;&quot;Comment(text=None)</span>

    <span class="s0">Comment element factory. This factory function creates a special element that will</span>
    <span class="s0">be serialized as an XML comment.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">cdef xmlNode*  c_node</span>
    <span class="s0">cdef xmlDoc*   c_doc</span>

    <span class="s0">if text is None:</span>
        <span class="s0">text = b''</span>
    <span class="s0">else:</span>
        <span class="s0">text = _utf8(text)</span>
        <span class="s0">if b'--' in text or text.endswith(b'-'):</span>
            <span class="s0">raise ValueError(&quot;Comment may not contain '--' or end with '-'&quot;)</span>

    <span class="s0">c_doc = _newXMLDoc()</span>
    <span class="s0">doc = _documentFactory(c_doc, None)</span>
    <span class="s0">c_node = _createComment(c_doc, _xcstr(text))</span>
    <span class="s0">tree.xmlAddChild(&lt;xmlNode*&gt;c_doc, c_node)</span>
    <span class="s0">return _elementFactory(doc, c_node)</span>


<span class="s0">def ProcessingInstruction(target, text=None):</span>
    <span class="s0">&quot;&quot;&quot;ProcessingInstruction(target, text=None)</span>

    <span class="s0">ProcessingInstruction element factory. This factory function creates a</span>
    <span class="s0">special element that will be serialized as an XML processing instruction.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">cdef xmlNode*  c_node</span>
    <span class="s0">cdef xmlDoc*   c_doc</span>

    <span class="s0">target = _utf8(target)</span>
    <span class="s0">_tagValidOrRaise(target)</span>
    <span class="s0">if target.lower() == b'xml':</span>
        <span class="s0">raise ValueError, f&quot;Invalid PI name '{target}'&quot;</span>

    <span class="s0">if text is None:</span>
        <span class="s0">text = b''</span>
    <span class="s0">else:</span>
        <span class="s0">text = _utf8(text)</span>
        <span class="s0">if b'?&gt;' in text:</span>
            <span class="s0">raise ValueError, &quot;PI text must not contain '?&gt;'&quot;</span>

    <span class="s0">c_doc = _newXMLDoc()</span>
    <span class="s0">doc = _documentFactory(c_doc, None)</span>
    <span class="s0">c_node = _createPI(c_doc, _xcstr(target), _xcstr(text))</span>
    <span class="s0">tree.xmlAddChild(&lt;xmlNode*&gt;c_doc, c_node)</span>
    <span class="s0">return _elementFactory(doc, c_node)</span>

<span class="s0">PI = ProcessingInstruction</span>


<span class="s0">cdef class CDATA:</span>
    <span class="s0">&quot;&quot;&quot;CDATA(data)</span>

    <span class="s0">CDATA factory.  This factory creates an opaque data object that</span>
    <span class="s0">can be used to set Element text.  The usual way to use it is::</span>

        <span class="s0">&gt;&gt;&gt; el = Element('content')</span>
        <span class="s0">&gt;&gt;&gt; el.text = CDATA('a string')</span>

        <span class="s0">&gt;&gt;&gt; print(el.text)</span>
        <span class="s0">a string</span>
        <span class="s0">&gt;&gt;&gt; print(tostring(el, encoding=&quot;unicode&quot;))</span>
        <span class="s0">&lt;content&gt;&lt;![CDATA[a string]]&gt;&lt;/content&gt;</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef bytes _utf8_data</span>
    <span class="s0">def __cinit__(self, data):</span>
        <span class="s0">self._utf8_data = _utf8(data)</span>


<span class="s0">def Entity(name):</span>
    <span class="s0">&quot;&quot;&quot;Entity(name)</span>

    <span class="s0">Entity factory.  This factory function creates a special element</span>
    <span class="s0">that will be serialized as an XML entity reference or character</span>
    <span class="s0">reference.  Note, however, that entities will not be automatically</span>
    <span class="s0">declared in the document.  A document that uses entity references</span>
    <span class="s0">requires a DTD to define the entities.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">cdef xmlNode*  c_node</span>
    <span class="s0">cdef xmlDoc*   c_doc</span>
    <span class="s0">name_utf = _utf8(name)</span>
    <span class="s0">c_name = _xcstr(name_utf)</span>
    <span class="s0">if c_name[0] == c'#':</span>
        <span class="s0">if not _characterReferenceIsValid(c_name + 1):</span>
            <span class="s0">raise ValueError, f&quot;Invalid character reference: '{name}'&quot;</span>
    <span class="s0">elif not _xmlNameIsValid(c_name):</span>
        <span class="s0">raise ValueError, f&quot;Invalid entity reference: '{name}'&quot;</span>
    <span class="s0">c_doc = _newXMLDoc()</span>
    <span class="s0">doc = _documentFactory(c_doc, None)</span>
    <span class="s0">c_node = _createEntity(c_doc, c_name)</span>
    <span class="s0">tree.xmlAddChild(&lt;xmlNode*&gt;c_doc, c_node)</span>
    <span class="s0">return _elementFactory(doc, c_node)</span>


<span class="s0">def SubElement(_Element _parent not None, _tag,</span>
               <span class="s0">attrib=None, nsmap=None, **_extra):</span>
    <span class="s0">&quot;&quot;&quot;SubElement(_parent, _tag, attrib=None, nsmap=None, **_extra)</span>

    <span class="s0">Subelement factory.  This function creates an element instance, and</span>
    <span class="s0">appends it to an existing element.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return _makeSubElement(_parent, _tag, None, None, attrib, nsmap, _extra)</span>


<span class="s0">def ElementTree(_Element element=None, *, file=None, _BaseParser parser=None):</span>
    <span class="s0">&quot;&quot;&quot;ElementTree(element=None, file=None, parser=None)</span>

    <span class="s0">ElementTree wrapper class.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef xmlNode* c_next</span>
    <span class="s0">cdef xmlNode* c_node</span>
    <span class="s0">cdef xmlNode* c_node_copy</span>
    <span class="s0">cdef xmlDoc*  c_doc</span>
    <span class="s0">cdef _ElementTree etree</span>
    <span class="s0">cdef _Document doc</span>

    <span class="s0">if element is not None:</span>
        <span class="s0">doc  = element._doc</span>
    <span class="s0">elif file is not None:</span>
        <span class="s0">try:</span>
            <span class="s0">doc = _parseDocument(file, parser, None)</span>
        <span class="s0">except _TargetParserResult as result_container:</span>
            <span class="s0">return result_container.result</span>
    <span class="s0">else:</span>
        <span class="s0">c_doc = _newXMLDoc()</span>
        <span class="s0">doc = _documentFactory(c_doc, parser)</span>

    <span class="s0">return _elementTreeFactory(doc, element)</span>


<span class="s0">def HTML(text, _BaseParser parser=None, *, base_url=None):</span>
    <span class="s0">&quot;&quot;&quot;HTML(text, parser=None, base_url=None)</span>

    <span class="s0">Parses an HTML document from a string constant.  Returns the root</span>
    <span class="s0">node (or the result returned by a parser target).  This function</span>
    <span class="s0">can be used to embed &quot;HTML literals&quot; in Python code.</span>

    <span class="s0">To override the parser with a different ``HTMLParser`` you can pass it to</span>
    <span class="s0">the ``parser`` keyword argument.</span>

    <span class="s0">The ``base_url`` keyword argument allows to set the original base URL of</span>
    <span class="s0">the document to support relative Paths when looking up external entities</span>
    <span class="s0">(DTD, XInclude, ...).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">if parser is None:</span>
        <span class="s0">parser = __GLOBAL_PARSER_CONTEXT.getDefaultParser()</span>
        <span class="s0">if not isinstance(parser, HTMLParser):</span>
            <span class="s0">parser = __DEFAULT_HTML_PARSER</span>
    <span class="s0">try:</span>
        <span class="s0">doc = _parseMemoryDocument(text, base_url, parser)</span>
        <span class="s0">return doc.getroot()</span>
    <span class="s0">except _TargetParserResult as result_container:</span>
        <span class="s0">return result_container.result</span>


<span class="s0">def XML(text, _BaseParser parser=None, *, base_url=None):</span>
    <span class="s0">&quot;&quot;&quot;XML(text, parser=None, base_url=None)</span>

    <span class="s0">Parses an XML document or fragment from a string constant.</span>
    <span class="s0">Returns the root node (or the result returned by a parser target).</span>
    <span class="s0">This function can be used to embed &quot;XML literals&quot; in Python code,</span>
    <span class="s0">like in</span>

       <span class="s0">&gt;&gt;&gt; root = XML(&quot;&lt;root&gt;&lt;test/&gt;&lt;/root&gt;&quot;)</span>
       <span class="s0">&gt;&gt;&gt; print(root.tag)</span>
       <span class="s0">root</span>

    <span class="s0">To override the parser with a different ``XMLParser`` you can pass it to</span>
    <span class="s0">the ``parser`` keyword argument.</span>

    <span class="s0">The ``base_url`` keyword argument allows to set the original base URL of</span>
    <span class="s0">the document to support relative Paths when looking up external entities</span>
    <span class="s0">(DTD, XInclude, ...).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">if parser is None:</span>
        <span class="s0">parser = __GLOBAL_PARSER_CONTEXT.getDefaultParser()</span>
        <span class="s0">if not isinstance(parser, XMLParser):</span>
            <span class="s0">parser = __DEFAULT_XML_PARSER</span>
    <span class="s0">try:</span>
        <span class="s0">doc = _parseMemoryDocument(text, base_url, parser)</span>
        <span class="s0">return doc.getroot()</span>
    <span class="s0">except _TargetParserResult as result_container:</span>
        <span class="s0">return result_container.result</span>


<span class="s0">def fromstring(text, _BaseParser parser=None, *, base_url=None):</span>
    <span class="s0">&quot;&quot;&quot;fromstring(text, parser=None, base_url=None)</span>

    <span class="s0">Parses an XML document or fragment from a string.  Returns the</span>
    <span class="s0">root node (or the result returned by a parser target).</span>

    <span class="s0">To override the default parser with a different parser you can pass it to</span>
    <span class="s0">the ``parser`` keyword argument.</span>

    <span class="s0">The ``base_url`` keyword argument allows to set the original base URL of</span>
    <span class="s0">the document to support relative Paths when looking up external entities</span>
    <span class="s0">(DTD, XInclude, ...).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">try:</span>
        <span class="s0">doc = _parseMemoryDocument(text, base_url, parser)</span>
        <span class="s0">return doc.getroot()</span>
    <span class="s0">except _TargetParserResult as result_container:</span>
        <span class="s0">return result_container.result</span>


<span class="s0">def fromstringlist(strings, _BaseParser parser=None):</span>
    <span class="s0">&quot;&quot;&quot;fromstringlist(strings, parser=None)</span>

    <span class="s0">Parses an XML document from a sequence of strings.  Returns the</span>
    <span class="s0">root node (or the result returned by a parser target).</span>

    <span class="s0">To override the default parser with a different parser you can pass it to</span>
    <span class="s0">the ``parser`` keyword argument.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">if isinstance(strings, (bytes, unicode)):</span>
        <span class="s0">raise ValueError(&quot;passing a single string into fromstringlist() is not&quot;</span>
                         <span class="s0">&quot; efficient, use fromstring() instead&quot;)</span>
    <span class="s0">if parser is None:</span>
        <span class="s0">parser = __GLOBAL_PARSER_CONTEXT.getDefaultParser()</span>
    <span class="s0">feed = parser.feed</span>
    <span class="s0">for data in strings:</span>
        <span class="s0">feed(data)</span>
    <span class="s0">return parser.close()</span>


<span class="s0">def iselement(element):</span>
    <span class="s0">&quot;&quot;&quot;iselement(element)</span>

    <span class="s0">Checks if an object appears to be a valid element object.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return isinstance(element, _Element) and (&lt;_Element&gt;element)._c_node is not NULL</span>


<span class="s0">def indent(tree, space=&quot;  &quot;, *, Py_ssize_t level=0):</span>
    <span class="s0">&quot;&quot;&quot;indent(tree, space=&quot;  &quot;, level=0)</span>

    <span class="s0">Indent an XML document by inserting newlines and indentation space</span>
    <span class="s0">after elements.</span>

    <span class="s0">*tree* is the ElementTree or Element to modify.  The (root) element</span>
    <span class="s0">itself will not be changed, but the tail text of all elements in its</span>
    <span class="s0">subtree will be adapted.</span>

    <span class="s0">*space* is the whitespace to insert for each indentation level, two</span>
    <span class="s0">space characters by default.</span>

    <span class="s0">*level* is the initial indentation level. Setting this to a higher</span>
    <span class="s0">value than 0 can be used for indenting subtrees that are more deeply</span>
    <span class="s0">nested inside of a document.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">root = _rootNodeOrRaise(tree)</span>
    <span class="s0">if level &lt; 0:</span>
        <span class="s0">raise ValueError(f&quot;Initial indentation level must be &gt;= 0, got {level}&quot;)</span>
    <span class="s0">if _hasChild(root._c_node):</span>
        <span class="s0">space = _utf8(space)</span>
        <span class="s0">indent = b&quot;\n&quot; + level * space</span>
        <span class="s0">_indent_children(root._c_node, 1, space, [indent, indent + space])</span>


<span class="s0">cdef int _indent_children(xmlNode* c_node, Py_ssize_t level, bytes one_space, list indentations) except -1:</span>
    <span class="s0"># Reuse indentation strings for speed.</span>
    <span class="s0">if len(indentations) &lt;= level:</span>
        <span class="s0">indentations.append(indentations[-1] + one_space)</span>

    <span class="s0"># Start a new indentation level for the first child.</span>
    <span class="s0">child_indentation = indentations[level]</span>
    <span class="s0">if not _hasNonWhitespaceText(c_node):</span>
        <span class="s0">_setNodeText(c_node, child_indentation)</span>

    <span class="s0"># Recursively indent all children.</span>
    <span class="s0">cdef xmlNode* c_child = _findChildForwards(c_node, 0)</span>
    <span class="s0">while c_child is not NULL:</span>
        <span class="s0">if _hasChild(c_child):</span>
            <span class="s0">_indent_children(c_child, level+1, one_space, indentations)</span>
        <span class="s0">c_next_child = _nextElement(c_child)</span>
        <span class="s0">if not _hasNonWhitespaceTail(c_child):</span>
            <span class="s0">if c_next_child is NULL:</span>
                <span class="s0"># Dedent after the last child.</span>
                <span class="s0">child_indentation = indentations[level-1]</span>
            <span class="s0">_setTailText(c_child, child_indentation)</span>
        <span class="s0">c_child = c_next_child</span>
    <span class="s0">return 0</span>


<span class="s0">def dump(_Element elem not None, *, bint pretty_print=True, bint with_tail=True):</span>
    <span class="s0">&quot;&quot;&quot;dump(elem, pretty_print=True, with_tail=True)</span>

    <span class="s0">Writes an element tree or element structure to sys.stdout. This function</span>
    <span class="s0">should be used for debugging only.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">xml = tostring(elem, pretty_print=pretty_print, with_tail=with_tail, encoding='unicode')</span>
    <span class="s0">if not pretty_print:</span>
        <span class="s0">xml += '\n'</span>
    <span class="s0">sys.stdout.write(xml)</span>


<span class="s0">def tostring(element_or_tree, *, encoding=None, method=&quot;xml&quot;,</span>
             <span class="s0">xml_declaration=None, bint pretty_print=False, bint with_tail=True,</span>
             <span class="s0">standalone=None, doctype=None,</span>
             <span class="s0"># method='c14n'</span>
             <span class="s0">bint exclusive=False, inclusive_ns_prefixes=None,</span>
             <span class="s0"># method='c14n2'</span>
             <span class="s0">bint with_comments=True, bint strip_text=False,</span>
             <span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;tostring(element_or_tree, encoding=None, method=&quot;xml&quot;,</span>
                 <span class="s0">xml_declaration=None, pretty_print=False, with_tail=True,</span>
                 <span class="s0">standalone=None, doctype=None,</span>
                 <span class="s0">exclusive=False, inclusive_ns_prefixes=None,</span>
                 <span class="s0">with_comments=True, strip_text=False,</span>
                 <span class="s0">)</span>

    <span class="s0">Serialize an element to an encoded string representation of its XML</span>
    <span class="s0">tree.</span>

    <span class="s0">Defaults to ASCII encoding without XML declaration.  This</span>
    <span class="s0">behaviour can be configured with the keyword arguments 'encoding'</span>
    <span class="s0">(string) and 'xml_declaration' (bool).  Note that changing the</span>
    <span class="s0">encoding to a non UTF-8 compatible encoding will enable a</span>
    <span class="s0">declaration by default.</span>

    <span class="s0">You can also serialise to a Unicode string without declaration by</span>
    <span class="s0">passing the name ``'unicode'`` as encoding (or the ``str`` function</span>
    <span class="s0">in Py3 or ``unicode`` in Py2).  This changes the return value from</span>
    <span class="s0">a byte string to an unencoded unicode string.</span>

    <span class="s0">The keyword argument 'pretty_print' (bool) enables formatted XML.</span>

    <span class="s0">The keyword argument 'method' selects the output method: 'xml',</span>
    <span class="s0">'html', plain 'text' (text content without tags), 'c14n' or 'c14n2'.</span>
    <span class="s0">Default is 'xml'.</span>

    <span class="s0">With ``method=&quot;c14n&quot;`` (C14N version 1), the options ``exclusive``,</span>
    <span class="s0">``with_comments`` and ``inclusive_ns_prefixes`` request exclusive</span>
    <span class="s0">C14N, include comments, and list the inclusive prefixes respectively.</span>

    <span class="s0">With ``method=&quot;c14n2&quot;`` (C14N version 2), the ``with_comments`` and</span>
    <span class="s0">``strip_text`` options control the output of comments and text space</span>
    <span class="s0">according to C14N 2.0.</span>

    <span class="s0">Passing a boolean value to the ``standalone`` option will output</span>
    <span class="s0">an XML declaration with the corresponding ``standalone`` flag.</span>

    <span class="s0">The ``doctype`` option allows passing in a plain string that will</span>
    <span class="s0">be serialised before the XML tree.  Note that passing in non</span>
    <span class="s0">well-formed content here will make the XML output non well-formed.</span>
    <span class="s0">Also, an existing doctype in the document tree will not be removed</span>
    <span class="s0">when serialising an ElementTree instance.</span>

    <span class="s0">You can prevent the tail text of the element from being serialised</span>
    <span class="s0">by passing the boolean ``with_tail`` option.  This has no impact</span>
    <span class="s0">on the tail text of children, which will always be serialised.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef bint write_declaration</span>
    <span class="s0">cdef int is_standalone</span>
    <span class="s0"># C14N serialisation</span>
    <span class="s0">if method in ('c14n', 'c14n2'):</span>
        <span class="s0">if encoding is not None:</span>
            <span class="s0">raise ValueError(&quot;Cannot specify encoding with C14N&quot;)</span>
        <span class="s0">if xml_declaration:</span>
            <span class="s0">raise ValueError(&quot;Cannot enable XML declaration in C14N&quot;)</span>
        <span class="s0">if method == 'c14n':</span>
            <span class="s0">return _tostringC14N(element_or_tree, exclusive, with_comments, inclusive_ns_prefixes)</span>
        <span class="s0">else:</span>
            <span class="s0">out = BytesIO()</span>
            <span class="s0">target = C14NWriterTarget(</span>
                <span class="s0">utf8_writer(out).write,</span>
                <span class="s0">with_comments=with_comments, strip_text=strip_text)</span>
            <span class="s0">_tree_to_target(element_or_tree, target)</span>
            <span class="s0">return out.getvalue()</span>
    <span class="s0">if not with_comments:</span>
        <span class="s0">raise ValueError(&quot;Can only discard comments in C14N serialisation&quot;)</span>
    <span class="s0">if strip_text:</span>
        <span class="s0">raise ValueError(&quot;Can only strip text in C14N 2.0 serialisation&quot;)</span>
    <span class="s0">if encoding is unicode or (encoding is not None and encoding.lower() == 'unicode'):</span>
        <span class="s0">if xml_declaration:</span>
            <span class="s0">raise ValueError, \</span>
                <span class="s0">&quot;Serialisation to unicode must not request an XML declaration&quot;</span>
        <span class="s0">write_declaration = 0</span>
        <span class="s0">encoding = unicode</span>
    <span class="s0">elif xml_declaration is None:</span>
        <span class="s0"># by default, write an XML declaration only for non-standard encodings</span>
        <span class="s0">write_declaration = encoding is not None and encoding.upper() not in \</span>
                            <span class="s0">('ASCII', 'UTF-8', 'UTF8', 'US-ASCII')</span>
    <span class="s0">else:</span>
        <span class="s0">write_declaration = xml_declaration</span>
    <span class="s0">if encoding is None:</span>
        <span class="s0">encoding = 'ASCII'</span>
    <span class="s0">if standalone is None:</span>
        <span class="s0">is_standalone = -1</span>
    <span class="s0">elif standalone:</span>
        <span class="s0">write_declaration = 1</span>
        <span class="s0">is_standalone = 1</span>
    <span class="s0">else:</span>
        <span class="s0">write_declaration = 1</span>
        <span class="s0">is_standalone = 0</span>

    <span class="s0">if isinstance(element_or_tree, _Element):</span>
        <span class="s0">return _tostring(&lt;_Element&gt;element_or_tree, encoding, doctype, method,</span>
                         <span class="s0">write_declaration, 0, pretty_print, with_tail,</span>
                         <span class="s0">is_standalone)</span>
    <span class="s0">elif isinstance(element_or_tree, _ElementTree):</span>
        <span class="s0">return _tostring((&lt;_ElementTree&gt;element_or_tree)._context_node,</span>
                         <span class="s0">encoding, doctype, method, write_declaration, 1,</span>
                         <span class="s0">pretty_print, with_tail, is_standalone)</span>
    <span class="s0">else:</span>
        <span class="s0">raise TypeError, f&quot;Type '{python._fqtypename(element_or_tree).decode('utf8')}' cannot be serialized.&quot;</span>



<span class="s0">def tostringlist(element_or_tree, *args, **kwargs):</span>
    <span class="s0">&quot;&quot;&quot;tostringlist(element_or_tree, *args, **kwargs)</span>

    <span class="s0">Serialize an element to an encoded string representation of its XML</span>
    <span class="s0">tree, stored in a list of partial strings.</span>

    <span class="s0">This is purely for ElementTree 1.3 compatibility.  The result is a</span>
    <span class="s0">single string wrapped in a list.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return [tostring(element_or_tree, *args, **kwargs)]</span>


<span class="s0">def tounicode(element_or_tree, *, method=&quot;xml&quot;, bint pretty_print=False,</span>
              <span class="s0">bint with_tail=True, doctype=None):</span>
    <span class="s0">&quot;&quot;&quot;tounicode(element_or_tree, method=&quot;xml&quot;, pretty_print=False,</span>
                  <span class="s0">with_tail=True, doctype=None)</span>

    <span class="s0">Serialize an element to the Python unicode representation of its XML</span>
    <span class="s0">tree.</span>

    <span class="s0">:deprecated: use ``tostring(el, encoding='unicode')`` instead.</span>

    <span class="s0">Note that the result does not carry an XML encoding declaration and is</span>
    <span class="s0">therefore not necessarily suited for serialization to byte streams without</span>
    <span class="s0">further treatment.</span>

    <span class="s0">The boolean keyword argument 'pretty_print' enables formatted XML.</span>

    <span class="s0">The keyword argument 'method' selects the output method: 'xml',</span>
    <span class="s0">'html' or plain 'text'.</span>

    <span class="s0">You can prevent the tail text of the element from being serialised</span>
    <span class="s0">by passing the boolean ``with_tail`` option.  This has no impact</span>
    <span class="s0">on the tail text of children, which will always be serialised.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if isinstance(element_or_tree, _Element):</span>
        <span class="s0">return _tostring(&lt;_Element&gt;element_or_tree, unicode, doctype, method,</span>
                          <span class="s0">0, 0, pretty_print, with_tail, -1)</span>
    <span class="s0">elif isinstance(element_or_tree, _ElementTree):</span>
        <span class="s0">return _tostring((&lt;_ElementTree&gt;element_or_tree)._context_node,</span>
                         <span class="s0">unicode, doctype, method, 0, 1, pretty_print,</span>
                         <span class="s0">with_tail, -1)</span>
    <span class="s0">else:</span>
        <span class="s0">raise TypeError, f&quot;Type '{type(element_or_tree)}' cannot be serialized.&quot;</span>


<span class="s0">def parse(source, _BaseParser parser=None, *, base_url=None):</span>
    <span class="s0">&quot;&quot;&quot;parse(source, parser=None, base_url=None)</span>

    <span class="s0">Return an ElementTree object loaded with source elements.  If no parser</span>
    <span class="s0">is provided as second argument, the default parser is used.</span>

    <span class="s0">The ``source`` can be any of the following:</span>

    <span class="s0">- a file name/path</span>
    <span class="s0">- a file object</span>
    <span class="s0">- a file-like object</span>
    <span class="s0">- a URL using the HTTP or FTP protocol</span>

    <span class="s0">To parse from a string, use the ``fromstring()`` function instead.</span>

    <span class="s0">Note that it is generally faster to parse from a file path or URL</span>
    <span class="s0">than from an open file object or file-like object.  Transparent</span>
    <span class="s0">decompression from gzip compressed sources is supported (unless</span>
    <span class="s0">explicitly disabled in libxml2).</span>

    <span class="s0">The ``base_url`` keyword allows setting a URL for the document</span>
    <span class="s0">when parsing from a file-like object.  This is needed when looking</span>
    <span class="s0">up external entities (DTD, XInclude, ...) with relative paths.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef _Document doc</span>
    <span class="s0">try:</span>
        <span class="s0">doc = _parseDocument(source, parser, base_url)</span>
        <span class="s0">return _elementTreeFactory(doc, None)</span>
    <span class="s0">except _TargetParserResult as result_container:</span>
        <span class="s0">return result_container.result</span>


<span class="s0">def adopt_external_document(capsule, _BaseParser parser=None):</span>
    <span class="s0">&quot;&quot;&quot;adopt_external_document(capsule, parser=None)</span>

    <span class="s0">Unpack a libxml2 document pointer from a PyCapsule and wrap it in an</span>
    <span class="s0">lxml ElementTree object.</span>

    <span class="s0">This allows external libraries to build XML/HTML trees using libxml2</span>
    <span class="s0">and then pass them efficiently into lxml for further processing.</span>

    <span class="s0">If a ``parser`` is provided, it will be used for configuring the</span>
    <span class="s0">lxml document.  No parsing will be done.</span>

    <span class="s0">The capsule must have the name ``&quot;libxml2:xmlDoc&quot;`` and its pointer</span>
    <span class="s0">value must reference a correct libxml2 document of type ``xmlDoc*``.</span>
    <span class="s0">The creator of the capsule must take care to correctly clean up the</span>
    <span class="s0">document using an appropriate capsule destructor.  By default, the</span>
    <span class="s0">libxml2 document will be copied to let lxml safely own the memory</span>
    <span class="s0">of the internal tree that it uses.</span>

    <span class="s0">If the capsule context is non-NULL, it must point to a C string that</span>
    <span class="s0">can be compared using ``strcmp()``.  If the context string equals</span>
    <span class="s0">``&quot;destructor:xmlFreeDoc&quot;``, the libxml2 document will not be copied</span>
    <span class="s0">but the capsule invalidated instead by clearing its destructor and</span>
    <span class="s0">name.  That way, lxml takes ownership of the libxml2 document in memory</span>
    <span class="s0">without creating a copy first, and the capsule destructor will not be</span>
    <span class="s0">called.  The document will then eventually be cleaned up by lxml using</span>
    <span class="s0">the libxml2 API function ``xmlFreeDoc()`` once it is no longer used.</span>

    <span class="s0">If no copy is made, later modifications of the tree outside of lxml</span>
    <span class="s0">should not be attempted after transferring the ownership.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef xmlDoc* c_doc</span>
    <span class="s0">cdef bint is_owned = False</span>
    <span class="s0">c_doc = &lt;xmlDoc*&gt; python.lxml_unpack_xmldoc_capsule(capsule, &amp;is_owned)</span>
    <span class="s0">doc = _adoptForeignDoc(c_doc, parser, is_owned)</span>
    <span class="s0">return _elementTreeFactory(doc, None)</span>


<span class="s0">################################################################################</span>
<span class="s0"># Include submodules</span>

<span class="s0">include &quot;readonlytree.pxi&quot; # Read-only implementation of Element proxies</span>
<span class="s0">include &quot;classlookup.pxi&quot;  # Element class lookup mechanisms</span>
<span class="s0">include &quot;nsclasses.pxi&quot;    # Namespace implementation and registry</span>
<span class="s0">include &quot;docloader.pxi&quot;    # Support for custom document loaders</span>
<span class="s0">include &quot;parser.pxi&quot;       # XML and HTML parsers</span>
<span class="s0">include &quot;saxparser.pxi&quot;    # SAX-like Parser interface and tree builder</span>
<span class="s0">include &quot;parsertarget.pxi&quot; # ET Parser target</span>
<span class="s0">include &quot;serializer.pxi&quot;   # XML output functions</span>
<span class="s0">include &quot;iterparse.pxi&quot;    # incremental XML parsing</span>
<span class="s0">include &quot;xmlid.pxi&quot;        # XMLID and IDDict</span>
<span class="s0">include &quot;xinclude.pxi&quot;     # XInclude</span>
<span class="s0">include &quot;cleanup.pxi&quot;      # Cleanup and recursive element removal functions</span>


<span class="s0">################################################################################</span>
<span class="s0"># Include submodules for XPath and XSLT</span>

<span class="s0">include &quot;extensions.pxi&quot;   # XPath/XSLT extension functions</span>
<span class="s0">include &quot;xpath.pxi&quot;        # XPath evaluation</span>
<span class="s0">include &quot;xslt.pxi&quot;         # XSL transformations</span>
<span class="s0">include &quot;xsltext.pxi&quot;      # XSL extension elements</span>


<span class="s0">################################################################################</span>
<span class="s0"># Validation</span>

<span class="s0">cdef class DocumentInvalid(LxmlError):</span>
    <span class="s0">&quot;&quot;&quot;Validation error.</span>

    <span class="s0">Raised by all document validators when their ``assertValid(tree)``</span>
    <span class="s0">method fails.</span>
    <span class="s0">&quot;&quot;&quot;</span>


<span class="s0">cdef class _Validator:</span>
    <span class="s0">&quot;Base class for XML validators.&quot;</span>
    <span class="s0">cdef _ErrorLog _error_log</span>
    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self._error_log = _ErrorLog()</span>

    <span class="s0">def validate(self, etree):</span>
        <span class="s0">&quot;&quot;&quot;validate(self, etree)</span>

        <span class="s0">Validate the document using this schema.</span>

        <span class="s0">Returns true if document is valid, false if not.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self(etree)</span>

    <span class="s0">def assertValid(self, etree):</span>
        <span class="s0">&quot;&quot;&quot;assertValid(self, etree)</span>

        <span class="s0">Raises `DocumentInvalid` if the document does not comply with the schema.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if not self(etree):</span>
            <span class="s0">raise DocumentInvalid(self._error_log._buildExceptionMessage(</span>
                    <span class="s0">&quot;Document does not comply with schema&quot;),</span>
                                  <span class="s0">self._error_log)</span>

    <span class="s0">def assert_(self, etree):</span>
        <span class="s0">&quot;&quot;&quot;assert_(self, etree)</span>

        <span class="s0">Raises `AssertionError` if the document does not comply with the schema.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if not self(etree):</span>
            <span class="s0">raise AssertionError, self._error_log._buildExceptionMessage(</span>
                <span class="s0">&quot;Document does not comply with schema&quot;)</span>

    <span class="s0">cpdef _append_log_message(self, int domain, int type, int level, int line,</span>
                              <span class="s0">message, filename):</span>
        <span class="s0">self._error_log._receiveGeneric(domain, type, level, line, message,</span>
                                        <span class="s0">filename)</span>

    <span class="s0">cpdef _clear_error_log(self):</span>
        <span class="s0">self._error_log.clear()</span>

    <span class="s0">@property</span>
    <span class="s0">def error_log(self):</span>
        <span class="s0">&quot;&quot;&quot;The log of validation errors and warnings.&quot;&quot;&quot;</span>
        <span class="s0">assert self._error_log is not None, &quot;XPath evaluator not initialised&quot;</span>
        <span class="s0">return self._error_log.copy()</span>

<span class="s0">include &quot;dtd.pxi&quot;        # DTD</span>
<span class="s0">include &quot;relaxng.pxi&quot;    # RelaxNG</span>
<span class="s0">include &quot;xmlschema.pxi&quot;  # XMLSchema</span>
<span class="s0">include &quot;schematron.pxi&quot; # Schematron (requires libxml2 2.6.21+)</span>

<span class="s0">################################################################################</span>
<span class="s0"># Public C API</span>

<span class="s0">include &quot;public-api.pxi&quot;</span>

<span class="s0">################################################################################</span>
<span class="s0"># Other stuff</span>

<span class="s0">include &quot;debug.pxi&quot;</span>
</pre>
</body>
</html>